{"meta":{"title":"YukiCCC的博客","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-07-01T08:25:01.917Z","updated":"2023-07-01T08:25:01.917Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"","date":"2023-07-01T08:54:37.410Z","updated":"2023-07-01T08:54:37.410Z","comments":true,"path":"data/friends.json","permalink":"http://example.com/data/friends.json","excerpt":"","text":"[{\"group\":\"分组1# 分组标题\",\"description\":\"友情链接\",\"items\":[{\"title\":\"Google\",\"avatar\":\"https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png\",\"url\":\"https://www.google.com/\",\"screenshot\":null,\"keywords\":null,\"description\":null},{\"title\":null,\"avatar\":null,\"url\":null,\"screenshot\":null,\"keywords\":null,\"description\":null}]}]"},{"title":"所有分类","date":"2023-07-01T08:25:42.219Z","updated":"2023-07-01T08:25:42.219Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-07-01T08:26:59.883Z","updated":"2023-07-01T08:26:59.883Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-07-01T08:26:42.238Z","updated":"2023-07-01T08:26:42.238Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"Java-IO流","slug":"Java-IO流","date":"2023-07-01T12:15:14.000Z","updated":"2023-07-01T14:36:24.329Z","comments":true,"path":"2023/07/01/Java-IO流/","link":"","permalink":"http://example.com/2023/07/01/Java-IO%E6%B5%81/","excerpt":"","text":"1. File1.1 File与流 1.2 File练习例11234567891011121314151617181920/*使用File对象，在C盘创建aaa/bbb/ccc的文件夹，在此文件夹下创建1.txt【C:/aaa/bbb/ccc/1.txt】 如果该文件存在，删除1.txt 如果该文件不存在，创建1.txt*/import java.io.File;import java.io.IOException;public class FileTest01 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\aaa\\\\bbb\\\\ccc\\\\1.txt&quot;); if (file.exists())&#123; file.delete(); &#125;else&#123; //创建文件夹 file.getParentFile().mkdirs(); //创建 文件 file.createNewFile(); &#125; &#125;&#125; 例21234567891011121314151617/*使用File对象 listFiles() 方法自定义类 implements FilenameFilterC:\\Program Files\\Java\\jdk1.8.0_321\\bin目录下，所有的 .exe结尾的文件打印出来。*/import java.io.File;import java.io.FilenameFilter;import java.io.IOException;import java.util.stream.Stream;public class FileTest02 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_361\\\\bin&quot;); String[] ay = file.list((dir, name) -&gt; name.endsWith(&quot;.exe&quot;)); Stream.of(ay).forEach(System.out::println); &#125;&#125; 2. 节点流2.1 字节流 2.2 节点流练习例312345678910111213141516171819202122232425/*使用FileOutputStream 向1.txt文件写入： A~Z 字符在 文件 结尾：a~z字符*/import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class FileOutputStreamTest03 &#123; public static void main(String[] args) throws IOException &#123; //输出流 自动创建文件 OutputStream os = new FileOutputStream(&quot;1.txt&quot;,true) ; //写 byte 比如：A for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125; /*for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125;*/ //建议： 可选 //os.flush(); os.close(); &#125;&#125; 例412345678910111213141516171819202122232425262728293031/*使用FileInputStream IDEA具体的JAVA文件 比如： Test1.java打印该Java文件中所有的内容*/import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class FileInputStreamTest04 &#123; public static void main(String[] args) throws IOException &#123; //输入流 注意：目标数据源 一定存在的 InputStream is = new FileInputStream(&quot;Test1.java&quot;) ; //读 /*while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; System.out.print((char)data); &#125;*/ int data = 0 ; while((data = is.read())!=-1)&#123; System.out.print((char)data); &#125; is.close(); &#125;&#125; 2.3 字符流 2.4 节点流 输入流 输出流 例51234567891011121314151617181920212223/*使用流 实现把图片从C盘拷贝D盘。*/import java.io.*;public class PicCopyTest05 &#123; public static void main(String[] args) throws IOException &#123; //1.输入流 怼到 目标数据源 InputStream is = new FileInputStream(&quot;D:\\\\Java180_2\\\\doc\\\\day01-html基础\\\\res\\\\mm.jpg&quot;) ; //2.输出流 项目下 OutputStream os = new FileOutputStream(&quot;meimei.jpg&quot;) ; //3. 读 while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; //4.写 os.write(data); &#125; System.out.println(&quot;====图片拷贝结束=========&quot;); &#125;&#125; 3. 处理流3.1 流嵌套 3.2 处理流 3.3 调包侠https://commons.apache.org/proper/commons-io/description.html 4. 对象流 例61234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用对象流 实现对对象实现读写功能*///写入import java.io.*;public class ObjectOutputStreamTest11 &#123; public static void main(String[] args) throws IOException &#123; //1.对象 创建商品对象 【A.瞬时状态 -- JVM 内存】 Goods goods = new Goods(&quot;G1001&quot;, &quot;苹果&quot;, 4.5D); //2. 写入 4.txt 文件 节点文件流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;4.txt&quot;)) ; /*OutputStream os = new FileOutputStream(&quot;4.txt&quot;) ; ObjectOutputStream oos = new ObjectOutputStream(os) ;*/ //【B.持久状态 -- 文件系统】 //goods.setName(&quot;香蕉&quot;); //对象流 写入 oos.writeObject(goods); oos.flush(); oos.close(); //【C.脱管状态 -- 脱离管理】 //goods.setName(&quot;菠萝&quot;); &#125;&#125;//读取import java.io.*;public class ObjectInputStreamTest12 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.读取 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;4.txt&quot;)) ; Object o = ois.readObject(); ois.close(); System.out.println(o); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-集合","slug":"Java-集合","date":"2023-06-29T14:07:43.000Z","updated":"2023-07-01T08:40:15.066Z","comments":true,"path":"2023/06/29/Java-集合/","link":"","permalink":"http://example.com/2023/06/29/Java-%E9%9B%86%E5%90%88/","excerpt":"","text":"1. Map集合框架类图 HashMap常用方法 API 例1：1234567891011121314151617181920212223242526272829/*1.遍历集合，并将序号与对应人名打印。2.向该map插入一个编码为5姓名为李晓红3.移除该map中的编号为1的信息4.将map集合中编号为2的姓名信息修改为&quot;周琳&quot;*/import java.util.HashMap;import java.util.Map;public class Ex01 &#123; public static void main(String[] args) &#123; Map map =new HashMap();//多态 map.put(1,&quot;张三丰&quot;); map.put(2,&quot;周芷若&quot;); map.put(3,&quot;汪峰&quot;); map.put(4,&quot;灭绝师太&quot;); //1.循环遍历 map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); //2.插入 map.put(5,&quot;李晓红&quot;); //3.移除 map.remove(1); //4.修改 //map.put(2,&quot;周琳&quot;); map.replace(2,&quot;周琳&quot;); System.out.println(&quot;==============================&quot;); map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); &#125;&#125; java8 参考循环输出： 123456Map map = new HashMap() ;map.put(1,&quot;张三1&quot;) ;map.put(2,&quot;张三2&quot;) ;map.put(3,&quot;张三3&quot;) ;// java lambda表达式 类似 ES6 的箭头函数 【可推导即可省略】map.forEach((k,v)-&gt; System.out.println(&quot;序号:&quot;+k+&quot;,姓名:&quot;+v)); 例2：1234567891011121314151617181920212223242526/*有2个数组，第一个省份数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，第二个省会数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为key，第二个数组元素作为value存储到Map集合中。如&#123;黑龙江省=哈尔滨, 浙江省=杭州, …&#125;。*/import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class Ex02 &#123; public static void main(String[] args) &#123; String[] proAy = &#123;&quot;黑龙江省&quot;,&quot;浙江省&quot;,&quot;江西省&quot;,&quot;广东省&quot;,&quot;福建省&quot;&#125; ; String[] cityAy = &#123;&quot;哈尔滨&quot;,&quot;杭州&quot;,&quot;南昌&quot;,&quot;广州&quot;,&quot;福州&quot;&#125; ; Map map = new LinkedHashMap(); // 把 数组中的元素 存放在 map的 条目中 for (int i=0;i&lt;proAy.length;i++)&#123; map.put(proAy[i],cityAy[i]); &#125; //打印map 无需循环 &#123;key=value,key=value&#125; System.out.println(map); &#125;&#125; 例3：1234567891011/*定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。 List list = new ArrayList() ;例如：集合中有”abc”、”bcd”两个元素， list.add(“abc”) ; list.add(“bcd”) ;程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。 Map map = ... String 类 1. length() 字母个数 2. charAt() 根据索引 获得 字母*/ Hashtable1null值问题? 对比： 2. Iterator基本使用 例41234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用ArrayList存储多个学生信息1. 删除年龄&gt;18岁的学生2. 使用Iterator进行遍历 */import java.util.ArrayList;import java.util.Iterator;import java.util.function.Predicate;/** * 使用ArrayList存储多个学生信息 * 1. 删除年龄&gt;18岁的学生 * 2. 使用Iterator进行遍历 */public class Ex04 &#123; public static void main(String[] args) &#123; ArrayList&lt;Stu&gt; stuList = new ArrayList(); stuList.add(new Stu(19)) ; stuList.add(new Stu(39)) ; stuList.add(new Stu(14)) ; stuList.add(new Stu(16)) ; stuList.add(new Stu(26)) ; stuList.add(new Stu(12)) ; //推荐 java8的语法 removeIf(e-&gt;e.getAge()&gt;18) forEach(System.out::println) //stuList.removeIf( o -&gt; ((Stu)o).getAge()&gt;18 ) ; //stuList.removeIf( o -&gt; o.getAge()&gt;18 ) ; //stuList.forEach(System.out::println); //Iterator 判断有没有下一个元素 hasNext() 取出下一个元素 next() 删除当前元素 remove() Iterator&lt;Stu&gt; iterator = stuList.iterator(); while (iterator.hasNext()) &#123; //腐烂味道代码 坏味道代码 Stu stu = iterator.next(); if (stu.getAge()&gt;18)&#123; iterator.remove(); &#125; &#125; System.out.println(stuList); &#125;&#125; 参考java8 List 删除元素： 12345678List list = new ArrayList() ;list.add(new Stu(1,&quot;aaa&quot;,19)) ;list.add(new Stu(2,&quot;bbb&quot;,16)) ;list.add(new Stu(3,&quot;ccc&quot;,14)) ;//如果满足条件 进行删除list.removeIf(ele-&gt;((Stu)ele).getAge()&gt;18) ;//循环输出list.forEach(System.out::println); 3. 泛型为什么 怎么用 4. Set4.1 HashSet 例512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.HashSet;import java.util.Random;import java.util.Set;/** * 双色球规则： * 双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。 * 红色球号码从1—33中选择； * 蓝色球号码从1—16中选择； * 请随机生成一注双色球号码。 * （要求同色号码不重复） */public class Ex05 &#123; public static void main(String[] args) &#123; Random random = new Random(); // 蓝色球号码 int blueBall = random.nextInt(16)+1 ; HashSet&lt;Ball&gt; ballSet = new LinkedHashSet&lt;&gt;() ; // 一个 蓝色球 ballSet.add(new Ball(&quot;蓝球&quot;,blueBall)) ; while (ballSet.size() != 7) &#123; //红色球号码 int redBall = random.nextInt(33)+1 ; ballSet.add(new Ball(&quot;红球&quot;,redBall)) ; &#125; System.out.println(ballSet); &#125;&#125;class Ball&#123; private String color ; private Integer num ; public Ball(String color, Integer num) &#123; this.color = color; this.num = num; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Ball ball = (Ball) o; return Objects.equals(color, ball.color) &amp;&amp; Objects.equals(num, ball.num); &#125; @Override public int hashCode() &#123; return Objects.hash(color, num); &#125; @Override public String toString() &#123; return &quot;Ball&#123;&quot; + &quot;color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &quot;, num=&quot; + num + &#x27;&#125;&#x27;; &#125;&#125; 5. Map练习5.1 Map练习例61234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162一、利用Map，完成下面的功能：/*从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。如果该年没有举办世界杯，则输出：没有举办世界杯。*/import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Ex06 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //map.put(2023,null); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入年份:&quot;); //怼死 死去活来法 int year = scanner.nextInt(); String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg); scanner.close(); /*String team = map.get(year); if (team!=null)&#123; System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /*if (map.containsKey(year)) &#123; String team = map.get(year); System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /* String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg);*/ &#125;&#125; 例712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Scanner;/** * 二、在原有世界杯Map 的基础上， * 增加如下功能： * 读入一支球队的名字，输出该球队夺冠的年份列表。 * 例如， * 读入“巴西”，应当输出 1958 1962 1970 1994 2002 * 读入“荷兰”，应当输出 没有获得过世界杯 */public class Ex07 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //逆向思维 Map&lt;String, StringBuilder&gt; teamMap = new HashMap&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; //当前 队伍 map集合中 是否包含当前 队伍 if (teamMap.containsKey(name)) &#123; // 字符串 缓存中 添加新的年份 StringBuilder sb = teamMap.get(name); sb.append(year).append(&quot;\\t&quot;) ; &#125;else &#123; //如果不包含 直接存放当前年份 teamMap.put(name, new StringBuilder(year + &quot;\\t&quot;)); &#125; &#125;); // System.out.println(teamMap); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一支球队的名字:&quot;); //怼死 死去活来法 String year = scanner.next(); String msg = teamMap.getOrDefault(year, new StringBuilder(&quot;没有获得过世界杯&quot;)).toString(); System.out.println(msg); &#125;&#125; 123456789101112131415//另一种方法 String inputTeamName = scanner.next(); AtomicBoolean isPrint = new AtomicBoolean(true); map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; System.out.println(year); //System.exit(-1); isPrint.set(false); &#125; &#125;); if (isPrint.get()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; 123456789101112131415161718//第三种方法 String inputTeamName = scanner.next(); //存放 获得世界杯的年份集合 List&lt;Integer&gt; yearList = new ArrayList&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; yearList.add(year) ; &#125; &#125;); //集合为空 条件没有满足 if (yearList.isEmpty()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; yearList.forEach(System.out::println); 5.2 Map.Entry 5.3 Map综合案例1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * * 将以上对应关系的数据存储到map集合中，key：表示站编号，value：表示站名，并遍历打印(可以不按顺序打印)： * 例如： * 第10站: 森林公园南门 * 第6站: 育新 * 第12站: 奥体中心 * 第13站: 北土城 */public class EX &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); &#125;&#125; 例81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * *计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； */public class Ex08 &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); //站之间的数量 int money = caclMoney(13) ; System.out.println(&quot;共:&quot; + money); &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; Map&lt;Integer,Integer&gt; moneyMap = new HashMap&lt;&gt;() ; moneyMap.put(0,3) ; moneyMap.put(1,3) ; moneyMap.put(2,3) ; moneyMap.put(3,3) ; moneyMap.put(4,4) ; moneyMap.put(5,4) ; // .... moneyMap.put(0,3) ; moneyMap.put(0,3) ; return count ; /*if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ;*/ &#125;&#125; 例9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*计算地铁票价规则： 总行程 3站内（包含3站）收费3元， 3站以上但不超过5站（包含5站）的收费4元， 5站以上的，在4元的基础上，每多1站增加2元， 10元封顶；*/import java.util.ArrayList;import java.util.HashMap;import java.util.Map;public class Test09 &#123; public static void main(String[] args) &#123; ArrayList&lt;Num&gt; numList = new ArrayList(); Map map = new HashMap(); map.put(1,&quot;朱辛庄&quot;); map.put(2,&quot;育知路&quot;); map.put(3,&quot;平西府&quot;); map.put(4,&quot;回龙观东大街&quot;); map.put(5,&quot;霍营&quot;); map.put(6,&quot;育新&quot;); map.put(7,&quot;西小口&quot;); map.put(8,&quot;永泰庄&quot;); map.put(9,&quot;林萃桥&quot;); map.put(10,&quot;森林公园南门&quot;); map.put(11,&quot;奥林匹克公园&quot;); map.put(12,&quot;奥体中心&quot;); map.put(13,&quot;北土城&quot;); for (Object j : map.keySet())&#123; System.out.println(&quot;第&quot; +j +&quot;站: &quot; +map.get(j)); &#125; int i=1; numList.add(new Num(1,3)) ; numList.add(new Num(2,3)) ; numList.add(new Num(3,3)) ; numList.add(new Num(4,4)) ; numList.add(new Num(5,4)) ; numList.add(new Num(5+i,4+2*i)) ; /*numList.forEach((k,v)-&gt;&#123; if(k.equals()&lt;=3)&#123; System.out.println(k + &quot; &quot;); &#125; &#125;);*/ &#125;&#125;class Num&#123; int number ; int money; public int getMoney() &#123; return money; &#125; public int getNumber() &#123; return number; &#125; public Num(int number,int money) &#123; this.number = number; this.money = money; &#125; @Override public String toString() &#123; return &quot;homework.Num&#123;&quot; + &quot;number=&quot; + number + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 例1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * 打印格式（需要对键盘录入的上车站和到达站进行判断，如果没有该站，提示重新输入，直到站名存在为止）： 注意：每站需要2分钟 请输入上车站： 朱辛庄 请输入到达站： 西小口 从朱辛庄到西小口共经过6站收费6元，大约需要 12分钟； */public class Ex09 &#123; private static String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ; private static Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; public static void main(String[] args) &#123;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); String beginName = &quot;林萃桥&quot; ; String endName = &quot;平西府&quot;; int count = caclCount(beginName, endName); int time = count*2 ; //站之间的数量 int money = caclMoney(count) ; System.out.println(&quot;从&quot;+beginName+&quot;到&quot;+endName+&quot;共经过&quot;+count+&quot;站收费&quot;+money+&quot;元，大约需要 &quot;+time+&quot;分钟&quot;); &#125; /** * 根据 两站 站名 计算 之间 站之间的数量 * @param beginName * @param endName * @return */ private static int caclCount(String beginName,String endName)&#123; //map的 key站名 value 站序号 反转 Map&lt;String,Integer&gt; name2IndxMap = new HashMap&lt;&gt;() ; //站序号 站名 map.forEach((idx,name)-&gt; name2IndxMap.put(name,idx)); Integer beginIdx = name2IndxMap.get(beginName); Integer endIdx = name2IndxMap.get(endName); return Math.abs(beginIdx-endIdx) ; &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ; &#125;&#125; 6.Set扩展6.1 TreeSet 6.2 例11123456789101112131415161718192021222324252627/*学生类 姓名 分数 double 存放 TreeSet中 实现 根据 分数 从大到小 内部排序Comparable 外部排序 ComparatorSet&lt;Stu&gt; set = new TreeSet&lt;&gt;() ;set.add(new Stu(“aa”,98.5)) ;set.add(new Stu(“bb”,88.5)) ;*/package set;import java.util.*;public class Ex11 &#123; public static void main(String[] args) &#123; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; (int) (c1.getScore()-c2.getScore())) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; c1.getScore().compareTo(c2.getScore())) ;// Set&lt;Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparing(Customer::getScore)) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(set.Customer::getScore)) ; Set&lt;Customer&gt; set = new TreeSet&lt;&gt;() ; set.add(new Customer(&quot;小丽&quot;,500D)) ; set.add(new Customer(&quot;小红&quot;,400.8)) ; set.add(new Customer(&quot;小夏&quot;,400.3)) ; set.add(new Customer(&quot;小花&quot;,700D)) ; set.forEach(System.out::println); &#125;&#125; java8 外部排序写法： 1Set&lt;Stu&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(Stu::getAge)) ; 7. Collections7.1 辅助类 7.2 例1212345678910111213141516171819202122232425262728/* 1. List&lt;Stu&gt; Collections.sort(stuList) Comparable Collections.sort(stuList,...) Comparator 分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序， 如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。*/package collections;import set.Customer;import java.util.Arrays;import java.util.Collections;import java.util.List;public class Ex12 &#123; public static void main(String[] args) &#123; //集合中 存放 Customer List&lt;Customer&gt; customerList = Arrays.asList(new Customer(&quot;aaa&quot;,100D),new Customer(&quot;bbb&quot;,80.5D),new Customer(&quot;ccc&quot;,90D)) ; //jdk1.8 新特性 不使用辅助类 Collections //customerList.sort((c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); //使用 辅助类 Collections //Collections.sort(customerList); Collections.sort(customerList,(c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); customerList.forEach(System.out::println); &#125;&#125; 8. Map扩展8.1 LinkedHashSet 8.2 LinkedHashMap 8.3 ConcurrentHashMap 8.4 Properties 9.泛型扩展9.1 什么是泛型 9.2 泛型好处 9.3 使用前后对比 9.4 类型参数 9.5 方法参数 9.6 泛型不是协变的 9.7 类型通配符 9.8 泛型局限性","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java开发利器--idea安装过程详解","slug":"Java开发利器-idea安装过程详解","date":"2023-06-29T13:46:51.000Z","updated":"2023-07-01T08:40:12.685Z","comments":true,"path":"2023/06/29/Java开发利器-idea安装过程详解/","link":"","permalink":"http://example.com/2023/06/29/Java%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-idea%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"0. IDEA0.1 安装 0.2 配置破解11. 打开 readme.txt 安装步骤进行破解 JDK 字体 编码 0.3 运行创建项目 创建Java类 编写&#x2F;运行源代码 0.4 debug 0.5 卸载 删除安装目录：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"ES6及之后新特性一览","slug":"ES6及之后新特性一览","date":"2023-06-25T04:40:11.000Z","updated":"2023-07-01T08:40:14.329Z","comments":true,"path":"2023/06/25/ES6及之后新特性一览/","link":"","permalink":"http://example.com/2023/06/25/ES6%E5%8F%8A%E4%B9%8B%E5%90%8E%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/","excerpt":"","text":"let声明变量let 声明变量1.let 不允许重复声明变量 var 可以重复声明2.let 不支持变量的声明提升，var可以3.let声明的变量会被所有代码块（{}内的范围）限制作用范围 var只会受到函数影响4.let 声明的变量不和顶层变量挂钩 const 声明常量const 声明常量1.const 不可以重复声明2.不支持声明提升3.作用范围受{}影响4.不和最上层对象window挂钩const num &#x3D; 10;const num &#x3D; 20;&#x2F;&#x2F;Cannot redeclare block-scoped variable ‘num’if(true){ const a &#x3D; 20;}console.log(a); let和const区别1.let声明的变量可以被修改，const声明的是常量 不可以改变2.let声明时可以不赋值，const声明时必须赋值 变量的解构赋值解构赋值；就是快速的从对象或者数组中取出成员的一个语法方式 解构对象12345678const obj = &#123; name:&quot;zs&quot;, age:18, genders:&quot;男&quot;&#125;let name = obj.name;let age = obj.age;let genders = obj.genders; 123456789101112131415const obj2 = &#123; name:&quot;ls&quot;, age:18, genders:&quot;女&quot;&#125;//解构对象//前面的必须是&#123;&#125;表示要从obj2这个对象中获取对象成员//name age genders 都是obj2的现有成员//obj2必须是对象let&#123;name,age,genders&#125; = obj2;console.log(name,age,genders);let&#123;name:a,age:b,genders:c&#125; = obj2;console.log(a,b,c);let&#123;max,min,ceil,floor,random&#125;=Math;console.log(max(10,20,30)); 解构数组12345678//使用解构赋值的方式从数组中提取成员const arr2 = [&quot;一&quot;,&quot;二&quot;,&quot;三&quot;];//解构数组//a b c 分别对应这个数组中的索引下标0 1 2//arr2 必须是数组//如果解构失败，返回结果就是undefinedlet [a,b,c,d] = arr2;console.log(a,b,c,d); 模板字符串ES5中 表示字符串的时候使用’’或者””ES6中 还有一种可以表示字符串的方法 就是&#96;&#96;ES5 字符串 需要同行书写，换行后需要拼接字符串 12const str2 = &#x27;hello&#x27; +&#x27;world&#x27; ES6 可以直接换行使用 12const str3 = `hello world` &#96;&#96;的拼接方式与””不同 12console.log(&quot;我要&quot;+a+&quot;块钱&quot;)console.log(`我要$&#123;a&#125;块钱`) 字符串与数值拓展字符串12345678910111213let &#123;log&#125; = console;let str = &quot;Tom&quot;;//判断字符串中是否存在指定字符 返回true或者falselet res = str.includes(&quot;opm&quot;);//判断字符串中以指定字符开头 返回true或者falseres = str.startsWith(&quot;p&quot;)//判断字符串中以指定字符结尾 返回true或者falseres = str.endsWith(&quot;m&quot;)//repeat() 将字符串重复N次，返回一个新的字符串res = str.repeat(3)//TomTomTomres = str.repeat(2.5)//TomTomres = str.repeat(0)//&quot;&quot;log(res); 数值12345678910111213141516171819202122232425262728let&#123;log&#125; = console;//Number.isFinite() 判断被传入的内容是否为有限数值let res = Number.isFinite(100);//trueres = Number.isFinite(100/0);//falseres = Number.isFinite(Infinity);//falseres = Number.isFinite(NaN);//falseres = Number.isFinite(&quot;100&quot;)//false//Number.isInteger() 判断被传入的内容是否为整数res = Number.isInteger(100);//trueres = Number.isInteger(100.0);//trueres = Number.isInteger(100.1);//falseres = Number.isInteger(&quot;Tom&quot;);//falseres = Number.isInteger(&quot;100&quot;)//false//Math.trunc() 将括号内的参数转化为数字再去掉小数点res = Math.trunc(1.2);//1res = Math.trunc(1.8);//1res = Math.trunc(-1.8);//-1res = Math.trunc(&quot;Tom&quot;);//NaNres = Math.trunc(&quot;10.2&quot;);//10//Math.sign() 判断括号内的数是正数负数还是0res = Math.sign(200);//1res = Math.sign(-200);//-1res = Math.sign(0);//0res = Math.sign(-0);//-0res = Math.sign(&quot;asld&quot;);//NaN 数组拓展12345678910111213//...扩展运算符: let arr = [1,2,3]; let arr2 = [4,5,6]; let res =[...arr,...arr2]; console.log(res);//1，2，3，4，5，6function test()&#123; //arguments 是函数参数的集合 是个伪数组 console.log(arguments); //Array.from() 将 伪数组 转换为 真实数组 res = Array.from(arguments); console.log(res);&#125;test(1,2,3) document.querySelectorAll() 通过选择器获取所有相关元素 返回的是NodeList 伪数组document.querySelector() 通过选择器获取首个相关元素 直接返回元素对象find() 主要用于查找一个符合条件的数组元素findIndex() 主要用于查找一个符合条件的数组元素的下标它的参数是一个回调函数 在回调函数中可以制定寻找元素的条件当条件成立为true时间。返回该元素，如果没有符合的条件，返回undefined 123456let arr3 = [11,22,33,44,55]res = arr3.find(function(item)&#123;//item 表示数组内的每一个成员 return item&gt;20; console.log(item);&#125;)console.log(lis); fill() 使用括号内的参数，直接在数组内填充数据（替换和添加）第一个参数 是替换的新value值第二个参数 是替换的起始坐标第三个参数 是替换的结束坐标 123let arr5 = [1,&quot;纯爱&quot;,&quot;纯爱&quot;];arr5.fill(&quot;牛头人&quot;,1,2);console.log(arr5); 对象拓展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; let name = &quot;张三&quot; let obj = &#123; name:name, fn:function()&#123;&#125; &#125; console.log(obj) //如果对象的属性和value的变量相同，就可以只写一个属性名 let obj2 = &#123; name, //name:name getMessage()&#123;&#125;, getList()&#123;&#125; &#125; console.log(obj2) let msg = &quot;class&quot;; //对象的属性名可以使用表达式 需要用到符号 [表达式] let obj3 = &#123; [msg+&quot;one&quot;]:&quot;Tom&quot;, [`$&#123;msg&#125;xxx`]()&#123;&#125; &#125; console.log(obj3) let obj4 = &#123; name:&quot;jerry&quot;, age:14 &#125; //对象内可以使用拓展运算符 let obj5 = &#123; ...obj4//相当于通过for in遍历，属于深拷贝 &#125; console.log(obj5) //Object.assign() 将需要操作的元素复制到目标对象中 //第一个参数 目标参数 //第二个参数及后面所有额参数都是 需要操作的对象 //如果复制的数据是 值类型数据 实现的是深拷贝 //如果复制的数据是 引用类型数据 使用的任然是该数据的指针(引用地址)，实现的是浅拷贝(重点) let obj6 = &#123;&#125;; let obj7 = &#123; name:&quot;ggBANG&quot;,//值类型深拷贝 friends:[&quot;小A&quot;]//引用类型浅拷贝 &#125; Object.assign(obj6,obj7); obj6.age = 20; obj6.friends = &quot;小王&quot;; console.log(obj6) console.log(obj7)&lt;/script&gt; 函数拓展1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; function fn()&#123;&#125; let fn2 = function()&#123;&#125; // =&gt; const fn3 = (a,b) =&gt;&#123; console.log(a+b) &#125; fn3(1,2) // xxx.onclick = ()=&gt;&#123;&#125; // setInterval(()=&gt;&#123;&#125;) //传入一个参数a, 并且a为函数的返回值 //只有一个参数的情况下 小括号可以省略 //函数内 只有一行需要执行的代码的时候 花括号可以省略 const fn4 = a =&gt;a; fn4(10) //箭头函数制定参数默认值 const fn5 = (a=20,b=50) =&gt;&#123; console.log(a,b); &#125; fn5() let div = document.querySelector(&#x27;div&#x27;); //函数区别 //1.箭头函数的this指向 函数的声明处 //2.箭头函数中无法使用arguments //3.箭头函数不可以作为构造函数 使用 div.onclick= () =&gt;&#123; console.log(this); &#125; // const fn6 = () =&gt;&#123; // console.log(arguments); // &#125; // fn6(1,2,3) const Tom = () =&gt;&#123; console.log(&quot;123&quot;); &#125; new Tom() &lt;/script&gt; SymbolSymbol：表示独一无二的值 1234567891011121314151617var names = Symbol();console.log(names);//使用symbol 当作对象名var obj = &#123; [names]:&quot;Tom&quot;&#125;console.log(obj);//Symbol 函数可以接收一个字符串作为字符串，表示堆Symbol实例的描述//主要是为了在控制台上显示，比较容易区分const ages = Symbol(&quot;age&quot;)console.log(ages)var obj2 = &#123; [ages]:18, [names]:&quot;Tom&quot;&#125;//获取带有Symbol格式的属性console.log(obj2[ages]);//不要加.了 Reflect 是一个内置对象的反射机制，用来提供方法 拦截js的操作Reflect.ownKeys(obj)返回一个数组forEach（）实现遍历的方法 123Reflect.ownKeys(obj).forEach(function(item)&#123; console.log(item);&#125;) Iterator接口Iterator接口的作用为各种数据结构，提供一个统一的，简单的访问接口使数组格式的成员能够按照某种次序排列es6创造了一种新的遍历命令 for of 循环， Iterator接口主要供for…of循环Iterator接口遍历的过程创建一个指针对象，指向当前数据结构的起始位置,第一次调用指针对象的next方法，可以将指针指向该数据结构的第一个成员第二次调用指针对象的next方法，指针就指向该数据结构的第二个成员不断调用指针对象的next方法，直到他指向数据结构的结束位置 1234let item = arr[Symbol.iterator]();console.log(item);console.log(item.next());console.log(item.next()); ES6规定，默认的Iterator接口部署在数据结构[Symbol.iterator]属性或者说 只要有 数据结构 具备Symbol.iterator属性 就认为是可遍历的Symbol.iterator属性本身就是一个函数，就是当前数据结构默认的遍历器生成函数执行这个函数就会返回一个遍历器原生默认具备 iterator 接口的数据结构如下:Array Set Map String arguments NodeList Set数据结构Set类似于数组，成员的值是唯一的，没有重复的值Set.size() 返回Set实例的成员总数Set.add() 添加Set成员Set.delete()删除Set成员Set.has() 查看括号内的成员是否在Set中存在 返回布尔类型 1234567let s1 = new Set([1,2,3,4]);console.log(s1);let s2 = new Set();s2.add(&#x27;hello&#x27;);s2.add(&#x27;world&#x27;);s2.delete(&quot;world&quot;);s2.clear(); Set遍历Set.keys() 返回键名的遍历器Set.values() 返回键值的遍历器Set.entries() 返回键值对的遍历器 123456789let result =s2.keys();console.log(result); result =s2.values();console.log(result); result =s2.entries(); console.log(result); s1.forEach(function(item)&#123; console.log(item);&#125;) 数组去重方法一： 123456let arr = [19,20,19,19,20,21,30,90];let s1 = new Set(arr);console.log(s1);//输出的是一个对象//需要转换为数组的话s1 = Array.from(s1);//使用Array.from() 转换成数组console.log(s1); 方法二： 12let s2 = [...new Set(arr)];//...扩展运算符console.log(s2); Map12345678910111213141516171819202122232425&lt;script&gt; //Map 类型对象 键值对的集合，但是Map中的key不限于字符串，可以是各种类型的值 let M1 = new Map(); M1.set(&#x27;name&#x27;,&#x27;tom&#x27;); M1.set(&#123;a:1&#125;,&#x27;tom&#x27;); M1.set(&#x27;big&#x27;,&#x27;small&#x27;); //操作方法 //Map.set(key.value); 在Map对象中添加key和对应的value //Map.get(key); 在Map对象中获取key对象的value //Map.delete(key); 删除指定的key //Map.has(key); 查看key是否在map中存在 返回布尔类型 //Map.clear(); 清空 console.log(M1); console.log(M1.get(&quot;name&quot;)); M1.delete(&quot;name&quot;); console.log(M1); let res = M1.has(&#x27;big&#x27;); console.log(res); //Map遍历方法 与 Set相同 res = M1.keys() res = M1.values() res = M1.entries() console.log(M1); console.log(res);&lt;/script&gt; ProxyObject.defineProperty() 拦截并处理数据第一个参数 需要拦截处理的对象第二个对象 对象内的属性第三个对象 {}配置项，格式是个对象 1234567891011121314151617181920let obj = &#123; data: 111, name:&quot;zs&quot;, age:20 &#125;let box = document.getElementById(&quot;box&quot;)Object.defineProperty(obj, &quot;data&quot;, &#123; get() &#123;// 当使用对象内的指定属性时调用 console.log(&quot;get函数调用&quot;); &#125;, set(value)&#123; console.log(&quot;set函数接收到了:&quot;,value); if(value&gt;=1000)&#123; box.innerHTML =`数据较大,请重新输入`; &#125; else&#123; box.innerHTML = `数据合理放心使用`; &#125; &#125;&#125;) Proxy代理: 123456789101112131415let proxy = new Proxy(obj,&#123; get(target,key)&#123; //target 表示 需要代理的对象 //key 表示的是访问的属性 console.log(target,key); return target[key]; &#125;, set(target,key,value)&#123; //target 表示 需要代理的对象 //key 表示的是设置的属性 //value 设置的新值 console.log(&quot;set:&quot;,target,key,value); target[key] = value//确认操作 &#125;&#125;) ReflectReflect 主要用来获取目标对象的行为,它与Object类似，但更容易读 Promise对象回调地狱当一个回调函数嵌套另一个回调函数的时候就会出现嵌套结构当嵌套结构多的时候，就会出现回调地狱的情况回调地狱 其实就是由多个回调函数互相嵌套导致的，代码维护性非常差 同步异步异步 当一行代码还没有执行结束，就可以去执行另一行代码的顺序 叫做异步同步 当代码逐行执行过程就是同步的过程异步的操作：定时器 callbackpromise 是异步编程的一种统一的解决方案，比传统回调函数，更合理更强大 1234567891011121314151617const api = new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; if(true)&#123; resolve()//resolve 表示成功的回调函数 &#125; else&#123; reject()//reject 表示失败的回调函数 &#125; &#125;,1000)&#125;)api.then(()=&gt;&#123; console.log(&quot;yyyyy&quot;);//.then() 成功&#125;).catch(()=&gt;&#123; console.log(&quot;nnnnn&quot;);//.catch() 失败&#125;) Promise 对象通过自身的状态，来控制异步操作。Promise实例具有三种状态异步操作未完成(pending)异步操作完成(fulfilled)异步操作失败(rejected) 链式调用为什么promise可以实现链式调用因为当promise方法执行结束后仍然会返回一个promise对象 123456789101112131415const a = promise.then((res) =&gt; &#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 2000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 3000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 5000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;);&#125;).catch((err)=&gt;&#123; console.log(&quot;失败啦&quot;,err);&#125;)console.log(a) all方法Promise.all() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态都是fulfilled pAll的状态才是 fulfilled此时P1,P2,P3的返回值组成一个数组，传递给pAll中 race方法Promise.race() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态只要有一个fulfilled pRace的状态才是 fulfilled此时返回值是首次达到fulfilled状态的值除非全部reject否则不会触发.catch Generator函数ES6 提供的一种异步编程解决方案 123456789101112function *gen()&#123; console.log(1); yield;//yield 表示暂停执行标记，通过next方法恢复执行 console.log(2); yield; console.log(3);&#125;let g = gen()//next() 驱动下一步的执行g.next()g.next()g.next()console.log(g); Class语法与继承123456789101112131415class Person&#123;//创建一个Person类 也叫做 构造函数 //类中的属性需要使用constructor 构造器创建 constructor(name,age,height)&#123; this.name = name; this.age = age; this.height = height; &#125; // 在类中创造方法 say()&#123; console.log(&quot;这是Person类&quot;); &#125;&#125;let obj = new Person(&quot;zhangsan&quot;,19,&quot;180cm&quot;);console.log(obj);obj.say() class继承 123456789101112131415161718192021222324class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(&quot;这是&quot;,this.name,this.age,&quot;岁&quot;); &#125;&#125;const one = new Person(&quot;张飞&quot;,100);one.say();class Student extends Person&#123;//extends 表示StudentPerson类中继承 constructor(name,age,height)&#123; super(name,age);//super() 表示从父类中继承的属性内容 必须写在 construtor中 this.height = height; &#125; say()&#123; super.say(); console.log(&quot;是学生&quot;) &#125;&#125;let obj = new Student(&#x27;xz&#x27;,12,&#x27;120&#x27;);console.log(obj);obj.say();","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"MarkDown学习(一)","slug":"MarkDown学习-一","date":"2023-06-22T13:39:30.000Z","updated":"2023-07-01T08:40:13.416Z","comments":true,"path":"2023/06/22/MarkDown学习-一/","link":"","permalink":"http://example.com/2023/06/22/MarkDown%E5%AD%A6%E4%B9%A0-%E4%B8%80/","excerpt":"","text":"MarkDOwn初识标题要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 () (例如：### My Header)。 1234567# 1级标题## 2级标题### 3级标题#### 四级标题 ##### 五级标题 ###### 六级标题 字体1*斜体文本* 斜体文本 1**加粗文本** 加粗文本 1***加粗和斜体文本*** 加粗和斜体文本 1~~删除文本~~ 删除文本 1&gt; 引用文本 引用文本 列表有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 一： First item Second item Third item Fourth item 二： 12341. First item1. Second item2. Third item3. Fourth item First item Second item Third item Fourth item 三： 12341. First item8. Second item7. Third item3. Fourth item First item Second item Third item Fourth item 无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 123456- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 复选框列表（CheckBoxList） 123- [ ] List Item 1 unchecked- [x] List Item 2 checked- [X] List Item 3 checked List Item 1 unchecked List Item 2 checked List Item 3 checked 代码12345678910111213141516#[derive(Debug)]pub enum State &#123; Start, Transient, Closed,&#125;impl From&lt;&amp;&#x27;a str&gt; for State &#123; fn from(s: &amp;&#x27;a str) -&gt; Self &#123; match s &#123; &quot;start&quot; =&gt; State::Start, &quot;closed&quot; =&gt; State::Closed, _ =&gt; unreachable!(), &#125; &#125;&#125; 123456789101112[ &#123; &quot;title&quot;: &quot;apples&quot;, &quot;count&quot;: [12000, 20000], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;, &#123; &quot;title&quot;: &quot;oranges&quot;, &quot;count&quot;: [17500, null], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;] 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Gre\\&#x27;ater&#x27; return (param2 - param1 + 1 + 0b10l) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; 12345678910111213&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt; function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt; 123456789101112131415161718192021function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=&quot;$&#123;cls&#125;&quot;`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log(&#x27;undefined&#x27;); &#125; return ( &lt;div&gt; &lt;web-component&gt;&#123;block&#125;&lt;/web-component&gt; &lt;/div&gt; )&#125;export $initHighlight; 1234567891011121314#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125; 123456789101112CREATE TABLE &quot;topic&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;forum_id&quot; integer NOT NULL, &quot;subject&quot; varchar(255) NOT NULL);ALTER TABLE &quot;topic&quot;ADD CONSTRAINT forum_id FOREIGN KEY (&quot;forum_id&quot;)REFERENCES &quot;forum&quot; (&quot;id&quot;);-- Initialsinsert into &quot;topic&quot; (&quot;forum_id&quot;, &quot;subject&quot;)values (2, &#x27;D&#x27;&#x27;artagnian&#x27;); 12345678910111213#import &lt;UIKit/UIKit.h&gt;#import &quot;Dependency.h&quot;@protocol WorldDataSource@optional- (NSString*)worldName;@required- (BOOL)allowsToLive;@end@property (nonatomic, readonly) NSString *title;- (IBAction) show;@end 12345678910111213141516/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123; public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; 123456789101112131415import Foundation@objc class Person: Entity &#123; var name: String! var age: Int! init(name: String, age: Int) &#123; /* /* ... */ */ &#125; // Return a descriptive string for this person func description(offset: Int = 0) -&gt; String &#123; return &quot;\\(name) is \\(age + offset) years old&quot; &#125;&#125; 123456789101112131415@font-face &#123; font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123; color: #F0F0F0; background: #600; font-family: Chunkfive, sans;&#125;@import url(print.css);@media print &#123; a[href^=http]::after &#123; content: attr(href) &#125;&#125; 12345678910111213# The Greeter classclass Greeter def initialize(name) @name = name.capitalize end def salute puts &quot;Hello #&#123;@name&#125;!&quot; endendg = Greeter.new(&quot;world&quot;)g.salute 12345678910111213# MakefileBUILDDIR = _buildEXTRAS ?= $(BUILDDIR)/extras.PHONY: main cleanmain: @echo &quot;Building main facility...&quot; build_main $(BUILDDIR)clean: rm -rf $(BUILDDIR)/* 123456789101112package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan float64) ch &lt;- 1.0e10 // magic number x, ok := &lt;- ch defer fmt.Println(`exitting now\\`) go println(len(&quot;hello world!&quot;)) return&#125; 123456789101112131415#!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then echo &quot;Superuser rights required&quot; exit 2figenApacheConf()&#123; echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125; 123456789101112; boilerplate[package]name = &quot;some_name&quot;authors = [&quot;Author&quot;]description = &quot;This is \\a description&quot;[[lib]]name = $&#123;NAME&#125;default = Trueauto = nocounter = 1_000 超链接1这是一个链接 [百度](https://baidu.com)。 这是一个链接 百度。 图片1![图片alt](图片链接 &quot;图片title&quot;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]},{"title":"Javascript 基础知识","slug":"Javascript-基础知识","date":"2023-06-12T05:11:08.000Z","updated":"2023-07-01T08:40:11.753Z","comments":true,"path":"2023/06/12/Javascript-基础知识/","link":"","permalink":"http://example.com/2023/06/12/Javascript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 JavaScrip简介JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。JavaScript 很容易学习。 ECMAScript 语法标准(es)JavaScript 输出JavaScript 可以通过不同的方式来输出数据：使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 外部的 JavaScript也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。 外部 JavaScript 文件的文件扩展名是 .js。 1&lt;script src=&quot;./01.js&quot;&gt;&lt;/script&gt; 变量1var a = 20; var 申明变量名a 变量名 用来存储变量20 变量&#x3D; 赋值符号 从右向左赋值 变量命名规则：1.可以是字母或者下划线_或者$开头2.长度不可超过255个字符3.名中不能含有空格，首字头不能是数字4.严格区分大小5.不能使用关键字或保留字6.汉字可使用不推荐当使用空的变量名时，得到的结果就是未定义 undefined使用不存在的变量名时，报错，d is not defined变量的声明提升:先使用变量再创建变量 得到的结果会是 undefined 只能提升变量名，不提升变量 12console.log(e);var e = 30; 相当于 123var e;console.log(e);var e = 30; 数据类型与转换基本数据类型:number 数字string 字符串 只要有引号包裹就是字符串boolean 布尔 true&#x2F;false将数据类型转化为number类型强制类型转换:Number（） 将数据类型转换成number转换字母等非数字内容的话会显示NaN (No a Number)parseFloat() 浮点型 将数据保留小数 并且转换为数字类型转换带数字的字符串时，必须开头为数字才能识别parseInt() 整型 将数据保留整数，并转换成数字类型isNaN()：判断内容是否是 非数字 如果是非数字 返回 true 反之为 false只查看数据内容，不查看数据类型数据类型转换为字符串强制类型转换String() 将数据类型转换为字符串xxx.toString() 将数据类型转换为字符串 需要转化的变量名写在前面将数据类型转换为布尔Boolean()0为false，其他为true值类型:number 数字string 字符串boolean 布尔null 空undefined未定义symbol 独一无二的引用数据类型：object 对象function函数array 数组tpyeof(undefined)&#x3D; undefined;tpyeof(null)&#x3D; object;tpyeof(error)&#x3D; object; 算数运算符+ 加法当符号两边都是数字的时候，会自动相加求和当符号两边有字符串时，会起到拼接字符串的作用（结果时字符串类型–隐式类型转换）当符号两边有布尔类型时，true为1，false为0 参与求和计算++ 自增加1++在后面 表示后加，处于正在加1的过程，还没加上，当再次使用变量时，才算自增结束++在前面 表示先加，直接自增结束，得到就是自增+1的结果- 减法当符号两边都是数字的时候，会自动相减求差当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算– 自减1，同自增* 乘法当符号两边都是数字的时候，会自动相乘求积当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算&#x2F; 除法当符号两边都是数字的时候，会自动相除求商当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算除数如果是0 得到的是 Infinity 无穷&#x2F;无限% 除余()优先运算符 比较运算符注意：&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D; 的不同&#x3D;&#x3D; 等号(只比较值，不比较数据类型)&#x3D;&#x3D;&#x3D; 全等号（值和数据类型都相同）&gt; 大于号&gt;&#x3D; 大于等于&lt; 小于&lt;&#x3D; 小于等于!&#x3D; 不等于!&#x3D;&#x3D; 不全等于 逻辑运算符&amp;&amp; 与 符号两边的表达都为true整个表达式的结果就是true 有一方为false，整个表达式的结果就是false|| 或 有一方为true，整个表达式的结果就是true！ 非 对象与事件实例化对象：var obj&#x3D;new Object();键值对（属性：属性值）obj.name&#x3D;”zs”;&#x2F;&#x2F;键值对就是XX&#x3D;XX字面量的方式创建对象: 12345var obj2 = &#123; name:&quot;1s&quot;, age:20, height:172&#125; 日期对象var&#x3D; new Date();date.getFullYear();获取当前年份getMonth 获取当前月份getDate日期getDay星期getHours小时getMinutes分钟getSeconds当前秒getMilliseconds 当前毫秒getTime从1970.1.1至今的毫秒数Math对象Math.max 返回最大数Math.min 返回最小数Math.ceil 天花板函数，有小数部分向上取整Math.floor 地板函数 舍掉小数部分Math.round(b) 四舍五入Math.random() 随机数字0-1 取不到1事件on绑定事件的关键字 click 点击事件box.onclick&#x3D;function(){}onblur 失去焦点 if else略 switchswitch 用来监视链路，捕获数据某种情况下需要执行的代码块switch 具有数据穿透性 需要break中断余下代码的执行default 相当于else 123456789101112switch(n)&#123; case 10: XXXX; break; case 20: XXXX; break; default: XXXX; break;&#125; 第二种情况：switch(true) 12345switch(true)&#123; case n&lt;10&amp;&amp;n&gt;=0: console.log(&quot;switch范围监测&quot;) break;&#125; 三目运算符表达式？ 结果1(true):结果2(false) 1a&gt;b ? console.log(&quot;a大&quot;):console.log(&quot;b大&quot;); for循环for循环执行顺序：for 首次执行 先创造变量 再判断条件 不走增量 直接执行代码块剩下的执行次数都是 先增量再判断 最后走代码块如果 变量不满足判断条件 循环结束for(初始化变量;判断条件；增量){重复执行代码块}break： 终止循环 终止整个循环体 余下代码不执行continue： 终止循环 终止当前次数的循环，余下代码不执行 while循环与do while循环1234while(i&lt;10)&#123; console.log(i); i++;&#125; 1234do &#123; i++; console.log(i); &#125; while (i &lt; 10) while 和 do while的区别while循环是 先判断再执行do while 循环 是先执行再判断 数组和数组api123456789101112131415161718192021222324252627282930313233var arr = new Array();//实例化数组// 数组内数据的序号 我们叫做下标（索引号）arr[0]=&quot;李白&quot;;arr[1]=&quot;白居易&quot;;console.log(arr);// 字面量的方式创建数组var arr2 = [&quot;ls&quot;,&quot;zs&quot;,123,false];console.log(arr2);// 数组的使用方式 数组名[下标]console.log(arr2[2]);// 数组名.length 数组内成员的个数console.log(arr2.length);//二维数组var arr4 = [1,3,4,[1,2,3]];console.log(arr4[3][1]);//多维数组var arr5 =[&#123; name:&quot;zs&quot;, age:18, friends:[&#x27;ls&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;ls&quot;, age:20, friends:[&#x27;zs&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;wr&quot;, age:22, friends:[&#x27;ls&#x27;,&#x27;zs&#x27;]&#125;] 数组的操作方法1.数组.includes() 查看数组内是否包含指定成员，如果是就返回true,如果不包含就返回false 2.Array.isArray() 判断是否是一个数组格式 返回 true 或 false 3.数组.indexOf() 查看数组内的成员，如果存在就返回首次出现的下标，如果不存在就返回-14.数组.lastIndexOf() 查看数组内的成员，如果存在就返回最后一次出现的下标，如果不存在就返回-15.数组.join() 在数组各元素之间插入相同的字符串拼接，将数组转换成字符串6.数组.push() 在原数组末尾添加新成员，返回新数组长度，原数组被改变7.数组.unshift() 在数组开头添加新成员，返回新数组长度，原数组被改变8.数组.pop() 删除数组最后一名成员，返回被删除内容，原数组被改变9.数组.shift() 删除数组开头的成员，返回被删除内容，原数组被改变 10.数组.reverse() 反转数据11.数组.splice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组改变当括号内有两个参数的时候，表示从当前下标开始一直截取到几个，返回被截取的内容，原数组改变当括号内有三个参数的时候，第三个参数表示在截取位置添加的新内容，返回被截取的内容，原数组改变12.数组.slice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组不改变当括号内有两个参数的时候，表示从当前下标开始到第二个参数下标结束，返回被截取的内容，原数组不改变var res &#x3D;arr.includes(“奥斯”); 字符串API字符串.length 获取字符串的长度字符串.split() 字符串转换成数组，根据括号的内容进行字符分割字符串.charAt() 返回指定下标处的字符字符串.indexOf() 返回查找首次出现字符的下标，如果不存在返回-1字符串.lastIndexOf() 返回查找最后一次出现字符的下标，如果不存在返回-1字符串.substr() 截取字符串 如果有一个参数 表示从当前下标开始截取到末尾 返回截取的内容如果有两个参数，表示从当前下标开始截取几个 返回截取的内容 函数匿名函数： 自调用 通过事件绑定在一起触发具名函数： function . 函数名()函数特性：不调用，不执行函数的使用叫做调用函数具有 预加载(函数的位置在定义先后不影响执行)具名函数的调用 函数名()return 返回值（余下代码不执行）function 函数名（形式参数）{}var a &#x3D; 函数名（实际参数）；封装函数 全局变量与局部变量变量是存在作用域的 分为 全局变量和局部变量局部变量： 在函数内部用var声明的变量就是局部变量（只在函数内部生效）全局变量：在函数外部用var声明的变量就是全局变量，可以在整个JS中生效不用var声明的，变量也是全局变量（不推荐使用）闭包：闭包的形式：多个函数互相嵌套闭包的目的：将内部函数的局部变量提到全局中去使用闭包的实现方式：不断地设置return 返回值闭包的缺点：会消耗电脑内存 影响性能 DOMdocument object model 文档对象模型 定时器1234567891011// setInterval(callback) 多次执行的定时器 callback参数 表示 回调函数start.onclick = function () &#123; timer = setInterval( function () &#123; console.log(1); &#125;, 1000) &#125; stop.onclick = function () &#123;// clearInterval(定时器的名字) 清除定时器 clearInterval(timer);&#125; thisthis 表示 这个this 在函数中 代指函数的调用者this在函数外 指向的是window对象，最大的对象 12345678910111213141516var lis = document.getElementsByTagName(&quot;li&quot;)console.log(this);for (var i = 0; i &lt; lis.length; i++)&#123; //属性绑定 写在循环的内部，事件的外部 // index 一般表示为下标 lis[i].index = i; lis[i].onclick = function() &#123; //先让所有颜色都变成蓝色 再让当前的这个变成红色 //这就是排他思想 for (var j = 0; j &lt; lis.length; j++)&#123; lis[j].style.background = &quot;skyblue&quot;; &#125; this.style.background = &quot;red&quot;; console.log(this.index);//获取到下标 &#125;&#125; 轮播图参考https://swiper.com.cn/ Node节点操作1.xx.parentNode 当前节点的父节点2.xx.childNodes 当前节点的所有子节点,包含文本节点(本次返回的text为回车造成的空格) 返回nodeList 伪数组3.xx.children 当前节点的所有子元素节点 返回HTMLCollection 伪数组4.xx.firstChild 当前节点的第一个子节点,包含文本节点5.xx.firstElementChild 当前节点的第一个子元素节点6.xx.lastChild 当前节点的最后一个子节点,包含文本节点7.xx.lastElementChild 当前节点的最后一个子元素节点8.xx.previousSibling 当前节点的前一个兄弟节点,包含文本节点9.xx.previousElementSibling 当前节点的前一个兄弟元素节点10.xx.nextSibling 当前节点的前一个兄弟节点,包含文本节点11.xx.nextElementSibling 当前节点的前一个兄弟元素节点节点的操作1.document.createElement() 创建节点2.xx.innerHTML 往节点内添加或替换内容(文本或标签)2.xx.innerText 往节点内添加或替换内容(文本)4.xx.appendChild() 往父节点的末尾添加新节点5.xx.insertBefore(新节点,目标节点) 将新节点添加到目标节点之前6.xx.cloneNode() 克隆节点,true的时候,将该节点及其子节点全部复制；flase的时候只复制节点本身。7.父节点.removeChild() 删除父节点的子节点 偏移量offsetWidth 元素自身的宽度 width+border+paddingoffsetHeight 元素自身的高度 同上offsetLeft 元素自身的位置offsetTop 元素自身的位置onscroll 滚动事件scroll卷曲的距离clientWidth可视区域的宽 width paddingclientWidth可视区域的宽 height padding document.body;&#x2F;&#x2F;获取body 标签document.documentElement&#x2F;&#x2F;获取html标签 事件对象event 事件对象 通过事件触发的时候调用函数内的参数该对象内包含了事件触发时的信息事件对象的兼容写法： 1var e = event || window.event;//兼容低版本ie浏览器 pageX 光标相对于网页的水平位置（ie无）*pageY 光标相对于网页的垂直位置（ie无）*screenX 光标相对于屏幕的水平位置screenY 光标相对于屏幕的垂直位置clientX 光标相对于可视区域的水平位置*clientY 光标相对于可视区域的垂直位置（重要且相同）xx.onkeypress 键盘按键 按下并且弹起xx.keyCode 表示键盘上对应按键的编码xx.onmouseenter 鼠标进入xx.onmouseleave 鼠标离开 事件冒泡和事件句柄事件冒泡：当一个元素的事件被触发的时候,比如鼠标点击了一个元素，同样的事件就会在这个元素的所有祖先元素上被触发这个过程就叫做事件冒泡,这个事件是从原始事件一直冒泡到dom树的最上层.不支持事件冒泡的事件: focus,blur,mouseenter,mouseleave,load,resize 12//阻止事件冒泡的兼容写法e.stopPropagation ? e.stopPropagation() :e.cancelBubble = true; 事件句柄:addEventLister 添加事件句柄第一个参数 事件的名称第二个参数 callback 回调函数第三个参数 false 触发的顺序是由内到外，叫做冒泡的顺序（默认）； true 触发的顺序是由外到内，叫做捕获的顺序同一个元素可以绑定多个相同事件，不会覆盖，挨个执行 123box.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;222&quot;); &#125;,true) 缓存注意：cookie localStorage sessionStorage的区别cookie 默认浏览器关闭时消失，存在于web服务器中，存储大小为4KBlocalStorage 本地储存 永久有效，除非手动删除，存储大小为5MBsessionStorage 会话存储 关闭浏览器或窗口事就消失，存储大小为5MBcookie缓存： 123456document.cookie=&quot;username = 李白&quot;//创建cookie缓存document.cookie=&quot;age = 30; expires = Tue, 20 Jun 2023 12:00:00 GMT&quot;//设置过期事件var res =document.cookie;var n = res.indexOf(&quot;=&quot;) +1 ;res = res.substr(n);console.log(res); localStorage缓存： 123456localStorage.setItem(&quot;NAME&quot;,&quot;TOM&quot;);//创建缓存 localStorage.setItem（key,value） localStorage.setItem(&quot;AGE&quot;,&quot;18&quot;);localStorage.removeItem(&quot;AGE&quot;);//删除指定缓存 localStorage.removeItem(key)var res = localStorage.getItem(&quot;NAME&quot;);//获取缓存 localStorage.getItem(key) var age = localStorage.getItem(&quot;AGE&quot;);localStorage.clear();//清空缓存 localStorage.clear() BOMbrowser object model 浏览器对象模型 Window对象window.open(“https://www.baidu.com&quot;//在当前窗口跳转window.close();&#x2F;&#x2F;关闭窗口 locationlocation.hostname web主机域名location.pathname 当前页面的路径location.port 端口号(0-65535)location.herf 整个URLlocation.protocol web协议常见的协议:http 和 https 的区别*http 免费 相对不安全，端口号默认80https 收费 比较安全，端口号默认443 secureftpfile history两种后退功能：history.back(); history.go(-1);两种前进功能：history.go(); history.go(1); navigatornavigator 设备信息对象navigator.appCodeName 浏览器代号navigator.appName 浏览器名称navigator.appVersion 浏览器版本navigator.vender 浏览器供应商navigator.cookieEnabled 浏览器是否启用了缓存navigator.platform 硬件平台navigator.userAgent 用户代理语言navigator.language 用户代理语言 正则表达式 实例化创建正则对象 1var reg = new RegExp(); &#x2F;&#x2F;字面量方式创造正则对象reg &#x3D; &#x2F;@&#x2F;; 含有@reg &#x3D; &#x2F;\\d&#x2F; 含有数字reg &#x3D; &#x2F;\\D&#x2F; 含有非数字reg &#x3D; &#x2F;\\s&#x2F; 含有不可见字符(空格，回车等)reg &#x3D; &#x2F;\\S&#x2F; 含有可见字符reg &#x3D; &#x2F;\\w&#x2F; 含有单词字符 字母 数字reg &#x3D; &#x2F;\\W&#x2F; 含有非单词字符 简单类reg &#x3D; &#x2F;[23]&#x2F; 含有2或者3负向类reg &#x3D; &#x2F;[^23]&#x2F; 含有非2或者3范围类reg.onblur &#x3D; &#x2F;[0-9]&#x2F; 含有0-9中的任意一个组合类reg &#x3D; &#x2F;[0-9a-z]&#x2F; 含有数字或者字母中的一个边界reg &#x3D; &#x2F;^12&#x2F; 必须以12开头reg &#x3D; &#x2F;23$&#x2F; 必须以23结束reg &#x3D; &#x2F;^123$&#x2F; 必须是123&#x2F;&#x2F;量词reg&#x3D; &#x2F;^123*$&#x2F; ‘3’的重复次数&gt;&#x3D;0次reg&#x3D; &#x2F;^123+$&#x2F; ‘3’的重复次数&gt;&#x3D;1次reg&#x3D; &#x2F;^123?$&#x2F; ‘3’的重复次数只能是0或1次reg&#x3D; &#x2F;^12{4}3$&#x2F; ‘2’的重复次数4次reg&#x3D; &#x2F;^12{4,}3$&#x2F; ‘2’的重复次数&gt;&#x3D;4次reg&#x3D; &#x2F;^12{4,10}3$&#x2F; ‘2’的重复次数4到10次 正则.test(需要校验的内容) 返回布尔类型 1var res = reg.test(inp.value); 高级JS(面向对象)值类型与引导类型值类型 ：number string boolean null undef symbol引用数据类型： array function object 值类型与引用数据类型的区别值类型 ：存储在栈中，内存空间固定当数据复制的时候，可以直接复制互不影响typeof 判断数据类型引用数据类型：存储在堆中，内存空间不固定浅拷贝：当数据复制的时候，只能复制数据的引用地址深拷贝：将数据复制并在堆中重新申请一片空间进行存储深拷贝实现的两种方式： 12var obj2 = JSON.stringify(obj);//对象 =&gt; string 将对象转换成json字符串var obj2 = JSON.parse(obj2);//string =&gt; 对象 将json字符串转换成对象 通过instanceof() 判断数据是哪一种引用类型（返回true&#x2F;false） 1var res = arr instanceof(Arry); 工厂模式和构造函数面向对象编程的基本特征封装： 将客观事物封装成抽象的类继承： 子类具有父类的公有属性多态： 对象的多功能，多方法，一个方法可以有多种表现形式字面量创建对象 创建量如果比较多就比较繁琐，并且对象之间没有关系 12345678var personOne = &#123; name:&quot;zs&quot;, age:20&#125;var personTwo = &#123; name:&quot;ls&quot;, age:24&#125; 通过封装的方式创建对象，解决代码重复的问题 123456function createPerson(name,age)&#123; return&#123; name:name, age:age &#125; &#125; 工厂模式 12345678function createPerson(name,age)&#123; var obj =new Object();//准备工厂环境 obj.name = name;//将属性进行加工 obj.age = age;//将属性进行加工 return obj;//将加工好的对象进行输出&#125;personOne = createPerson(&quot;王二&quot;,10);personTwo = createPerson(&quot;zy&quot;,30); 构造函数 12345678function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;var personOne = new CreatePerson(&quot;张三丰&quot;,&quot;108&quot;)var personTwo = new CreatePerson(&quot;孙悟空&quot;,&quot;正无穷&quot;)console.log(personOne);console.log(personTwo); 构造函数需要注意的事情：1.CreatePerson 称之为 构造函数 也叫做 类，构造函数就是类2.personOne 就是 CreatePerson 的实例对象3.构造函数中的this指向的是通过new实例化出来的4.必须使用new关键字 将函数实例化5.构造函数的开头必须大写6.构造函数会自动创造出来一个 constructor(构造器)属性，这是属性就是指向CreatePerson prototype原型属性，存在于每个构造函数之中通过prototype原型创建的方法可以在构造函数生成的实例中公用，有利于提升效率prototype 的顶端 是 object 123456789 function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;CreatePerson.prototype.say = function()&#123; console.log(&quot;yyy&quot;); return 0;&#125;var one = new CreatePerson(&quot;zs&quot;,20); 对象继承12345678910111213141516171819202122232425function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.run=function()&#123; console.log(&quot;啊啊啊啊啊&quot;);&#125;Person.prototype.findWork=function()&#123; console.log(&quot;working&quot;);&#125;function Man()&#123; console.log(&quot;nnnnn&quot;);&#125;//看似赋值的过程 =&gt; 实际上实现的是浅拷贝// Man.prototype = Person.prototype; //for in 循环（用来遍历对象）for(var k in Person.prototype)&#123; console.log(k);//k是对象的属性 Man.prototype[k] = Person.prototype[k]&#125;Man.prototype.jump = function()&#123; console.log(&quot;hhhhhhhhhhh&quot;); &#125;console.log(Man.prototype);console.log(Person.prototype); 多态多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态的实现方式：覆盖指子类重新定义父类方法，基于prototype继承就是。 call和apply和bind12345678910111213141516171819 //thiswindow.color = &quot;red&quot;;document.color = &quot;green&quot;;// console.log(window);var obj = &#123; color:&quot;white&quot;&#125;function changeColor(a,b)&#123; console.log(a+&quot;和&quot;+b+&quot;喜欢&quot;+this.color)&#125;//函数.call(this需要指向的对象，参数必须使用逗号分隔)changeColor(&quot;小王&quot;,&quot;小明&quot;);changeColor.call(document,&quot;小王&quot;,&quot;小明&quot;);changeColor.call(obj,&quot;小王&quot;,&quot;小明&quot;);//函数.apply(this需要指向的对象，参数必须使用数组)changeColor.apply(document,[&quot;小王&quot;,&quot;小明&quot;]);changeColor.apply(obj,[&quot;小王&quot;,&quot;小明&quot;]);//函数名.bind(this需要指向的对象，参数可以是任意形式)() 返回的是函数需要再次调用changeColor.bind(obj,[&quot;小李&quot;],[&quot;zs&quot;])()","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2023-06-03T11:42:34.000Z","updated":"2023-06-03T12:32:21.534Z","comments":true,"path":"2023/06/03/我的第一篇博客文章/","link":"","permalink":"http://example.com/2023/06/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"一年前，就试着搭建了这个Hexo框架的微博，但是只是部署到了Github上，并没有打理自己的博客，也没有写一些内容，这和当初搭建博客的目的有点南辕北辙了。这段时间确实是让人比较疲惫且受挫，但还是得打起精神，继续前进。","categories":[],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]}