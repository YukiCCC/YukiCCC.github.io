{"meta":{"title":"YukiCCC的博客","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-07-01T08:25:42.219Z","updated":"2023-07-01T08:25:42.219Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-18T17:09:14.605Z","updated":"2023-07-18T17:09:14.605Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"自己想做的XXX件事： 干一份自己值得为之倾尽全力的工作 邂逅真爱 自驾游环游中国 考取研究生 研究生顺利毕业 学会射箭 学会写一手花体英文字 去日本旅行一次 学会骑马 去内蒙古玩一次 去舟山群岛到普陀山登顶 学会开车 拥有一台旗舰级顶级配置的电脑 让父母放心为他们分一次忧 开一次大排量摩托车 坐一次倒悬式的过山车 作为长辈给晚辈精心准备一次礼物 给家里坏掉的房门装锁 自己自驾游一座城市 写好中国字练一手好字"},{"title":"我的朋友们","date":"2023-07-01T08:26:42.238Z","updated":"2023-07-01T08:26:42.238Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2023-07-01T08:26:59.883Z","updated":"2023-07-01T08:26:59.883Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-01T08:54:37.410Z","updated":"2023-07-01T08:54:37.410Z","comments":true,"path":"data/friends.json","permalink":"http://example.com/data/friends.json","excerpt":"","text":"[{\"group\":\"分组1# 分组标题\",\"description\":\"友情链接\",\"items\":[{\"title\":\"Google\",\"avatar\":\"https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png\",\"url\":\"https://www.google.com/\",\"screenshot\":null,\"keywords\":null,\"description\":null},{\"title\":null,\"avatar\":null,\"url\":null,\"screenshot\":null,\"keywords\":null,\"description\":null}]}]"}],"posts":[{"title":"Maven学习","slug":"Maven学习","date":"2023-08-07T01:16:39.000Z","updated":"2023-08-07T01:39:52.771Z","comments":true,"path":"2023/08/07/Maven学习/","link":"","permalink":"http://example.com/2023/08/07/Maven%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Maven简介1. 什么是Maven​ maven [ˈmeɪvn] 专家、内行 ​ Apache Maven 是一个软件项目管理和构建工具，可以帮助创建和管理项目 ​ 基于项目对象模型（POM：Project Object Model）的概念，帮助开发者构建一个项目的完整生命周期 ​ 官网：http://maven.apache.org/ 2. 为什么使用Maven 项目的管理工具 项目规模很大时一定会将项目进行拆分，拆分成多个工程，使用Maven在多个工程之间建立依赖关系 jar包的管理工具 通过仓库管理jar包、解决jar包的依赖、自动下载jar包 自动化的构建工具 编译代码、执行测试、打包、部署等 3. 术语 中央仓库 是一个网络仓库，用于存放jar包和maven插件 https://repo1.maven.org/maven2 https://mvnrepository.com 本地仓库 从中央仓库下载的jar包的存放位置，也是一个仓库，只不过是存放在本地电脑上 镜像仓库 对中央仓库做的镜像（mirror） 阿里云提供的镜像仓库 https://maven.aliyun.com/repository/public 私服 局域网内部搭建的maven服务器 二、安装Maven1. 下载安装包​ 从maven官网下载安装包，这里使用apache-maven-3.6.0-bin.tar.gz 2. 解压安装包​ 将安装包解压到无中文、无空格的路径下，如：D:\\software\\apache-maven-3.6.0 ​ 配置环境变量，将bin目录添加到Path变量中，如：D:\\software\\apache-maven-3.6.0\\bin ​ 测试，在DOS窗口中执行以下命令： 1mvn -version 3. 配置本地仓库本地仓库的默认位置： ~&#x2F;.m2&#x2F;repository（如 C:&#x2F;Users&#x2F;登录用户&#x2F;.m2&#x2F;repository） 修改本地仓库的位置：编辑conf&#x2F;setting.xml文件 1234&lt;settings&gt; &lt;!--指定本地仓库的位置--&gt; &lt;localRepository&gt;D:\\maven-repos&lt;/localRepository&gt;&lt;/settings&gt; 4. 配置镜像仓库​ 使用maven时默认从中央仓库下载所需的包(插件)，比较慢，可以配置使用阿里云提供的镜像仓库 ​ 编辑maven主目录下的&#x2F;conf&#x2F;setting.xml文件，在&lt;mirrors&gt;&lt;/mirrors&gt;标签中添加如下内容： 123456&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;!-- 名称自定义，必须唯一 --&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;!-- 所有访问都使用该镜像仓库 --&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 5. 配置Maven的JDK版本​ 修改maven默认使用的jdk版本，编辑conf&#x2F;setting.xml文件，在profiles标签里面添加如下内容 123456789101112&lt;profile&gt; &lt;id&gt;jdk‐1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 三、使用Maven1. 在IDEA中集成maven指定Maven主目录和配置文件：Settings——&gt;搜索Maven——&gt;Maven Home directory和User settings file 注：切换Porject后要重新配置maven 2. 创建maven项目File——&gt;New——&gt;Module——&gt;Maven Archetype Archetype：maven-archetype-quickstart（Java项目） &#x2F; maven-archetype-webapp（Java Web项目） GroupId : net.wanho.shop（组织域名反向+项目名称） ArtifactId : shop-product（模块名称） Version : 1.0.1（版本） 3. 目录结构Maven项目的目录结构如下： 1234567891011121314|-项目名称 |-src //程序代码 |-main //主代码 |-java //源代码 |-用于存放源代码，相当于传统项目中的src，传统项目的包名.类名，如net.wanho.shop.dao |-resources //配置文件 |-用于存放配置文件 |-webapp //网站根目录 |-WEB-INF |-web.xml |-test //测试代码，目录结构和main中完全一致 |-java |-resources |-pom.xml //maven核心配置文件 如果没有对应的目录，可以自己创建，但必须符合该目录结构 在IDEA中目录是分类型的，常用的有四种： Sources Root：主代码的目录——&gt;src&#x2F;main&#x2F;java Test Sources Root：测试代码的目录——&gt;src&#x2F;test&#x2F;java Resources Root：主代码所需资源的目录——&gt;src&#x2F;main&#x2F;resources Test Resources Root：测试代码所需资源的目录——&gt;src&#x2F;test&#x2F;resources 默认情况下新建的目录是普通的Directory，创建后可以设置目录的类型： 右击目录——&gt;Mark Directory As 每种目录的图标有所不同 4. 执行maven操作在IDEA中管理所有Maven项目：View——&gt;Tool Windows——&gt;Maven Maven项目的生命周期： 命令 作用 描述 clean 清理 删除target目录 compile 编译 将main&#x2F;中的源代码编译成字节码文件，放在target&#x2F;classes目录下 test 测试 执行测试类（使用JUnit），并生成测试报告，放在target&#x2F;surefire-reports目录下 package 打包 将java项目打包成jar，将web项目打包成war，放在target目录下 install 安装 将项目的jar包安装到本地仓库，供其他项目使用 注意： 问题：在Maven Projects中项目显示为灰色，表示该maven项目未被管理，不可用 解决：在Maven Projects里点击”+”，选择项目对应的pom.xml文件 四、pom.xml文件1. 简介​ pom:project object model 项目对象模型 ​ pom.xml是Maven的核心配置文件，与项目构建相关的所有配置都在该文件中 2. 坐标​ 用来唯一的标识每个项目，必须为项目定义坐标，且坐标必须唯一 ​ Maven坐标是通过一些元素定义的：groupId、artifactId、version 123456789&lt;!-- 坐标： groupId：定义组织id，表示当前模块隶属的项目，采用&quot;组织域名反向+项目名称&quot; artifactId：定义模块id version：定义当前的版本--&gt;&lt;groupId&gt;net.wanho.shop&lt;/groupId&gt;&lt;artifactId&gt;shop-product&lt;/artifactId&gt;&lt;version&gt;1.0.1&lt;/version&gt; 3. dependency​ 如何查找一个jar包的坐标? https://mvnrepository.com 12345678910111213141516171819202122232425262728293031&lt;!-- dependency基本配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; ​ scope表示依赖的作用域，用来配置依赖的jar包的可作用范围，即在什么地方可以使用 取值 含义 举例 compile 表示该依赖可以在整个项目中使用，参与打包部署，默认值 fastjson test 表示该依赖只能在测试程序中使用，不参与打包和部署 junit provided 表示编写源代码的时候需要，不参与打包部署 lombok、servlet-api（因为tomcat中已有） runtime 表示运行时需要，编译代码时不需要 mysql-connector（通过接口反射加载） 4. properties​ 全局属性，一般情况下用于定义全局的jar的版本 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 可以自定义标签名，然后使用 $&#123;标签名&#125; 获取标签中的值 一般情况下用于定义全局的jar的版本，相当于定义全局变量 --&gt; &lt;spring.version&gt;5.3.27&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspect&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 注：快速将jar包的版本添加到properties中：右击版本号——&gt;Refactor——&gt;Property 5. repositories​ 用于配置当前工程使用的远程仓库 ​ 查找顺序：本地仓库、pom.xml中配置的远程仓库、maven主录下的conf&#x2F;setting.xml中配置的远程仓库 1234567&lt;repositories&gt; &lt;!-- 有些最新版本的jar包，在中央仓库中可能并没有，此时可以指定其他可用的远程仓库 --&gt; &lt;repository&gt; &lt;id&gt;springio&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 6. plugins插件是一种工具，如 maven-clean-plugin插件是用来清理项目的工具 maven-compile-plugin插件是用来编译代码的工具 tomcat7-maven-plugin插件是用来将web项目自动打包并部署到tomcat的工具 1234567891011121314&lt;build&gt; &lt;plugins&gt; &lt;!-- tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8888&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 7. 案例Web应用的开发，模块名称：shop-user 步骤： 添加依赖 12345678910111213&lt;!-- servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 创建HelloServlet类 1234567891011121314151617@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setAttribute(&quot;name&quot;,&quot;tom&quot;); List&lt;Integer&gt; nums = Arrays.asList(13, 25, 38); req.setAttribute(&quot;nums&quot;,nums); Properties p=new Properties(); p.load(HelloServlet.class.getClassLoader().getResourceAsStream(&quot;stu.properties&quot;)); System.out.println(p); req.setAttribute(&quot;age&quot;,p.getProperty(&quot;age&quot;)); req.setAttribute(&quot;sex&quot;,p.getProperty(&quot;sex&quot;)); req.getRequestDispatcher(&quot;/index.jsp&quot;).forward(req,resp); &#125;&#125; 创建index.jsp 1234567891011121314151617&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--默认生成的web.xml文件使用的是web-app_2_3.dtd，会忽略EL表达式，需要启用EL表达式--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;name&#125; &lt;br&gt; &lt;ul&gt; &lt;c:forEach items=&quot;$&#123;hobbies&#125;&quot; var=&quot;hobby&quot;&gt; &lt;li&gt;$&#123;hobby&#125;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; stu.properties 123name=aliceage=21sex=male 五、Maven中的关系1. 继承含义：一个Maven工程继承自另一个Maven工程，分别称为子工程、父工程 场景：实际开发中一个大项目会拆分为多个子项目（子模块&#x2F;子工程），多个子工程使用的技术基本都相同，即多个子工程中使用的是相同的依赖或插件等配置，此时可以把相同配置抽取到一个父工程中，进行统一管理，保持一致性，简化pom.xml配置 步骤： 创建三个工程：子工程child01和child02、父工程parent 将父项目的打包方式设置为pom 12345678&lt;!-- 打包方式 jar：java项目的打包方式，默认值 war：web项目的打包方式 pom：父项目的打包方式 注：将父工程打包方式设置为pom后，父工程将不会被打包，因此不要在父工程中写java代码，父工程只是用来简化POM配置 --&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 在子项目中引用父项目，指定父项目的坐标，并指定父项目pom.xml文件的路径 12345678&lt;!-- 引用父项目，指定父项目的坐标 --&gt;&lt;parent&gt; &lt;groupId&gt;net.wanho.study&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 指定父项目pom.xml文件的相对物理路径 --&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; 注：如果子项目的位置是在父项目所在的目录中，则可以省略不配置relativePath项 问题：有时并不是父项目的所有ja包都需要被子项目继承，但又希望能够对依赖进行统一管理，如：jar包版本的控制，怎么办？ 解决：配置dependencyManagement 步骤： 在父项目中配置dependencyManagement此时父项目只进行jar包的管理，父项目的jar包默认并不会被子项目继承 12345678910111213141516171819202122&lt;!-- dependencyManagement表示父项目只进行依赖的管理，依赖默认不会被子项目继承 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在子项目中引用父项目中的依赖 如果子项目想继承父项目的jar包，需要在子项目中手动引用，且引用时只需要配置groupId和artifactId，无需指定版本version 123456789101112131415&lt;dependencies&gt; &lt;!-- 父项目配置dependencyManagement后默认并不会继承过来，需要手动在子项目中引用 只需要指定groupId和artifactId，无需指定版本version 可以指定要引用的依赖，并不一定要使用父项目中所有的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 聚合将多个子项目聚合到一个父项目中，然后通过对该父项目进行操作，从而实现对所有的聚合项目的操作 在父项目中聚合子项目： 12345&lt;!-- 聚合子项目，指定子项目的根目录--&gt;&lt;modules&gt; &lt;module&gt;../child01&lt;/module&gt; &lt;module&gt;../child02&lt;/module&gt;&lt;/modules&gt; 3. 依赖项目C —&gt; 项目B —&gt; 项目A 概念：如果项目C依赖于项目B，项目B依赖于项目A，则项目C也依赖于项目A，这叫依赖的传递 步骤： 配置依赖关系 child03——&gt;child02——&gt;child01 在child01中添加依赖时，child02和child03会传递该依赖，也会出现该依赖 3.1 控制依赖的传递并不是所有的依赖都会被传递： scope为compile的依赖会被传递 scope为test和provided的依赖不会被传递 配置optional为true的依赖不会被传递 123456&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 表示该jar包不传递 --&gt;&lt;/dependency&gt; 3.2 继承和依赖的区别继承： 使用&lt;parent&gt; 继承是指子项目可以继承父项目的数据和配置，从而简化配置 继承时父项目一般都是自己创建的项目，也可以是第三方的 依赖： 使用&lt;dependencies&gt; 依赖是指jar包可以通过依赖的方式引入 依赖时所依赖的jar包一般多是第三方的，也可以是自己创建的依赖项目 六、Maven综合应用1. 分析将项目分为多个工程，可以按层次分，也可以按模块分，或者同时按层次和模块分 以ums为例，使用Maven创建和管理项目： 父工程：ums-parent dao工程：ums-dao service工程：ums-service web工程：ums-web 2. 步骤2.1 创建工程 创建父工程：ums-parent File——&gt;New——&gt;Module——&gt;Maven Archetype——&gt;maven-archetype-quickstart GroupId：net.wanho.ums ArtifactId：ums-parent Context root：~&#x2F;IdeaProjects&#x2F;framework&#x2F;ums-parent 创建子工程：ums-dao 右键ums-parent父工程——&gt;New——&gt;Module——&gt;Maven Archetype——&gt;maven-archetype-quickstart ArtifactId：ums-dao Content root：~&#x2F;IdeaProjects&#x2F;framework&#x2F;ums-parent&#x2F;ums-dao 创建子工程：ums-service 创建子工程：ums-web，web工程 2.2 配置依赖 在父工程中配置依赖管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;javax.servlet-api.version&gt;4.0.1&lt;/javax.servlet-api.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;mysql-connector-java.version&gt;5.1.38&lt;/mysql-connector-java.version&gt; &lt;fastjson.version&gt;1.2.31&lt;/fastjson.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;hutool-all.version&gt;5.8.15&lt;/hutool-all.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hutool --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;$&#123;hutool-all.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在各个子工程中引用依赖 ums-dao 123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; ums-service 123456&lt;!-- 依赖于dao --&gt;&lt;dependency&gt; &lt;groupId&gt;net.wanho.ums&lt;/groupId&gt; &lt;artifactId&gt;ums-dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; ums-web 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 依赖于service --&gt; &lt;dependency&gt; &lt;groupId&gt;net.wanho.ums&lt;/groupId&gt; &lt;artifactId&gt;ums-service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 部署访问 先对其他模块进行install操作，然后再对ums-web进行部署访问 2.3 配置dao子工程​ create.sql 123456789drop database if exists ums;create database ums charset utf8;use ums;create table t_user( id int primary key auto_increment, username varchar(100), password varchar(100), age int) engine=Innodb charset utf8; ​ datasource.properties 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ums?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=root 2.3 配置service子工程2.4 配置web子工程2.5 测试​ 只要修改了其他模块，都需要先对这些模块进行install操作，然后再对ums-web进行部署访问","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"}]},{"title":"Java-后端多表增删改查","slug":"Java-后端多表增删改查","date":"2023-07-30T11:27:36.000Z","updated":"2023-08-03T02:36:11.461Z","comments":true,"path":"2023/07/30/Java-后端多表增删改查/","link":"","permalink":"http://example.com/2023/07/30/Java-%E5%90%8E%E7%AB%AF%E5%A4%9A%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","excerpt":"","text":"1. Many2One1.1 数据建模关系图 表结构123456789101112131415161718192021222324252627282930313233drop table if exists t_clazz;/*==============================================================*//* Table: t_clazz 父 *//*==============================================================*/create table t_clazz( bno varchar(20) not null, name varchar(20), primary key (bno));alter table t_clazz comment &#x27;班级表&#x27;;drop table if exists t_student;/*==============================================================*//* Table: t_student 子 *//*==============================================================*/create table t_student( sid varchar(20) not null comment &#x27;学号 主键&#x27;, name varchar(20) comment &#x27;姓名&#x27;, age int(3) comment &#x27;年龄&#x27;, sex int(1) comment &#x27;性别 0 男 1 女&#x27;, bno varchar(20), primary key (sid));alter table t_student comment &#x27;学生信息表&#x27;;alter table t_student add constraint FK_stu_clazz_bno foreign key (bno) references t_clazz (bno) on delete restrict on update restrict; 表数据12345678910111213141516171819public abstract class BaseTest &#123; protected JDBCTemplate jdbcTemplate = new JDBCTemplate() ; // 初始化 测试环境 @Before public void before()&#123; //清空表数据 truncate table 截断表 无法使用 关联关系 先删除儿子 在删除爹 jdbcTemplate.update(&quot;delete from t_student &quot;) ; jdbcTemplate.update(&quot;delete from t_clazz &quot;) ; //插入班级数据 jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B001&#x27;,&#x27;Java177&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B002&#x27;,&#x27;Java178&#x27;)&quot;) ; //插入 68 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student(sid,name,age,sex,bno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;张三&quot;+(i+1)+&quot;&#x27;,18,0,&#x27;B001&#x27;)&quot;) ; &#125; &#125;&#125; 1.2 领域建模1234public class Clazz &#123; private String bno ; private String name ;&#125; 1234567public class Student &#123; private String sid ; private String name ; private Integer age ; private Integer sex ; private Clazz clazz = new Clazz() ;&#125; 1.3 列表DAO12-- 分页查询的SQL： select sid,s.name,age,sex,c.bno &quot;clazz.bno&quot;,c.name &quot;clazz.name&quot; from t_student s left join t_clazz c on s.bno = c.bno where 1=1 12345// t_student表 t_clazz表 同名列 二义性 条件查询需指定 哪个表的nameif (query!=null &amp;&amp; StringUtils.isNotEmpty(query.getName())) &#123; sb.append(&quot; and s.name like ?&quot;) ; paramList.add(&quot;%&quot;+query.getName()+&quot;%&quot;); &#125; jsplist-stu.jsp 12345678910111213141516171819202122232425262728293031&lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;班号&lt;/th&gt; &lt;th&gt;班名&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;studentPage.list&#125;&quot; var=&quot;student&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;sid&quot; value=&quot;$&#123;student.sid&#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.clazz.bno&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.clazz.name&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-stu.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-stu.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt;&lt;/table&gt; 1.4 新增beforeDAO123public interface ClazzDAO &#123; List&lt;Clazz&gt; selectAll() ;&#125; 1234567891011public class ClazzDAOImpl implements ClazzDAO &#123; private JDBCTemplate jdbcTemplate = new JDBCTemplate() ; @Override public List&lt;Clazz&gt; selectAll() &#123; String DQL = &quot;select bno,name from t_clazz&quot; ; Object[] paramAy = &#123;&#125; ; return jdbcTemplate.queryList(DQL,Clazz.class,paramAy); &#125;&#125; Service123456789101112public class ClazzService &#123; private ClazzDAO clazzDAO = new ClazzDAOImpl() ; /** * 查询所有班级 * @return */ public Collection&lt;Clazz&gt; list()&#123; return clazzDAO.selectAll(); &#125;&#125; Controller1234567891011121314151617@WebServlet(...&quot;/toAddView-stu.do&quot;&#125;)public class StudentServlet extends HttpServlet &#123; private ClazzService clazzService = new ClazzService() ; ... service(..)&#123; else if (&quot;/toAddView-stu.do&quot;.equals(requestURI))&#123; this.toAddView(request,response) ; &#125; &#125; //跳转到新增学生界面 protected void toAddView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Collection&lt;Clazz&gt; clazzList = clazzService.list(); request.setAttribute(&quot;clazzList&quot;,clazzList); request.getRequestDispatcher(&quot;/add-stu.jsp&quot;).forward(request,response); &#125;&#125; Jsplist-stu.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toAddView-stu.do&quot; class=&quot;btn btn-primary&quot;&gt;添加学生&lt;/a&gt; add-stu.jsp 1234567891011&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;班级&lt;/label&gt; &lt;select name=&quot;clazz.bno&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择班级--&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;option value=&quot;$&#123;clazz.bno&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/div&gt; 1.5 新增DAO123456@Overridepublic boolean insert(Student student) &#123; String DQL = &quot;insert into t_student(sid,name,age,sex,bno) values (?,?,?,?,?)&quot; ; Object[] paramAy = &#123;student.getSid(),student.getName(),student.getAge(),student.getSex(),student.getClazz().getBno()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; Controller12//重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/page-stu.do&quot;); 1.6 查看jspmodify-stu.jsp 123456789101112131415&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;班级&lt;/label&gt; &lt;select name=&quot;clazz.bno&quot; class=&quot;form-control&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择班级--&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;option value=&quot;$&#123;clazz.bno&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/div&gt;//设置下拉框被选中$(&quot;select&quot;).val(&quot;$&#123;student.clazz.bno&#125;&quot;) Controller123456789101112protected void view(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得查看的学生编号 String sid = request.getParameter(&quot;sid&quot;); //2.调用业务方法 Student student = studentService.get(sid); //3.request作用域中设置 学生信息 request.setAttribute(&quot;student&quot;,student); Collection&lt;Clazz&gt; clazzList = clazzService.list(); request.setAttribute(&quot;clazzList&quot;,clazzList); //4.跳转页面 服务器内部跳转 request.getRequestDispatcher(&quot;/modify-stu.jsp&quot;).forward(request,response); &#125; DAO1String DQL = &quot;select sid,s.name,age,sex,c.bno \\&quot;clazz.bno\\&quot;,c.name \\&quot;clazz.name\\&quot; from t_student s left join t_clazz c on s.bno = c.bno where s.sid=?&quot; ; 1.7 修改DAO123456@Overridepublic boolean update(Student student) &#123; String DQL = &quot;update t_student set name=?,age=?,sex=?,bno=? where sid=?&quot; ; Object[] paramAy = &#123;student.getName(),student.getAge(),student.getSex(),student.getClazz().getBno(),student.getSid()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; 2. One2Many2.1 列表[单表]controller1234567891011121314151617181920212223242526272829303132@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;&#125;)public class ClazzServlet extends HttpServlet &#123; /** 班级业务实例 */ private ClazzService clazzService = new ClazzService() ; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得请求的url 包含项目名 String requestURI = request.getRequestURI(); //2. 去掉项目名 /list-stu.do /add-stu.do requestURI = requestURI.replace(request.getContextPath(),&quot;&quot;); //3.判断 url 与方法 调用 if (&quot;/list-clazz.do&quot;.equals(requestURI))&#123; this.list(request,response) ; &#125; &#125; /** * * @param request * @param response * @throws ServletException * @throws IOException */ protected void list(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 调用业务方法 Collection&lt;Clazz&gt; clazzCollection = clazzService.list(); //2. 把查询数据保存 四种(pageContext,request,session,application)属性作用域中 set ==&gt; list-stu.jsp get request.setAttribute(&quot;clazzList&quot;,clazzCollection); //3. 跳转到 list-stu.jsp request.getRequestDispatcher(&quot;/list-clazz.jsp&quot;).forward(request,response); &#125;&#125; jspindex.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/list-clazz.do&quot;&gt;班级列表&lt;/a&gt; &lt;br&gt; list-clazz.jsp 1234567891011 &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;bno&quot; value=&quot;$&#123;clazz.sid&#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;clazz.bno&#125;&lt;/td&gt; &lt;td&gt;$&#123;clazz.name&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-clazz.do?sid=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-clazz.do?sid=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 2.2 新增准备【裸跳页面】逻辑上： 直接怼到页面 比如 add-clazz.jsp OCP A. 代码复用 B.新增班级 【权限访问控制？当前登录用户是否有权限？】 jsplist-clazz.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toAddView-clazz.do&quot; class=&quot;btn btn-primary&quot;&gt;添加班级&lt;/a&gt; add-clazz.jsp 1234567891011121314151617181920212223242526272829&lt;h1&gt;新增班级&lt;/h1&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/add-clazz.do&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sid&quot;&gt;班号&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sid&quot; name=&quot;bno&quot; value=&quot;$&#123;param.bno&#125;&quot; placeholder=&quot;请输入班号&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sname&quot;&gt;班名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sname&quot; name=&quot;name&quot; value=&quot;$&#123;param.name&#125;&quot; placeholder=&quot;请输入班名&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;新增&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;重置&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; Controller1234567891011// ClazzServlet@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;&#125;).... else if(&quot;/toAddView-clazz.do&quot;.equals(requestURI))&#123; this.toAddView(request,response) ; &#125;//跳转到新增班级界面protected void toAddView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher(&quot;/add-clazz.jsp&quot;).forward(request,response);&#125; 2.3 新增【单表】controller12345678910111213141516171819202122232425262728//添加新的请求 url@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;&#125;)//添加判断 调用自定义的方法else if(&quot;/add-clazz.do&quot;.equals(requestURI))&#123; this.add(request,response) ;&#125;protected void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置请求中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); //调用 自定义 工具类 实现：解析请求自动封装 pojo中 Clazz clazz = RequestUtil.parseParameter(request, Clazz.class); //4. 调用业务方法 boolean saveRs = clazzService.save(clazz); //5. 根据业务方法的返回值 if (saveRs)&#123; //6.响应 //重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do&quot;); return; &#125; //新增失败 view实现显示效果 request.setAttribute(&quot;errorMsg&quot;,&quot;班号已经存在！！！&quot;); //使用服务器内部跳转 request.getRequestDispatcher(&quot;/toAddView-clazz.do&quot;).forward(request,response);&#125; Service12345678910111213... ClazzService &#123; public boolean save(Clazz clazz) &#123; //获得新增的班号 String bno = clazz.getBno() ; //1.判断是否 新增的班号 db 中已经存在 Clazz dbClazz = clazzDAO.selectById(bno); if (dbClazz!=null)&#123; return false ; &#125; //班号不存在 向数据库插入数据 return clazzDAO.insert(clazz) ; &#125;&#125; DAO12345... ClazzDAO&#123; Clazz selectById(String bno); boolean insert(Clazz clazz);&#125; 123456789101112131415... ClazzDAOImpl ... &#123; @Override public Clazz selectById(String bno) &#123; String DQL = &quot;select bno,name from t_clazz where bno=?&quot; ; Object[] paramAy = &#123;bno&#125; ; return jdbcTemplate.queryObject(DQL,Clazz.class,paramAy); &#125; @Override public boolean insert(Clazz clazz) &#123; String DQL = &quot;insert into t_clazz(bno,name) values (?,?)&quot; ; Object[] paramAy = &#123;clazz.getBno(),clazz.getName()&#125; ; return jdbcTemplate.update(DQL,paramAy); &#125;&#125; 2.4 删除【单表&#x2F;子记录依赖】jsplist-clazz.jsp 123 &lt;form action=&#x27;$&#123;pageContext.request.contextPath&#125;/del-clazz.do&#x27;&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;bno&quot; value=&quot;$&#123;clazz.bno&#125;&quot; /&gt;&lt;/td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-clazz.do?bno=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; controller1234567891011121314151617181920@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;&#125;)else if(&quot;/del-clazz.do&quot;.equals(requestURI))&#123; this.del(request,response) ;&#125;protected void del(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得 删除的班号 String[] idAy = request.getParameterValues(&quot;bno&quot;); //把数组 拼接成一个 字符串 String id =&quot;&quot;; for (String s : idAy) &#123; id +=s+&quot;,&quot; ; &#125; id = id.substring(0,id.length()-1) ; //2. 调用业务方法 boolean removeRs = clazzService.remove(id); String msg = removeRs?&quot;&quot;:&quot;del-fail&quot; ; response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do?msg=&quot;+msg);&#125; Service123456789101112131415161718public class ClazzService &#123; private StudentDAO studentDAO = new StudentDAOImpl() ; public boolean remove(String id) &#123; //字符串 转成数组 String[] sidAy = id.split(&quot;,&quot;); for (String bno : sidAy) &#123; //根据FK 查询学生列表 List&lt;Student&gt; studentList = studentDAO.selectByFk(bno); //删除班级编号 在学生表中出现了 不能删除 if (!studentList.isEmpty())&#123; return false ; &#125; &#125; //调用批处理删除 return clazzDAO.delete(sidAy) ; &#125;&#125; DAOStudentDAO1List&lt;Student&gt; selectByFk(String bno) ; 123456@Overridepublic List&lt;Student&gt; selectByFk(String bno) &#123; String DQL = &quot;select sid,name,age,sex from t_student where bno=?&quot; ; Object[] paramAy = &#123;bno&#125; ; return jdbcTemplate.queryList(DQL,Student.class,paramAy);&#125; ClazzDAO1boolean delete(String ... idAy) ; 123456789101112public class ClazzDAOImpl implements ClazzDAO &#123; @Override public boolean delete(String... sidAy) &#123; String DML = &quot;delete from t_clazz where bno=?&quot; ; Object[][] paramAy = new Object[sidAy.length][1] ; for (int i = 0; i &lt; sidAy.length; i++) &#123; paramAy[i][0] = sidAy[i] ; &#125; return jdbcTemplate.updateBatch(DML,paramAy); &#125;&#125; 2.5 查看【N+1】jsplist-clazz.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-clazz.do?bno=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; modify-clazz.jsp 1234567891011121314151617&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sname&quot; name=&quot;name&quot; value=&quot;$&#123;clazz.name&#125;&quot; placeholder=&quot;请输入班名&quot;/&gt;&lt;c:forEach items=&quot;$&#123;clazz.studentList&#125;&quot; var=&quot;student&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; Controller1234567891011121314151617@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;,&quot;/view-clazz.do&quot;&#125;)else if(&quot;/view-clazz.do&quot;.equals(requestURI))&#123; this.view(request,response) ;&#125;protected void view(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得查看的学生编号 String bno = request.getParameter(&quot;bno&quot;); //2.调用业务方法 Clazz clazz = clazzService.get(bno) ; //3.request作用域中设置 学生信息 request.setAttribute(&quot;clazz&quot;,clazz); //4.跳转页面 服务器内部跳转 request.getRequestDispatcher(&quot;/modify-clazz.jsp&quot;).forward(request,response);&#125; Service12345678910 public Clazz get(String bno) &#123; //N+1查询 //1. 根据班级id 查询 班级对象 单表查询 Clazz clazz = clazzDAO.selectById(bno); //2. 根据班级id 查询当前班级的学生列表 单表查询 List&lt;Student&gt; studentList = studentDAO.selectByFk(bno); //3.当前班级对象的 stuList属性进行赋值 clazz.setStudentList(studentList); return clazz ;&#125; 2.6 修改【单表】jspmodify-clazz.jsp 12&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/modify-clazz.do&quot; method=&quot;post&quot;&gt; .... controller123456789101112131415161718192021222324@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;,&quot;/view-clazz.do&quot;,&quot;/modify-clazz.do&quot;&#125;)else if(&quot;/modify-clazz.do&quot;.equals(requestURI))&#123; this.modify(request,response) ;&#125;protected void modify(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置请求中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); //调用 自定义 工具类 实现：解析请求自动封装 pojo中 Clazz clazz = RequestUtil.parseParameter(request, Clazz.class); //4. 调用业务方法 boolean modifyRs = clazzService.modify(clazz); //5. 根据业务方法的返回值 if (modifyRs)&#123; //6.响应 //重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do&quot;); return; &#125; request.setAttribute(&quot;errorMsg&quot;,&quot;修改班级失败！！！&quot;); request.getRequestDispatcher(&quot;/view-clazz.do&quot;).forward(request,response);&#125; Service123public boolean modify(Clazz clazz) &#123; return clazzDAO.update(clazz) ;&#125; DAO1boolean update(Clazz clazz); 123456@Overridepublic boolean update(Clazz clazz) &#123; String DQL = &quot;update t_clazz set name=? where bno=?&quot; ; Object[] paramAy = &#123;clazz.getName(),clazz.getBno()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; 3. Many2Many3.1 数据建模表关系 表结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869drop table if exists t_clazz;/*==============================================================*//* Table: t_clazz 父 *//*==============================================================*/create table t_clazz( bno varchar(20) not null, name varchar(20), primary key (bno));alter table t_clazz comment &#x27;班级表&#x27;;drop table if exists t_student;/*==============================================================*//* Table: t_student 子 *//*==============================================================*/create table t_student( sid varchar(20) not null comment &#x27;学号 主键&#x27;, name varchar(20) comment &#x27;姓名&#x27;, age int(3) comment &#x27;年龄&#x27;, sex int(1) comment &#x27;性别 0 男 1 女&#x27;, bno varchar(20), primary key (sid));alter table t_student comment &#x27;学生信息表&#x27;;drop table if exists t_teacher;/*==============================================================*//* Table: t_teacher *//*==============================================================*/create table t_teacher( tno varchar(20) not null, tname varchar(20), primary key (tno));alter table t_teacher comment &#x27;教师表&#x27;;drop table if exists t_student_teacher;/*==============================================================*//* Table: t_student_teacher *//*==============================================================*/create table t_student_teacher( tno varchar(20) not null, sid varchar(20) not null comment &#x27;学号 主键&#x27;, primary key (tno, sid));alter table t_student_teacher comment &#x27;教师学生关系表&#x27;;alter table t_student_teacher add constraint FK_stu_teacher_teacher_tno foreign key (tno) references t_teacher (tno) on delete restrict on update restrict;alter table t_student_teacher add constraint FK_stu_teacher_stu_sid foreign key (sid) references t_student (sid) on delete restrict on update restrict;alter table t_student add constraint FK_stu_clazz_bno foreign key (bno) references t_clazz (bno) on delete restrict on update restrict; 表数据12345678910111213141516171819202122232425@Beforepublic void before()&#123; //清空表数据 truncate table 截断表 无法使用 关联关系 先删除儿子 在删除爹 jdbcTemplate.update(&quot;delete from t_student_teacher &quot;) ; jdbcTemplate.update(&quot;delete from t_teacher &quot;) ; jdbcTemplate.update(&quot;delete from t_student &quot;) ; jdbcTemplate.update(&quot;delete from t_clazz &quot;) ; //插入班级数据 jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B001&#x27;,&#x27;Java177&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B002&#x27;,&#x27;Java178&#x27;)&quot;) ; //插入学生 68 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student(sid,name,age,sex,bno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;张三&quot;+(i+1)+&quot;&#x27;,18,0,&#x27;B001&#x27;)&quot;) ; &#125; //插入教师数据 jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T001&#x27;,&#x27;赵贺贺&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T002&#x27;,&#x27;赵健&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T003&#x27;,&#x27;马美平&#x27;)&quot;) ; //插入学生与教师关系表 68*2 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student_teacher(sid,tno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;T001&#x27;),(&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;T002&#x27;)&quot;) ; &#125;&#125; 3.2 列表pojo1234public class Teacher &#123; private String tno ; private String tname ;&#125; 12345public class Student &#123; ... /**Many2Many 一个学生拥有多个老师 */ private List&lt;Teacher&gt; teacherList ;&#125; DAO123public interface TeacherDAO &#123; List&lt;Teacher&gt; selectBySid(String sid) ;&#125; 123456789public class TeacherDAOImpl implements TeacherDAO &#123; private JDBCTemplate jdbcTemplate = new JDBCTemplate() ; @Override public List&lt;Teacher&gt; selectBySid(String sid) &#123; String DQL = &quot;select tno,tname from t_teacher where tno in (select tno from t_student_teacher where sid = ?)&quot; ; Object[] paramAy = &#123;sid&#125; ; return jdbcTemplate.queryList(DQL, Teacher.class,paramAy); &#125;&#125; service123456789101112131415161718192021public class StudentService &#123; private TeacherDAO teacherDAO = new TeacherDAOImpl() ; public void selectPage(Page&lt;Student, StudentQuery&gt; page)&#123; //1.统计总记录数 long count = studentDAO.count(page.getCond()); //2.查询当前页面的数据 List&lt;Student&gt; studentList = studentDAO.selectPage(page); //循环所有的学生列表 for (Student student : studentList) &#123; //根据学号查询老师信息 List&lt;Teacher&gt; teacherList = teacherDAO.selectBySid(student.getSid()); //设置到 当前学生的 关联老师集合属性 student.setTeacherList(teacherList); &#125; //3. 设置总记录数 page.setTotalRecord(count); //4. 设置当前页的数据 page.setList(studentList); &#125;&#125; jsplist-stu.jsp 123456&lt;td&gt; &lt;c:forEach items=&quot;$&#123;student.teacherList&#125;&quot; var=&quot;teacher&quot; varStatus=&quot;vs&quot;&gt; $&#123;teacher.tname&#125; &lt;c:if test=&quot;$&#123;not vs.last&#125;&quot;&gt;,&lt;/c:if&gt; &lt;/c:forEach&gt;&lt;/td&gt; 3.3 显示关联教师DAO123public interface TeacherDAO &#123; List&lt;Teacher&gt; selectAll();&#125; 12345678public class TeacherDAOImpl implements TeacherDAO &#123; @Override public List&lt;Teacher&gt; selectAll() &#123; String DQL = &quot;select tno,tname from t_teacher&quot; ; Object[] paramAy = &#123;&#125; ; return jdbcTemplate.queryList(DQL, Teacher.class,paramAy); &#125;&#125; Service123456789101112131415161718public class StudentService &#123; private TeacherDAO teacherDAO = new TeacherDAOImpl() ; /** * 根据id 查询学生信息 * @param sid * @return */ public Student get(String sid)&#123; //学生信息 班级信息 Student student = studentDAO.selectById(sid) ; // N+1 根据学生id 查询关联的教师 List&lt;Teacher&gt; teacherList = teacherDAO.selectBySid(sid); // 设置当前学生关联的教师信息 student.setTeacherList(teacherList); return student ; &#125;&#125; Controller1234567891011121314151617181920@WebServlet(.... &quot;/toSelectView-teacher.do&quot;&#125;)else if (&quot;/toSelectView-teacher.do&quot;.equals(requestURI))&#123; this.toSelectTeacherView(request,response) ;&#125;protected void toSelectTeacherView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得学生的id String sid = request.getParameter(&quot;sid&quot;); //2.查询当前学生信息 Student student = studentService.get(sid); //3.查询所有的老师信息 List&lt;Teacher&gt; teacherList = teacherService.list() ; //4. 数据存放在作用域中 request.setAttribute(&quot;student&quot;,student); request.setAttribute(&quot;teacherList&quot;,teacherList); request.getRequestDispatcher(&quot;/select-teacher.jsp&quot;).forward(request,response);&#125; Jsplist-stu.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toSelectView-teacher.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;关联教师&lt;/a&gt; select-teacher.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div class=&quot;container&quot;&gt; &lt;h1&gt;学生选择教师&lt;/h1&gt; &lt;div class=&quot;widget-content padded clearfix&quot;&gt; &lt;!-- 学生基本信息 --&gt; &lt;table class=&quot;table detail-view&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性别&lt;/th&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;td&gt;$&#123;student.clazz.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;!-- 教师信息 --&gt; &lt;form action=&quot;&quot;&gt; &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/th&gt; &lt;th&gt;工号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;teacherList&#125;&quot; var=&quot;teacher&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;tno&quot; value=&quot;$&#123;teacher.tno&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;$&#123;teacher.tno&#125;&lt;/td&gt; &lt;td&gt;$&#123;teacher.tname&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;关联教师&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 循环当前学生的关联老师信息 &lt;c:forEach items=&quot;$&#123;student.teacherList&#125;&quot; var=&quot;teacher&quot;&gt; $(&quot;:checkbox[value=&#x27;$&#123;teacher.tno&#125;&#x27;]&quot;).prop(&#x27;checked&#x27;,true) &lt;/c:forEach&gt;&lt;/script&gt; 3.4 设置关联教师jspselect-teacher.jsp 123456 &lt;!-- 教师信息 --&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/set-teacher.do&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sid&quot; value=&quot;$&#123;student.sid&#125;&quot;&gt;.... &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;tno&quot; value=&quot;$&#123;teacher.tno&#125;&quot;/&gt;&lt;/td&gt; DAO12345public interface StudentDAO &#123; boolean deleteRefBySid(String sid) ; boolean insertRef(Student student) ;&#125; 12345678910111213141516171819202122232425public class StudentDAOImpl implements StudentDAO &#123; @Override public boolean deleteRefBySid(String sid) &#123; String DQL = &quot;delete from t_student_teacher where sid = ?&quot; ; Object[] paramAy = &#123;sid&#125; ; return jdbcTemplate.update(DQL,paramAy); &#125; @Override public boolean insertRef(Student student) &#123; //获得当前学生的学号 String sid = student.getSid(); //获得当前学生关联的教师信息 List&lt;Teacher&gt; teacherList = student.getTeacherList(); String DML = &quot;insert into t_student_teacher(sid,tno) values(?,?)&quot; ; Object[][] paramAy = new Object[teacherList.size()][2] ; for (int i = 0; i &lt; teacherList.size(); i++) &#123; //教师信息 Teacher teacher = teacherList.get(i); paramAy[i][0] = sid ; paramAy[i][1] = teacher.getTno() ; &#125; return jdbcTemplate.updateBatch(DML,paramAy); &#125;&#125; Service12345678910public class StudentService &#123; public boolean setTeacher(Student student)&#123; //1.中间表删除 当前学号 关联所有信息 boolean delRs = studentDAO.deleteRefBySid(student.getSid()) ; //2.批量新增 中间表 关联信息 boolean insertRs = studentDAO.insertRef(student) ; return delRs &amp;&amp; insertRs ; &#125;&#125; controller123456789101112131415161718192021222324252627@WebServlet(...&quot;/set-teacher.do&quot;&#125;)else if (&quot;/set-teacher.do&quot;.equals(requestURI))&#123; this.setTeacher(request,response) ;&#125;protected void setTeacher(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获得学生的id String sid = request.getParameter(&quot;sid&quot;); // 关联的教师工号 String[] tnoAy = request.getParameterValues(&quot;tno&quot;); //封装学生对象 Student student = new Student(); student.setSid(sid); List&lt;Teacher&gt; teacherList = new ArrayList&lt;&gt;() ; for (String tno : tnoAy) &#123; Teacher teacher = new Teacher(); teacher.setTno(tno); teacherList.add(teacher); &#125; //设置关联关系 student.setTeacherList(teacherList); boolean rs = studentService.setTeacher(student) ; //重新查询 response.sendRedirect(request.getContextPath()+&quot;/page-stu.do&quot;);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Vue指令学习","slug":"Vue指令学习","date":"2023-07-24T06:34:03.000Z","updated":"2023-07-25T11:25:24.993Z","comments":true,"path":"2023/07/24/Vue指令学习/","link":"","permalink":"http://example.com/2023/07/24/Vue%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Vue构成vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。之前接触到的 App.vue 文件本质上就是一个 vue 的组件。每个 .vue 组件都由 3 部分构成，分别是： 模板结构 功能 template 组件的模板结构 script 组件的 JavaScript 行为 style 组件的样式 其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。vue 规定：每个组件对应的模板结构，需要定义到 template 节点中。 在 template 中使用指令在组件的 template 节点中，支持使用前面所学的指令语法，来辅助开发者渲染当前组件的 DOM 结构。代码示例如下： 123456789&lt;template&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;!-- 使用&#123;&#123; &#125;&#125;插值表达式 --&gt;&lt;p&gt;生成一个随机数字: &#123;&#123; (Math. random() * 10). toFixed(2) &#125;&#125;&lt;/p&gt;&lt;!-- 使用v-bind属性绑定 --&gt;&lt;p :title=&quot;new Date().tolocaleTimeString()&quot;&gt;我在学习vue.js&lt;/p&gt;&lt;!-- 属性v-on事件绑定 --&gt;&lt;button @click=”showInfo&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt; 在 template 中定义根节点在 vue 2.x 的版本中，template 节点内的 DOM 结构仅支持单个根节点： 1234567&lt;template&gt; &lt;!-- vue 2.x中，template节点内的所有元素，最外层“必须有”唯一的根节点进行包裹，否则报错 --&gt;&lt;div&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;h2&gt;这是副标题&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt; 但是，在 vue 3.x 的版本中，&lt; template&gt; 中支持定义多个根节点： 12345&lt;template&gt;&lt;!-- 这是包含多个根节点的template结构，因为h1标签和h2标签外层没有包裹性质的根元素 --&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;h2&gt;这是副标题&lt;/h2&gt;&lt;/template&gt; 组件的 script 节点vue 规定：组件内的 &lt; script&gt; 节点是可选的，开发者可以在 &lt; script&gt; 节点中封装组件的 JavaScript 业务逻辑。&lt; script &gt; 节点的基本结构如下： 1234&lt;script&gt;//今后，组件相关的data数据、methods方法等，都需要定义到export default所导出的对象中。export default &#123;&#125;&lt;/script&gt; script 中的 name 节点可以通过 name 节点为当前组件定义一个名称，代码如下： 123456&lt;script&gt;export default &#123;// name属性指向的是当前组件的名称（建议：每个单词的首字母大写）name: &#x27;MyApp&#x27;&#125;&lt;/script&gt; 在使用 vue-devtools 进行项目调试的时候，自定义的组件名称可以清晰的区分每个组件。 script 中的 data 节点vue 组件渲染期间需要用到的数据，可以定义在 data 节点中： 123456789101112&lt;script&gt;export default &#123;// 组件的名称 name: &#x27;MyApp&#x27;,// 组件的数据（data方法中return出去的对象，就是当前组件渲染期间需要用到的数据对象） data() &#123; return &#123; username: &#x27;哇哈哈&#x27;, &#125; &#125;,&#125;&lt;/script&gt; 其中组件中的 data 必须是函数，vue 规定：组件中的 data 必须是一个函数，不能直接指向一个数据对象。因此在组件中定义 data 数据节点时，下面的方式是错误的： 123data: &#123; // 组件中，不能直接让 data 指向一个数据对象（会报错） count: 0&#125; script 中的 methods 节点组件中的事件处理函数，必须定义到 methods 节点中，示例代码如下： 12345678910111213export default &#123; name: &#x27;MyApp&#x27;, // 组件的名称 data() &#123; // 组件的数据 return &#123; count: 0, &#125; &#125;, methods: &#123; //处理函数 addCount() &#123; this.count++ &#125;, &#125;,&#125; 组件的 style 节点vue 规定：组件内的 &lt; style &gt; 节点是可选的，开发者可以在 &lt; style &gt; 节点中编写样式美化当前组件的 UI 结构。&lt; script &gt; 节点的基本结构如下： 12345&lt;style&gt;h1 &#123;font-weight: normal;&#125;&lt;/style&gt; 其中 &lt; style &gt; &lt;&#x3D;”” font&#x3D;””&gt; 标签上的 lang&#x3D;”css” 属性是可选的，它表示所使用的样式语言。默认只支持普通的 css 语法，可选值还有 less、scss 等。多学一招：让 style 中支持 less 语法：如果希望使用 less 语法编写组件的 style 样式，可以按照如下两个步骤进行配置：① 运行 npm install less -D 命令安装依赖包，从而提供 less 语法的编译支持；② 在 &lt; style &gt; &lt;&#x3D;”” font&#x3D;””&gt; 标签上添加 lang&#x3D;”less” 属性，即可使用 less 语法编写组件的样式。 123456789&lt;style&gt;h1 &#123;font-weight: normal;&#125;i &#123;color: red;font-style: normal;&#125;&lt;/style&gt; Vue指令插值表达式 目的: 在dom标签中, 直接插入内容 又叫: 声明式渲染&#x2F;文本插值 语法: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; person.age &gt; 100 ? `老头` : `小伙` &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // data 格式固定, 定义vue数据之处 data() &#123; // key相当于变量名 return &#123; msg: `hello vue!!!`, person: &#123; name: `张三丰`, age: 108, &#125;, &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 总结: dom中插值表达式赋值, vue的变量必须在data里声明注意点：1.在插值表达式中使用的数据 必须在data中进行了提供2.支持的是表达式，而非语句，比如：if for …3.不能在标签属性中使用插值（插值表达式只能在标签中间使用），比如：&lt;p title=&quot;&#123;&#123;username&#125;&#125;&quot;&gt;我是P标签&lt;/p&gt; v-bind 目标: 给标签属性设置vue变量的值 vue指令, 实质上就是特殊的 html 标签属性, 特点: v- 开头 每个指令, 都有独立的作用 语法：v-bind:属性名=&quot;vue变量&quot; 简写：:属性名=&quot;vue变量&quot; 123456789&lt;!-- vue指令-v-bind属性动态赋值 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;我是a标签&lt;/a&gt;&lt;img :src=&quot;imgSrc&quot;&gt;图片服务器:https://demo-video-oss.oss-cn-hangzhou.aliyuncs.com/images/mm.jpg或 指定尺寸 https://demo-video-oss.oss-cn-hangzhou.aliyuncs.com/images/mm.jpg?x-oss-process=image/resize,w_60,h_60 总结: 把vue变量的值, 赋予给dom属性上, 影响标签显示效果 v-on 目标: 给标签绑定事件 语法 v-on:事件名&#x3D;”要执行的 少量代码 “ v-on:事件名&#x3D;”methods中的函数” v-on:事件名&#x3D;”methods中的函数(实参)” 简写: @事件名&#x3D;”methods中的函数” 123456789101112131415161718192021222324&lt;!-- vue指令: v-on事件绑定--&gt;&lt;p&gt;你要买商品的数量: &#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count = count + 1&quot;&gt;增加1&lt;/button&gt;&lt;button v-on:click=&quot;addFn&quot;&gt;增加1个&lt;/button&gt;&lt;button v-on:click=&quot;addCountFn(5)&quot;&gt;一次加5件&lt;/button&gt;&lt;button @click=&quot;subFn&quot;&gt;减少&lt;/button&gt;&lt;script&gt; export default &#123; // ...其他省略 methods: &#123; addFn()&#123; // this代表export default后面的组件对象(下属有data里return出来的属性) this.count++ &#125;, addCountFn(num)&#123; this.count += num &#125;, subFn()&#123; this.count-- &#125; &#125; &#125;&lt;/script&gt; 总结: 常用@事件名, 给dom标签绑定事件, 以及&#x3D;右侧事件处理函数 v-on事件对象 目标: vue事件处理函数中, 拿到事件对象 语法: 无传参, 通过形参直接接收 传参, 通过$event指代事件对象传给事件处理函数 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止百度&lt;/a&gt; &lt;hr&gt; &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止去百度&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; one(e)&#123; e.preventDefault() &#125;, two(num, e)&#123; e.preventDefault() &#125; &#125;&#125;&lt;/script&gt; v-on修饰符 目的: 在事件后面.修饰符名 - 给事件带来更强大的功能 语法: @事件名.修饰符&#x3D;”methods里函数” .stop - 阻止事件冒泡 .prevent - 阻止默认行为 .once - 程序运行期间, 只触发一次事件处理函数 123456789101112131415161718192021&lt;template&gt; &lt;div @click=&quot;fatherFn&quot;&gt; &lt;!-- vue对事件进行了修饰符设置, 在事件后面.修饰符名即可使用更多的功能 --&gt; &lt;button @click.stop=&quot;btn&quot;&gt;.stop阻止事件冒泡&lt;/button&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;.prevent阻止默认行为&lt;/a&gt; &lt;button @click.once=&quot;btn&quot;&gt;.once程序运行期间, 只触发一次事件处理函数&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fatherFn()&#123; console.log(&quot;father被触发&quot;); &#125;, btn()&#123; console.log(1); &#125; &#125;&#125;&lt;/script&gt; 总结: 修饰符给事件扩展额外功能 v-on按键修饰符 目标: 给键盘事件, 添加修饰符, 增强能力 语法: @keyup.enter - 监测回车按键 @keyup.esc - 监测返回按键 更多修饰符 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; enterFn()&#123; console.log(&quot;enter回车按键了&quot;); &#125;, escFn()&#123; console.log(&quot;esc按键了&quot;); &#125; &#125;&#125;&lt;/script&gt; 总结: 多使用事件修饰符, 可以提高开发效率, 少去自己判断过程 例1：翻转字符串 目标: 点击按钮 - 把文字取反显示 - 再点击取反显示(回来了) 提示: 把字符串取反赋予回去 正确代码: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;反转字符串&lt;/h1&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;reverseStr&quot;&gt;反转字符串&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: `我是我爹的儿`, &#125; &#125;, methods: &#123; reverseStr() &#123; this.msg = this.msg.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 总结: 记住方法特点, 多做需求, vue是数据变化视图自动更新, 减少操作DOM时间, 提高开发效率 v-model 目标: 把value属性和vue数据变量, 双向绑定到一起 语法: v-model&#x3D;”vue数据变量” 双向数据绑定 数据变化 -&gt; 视图自动同步 视图变化 -&gt; 数据自动同步 演示: 用户名绑定 - vue内部是MVVM设计模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;!-- v-model:是实现vuejs变量和表单标签value属性, 双向绑定的指令 --&gt; &lt;div&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; v-model=&quot;pass&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;来自于: &lt;/span&gt; &lt;!-- 下拉菜单要绑定在select上 --&gt; &lt;select v-model=&quot;from&quot;&gt; &lt;option value=&quot;北京市&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;南京市&quot;&gt;南京&lt;/option&gt; &lt;option value=&quot;天津市&quot;&gt;天津&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- (重要) 遇到复选框, v-model的变量值 非数组 - 关联的是复选框的checked属性 数组 - 关联的是复选框的value属性 --&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;抽烟&quot;&gt;抽烟 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;喝酒&quot;&gt;喝酒 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;写代码&quot;&gt;写代码 &lt;/div&gt; &lt;div&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;男 &lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;女 &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍&lt;/span&gt; &lt;textarea v-model=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; username: &quot;&quot;, pass: &quot;&quot;, from: &quot;&quot;, hobby: [], sex: &quot;&quot;, intro: &quot;&quot;, &#125;; // 总结: // 特别注意: v-model, 在input[checkbox]的多选框状态 // 变量为非数组, 则绑定的是checked的属性(true/false) - 常用于: 单个绑定使用 // 变量为数组, 则绑定的是他们的value属性里的值 - 常用于: 收集勾选了哪些值 &#125;&#125;;&lt;/script&gt; 总结: 本阶段v-model只能用在表单元素上, 以后学组件后讲v-model高级用法 v-model修饰符 目标: 让v-model拥有更强大的功能 语法: v-model.修饰符&#x3D;”vue数据变量” .number 以parseFloat转成数字类型 .trim 去除首尾空白字符 （记下：去除字符串中间 空格 不是vue ） .lazy 在change事件时触发而非inupt触发 时 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;span&gt;年龄:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;人生格言:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;motto&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍:&lt;/span&gt; &lt;textarea v-model.lazy=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: &quot;&quot;, motto: &quot;&quot;, intro: &quot;&quot; &#125; &#125;&#125;&lt;/script&gt; 总结: v-model修饰符, 可以对值进行预处理, 非常高效好用 v-text和v-html 目的: 更新DOM对象的innerText&#x2F;innerHTML 语法: v-text&#x3D;”vue数据变量” v-html&#x3D;”vue数据变量” 注意: 会覆盖插值表达式 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; str: &quot;&lt;span&gt;我是一个span标签&lt;/span&gt;&quot; &#125; &#125;&#125;&lt;/script&gt; 总结: v-text把值当成普通字符串显示, v-html把值当做html解析 v-show和v-if 目标: 控制标签的隐藏或出现 语法: v-show&#x3D;”vue变量” v-if&#x3D;”vue变量” 原理 v-show 用的display:none隐藏 (频繁切换使用) v-if 直接从DOM树上移除 高级 v-else使用 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 v-show=&quot;isOk&quot;&gt;v-show的盒子&lt;/h1&gt; &lt;h1 v-if=&quot;isOk&quot;&gt;v-if的盒子&lt;/h1&gt; &lt;div&gt; &lt;p v-if=&quot;age &gt; 18&quot;&gt;我成年了&lt;/p&gt; &lt;p v-else&gt;还得多吃饭&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isOk: true, age: 15 &#125; &#125;&#125;&lt;/script&gt; 总结: 使用v-show和v-if以及v-else指令, 方便通过变量控制一套标签出现&#x2F;隐藏 例2：折叠面板 目标: 点击展开或收起时，把内容区域显示或者隐藏 此案例使用了less语法, 项目中下载模块 1yarn add less@3.0.4 less-loader@5.0.0 -D 只有标签和样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; &gt; 收起 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;body &#123; background-color: #ccc; #app &#123; width: 400px; margin: 20px auto; background-color: #fff; border: 4px solid blueviolet; border-radius: 1em; box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.5); padding: 1em 2em 2em; h3 &#123; text-align: center; &#125; .title &#123; display: flex; justify-content: space-between; align-items: center; border: 1px solid #ccc; padding: 0 1em; &#125; .title h4 &#123; line-height: 2; margin: 0; &#125; .container &#123; border: 1px solid #ccc; padding: 0 1em; &#125; .btn &#123; /* 鼠标改成手的形状 */ cursor: pointer; &#125; &#125;&#125;&lt;/style&gt; 参考答案: 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt; &#123;&#123; isShow ? &#x27;收起&#x27; : &#x27;展开&#x27; &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt; &lt;p&gt;寒雨连江夜入吴, &lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isShow: false &#125; &#125;&#125;&lt;/script&gt; v-for 目标: 列表渲染, 所在标签结构, 按照数据数量, 循环生成 语法 v-for&#x3D;”(值, 索引) in 目标结构” v-for&#x3D;”值 in 目标结构” 目标结构: 可以遍历数组 &#x2F; 对象 &#x2F; 数字 &#x2F; 字符串 (可遍历结构) 注意: v-for的临时变量名不能用到v-for范围外 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- v-for 把一组数据, 渲染成一组DOM --&gt; &lt;!-- 口诀: 让谁循环生成, v-for就写谁身上 --&gt; &lt;p&gt;学生姓名&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;item&quot;&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;学生详细信息&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;obj in stuArr&quot; :key=&quot;obj.id&quot;&gt; &lt;span&gt;&#123;&#123; obj.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.sex &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.hobby &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- v-for遍历对象(了解) --&gt; &lt;p&gt;老师信息&lt;/p&gt; &lt;div v-for=&quot;(value, key) in tObj&quot; :key=&quot;value&quot;&gt; &#123;&#123; key &#125;&#125; -- &#123;&#123; value &#125;&#125; &lt;/div&gt; &lt;!-- v-for遍历整数(了解) - 从1开始 --&gt; &lt;p&gt;序号&lt;/p&gt; &lt;div v-for=&quot;i in count&quot; :key=&quot;i&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; arr: [&quot;小明&quot;, &quot;小欢欢&quot;, &quot;大黄&quot;], stuArr: [ &#123; id: 1001, name: &quot;孙悟空&quot;, sex: &quot;男&quot;, hobby: &quot;吃桃子&quot;, &#125;, &#123; id: 1002, name: &quot;猪八戒&quot;, sex: &quot;男&quot;, hobby: &quot;背媳妇&quot;, &#125;, ], tObj: &#123; name: &quot;蜘蛛精&quot;, age: 18, class: &quot;昆虫&quot;, &#125;, count: 10, &#125;; &#125;,&#125;;&lt;/script&gt; 总结: vue最常用指令, 铺设页面利器, 快速把数据赋予到相同的dom结构上循环生成","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Java-常见异常","slug":"Java-常见异常","date":"2023-07-20T10:54:44.000Z","updated":"2023-08-03T01:27:16.127Z","comments":true,"path":"2023/07/20/Java-常见异常/","link":"","permalink":"http://example.com/2023/07/20/Java-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/","excerpt":"","text":"1.ClassCastException(类转换异常)数据类型转换错误，比如有个String temp&#x3D;”abc”; 如果设为(int)temp就会报错了，因为它们类型不一样，但是设为(object)temp就可以，因为object是它们的父类 2.IndexOutOfBoundsException(数组越界)这个异常我们在操作数组的时候会经常遇到，异常的解释是“数组下标越界”，现在程序中大多都有对数组的操作，因此在调用数组的时候一定要认真检查，看自己调用的下标是不是超出了数组的范围，一般来说，显示(即直接用常数当下标)调用不太容易出这样的错，但隐式(即用变量表示下标)调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。 3.NullPointerException(空指针)这个异常在编程时也经常遇到，异常的解释是 “程序遇上了空指针”，简单地说就是调用了未经初始化的对象或者是不存在的对象，这个错误经常出现在调用数组这些操作中，对数组操作中出现空指针，很多情况下是一些刚开始学习编程的人常犯的错误，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化(如果要调用的话)。 4.IllegalAccessException(安全权限异常)这个异常的解释是“没有访问权限“，当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常。 5. IOException(输入输出异常)一般读写文件会出现这个异常,比如你想从磁盘上读一个文件到你写的程序,如果硬盘上没有这文件,java虚拟机就会报这个异常","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-多表查询","slug":"Mysql-多表查询","date":"2023-07-18T16:27:20.000Z","updated":"2023-07-18T16:30:57.140Z","comments":true,"path":"2023/07/19/Mysql-多表查询/","link":"","permalink":"http://example.com/2023/07/19/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"1.DDLcreate 创建 alter 修改 drop 删除 truncate清空&#x2F;截断 【事务自动提交】 1.1 创建表常用创建 1234567表名 练习： t_emp tb_emp tbl_emp 项目： sys_ oa_ order_ product_create table 表名( 字段名 数据类型 [列级约束], 字段名 数据类型 [列级约束], [表级约束]) ; 1234CREATE TABLE t_emp01( id INT, NAME VARCHAR(20)) ; 查看表结构 1DESC t_emp01; 查看表创建语句 1SHOW CREATE TABLE t_emp01 ; CTAS语法创建表【没约束】 123CREATE TABLE emp10 AS SELECT * FROM emp WHERE deptno = 10;CREATE TABLE emp20 AS SELECT empno id,ename NAME,sal sal FROM emp WHERE deptno = 20;CREATE TABLE myemp AS SELECT * FROM emp WHERE 1=2 ; 1.2 约束主键 PK 非空+唯一 123456789101112131415CREATE TABLE t_emp02( id INT PRIMARY KEY, NAME VARCHAR(20)) ;或CREATE TABLE t_emp03( id INT , NAME VARCHAR(20), PRIMARY KEY (id)) ;INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;a&#x27;) ;INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) ;查询：INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) 错误代码： 1062Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27; 123456789CREATE TABLE t_emp04( id INT , NAME VARCHAR(20), PRIMARY KEY (id,NAME) -- 联合主键) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;a&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;2&#x27;,&#x27;b&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;2&#x27;,&#x27;a&#x27;) ; 查看表约束 123-- 查询数据字典：SELECT * FROM `information_schema`.`TABLE_CONSTRAINTS` WHERE TABLE_SCHEMA=&#x27;scott&#x27; AND table_name=&#x27;t_emp04&#x27;; 外键 FK 参考完整性 可以为 NULL 给值 只能关联 另一个主键 123456789101112131415161718192021222324CREATE TABLE mydept AS SELECT * FROM dept ;CREATE TABLE myemp02 ( id INT PRIMARY KEY, NAME VARCHAR(20), deptno INT REFERENCES mydept(deptno)) ;或CREATE TABLE myemp03 ( id INT PRIMARY KEY, NAME VARCHAR(20), deptno INT , CONSTRAINT fk_myemp03 FOREIGN KEY (deptno) REFERENCES mydept(deptno) -- 注意：PK) ;INSERT INTO myemp03(id,NAME,deptno) VALUES (3,&#x27;aaa&#x27;,NULL) ;INSERT INTO myemp03(id,NAME,deptno) VALUES (4,&#x27;aaa&#x27;,88) ; -- 88 部门表中没有该数据查询：INSERT INTO myemp03(id,NAME,deptno) VALUES (4,&#x27;aaa&#x27;,88) 错误代码： 1452Cannot add or update a child row: a foreign key constraint fails (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `mydept` (`DEPTNO`))DELETE FROM `mydept` WHERE deptno = 10 ; -- 10部门下 有关联的员工查询：delete from `mydept` where deptno = 10 错误代码： 1451Cannot delete or update a parent row: a foreign key constraint fails (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `mydept` (`DEPTNO`)) 非空 1234CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) NOT NULL -- 该列不能为空) ; 唯一 1234CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) UNIQUE -- 该列唯一 可以为 null 【只能一个null】) ; 默认值 12345CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) , age INT DEFAULT 18 ) ; 自增长 123456789-- 历史遗留问题：ID 使用雪花算法 【通过程序控制】CREATE TABLE t_emp08( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ) ;INSERT INTO t_emp08 (id,NAME) VALUES (NULL,&#x27;a&#x27;) ;INSERT INTO t_emp08 (id,NAME) VALUES (200,&#x27;b&#x27;) ;INSERT INTO t_emp08 (id,NAME) VALUES (NULL,&#x27;c&#x27;) ; 1.3 修改表注意： 权限问题 ？ 修改表名 1ALTER TABLE t_emp08 RENAME TO tbl_emp08 ; 修改字段名 1ALTER TABLE tbl_emp08 CHANGE NAME e_name VARCHAR(20); 修改字段类型 1ALTER TABLE tbl_emp08 MODIFY e_name VARCHAR(80); 添加字段 12ALTER TABLE tbl_emp08 ADD age INT ;ALTER TABLE tbl_emp08 ADD sex INT AFTER id ; 删除字段 1ALTER TABLE tbl_emp08 DROP COLUMN sex ; 1.4 删除表12-- 最新的备份 最新的简历DROP TABLE tbl_emp08 ; 1.5 清空表1234567891011-- 1. 清空表中数据 表结构保留 DDL事务自动提交 不可回滚 速度快 自增长从1开始-- 降低高水位TRUNCATE TABLE myemp03 ;TRUNCATE TABLE mydept; -- FK 外键引用查询：truncate table mydept错误代码： 1701Cannot truncate a table referenced in a foreign key constraint (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `scott`.`mydept` (`DEPTNO`))-- 2. delete where过滤条件 DML语句 事务不提交 可以回滚 速度慢delete from myemp03 where .... DDL练习12345678910111213141516171819202122232425262728293031323334351.创建一张表 student id int name varchar(10) age int(10) tel varchar（10） 给 id 字段添加主键约束 自增长 给 name 字段添加非空约束 给 age 字段 默认值 0 给 tel 添加唯一 非空 约束 2.创建一张学员兴趣爱好表 hobby id int(10) hobby_name varchar(10) sid int --学生 id 给 sid 字段添加外键约束 3.创建一个表emp1empno int(10)ename varchar(50)4.emp1 添加一个字段 sal int(4)5.emp1 修改字段 ename varchar(100) 6.emp1 删除字段 sal7.把表 emp1 改成 emp2 SQL面试题面试题一（厦门）12345678910111213141516Table: （员工emp1） id name 1 a 2 b 3 c 4 dTable:( 性别sext) id sex 1 男 4 女 5 男找出忘记填写性别的员工? create table emp1(id int,name varchar(20)) ; insert into emp1(id,name) values (1,&#x27;a&#x27;),(2,&#x27;b&#x27;),(3,&#x27;c&#x27;),(4,&#x27;d&#x27;) ; create table sext(id int,sex varchar(20)) ; insert into sext(id,sex) values (1,&#x27;男&#x27;),(4,&#x27;女&#x27;),(5,&#x27;男&#x27;) ; 12345-- 员工id 没有在 sext表出现过? -- inselect * from emp1 where id not in (select id from sext) ;-- existsselect * from emp1 e where not exists (select null from sext where id=e.id) ; 面试题二（上海）12345678910111213141516表一(AAA) 商品名称 mc 商品总量 sl A 100 B 120表二(BBB) 商品名称 mc 出库数量 sl A 10 A 20 B 10 B 20 B 30用一条 SQL 语句算出商品 A,B 目前还剩多少？ create table AAA(mc varchar(20),sl int) ; insert into AAA (mc,sl) values (&#x27;A&#x27;,100),(&#x27;B&#x27;,120) ; create table BBB(mc varchar(20),sl int) ; insert into BBB (mc,sl) values (&#x27;A&#x27;,10),(&#x27;A&#x27;,20),(&#x27;B&#x27;,10),(&#x27;B&#x27;,20),(&#x27;B&#x27;,30) ; 12345678910111213-- 期望结果： -- mc sl-- A 70 -- B 60 -- 方法1: 子查询 select mc, sl-(select sum(sl) from BBB where mc=a.mc) sy from AAA a ;-- 方法2: 多表-- 先分组select mc,sum(sl) from BBB group by mc ;-- 看做一张表select a.mc, a.sl-t.sum_sl from AAA a join (select mc,sum(sl) sum_sl from BBB group by mc) t on a.mc = t.mc ; 面试题三（上海）1234567891011121314151617181920212223242526272829人员情况表（employee）中字段包括，员工号（ID），姓名（name），年龄（age），文化程度（wh）：包括四种情况（本科以上，大专，高中，初中以下）,现在我要根据年龄字段查询统计出：表中文化程度为本科以上，大专，高中，初中以下，各有多少人，占总人数多少。结果如下A：学历 年龄 人数 百分比本科以上 20 34 14大专 20 33 13高中 20 33 13初中以下 20 100 40本科以上 21 50 20。。。。。。SQL 查询语句如何写？create table employee(id int primary key auto_increment, name varchar(20), age int(2), wh varchar(20) ) ;insert into employee(id,name,age,wh) values (null,&#x27;a&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;b&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;c&#x27;,21,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;d&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;大专&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,21,&#x27;大专&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,21,&#x27;高中&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;高中&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;初中以下&#x27;) ; 123456查询结果集B：-- [行列转换]学历 20岁 21岁本科以上 3 1大专 2 2高中 4 1SQL 查询语句如何写？ 面试题四（福州）1234567891011121314151617181920212223242526272829303132333435363738四张表-- 学生表 create table student(sid varchar(20),sname varchar(20));insert into student values(1,&#x27;小明&#x27;);insert into student values(2,&#x27;小花&#x27;);-- 教师表 create table teacher(tid varchar(20),tname varchar(20)) ;insert into teacher values(1,&#x27;陈红&#x27;);insert into teacher values(2,&#x27;陈白&#x27;);-- 课程表 create table course(cid varchar(20),cname varchar(20)，ctype varchar(20)) ;insert into course values(1,&#x27;语文&#x27;,&#x27;文科&#x27;);insert into course values(2,&#x27;数学&#x27;,&#x27;理科&#x27;);-- 选课表 create table choose_course(ccid varchar(20),sid varchar(20),tid varchar(20), cid varchar(20));-- 小明选了陈红老师的语文insert into choose_course values(1,1,1,1);-- 小明选了陈红老师的数学insert into choose_course values(2,1,1,2);-- 小花选了陈红老师的数学insert into choose_course values(3,2,1,2);-- 小明选了陈白老师的语文insert into choose_course values(1,1,2,1);-- 小花选了陈红老师的语文insert into choose_course values(4,2,1,1);-- 1. 查找陈红老师教的学生是那些？-- 2.找学生小明所有的文科老师？-- 3.找出没有选修陈红老师的学生？-- 4.教的学生最少的老师？ 面试题五（厦门）12345678910111213141516171819202122232425262728293031323334-- 8:00--12:00 为迟到, 12:00--18:00 为早退-- 打卡表 card create table card( cid int(10), ctime timestamp , cuser int(10) ); -- 人员表 personcreate table person( pid int(10), name varchar(10)) ;-- 插入人员表的数据insert into person values(1,&#x27;a&#x27;);insert into person values(2,&#x27;b&#x27;);-- 插入打卡的数据insert into card values(1,&#x27;2009-07-19 08:02:00&#x27;,1);insert into card values(2,&#x27;2009-07-19 18:02:00&#x27;,1);insert into card values(3,&#x27;2009-07-19 09:02:00&#x27;,2);insert into card values(4,&#x27;2009-07-19 17:02:00&#x27;,2);insert into card values(5,&#x27;2009-07-20 08:02:00&#x27;,1);insert into card values(6,&#x27;2009-07-20 16:02:00&#x27;,1);insert into card values(7,&#x27;2009-07-20 07:02:00&#x27;,2);insert into card values(8,&#x27;2009-07-20 20:02:00&#x27;,2);-- 查询 迟到 早退的员工姓名？查询结果如下:工号 姓名 打卡日期 上班打卡 下班打卡 迟到 早退1 a 2009-07-19 08:02:00 18:02:00 是 否1 a 2009-07-20 08:02:00 16:02:00 是 是2 b 2009-07-19 09:02:00 17:02:00 是 是 2. DML事务不自动提交 2.1 插入数据所有字段插入 123INSERT INTO dept(deptno,dname,loc) VALUES (11,&#x27;dev&#x27;,&#x27;NJ&#x27;) ;-- 所有列插入 可以省略列名 【不建议】 考虑兼容问题？INSERT INTO dept VALUES (12,&#x27;dev&#x27;,&#x27;NJ&#x27;) ; 插入多条 1INSERT INTO dept(deptno,dname,loc) VALUES (13,&#x27;dev&#x27;,&#x27;NJ&#x27;),(14,&#x27;test&#x27;,&#x27;BJ&#x27;) ; 查询结果集插入 1234-- CTAS 语法创建表 【同时拷贝数据 没有约束】CREATE TABLE myemp AS SELECT * FROM emp ;-- 查询结果集 插入 myemp表中INSERT INTO myemp SELECT * FROM emp ; 2.2 更新数据1UPDATE myemp SET sal=sal*1.5 ,comm=500 WHERE empno =7788 ; 2.3 删除数据1DELETE FROM myemp WHERE empno = 7788 ; DML练习：123456789-- 1.往 emp 表中插入 empno,ename,sal 数据（111,&#x27;1&#x27;,1000)(222,&#x27;2&#x27;,2000) insert into emp(empno,ename,sal) values (111,&#x27;1&#x27;,1000),(222,&#x27;2&#x27;,2000) ;-- 2.把 empno=111 的员工 comm 改成 100 update emp set comm = 100 where empno = 111 ;-- 3.往 dept 表中插入编号50 ，dname，loc 与10部门相同 的数据 insert into dept(deptno,dname,loc) select 55,dname,loc from dept where deptno=10 ;-- 4.删除 empno=111 的数据 delete from emp where empno=111 ; 3. 视图view &#x3D; 虚表 table &#x3D; 基表 【1.数据安全性 2.简化查询】 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 3.1 简单视图增删改查 &#x3D;&#x3D;&gt; 基表 增删改查 123456789-- 创建或替换视图CREATE OR REPLACE VIEW v_emp10ASSELECT empno,ename,sal FROM emp WHERE deptno = 10 ;-- 查询 基表SELECT * FROM v_emp10 ;-- 插入视图数据 基表数据插入INSERT INTO v_emp10 (empno,ename,sal) VALUES (333,&#x27;xxx&#x27;,800) ; 3.2 高级视图只能查询 无法新增 删除 修改 【统计函数 ，多表数据】 1234567CREATE OR REPLACE VIEW v_emp10ASSELECT deptno,COUNT(0) cut FROM emp GROUP BY deptno ;SELECT * FROM v_emp10 ;-- 无法插入数据 基表没有该列【cut 统计出来的】INSERT INTO v_emp10 (deptno,cut) VALUES (80,6) ; 视图练习1234-- 1.创建一个包含所有雇员的雇员编号、雇员名称、部门名称和薪金的视图 -- 2.创建一个包含各种工作的薪金总和的视图 4.索引 4.1 优缺点&#x2F;分类123456789101112优势1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。劣势1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。索引分类1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引2） 唯一索引 ：索引列的值必须唯一，但允许有空值3） 复合索引 ：即一个索引包含多个列 4.2 创建索引1234-- 创建索引CREATE INDEX idx_dept_dname ON dept(dname) ;-- 查看SQL执行计划EXPLAIN SELECT * FROM dept WHERE dname=&#x27;SALES&#x27;; 4.3 删除索引12-- 删除索引DROP INDEX idx_dept_dname ON dept ; 4.4 查看索引1SHOW INDEX FROM dept ; 4.5 索引设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I&#x2F;O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 12345678创建复合索引: CREATE INDEX idx_name_email_status ON tb_xx(NAME,email,STATUS);就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 索引练习:1-- 1. 在 emp 表的 ename 上创建一个索引 并查看执行计划？ 5. 存储过程 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 5.1 创建存储过程1234CREATE PROCEDURE procedure_name ([proc_parameter[,...]])begin -- SQL语句end ; 示例 ： 12345678delimiter $create procedure pro_test1()begin select &#x27;Hello Mysql&#x27; ;end$delimiter ; DELIMITER 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 5.2 调用存储过程1call procedure_name() ; 5.3 查看存储过程12345678910-- 查询db_name数据库中的所有的存储过程select name from mysql.proc where db=&#x27;db_name&#x27;;-- 查询存储过程的状态信息show procedure status;-- 查询某个存储过程的定义show create procedure test.pro_test1 \\G; 5.4 删除存储过程1DROP PROCEDURE [IF EXISTS] sp_name ； 5.5 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 1DECLARE var_name[,...] type [DEFAULT value] 示例 : 123456789delimiter $create procedure pro_test2() begin declare num int default 5; select num+ 10; end$delimiter ; SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： 1SET var_name = expr [, var_name = expr] ... 示例 : 12345678910DELIMITER $CREATE PROCEDURE pro_test3()BEGIN DECLARE NAME VARCHAR(20); SET NAME = &#x27;MYSQL&#x27;; SELECT NAME ;END$DELIMITER ; 也可以通过select … into 方式进行赋值操作 : 12345678910DELIMITER $CREATE PROCEDURE pro_test5()BEGIN declare countnum int; select count(*) into countnum from city; select countnum;END$DELIMITER ; if条件判断语法结构 : 1234567if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 需求： 1234567根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ----------&gt; 身材高挑 170 - 180 ---------&gt; 标准身材 170 以下 ----------&gt; 一般身材 示例 : 12345678910111213141516171819delimiter $create procedure pro_test6()begin declare height int default 175; declare description varchar(50); if height &gt;= 180 then set description = &#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description = &#x27;标准身材&#x27;; else set description = &#x27;一般身材&#x27;; end if; select description ;end$delimiter ; 调用结果为 : 传递参数语法格式 : 1234567create procedure procedure_name([in/out/inout] 参数名 参数类型)...IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认OUT: 该参数作为输出，也就是该参数可以作为返回值INOUT: 既可以作为输入参数，也可以作为输出参数 IN - 输入 需求 : 1根据定义的身高变量，判定当前身高的所属的身材类型 示例 : 12345678910111213141516delimiter $create procedure pro_test5(in height int)begin declare description varchar(50) default &#x27;&#x27;; if height &gt;= 180 then set description=&#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description=&#x27;标准身材&#x27;; else set description=&#x27;一般身材&#x27;; end if; select concat(&#x27;身高 &#x27;, height , &#x27;对应的身材类型为:&#x27;,description);end$delimiter ; OUT-输出 需求 : 1根据传入的身高变量，获取当前身高的所属的身材类型 示例: 12345678910create procedure pro_test5(in height int , out description varchar(100))begin if height &gt;= 180 then set description=&#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description=&#x27;标准身材&#x27;; else set description=&#x27;一般身材&#x27;; end if;end$ 调用: 123call pro_test5(168, @description)$select @description$ @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 case结构语法结构 : 12345678910111213141516171819202122232425方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE;方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 需求: 1给定一个月份, 然后计算出所在的季度 示例 : 1234567891011121314151617181920212223delimiter $create procedure pro_test9(month int)begin declare result varchar(20); case when month &gt;= 1 and month &lt;=3 then set result = &#x27;第一季度&#x27;; when month &gt;= 4 and month &lt;=6 then set result = &#x27;第二季度&#x27;; when month &gt;= 7 and month &lt;=9 then set result = &#x27;第三季度&#x27;; when month &gt;= 10 and month &lt;=12 then set result = &#x27;第四季度&#x27;; end case; select concat(&#x27;您输入的月份为 :&#x27;, month , &#x27; , 该月份为 : &#x27; , result) as content ; end$delimiter ; while循环语法结构: 12345while search_condition do statement_list end while; 需求: 1计算从1加到n的值 示例 : 1234567891011121314delimiter $create procedure pro_test8(n int)begin declare total int default 0; declare num int default 1; while num&lt;=n do set total = total + num; set num = num + 1; end while; select total;end$delimiter ; repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : 1234567REPEAT statement_list UNTIL search_conditionEND REPEAT; 需求: 1计算从1加到n的值 示例 : 123456789101112131415161718delimiter $create procedure pro_test10(n int)begin declare total int default 0; repeat set total = total + n; set n = n - 1; until n=0 end repeat; select total ; end$delimiter ; loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： 12345[begin_label:] LOOP statement_listEND LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 eave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： 123456789101112131415161718192021delimiter $CREATE PROCEDURE pro_test11(n int)BEGIN declare total int default 0; ins: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP ins; select total;END$delimiter ; 游标&#x2F;光标游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。 声明光标： 1DECLARE cursor_name CURSOR FOR select_statement ; OPEN 光标： 1OPEN cursor_name ; FETCH 光标： 1FETCH cursor_name INTO var_name [, var_name] ... CLOSE 光标： 1CLOSE cursor_name ; 示例 : 初始化脚本: 12345678910create table emp( id int(11) not null auto_increment , name varchar(50) not null comment &#x27;姓名&#x27;, age int(11) comment &#x27;年龄&#x27;, salary int(11) comment &#x27;薪水&#x27;, primary key(`id`))engine=innodb default charset=utf8 ;insert into emp(id,name,age,salary) values(null,&#x27;金毛狮王&#x27;,55,3800),(null,&#x27;白眉鹰王&#x27;,60,4000),(null,&#x27;青翼蝠王&#x27;,38,2800),(null,&#x27;紫衫龙王&#x27;,42,1800); 12345678910111213141516171819202122232425262728-- 查询emp表中数据, 并逐行获取进行展示create procedure pro_test11()begin declare e_id int(11); declare e_name varchar(50); declare e_age int(11); declare e_salary int(11); declare emp_result cursor for select * from emp; open emp_result; fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); close emp_result;end$ 通过循环结构 , 获取游标中的数据 : 12345678910111213141516171819202122232425DELIMITER $create procedure pro_test12()begin DECLARE id int(11); DECLARE name varchar(50); DECLARE age int(11); DECLARE salary int(11); DECLARE has_data int default 1; DECLARE emp_result CURSOR FOR select * from emp; DECLARE EXIT HANDLER FOR NOT FOUND set has_data = 0; open emp_result; repeat fetch emp_result into id , name , age , salary; select concat(&#x27;id为&#x27;,id, &#x27;, name 为&#x27; ,name , &#x27;, age为 &#x27; ,age , &#x27;, 薪水为: &#x27;, salary); until has_data = 0 end repeat; close emp_result;end$DELIMITER ; 6.函数语法结构: 12345CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ...END; 案例 : 定义一个存储过程, 请求满足条件的总记录数 ; 1234567891011121314delimiter $create function count_city(countryId int)returns intbegin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum;end$delimiter ; 调用: 12select count_city(1);select count_city(2); 7.触发器介绍触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 创建触发器语法结构 : 12345678910111213create trigger trigger_name before/after insert/update/deleteon tbl_name [ for each row ] -- 行级触发器begin trigger_stmt ;end; 示例 需求 1通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ; 首先创建一张日志表 : 12345678create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment &#x27;操作类型, insert/update/delete&#x27;, operate_time datetime not null comment &#x27;操作时间&#x27;, operate_id int(11) not null comment &#x27;操作表的ID&#x27;, operate_params varchar(500) comment &#x27;操作参数&#x27;, primary key(`id`))engine=innodb default charset=utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_insert_triggerafter insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;insert&#x27;,now(),new.id,concat(&#x27;插入后(id:&#x27;,new.id,&#x27;, name:&#x27;,new.name,&#x27;, age:&#x27;,new.age,&#x27;, salary:&#x27;,new.salary,&#x27;)&#x27;)); end $DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_update_triggerafter update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;update&#x27;,now(),new.id,concat(&#x27;修改前(id:&#x27;,old.id,&#x27;, name:&#x27;,old.name,&#x27;, age:&#x27;,old.age,&#x27;, salary:&#x27;,old.salary,&#x27;) , 修改后(id&#x27;,new.id, &#x27;name:&#x27;,new.name,&#x27;, age:&#x27;,new.age,&#x27;, salary:&#x27;,new.salary,&#x27;)&#x27;)); end $DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_delete_triggerafter delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;delete&#x27;,now(),old.id,concat(&#x27;删除前(id:&#x27;,old.id,&#x27;, name:&#x27;,old.name,&#x27;, age:&#x27;,old.age,&#x27;, salary:&#x27;,old.salary,&#x27;)&#x27;)); end $DELIMITER ; 测试： 123456insert into emp(id,name,age,salary) values(null, &#x27;光明左使&#x27;,30,3500);insert into emp(id,name,age,salary) values(null, &#x27;光明右使&#x27;,33,3200);update emp set age = 39 where id = 3;delete from emp where id = 5; 删除触发器语法结构 : 1drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 语法结构 ： 1show triggers ；","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Ajax学习","slug":"Ajax","date":"2023-07-13T10:33:25.000Z","updated":"2023-08-03T05:43:27.837Z","comments":true,"path":"2023/07/13/Ajax/","link":"","permalink":"http://example.com/2023/07/13/Ajax/","excerpt":"","text":"1.接口文档概念及说明 我们使用的 url，数据接口，或者简称为接口。 接口是服务器提供的一个url地址，通过这个url地址，我们可以操作服务器上的资源。 通过Ajax技术向一个接口发送请求，也叫做调用接口。 接口是谁设计的呢 后端设计的（学java的、学php的同学、…..） 后端设计完接口之后，会提供一个接口文档给前端开发工程师 一个好的接口文档，至少需要包含下面几项内容 接口说明（通过接口说明，大致了解到接口是干什么用的） 接口的url（发送ajax请求，必要的条件） 接口请求方式（发送ajax请求，必要的条件） 请求参数（参数名称、数据类型、是否必填、参数说明等） 响应格式 响应示例 请求的根路径 http://localhost:8080/day19-02-ajax 图书管理 1.1 图书列表 接口URL： &#x2F;api&#x2F;getbooks 调用方式： GET 参数格式： 参数名称 参数类型 是否必选 参数说明 id String 否 图书Id bookname String 否 图书名称 author String 否 作者 publisher String 否 出版社 响应格式： 数据名称 数据类型 说明 status Number 200 成功；500 失败； msg String 对 status 字段的详细说明 data Array 图书列表 +id String 图书Id +bookname String 图书名称 +author String 作者 +publisher String 出版社 返回示例： 123456789&#123; &quot;status&quot;: 200, &quot;msg&quot;: &quot;获取图书列表成功&quot;, &quot;data&quot;: [ &#123; &quot;id&quot;: &quot;B001&quot;, &quot;bookname&quot;: &quot;西游记&quot;, &quot;author&quot;: &quot;吴承恩&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125;, &#123; &quot;id&quot;: &quot;B002&quot;, &quot;bookname&quot;: &quot;红楼梦&quot;, &quot;author&quot;: &quot;曹雪芹&quot;, &quot;publisher&quot;: &quot;上海图书出版社&quot; &#125;, &#123; &quot;id&quot;: &quot;B003&quot;, &quot;bookname&quot;: &quot;三国演义&quot;, &quot;author&quot;: &quot;罗贯中&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125; ]&#125; 1.2 添加图书 接口URL： &#x2F;api&#x2F;addbook 调用方式： POST 参数格式： 参数名称 参数类型 是否必选 参数说明 bookname String 是 图书名称 author String 是 作者 publisher String 是 出版社 响应格式： 数据名称 数据类型 说明 status Number 201 添加成功；500 添加失败； msg String 对 status 字段的详细说明 返回示例： 1234&#123; &quot;status&quot;: 201, &quot;msg&quot;: &quot;添加图书成功&quot;&#125; 1.3 删除图书 接口URL： &#x2F;api&#x2F;delbook 调用方式： GET 参数格式： 参数名称 参数类型 是否必选 参数说明 id String 是 图书Id 响应格式： 数据名称 数据类型 说明 status Number 200 删除成功；500 未指定要删除的图书Id；502 要删除的图书不存在； msg String 对 status 字段的详细说明 返回示例： 1234&#123; &quot;status&quot;: 200, &quot;msg&quot;: &quot;删除图书成功！&quot;&#125; 2.服务器端开发2.1 vo封装返回结果123456789101112131415161718192021222324/** * 封装 ajax 响应结果 */public class AjaxResult &#123; /**响应状态码 */ private Integer status ; /**响应消息*/ private String msg ; /**响应数据 主要是查询接口返回的数据*/ private Object data ; public AjaxResult(Integer status, String msg) &#123; super(); this.status = status; this.msg = msg; &#125; public AjaxResult(Integer status, String msg, Object data) &#123; super(); this.status = status; this.msg = msg; this.data = data; &#125;&#125; 2.2 pojo1234567891011121314151617public class Book &#123; private String id ; private String bookname ; private String author ; private String publisher ; public Book() &#123; super(); // TODO Auto-generated constructor stub &#125; public Book(String id, String bookname, String author, String publisher) &#123; super(); this.id = id; this.bookname = bookname; this.author = author; this.publisher = publisher; &#125;&#125; 2.3 Service1234567891011121314151617181920212223242526272829public class BookService &#123; private static Map&lt;String,Book&gt; bookMap = Collections.synchronizedMap(new LinkedHashMap&lt;&gt;()) ; static &#123; bookMap.put(&quot;B001&quot;, new Book(&quot;B001&quot;,&quot;西游记&quot;,&quot;吴承恩&quot;,&quot;北京图书出版社&quot;)) ; bookMap.put(&quot;B002&quot;, new Book(&quot;B002&quot;,&quot;西红楼梦&quot;,&quot;曹雪芹&quot;,&quot;上海图书出版社&quot;)) ; bookMap.put(&quot;B003&quot;, new Book(&quot;B003&quot;,&quot;三国演义&quot;,&quot;罗贯中&quot;,&quot;北京图书出版社&quot;)) ; &#125; public AjaxResult save(Book book) &#123; //获得随机id String id = UUID.randomUUID().toString() ; //设置书籍id book.setId(id); bookMap.put(id, book); return new AjaxResult(201, &quot;添加图书成功&quot;) ; &#125; public AjaxResult remove(String id) &#123; if(!bookMap.containsKey(id)) &#123; return new AjaxResult(500, &quot;502 要删除的图书不存在&quot;) ; &#125; bookMap.remove(id) ; return new AjaxResult(200, &quot;删除图书成功！&quot;) ; &#125; public AjaxResult find(Book book) &#123; //此次忽略 条件 查询 return new AjaxResult(200, &quot;获取图书列表成功&quot;,bookMap.values()) ; &#125;&#125; 2.4 Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@WebServlet(&#123; &quot;/api/getbooks&quot;, &quot;/api/addbook&quot;, &quot;/api/delbook&quot; &#125;)public class BookController extends HttpServlet &#123; private static final long serialVersionUID = 1L; private BookService bookService = new BookService() ; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json;charset=UTF-8&quot;); String requestURI = request.getRequestURI() ; requestURI = requestURI.substring((request.getContextPath()+&quot;/api/&quot;).length()) ; try &#123; Method m = this.getClass().getDeclaredMethod(requestURI, HttpServletRequest.class,HttpServletResponse.class) ; AjaxResult ajaxResult = (AjaxResult)m.invoke(this, request,response) ; String json = JSON.toJSONString(ajaxResult) ; PrintWriter out = response.getWriter(); out.print(json); out.flush(); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; protected AjaxResult getbooks(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;POST&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; return bookService.find(null) ; &#125; protected AjaxResult addbook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;GET&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; String bookname = request.getParameter(&quot;bookname&quot;) ; String author = request.getParameter(&quot;author&quot;) ; String publisher = request.getParameter(&quot;publisher&quot;) ; Book book = new Book() ; book.setBookname(bookname); book.setAuthor(author); book.setPublisher(publisher); return bookService.save(book) ; &#125; protected AjaxResult delbook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;POST&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; String id = request.getParameter(&quot;id&quot;) ; if(id==null || id.equals(&quot;&quot;)) &#123; return new AjaxResult(500, &quot;未指定要删除的图书Id&quot;) ; &#125; return bookService.remove(id) ; &#125;&#125; 3. 接口测试准备工作： 121. tomcat先启动2. 安装 postman【默认安装】 3.1 图书列表 3.2 添加图书 3.3 删除图书 4. Ajax4.1 浏览器&#x2F;服务器交互模型 4.2 Ajax基本概念1234HTML是骨架CSS是颜值JS是行为数据是灵魂 AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用浏览器内置对象 XMLHttpRequest 与服务器通信。 Ajax是一种技术，通过浏览器内置对象和服务器进行数据交互的技术。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。 AJAX最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 你可以使用AJAX最主要的两个特性做下列事： 在不重新加载页面的情况下发送请求给服务器。 接受并使用从服务器发来的数据。 4.3 Ajax请求和浏览器请求1234567891011浏览器请求 是浏览器本能的请求 不需要执行任何JS代码 地址栏输入地址后，按下回车即可发送请求 接收到服务器的响应后，浏览器自动渲染响应结果到页面中Ajax请求 是通过浏览器内置对象（XHR）完成的 通过执行一段JS代码，才能实现的请求 响应结果由程序员自行处理，浏览器只负责接收响应结果。无论是浏览器请求，还是Ajax请求，道理都一样，都符合浏览器 – 服务器交互模型 123456789101112131415Ajax 优点： 可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 只更新页面的部分数据，节省带宽 用户体验好 异步，不阻塞 不阻塞，Ajax 代码之后的 其他 JS 代码无需等待 Ajax 代码执行完毕，即可执行。 多个Ajax请求可以同时进行。 Ajax 缺点: 1、增加了设计和开发时间 2、比构建经典Web应用程序更复杂 3、AJAX应用程序中的安全性较低，因为所有文件都是在客户端下载的。 4、可能出现网络延迟问题 5、禁用JavaScript的浏览器无法使用该应用程序。 6、由于安全限制，只能使用它来访问服务于初始页面的主机的信息。如果需要显示来自其他服务器的信息，则无法在AJAX中显示 4.4 JQuery封装的ajax方法$.get() 123jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求，从而将服务器上的资源请求到客户端来进行使用。 $.get() 函数的语法如下： $.get(url,[data],[success],[dataType]) 参数 是否必填 类型 说明 url 是 string 请求资源的接口地址，一般由后端开发工程师提供 data 否 string|array|object 请求参数，由后端提供 success 否 function 请求成功后触发的回调函数，函数的形参为响应结果 dataType 否 string 预期服务器端响应的数据的类型，一般不用设置 1234567891011121314//定义 请求接口地址 及 请求参数let url = &#x27;http://localhost:8080/day19-02-Ajax/api/getbooks&#x27;let obj = &#123; id: 1, bookname: &#x27;西游记&#x27;,&#125; ;//发送ajax get 请求$.get( url, obj, function (res) &#123; console.log(res) &#125;) $.post() 123jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，用于向服务器提交资源。 $.post() 函数的语法如下： $.post(url,[data],[success],[dataType]) 参数 是否必填 类型 说明 url 是 string 请求资源的接口地址，一般由后端开发工程师提供 data 否 string|array|object 请求参数，由后端提供 success 否 function 请求成功后触发的回调函数，函数的形参为响应结果 dataType 否 string 预期服务器端响应的数据的类型，一般不用设置 1234567891011// 定义路径和参数let url = &#x27;http://localhost:8080/day19-02-Ajax/api/addbook&#x27;;let obj = &#123; bookname: &#x27;三体之地球往&#x27;, author: &#x27;刘慈欣&#x27;, publisher: &#x27;中央人民出版社&#x27;&#125;;// 发送post类型的ajax$.post(url, obj, function (res) &#123; console.log(res);&#125;); $.ajax() 123456789$.ajax() - 一个综合的发送Ajax请求的方法，即可以发送GET方式的请求，也可以发送POST方式的请求，还可以根据需求配置更加复杂的Ajax请求，使用频率最高。$.ajax(&#123; method:&#x27;GET|POST&#x27;, // 请求方式 必填 url:&#x27;url接口地址&#x27;, //请求的接口地址 必填 data:&#x27;object|array|string&#x27;, // 请求参数 ，可选 success:function(res)&#123; //请求成功后的回调函数 res 表示响应结果 &#125;&#125;) 123456789101112// $.ajax(); 传递的参数是对象;// 四个关键参数都是一个属性形式存在！$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080/day19-02-Ajax/api/getbooks&#x27;, data: &#123; id: 1 &#125;, success: function (res) &#123; console.log(res); &#125;&#125;) 4.5 network工具使用 network工具使用 All – 查看所有请求 XHR – 查看Ajax请求 JS – 查看请求了哪些JS文件 CSS – 查看请求了哪些CSS文件 Img – 查看请求了哪些图片 Media – 查看请求了哪些音频、视频等 Font – 查看请求了哪些字体文件 Doc – document，查看请求了哪些html文件 4.6 综合案例效果图 素材12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!-- 套一个 .container 内容就有版心了 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;!-- bootstrap3 =&gt; 组件 =&gt; 面板 =&gt; 带标题的面版 =&gt; 情境效果 --&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;添加图书&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;!-- bootstrap3 =&gt; 全局CSS样式 =&gt; 表单 =&gt; 内联表单 --&gt; &lt;div class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;书名&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;书名&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpBookname&quot; placeholder=&quot;请输入书名&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;作者&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;作者&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpAuthor&quot; placeholder=&quot;请输入作者&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;出版社&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;出版社&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpPublisher&quot; placeholder=&quot;请输入出版社&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;btnAdd&quot; type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt; 添加 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注意: 第二部分是table标签，要写道 container 里面，panel下面 --&gt; &lt;!-- bootstrap3 =&gt; 全局CSS样式 =&gt; 表格 =&gt; 带边框的表格 --&gt; &lt;table class=&quot;table table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;西游记&lt;/td&gt; &lt;td&gt;吴承恩&lt;/td&gt; &lt;td&gt;北京图书出版社&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 5. CORS 错误跨源资源分享（CORS）是一种允许服务器放宽同源策略的标准。这用于明确允许一些跨源请求，同时拒绝其他请求。例如，如果站点提供外界嵌入的服务，则可能需要放宽同源策略。设置这样的 CORS 配置并不一定容易，并且可能存在一些挑战。在这些页面中，我们将研究一些常见的 CORS 错误消息以及如何解决它们。 如果未正确设置 CORS 配置，浏览器控制台将显示错误，例如 “Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite” 表示请求因违反 CORS 安全规则而被阻止。但这可能不一定是设置错误。因为用户的 Web 应用程序和远程外部服务可能故意禁止该请求。如果要使端点可用，则需要进行一些调试才能成功。 什么是跨域问题前端调用的后端接口不属于同一个域（域名或端口不同），就会产生跨域问题，也就是说你的应用访问了该应用域名或端口之外的域名或端口。 服务器端 开启跨域 12345678910111213141516171819202122232425262728/** * 功能描述：解决跨域过滤器 */@WebFilter(&quot;/api/*&quot;)public class CORSFilter implements Filter &#123; private final int time = 20*24*60*60; public void init(FilterConfig fConfig) throws ServletException &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse resp = (HttpServletResponse) response; // 添加参数，允许任意domain访问 resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 这个allow-headers要配为*，这样才能允许所有的请求头 resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;); resp.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); resp.setHeader(&quot;Access-Control-Max-Age&quot;, time+&quot;&quot;); chain.doFilter(request, resp); &#125; public void destroy() &#123; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"}]},{"title":"jQuery","slug":"jQuery","date":"2023-07-13T02:52:36.000Z","updated":"2023-07-13T02:58:04.316Z","comments":true,"path":"2023/07/13/jQuery/","link":"","permalink":"http://example.com/2023/07/13/jQuery/","excerpt":"","text":"1. JQ1.1 jQ概述jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。JavaScript库：是一个封装好的特定的集合包大量的方法。从封装函数的角度理解库，就是在JavaScrip库中，封装了很多预先定义好的函数在里面JQuery就是这样的一个js文件: 本质上就是对我们之前原生js代码封装后的一个js文件j 代表js Query 代表查询 优点： 轻量级。核心文件才几十kb，不会影响页面加载速度 跨浏览器兼容。基本兼容了现在主流的浏览器 链式编程、隐式迭代 对事件、样式、动画支持，大大简化了DOM操作 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等 免费、开源 初体验1234567891011121314151617181920212223242526272829303132&lt;!-- 使用 原生js 与 JQ PK 点击事件 --&gt; &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 隐式循环 2. 链式操作 3. $(dom对象) 转成 jq对象 调用 jq 的方法 $(&quot;li&quot;).mouseover(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;)).mouseout(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;&#x27;)) &lt;/script&gt; &lt;script&gt; //原生 let liCompAy = document.querySelectorAll(&#x27;li&#x27;) liCompAy.forEach((liComp) =&gt; &#123; liComp.addEventListener(&#x27;mouseover&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `pink` console.log(`鼠标覆盖`) &#125;) liComp.addEventListener(&#x27;mouseout&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `` console.log(`鼠标离开`) &#125;) &#125;) &lt;/script&gt; 入口函数12无需关心JS代码书写顺序 DOM中如果在HTML结构之前写JS代码,需要设置加载事件,获取HTML元素 【加载事件 window.onload】 123456789101112131415&lt;script&gt; //原生 window.addEventListener(&quot;load&quot;,()=&gt;&#123; let inputComp = document.querySelector(&quot;#name&quot;) console.log(`姓名 原生 :$&#123;inputComp.value&#125;`); &#125;) &lt;/script&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //JQ $(()=&gt;console.log(`姓名JQ: $&#123;$(&quot;#name&quot;).val()&#125;`)) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; DOM JQ转换12345678910DOM对象: 通过 document 方式获取到的元素都叫DOM对象jQuery对象 通过 $ 方式获取到的元素都叫 JQ对象将JQ对象转为DOM对象方式: JQ对象[索引] JQ对象.get(索引)将DOM对象转化为JQ对象: $(dom对象)注意： 只能由DOM对象 调用DOM的属性及方法，只能使用JQ对象调用 JQ的属性及方法 12345678910111213141516171819202122&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //dom对象 // let inputComp = document.querySelector(&quot;#name&quot;) // .val() jq的方法 必须 jq对象调用 .value dom的属性 必须 dom对象调用 // console.log(`姓名:$&#123;inputComp.value&#125;`); // jq对象 使用$开头 dom对象 // let $input = $(&quot;#name&quot;) // console.log(`姓名: $&#123;$input.val()&#125;`); //dom 转 jq let jq = $(dom) // let $input = $(inputComp) // console.log(`姓名: $&#123;$input.val()&#125;`); // jq 转 dom [0] .get(0) let $input = $(&quot;#name&quot;) // let input = $input[0] let input = $input.get(0) console.log(`姓名:$&#123;input.value&#125;`); &lt;/script&gt; 1.2 JQ 选择器基本选择器1234561. id选择器 #id值 $(&quot;#name&quot;)2. class选择器 .class值 $(&quot;.a&quot;)3. 标签选择器 标签名 $(&quot;li&quot;)4. 并集 OR , $(&quot;h1,#name,.a&quot;) 5. 交集 AND 直接写 $(&quot;li.c1&quot;)6. 适配 * $(&quot;*&quot;) 123456789101112131415161718192021&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li class=&quot;red&quot;&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data7&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`id选择器:$&#123;$(&#x27;#d5&#x27;).html()&#125;`) console.log(`class选择器:$&#123;$(&#x27;.red&#x27;).html()&#125;`) console.log(`标签选择器:$&#123;$(&#x27;ul&#x27;).html()&#125;`) console.log(`并集选择器===========`) $(&#x27;.red,#d5&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) $(&#x27;li.blue&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;) $(&#x27;*&#x27;).css(&#x27;fontSize&#x27;, &#x27;80px&#x27;)&lt;/script&gt; 层次选择器12345678910111. 儿子 &gt; $(&quot;tr&gt;td&quot;) $(&#x27;元素&#x27;).children([选择器]); 2. 后代 空格 $(&quot;table td&quot;) $(&#x27;元素&#x27;).find(选择器); 3. 下一个弟弟 + $(&quot;#data2+li&quot;) next() $(&quot;#data2&quot;).next(&quot;li&quot;)4. 所有的弟弟 ~ $(&quot;#data2~li&quot;) nextAll() $(&quot;#data2&quot;).nextAll(&quot;li&quot;)5. 上一个哥哥 prev() $(&quot;#data2&quot;).prev(&quot;li&quot;)6. 所有的哥哥 prevAll() $(&quot;#data2&quot;).prevAll(&quot;li&quot;)7. 同胞【哥哥弟弟们】 siblings() $(&quot;#data2&quot;).siblings(&quot;li&quot;) 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;ul&gt;li&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&quot;html li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5+li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).next(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5~li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).nextAll(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prev(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prevAll(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).siblings(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;)&lt;/script&gt; 属性选择器123451.拥有该属性 [attr] $(&quot;[name]&quot;)2.等于属性值 [attr=value] $(&quot;[name=&#x27;sid&#x27;]&quot;)3.使用属性值开头 [attr^=value] $(&quot;[name^=&#x27;s&#x27;]&quot;)4.使用属性值结尾 [attr$=value] $(&quot;[name$=&#x27;s&#x27;]&quot;)5.包含该属性值 [attr*=value] $(&quot;[name*=&#x27;s&#x27;]&quot;) 123456789101112131415&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;abc.html&quot;&gt;data1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;aaa.html&quot;&gt;data2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;ccc.html&quot;&gt;data3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;abcd.html&quot;&gt;data4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a&gt;data5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;[href]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href=&#x27;aaa.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href^=&#x27;a&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href$=&#x27;c.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href*=&#x27;c&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;)&lt;/script&gt; 过滤选择器基本过滤选择器12345671. 第一个 :first $(&quot;li:first&quot;)2. 最后一个 :last $(&quot;li:last&quot;)3. 偶数 :even $(&quot;li:even&quot;)4. 奇数 :odd $(&quot;li:odd&quot;)5. 等于索引 :eq(idx) 或 .eq(idx) $(&quot;li:eq(1)&quot;) 或 $(&quot;li&quot;).eq(1) 从0开始6. 小于索引 :lt(idx) $(&quot;li:lt(3)&quot;)7. 大于索引 :gt(idx) $(&quot;li:gt(3)&quot;) 123456789101112131415161718 &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li:first&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:last&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:even&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:odd&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:eq(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li&#x27;).eq(2).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:lt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:gt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;)&lt;/script&gt; 可见性过滤选择器121. 隐藏 :hidden2. 可见 :visible 1234567891011121314151617&lt;!-- 1. 隐藏 :hidden2. 可见 :visible--&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;显示&lt;/button&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).click(() =&gt; &#123; $(&#x27;img:visible&#x27;).hide(1000) &#125;) $(&#x27;button:eq(1)&#x27;).click(() =&gt; &#123; $(&#x27;img:hidden&#x27;).show(1000) &#125;)&lt;/script&gt; 表单过滤选择器12345678910111213141. input标签 :input $(&quot;input&quot;) &lt;input /&gt;2. type=&#x27;text&#x27; :text $(&quot;input[type=&#x27;text&#x27;]&quot;) &lt;input type=&#x27;text&#x27;/&gt;3. type=&#x27;password&#x27;:password $(&quot;input[type=&#x27;password&#x27;]&quot;) &lt;input type=&#x27;password&#x27;/&gt;4. type=&#x27;radio&#x27; :radio $(&quot;input[type=&#x27;radio&#x27;]&quot;) &lt;input type=&#x27;radio&#x27;/&gt;5. type=&#x27;checkbox&#x27;:checkbox $(&quot;input[type=&#x27;checkbox&#x27;]&quot;) &lt;input type=&#x27;checkbox&#x27;/&gt;6. type=&#x27;submit&#x27; :submit $(&quot;input[type=&#x27;submit&#x27;]&quot;) &lt;input type=&#x27;submit&#x27;/&gt;7. type=&#x27;image&#x27; :image $(&quot;input[type=&#x27;image&#x27;]&quot;) &lt;input type=&#x27;image&#x27;/&gt;8. type=&#x27;reset&#x27; :reset $(&quot;input[type=&#x27;reset&#x27;]&quot;) &lt;input type=&#x27;reset&#x27;/&gt;9. type=&#x27;button&#x27; :button $(&quot;input[type=&#x27;button&#x27;]&quot;) &lt;input type=&#x27;button&#x27;/&gt;10.type=&#x27;file&#x27; :file $(&quot;input[type=&#x27;file&#x27;]&quot;) &lt;input type=&#x27;file&#x27;/&gt;===========================布尔值属性==================11.被选中的单选/复选按钮 :checked $(&quot;:radio:checked&quot;)12.下拉框被选中 :selected $(&quot;:selected&quot;)13.被禁用 :disabled $(&quot;:disabled&quot;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;form action=&quot;xxController&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;admin1&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; value=&quot;admin2&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;hidden&quot; value=&quot;S1001&quot; /&gt; &lt;input type=&quot;text&quot; value=&quot;S1001&quot; disabled /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; value=&quot;123&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;CS&quot; /&gt;CS &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;LOL&quot; checked /&gt;LOL &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;DOTA&quot; checked /&gt;DOTA &lt;br /&gt; &lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt; &lt;br /&gt; &lt;select name=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;data1&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;data2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;data3&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;image&quot; src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`第一文本输入框:$&#123;$(&quot;input&quot;).val()&#125;`); console.log(`第一文本输入框:$&#123;$(&quot;:input&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;input[type=&#x27;text&#x27;]:eq(1)&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;:input:text:eq(1)&quot;).val()&#125;`); console.log(`密码输入框:$&#123;$(&quot;:password&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio:checked&quot;).val()&#125;`); $(&quot;:radio[value=&#x27;1&#x27;]&quot;)[0].checked = true $(&quot;:checkbox:checked&quot;).each((idx,e)=&gt;&#123; // console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); console.log(`索引:$&#123;idx&#125;========value:$&#123;$(e).val()&#125;`); &#125;) $.each($(&quot;:checkbox:checked&quot;),(idx,e)=&gt;&#123; console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); &#125;) $(&#x27;:submit&#x27;).val(&#x27;我是提交按钮&#x27;) $(&quot;:image&quot;).attr(&quot;src&quot;,&#x27;./images/html-css-js.png&#x27;) $(&quot;:reset&quot;).val(`回到解放前`) console.log(`file的name属性值:$&#123;$(&#x27;:file&#x27;).attr(&#x27;name&#x27;)&#125;`) console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).val()&#125;`); console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).text()&#125;`); console.log(`获得禁用的值:$&#123;$(&#x27;:disabled&#x27;).val()&#125;`) console.log(`获得隐藏的值:$&#123;$(&#x27;input:hidden&#x27;).val()&#125;`)&lt;/script&gt; 1.3 JQ注册事件鼠标事件121. 鼠标进入 mouseover = mouseenter2. 鼠标离开 mouseout = mouseleave 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* $(&#x27;li&#x27;) .mouseover(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) &#125;) .mouseout((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;)) */ $(&#x27;li&#x27;) .mouseenter((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;)) .mouseleave((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;))&lt;/script&gt; 123456789101112131415161718192021&lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;ul class=&quot;ul1&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;联系我们&lt;/a&gt; &lt;ul class=&quot;u2&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;邮件联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;电话联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;微信联系&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;.nav .ul1&gt;li:last&quot;).mouseenter(()=&gt;$(&quot;.u2&quot;).show()).mouseleave(()=&gt;$(&quot;.u2&quot;).hide()) &lt;/script&gt; 键盘事件121. 键盘按下 keydown2. 键盘释放 keyup 1234567&lt;input type=&quot;text&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;input&#x27;) .keydown((e) =&gt; console.log(e.keyCode)) .keyup(() =&gt; console.log(`释放`))&lt;/script&gt; 表单事件1234561.单击 click2.双击 dblclick3.值改变 change4.失去焦点 blur5.获得焦点 focus6.表单提交 submit 1234567891011121314151617181920212223242526272829&lt;form action=&quot;logcontroller&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;span id=&quot;accountError&quot;&gt;&lt;/span&gt;&lt;br /&gt; &lt;input type=&quot;password&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;:text&#x27;).focus((e) =&gt; $(e.target).css(&#x27;borderColor&#x27;, &#x27;red&#x27;)) $(&#x27;:text&#x27;).blur(() =&gt; &#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return &#125; console.log(`======用户名=====`) $(&#x27;#accountError&#x27;).html(``) &#125;) $(&quot;form&quot;).submit((e)=&gt;&#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return e.preventDefault() &#125; &#125;)&lt;/script&gt; 事件绑定1234561.绑定 bind(&quot;事件名&quot;,事件处理函数) = on (&quot;事件名&quot;,事件处理函数) 【结构固定,内容多变】 $(&quot;button:eq(0)&quot;).click(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;click&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).dblclick(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;dblclick&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).blur(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;blur&quot;,()=&gt;&#123;...&#125;)2.解绑 unbind(&quot;事件名&quot;) = off(&quot;事件名&quot;)3.只执行一次 one(&quot;事件名&quot;,事件处理函数) 1234567891011&lt;button&gt;绑定 click 按钮1&lt;/button&gt;&lt;button&gt;解除 click 按钮2&lt;/button&gt;&lt;button&gt;只绑定一次 click 按钮3&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).on(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).on(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).off(&#x27;click&#x27;)) $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).unbind(&#x27;click&#x27;)) $(&#x27;button:eq(2)&#x27;).one(&#x27;click&#x27;, () =&gt; console.log(`按钮3 被点击了..11.`))&lt;/script&gt; 复合事件12该事件由2个或2个以上的函数hover(fnOver,fnOut) 1234567891011121314151617&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li&#x27;).hover( (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;), (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) )&lt;/script&gt; 123456789101112131415161718 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;价格与包装&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;售后保障&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品评价&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;.box li&#x27;).hover( (e) =&gt; (e.target.className = &#x27;active&#x27;), (e) =&gt; (e.target.className = &#x27;&#x27;) )&lt;/script&gt; 事件冒泡1234触发子元素事件 级联 触发 父元素的事件【阻止事件冒泡:】1. event.stopPropagation()2. event.cancelBubble = true 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; #d1 &#123; width: 200px; height: 200px; background-color: pink; &#125; #d2 &#123; width: 100px; height: 100px; background-color: yellowgreen; &#125; #d3 &#123; width: 40px; height: 40px; background-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;d1&quot;&gt; &lt;div id=&quot;d2&quot;&gt; &lt;div id=&quot;d3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;#d1&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`爷爷被点击了`)) $(&#x27;#d2&#x27;).bind(&#x27;click&#x27;, function () &#123; console.log(`爸爸被点击了`) // event 内置对象 浏览器中 内置 对象 event.cancelBubble = true &#125;) $(&#x27;#d3&#x27;).bind(&#x27;click&#x27;, (e) =&gt; &#123; console.log(`你小子被点击了`) //e.stopPropagation() event.stopPropagation() &#125;)&lt;/script&gt; 事件默认行为1234默认事件行为： 比如 &lt;a href=&quot;addStu()&quot;&gt;...&lt;/a&gt; 默认链接到目标地址【阻止事件默认行为】1. javaScript:2. event.preventDefault() 12345678&lt;a href=&quot;http://www.baidu.com&quot;&gt;去百度 1 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:&quot;&gt;去百度 2 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:void(0)&quot;&gt;去百度 3 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;&quot;&gt;去百度 4 &lt;/a&gt; &lt;br /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;a&#x27;).bind(&#x27;click&#x27;, () =&gt; event.preventDefault())&lt;/script&gt; 表单序列化1234567序列化: 一次获取到表单中所有元素内容$(&#x27;form&#x27;).on(&#x27;submit&#x27;, function () &#123; // 通过 jQuery 对象的 serialize 方法，获取所有表单元素的数据 $(this).serialize(); // 阻止表单默认提交 return false;&#125;) 12345678910111213141516171819202122 &lt;form action=&quot;02-login-rs.html&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;account&quot; placeholder=&quot;请输入账号&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;pswd&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; placeholder=&quot;请输入年龄&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; location.href = `xxController?$&#123;$(&#x27;form&#x27;).serialize()&#125;` //阻止默认行为 event.preventDefault() &#125;) /* $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; let account = $(&quot;input[name=&#x27;account&#x27;]&quot;).val() let pswd = $(&quot;input[name=&#x27;pswd&#x27;]&quot;).val() location.href = `xxController?account=$&#123;account&#125;&amp;pswd=$&#123;pswd&#125;` //阻止默认行为 event.preventDefault() &#125;) */&lt;/script&gt; 1.4 JQ操作样式1234561.$(&#x27;元素&#x27;).css(&#x27;属性&#x27;, 值); 设置单个属性样式 $(&#x27;元素&#x27;).css(&#123;&#x27;属性&#x27;: &#x27;值&#x27;,&#x27;属性&#x27;: &#x27;值&#x27;&#125;) 设置多个属性样式2.$(&#x27;元素&#x27;).addClass(&#x27;类名 类名&#x27;); 3.$(&#x27;元素&#x27;).hasClass(&#x27;类名&#x27;);4.$(&#x27;元素&#x27;).removeClass(&#x27;类名&#x27;);5.$(&#x27;元素&#x27;).toggleClass(&#x27;类名&#x27;); 123456789101112131415161718192021222324&lt;style&gt; .pic &#123; width: 400px; height: 400px; border: 10px solid #000; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;/&gt;&lt;button&gt;添加样式1&lt;/button&gt;&lt;button&gt;添加样式2&lt;/button&gt;&lt;button&gt;添加样式3&lt;/button&gt;&lt;button&gt;删除样式4&lt;/button&gt;&lt;button&gt;切换样式5&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#x27;width&#x27;, &#x27;80px&#x27;)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#123; width: &#x27;80px&#x27; &#125;)) $(&#x27;button:eq(2)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).addClass(&#x27;pic&#x27;)) $(&#x27;button:eq(3)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).removeClass(&#x27;pic&#x27;)) $(&#x27;button:eq(4)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).toggleClass(&#x27;pic&#x27;)) console.log(`是否拥有pic样式: $&#123;$(&#x27;img&#x27;).hasClass(&#x27;pic&#x27;)&#125;`)&lt;/script&gt; 1.5 jQ操作属性12345678910111. 操作内置属性 获取: $(对象).prop(&#x27;属性名&#x27;); 设置: $(对象).prop(&#x27;属性名&#x27;, 值);2.操作自定义属性 获取: $(对象).attr(自定义属性名); 设置: $(对象).attr(自定义属性名, 值);3. 获取表单控件中的值 $(对象).val() $(对象).val(值);4. 操作普通标签中的值 $(对象).text(值); $(对象).html(值); 12345678910111213141516171819202122232425&lt;input type=&quot;text&quot; value=&quot;admin&quot; name=&quot;username&quot; data-user-id=&quot;S1001&quot; /&gt;&lt;span&gt;111111&lt;/span&gt;&lt;div&gt;&lt;h1&gt;2222&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`获得内置属性: $&#123;$(&#x27;input&#x27;).prop(&#x27;name&#x27;)&#125;`) $(&#x27;input&#x27;).prop(&#x27;name&#x27;, &#x27;uname&#x27;) console.log(`获得自定义属性: $&#123;$(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;)&#125;`) $(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;, &#x27;S6666&#x27;) console.log(`获得value属性: $&#123;$(&#x27;input&#x27;).val()&#125;`) $(&#x27;input&#x27;).val(&#x27;zhang3&#x27;) console.log(`获得innerText: $&#123;$(&#x27;span&#x27;).text()&#125;`) $(&#x27;span&#x27;).text(&#x27;span&#x27;) console.log(`获得innerHTML: $&#123;$(&#x27;div&#x27;).html()&#125;`) $(&#x27;div&#x27;).html(`&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt;&lt;/ul&gt;`)&lt;/script&gt; 1.6 jQ操作元素删除元素1231. $对象.remove(); 从页面中将当前标签删除2. $对象.empty(); 将标签中的所有内容清空3. $对象.html(&#x27;&#x27;); 将标签中的所有内容清空 创建元素121. $对象.html(&#x27;html标签名&#x27;); 直接在标签中添加新标签2. let res = $(&#x27;html标签&#x27;); 创建标签, 返回: JQ标签对象 添加元素1234567891. $父元素.append(元素); 将创建元素添加到父元素末尾2. $父元素.prepend(元素); 将创建元素添加到父元素开始1.尾部添加 父.append(子) 子.appendTo(父) 2.开始添加 父.prepend(子) 子.prependTo(父) 12345678910111213141516171819202122232425262728293031&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;p&gt;我的div中p&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.删除元素 $(&#x27;ul li:first&#x27;).remove() $(&#x27;ul li:last&#x27;).empty() $(&#x27;ul li:last&#x27;).html(``) //2.创建元素 $(&quot;ul li:first&quot;).html(`&lt;p&gt;aaaa&lt;/p&gt;`) let btn = $(`&lt;button&gt;按钮&lt;/button&gt;`) //3.添加元素 $(&#x27;div&#x27;).append(btn) btn.appendTo($(&#x27;div&#x27;)) $(&#x27;div&#x27;).prepend(btn) btn.prependTo($(&#x27;div&#x27;))&lt;/script&gt; 例：根据素材： 03-信息发布.html 实现元素添加&#x2F;删除功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; .msg &#123; width: 980px; padding-bottom: 10px; border: 1px solid #ccc; margin: 50px auto; &#125; textarea &#123; width: 880px; height: 100px; border: 0 none; border: 1px solid orange; resize: none; outline-style: none; border-radius: 10px; display: block; margin: 50px auto 0 auto; padding-left: 20px; padding-top: 20px; box-sizing: border-box; &#125; .btn &#123; width: 80px; height: 40px; display: block; float: right; margin-right: 50px; margin-top: 20px; background-color: blue; color: #fff; text-align: center; text-decoration: none; line-height: 40px; border-radius: 10px; clear: both; &#125; .content &#123; width: 880px; margin: 80px auto 0 auto; &#125; .item &#123; height: 50px; line-height: 50px; border-bottom: 1px dashed #ccc; padding-left: 20px; &#125; .item p &#123; float: left; &#125; .del &#123; float: right; text-decoration: none; color: #999; &#125; .del:hover &#123; color: orange; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;msg&quot;&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;btn&quot;&gt;发布&lt;/a&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;三天没吃肉啦&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //发布 $(`a.btn`).bind(`click`, () =&gt; &#123; //创建 元素 let divItemElt = $(`&lt;div class=&quot;item&quot;&gt; &lt;p&gt;$&#123;$(&#x27;textarea&#x27;).val()&#125;&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt;`) //添加元素 $(`div.content`).prepend(divItemElt) //清空输入框 $(&#x27;textarea&#x27;).val(``) console.log(`===发布=======`) &#125;) //删除 使用 事件委托 代理 $(`div.content`).on(`click`, `.del`, () =&gt; &#123; if (confirm(`确认删除吗?`)) &#123; $(event.target).parent().remove() &#125; console.log(`===删除=========`) &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"JDBC","slug":"JDBC","date":"2023-07-11T10:37:55.000Z","updated":"2023-07-11T16:45:26.895Z","comments":true,"path":"2023/07/11/JDBC/","link":"","permalink":"http://example.com/2023/07/11/JDBC/","excerpt":"","text":"JDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。 1. JDBC1.1 简介 1.2 工作原理 1.3 JDBC API 1.4 JDBC 驱动 1.5 Connection[会话] 1.6 Statement【执行SQL】Statement用于执行静态 SQL 语句 PreparedStatement表示预编译的 SQL 语句的对象。 CallableStatement用于执行 SQL 存储过程的接口。 存储过程定义1234567891011121314151617DELIMITER $$CREATE PROCEDURE p_save_dept(v_deptno INT,v_dname VARCHAR(20),v_loc VARCHAR(20) ,OUT v_rs INT ) BEGIN DECLARE cut INT(1) ; SELECT COUNT(0) INTO cut FROM dept WHERE deptno = v_deptno ; IF cut = 1 THEN SET v_rs = -1 ; END IF ; IF cut = 0 THEN SET v_rs = 1 ; INSERT INTO dept (deptno,dname,loc) VALUES (v_deptno,v_dname,v_loc) ; COMMIT ; END IF ;END $$DELIMITER ; 数据库直接调用12CALL p_save_dept(11,&#x27;aa&#x27;,&#x27;NJ&#x27;,@rs) ;SELECT @rs ; JDBC调用1234567891011Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;root&quot;);CallableStatement cs = conn.prepareCall(&quot;&#123;call p_save_dept(?,?,?,?)&#125;&quot;);cs.setInt(1,12);cs.setString(2,&quot;dev&quot;);cs.setString(3,&quot;NJ&quot;);cs.registerOutParameter(4, JDBCType.INTEGER);cs.execute() ;int out = cs.getInt(4);System.out.println(out);cs.close();conn.close(); 1.7 ResultSet 【查询结果集】 2. DAO2.1 什么是DAO 2.2 DAO作用 2.3 组成部分 2.4 示例 3.DbutilsDbutils：主要是封装了JDBC的代码，简化dao层的操作。作用：帮助java程序员，开发Dao层代码的简单框架。框架的作用：帮助程序员，提高程序的开发效率。 3.1 环境搭建jar包下载 https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils/1.7 3.2 官网地址https://commons.apache.org/proper/commons-dbutils/examples.html 3.3 Dbutils三个核心类介绍1：DbUtils：连接数据库对象—-jdbc辅助方法的集合类，线程安全构造方法：DbUtils()作用：控制连接，控制事务，控制驱动加载额一个类。 2：QueryRunner：SQL语句的操作对象，可以设置查询结果集的封装策略，线程安全。构造方法：（1）QueryRunner()：创建一个与数据库无关的QueryRunner对象，后期再操作数据库的会后，需要手动给一个Connection对象，它可以手动控制事务。Connection.setAutoCommit(false); 设置手动管理事务Connection.commit(); 提交事务 （2）QueryRunner(DataSource ds)：创建一个与数据库关联的queryRunner对象，后期再操作数据库的时候，不需要Connection对象，自动管理事务。DataSource：数据库连接池对象。 12345678 //构造函数与增删改查方法的组合：QueryRunner() update(Connection conn, String sql, Object... params) query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) QueryRunner(DataSource ds) update(String sql, Object... params) query(String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) 3：ResultSetHandle：封装数据的策略对象——将封装结果集中的数据，转换到另一个对象策略：封装数据到对象的方式（示例：将数据库保存在User、保存到数组、保存到集合）方法介绍：handle（ResultSet rs） 3.4 创建DBCP连接池1、创建DBCP链接池配置文件：名称为 dbcp.properties 内容如下： 12345driverClassName=com.mysql.jdbc.Driverusername=rootpassword=123456url=jdbc:mysql://127.0.0.1:3306/long1?characterEncoding=UTF8maxActive=2 2、读取配置文件，创建 DataSource 连接池实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.test.dbcp;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;public class DbcpDataSource &#123;/* * 重点：创建一个DataSource * 步骤为：1、用Properties类读取配置文件。 * 2、通过工厂类，读取这个Properties类获取的配置文件，创建出DataSource * DataSource作用： * 创建DataSource可以返回多个连接。可以实现dbutil简化操作数据库的流程。 *///1、创建一个静态的datasourceprivate static DataSource ds;//2、在静态代码块中，给ds赋值static&#123; //读取资源文件 try&#123; Properties p = new Properties(); p.load(DbcpDataSource.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;)); //在dbcp中有一个工厂类，读取一个资源文件,创建一个datasource ds = BasicDataSourceFactory.createDataSource(p); System.out.println(&quot;创建DataSource为&quot;+ds); &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125; &#125;//提供一个方法用于获取整个datasource对象public static DataSource getDataSource()&#123; return ds; &#125;//提供一个方法，获取connection连接public static Connection getConnection()&#123; Connection con = null; try&#123; con = ds.getConnection(); System.out.println(&quot;通过DataSource获取connection连接&quot;+con); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return con; &#125;&#125; 另外也可以不配置文件直接使用 1234567891011121314static &#123; //模拟初始化数据 Properties prop = new Properties(); prop.setProperty(&quot;driverClassName&quot;,&quot;com.mysql.jdbc.Driver&quot;); prop.setProperty(&quot;url&quot;,&quot;jdbc:mysql://localhost:3306/customer?useSSL=false&amp;characterEncoding=utf8&quot;); prop.setProperty(&quot;password&quot;,&quot;root&quot;); prop.setProperty(&quot;username&quot;,&quot;root&quot;); try&#123; dataSource = DruidDataSourceFactory.createDataSource(prop); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; //初始化 连接池&#125; 3.5 DBUtil 增删改查12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.test.ts;import java.sql.SQLException;import java.util.List;import javax.persistence.Version;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayHandler;import org.apache.commons.dbutils.handlers.ArrayListHandler;import org.junit.Test;import com.test.dbcp.DbcpDataSource;public class DbutilTests &#123;/* * dbutil向数据库新增数据 */@Testpublic void add() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run1 = new QueryRunner(DbcpDataSource.getDataSource()); //申明对象，获取DataSource链接池 //2、书写SQL字符串语句 String sq1 = &quot;INSERT INTO student(id,namee,sex,birth,department,address)&quot; + &quot;VALUES(3,&#x27;王思&#x27;,&#x27;男&#x27;,1995,&#x27;英文系&#x27;,&#x27;山东沧州&#x27;)&quot;; //3、执行sql语句 int result1 = run1.update(sq1); System.out.println(&quot;新增数据库结果，更新了数据有：&quot;+result1+&quot;条&quot;); &#125;/* * dbutil 修改数据库数据 * */@Testpublic void update() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run2 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句 String sq2 = &quot;UPDATE student SET sex=? WHERE id=?&quot;; //3、执行SQL语句 int result2 = run2.update(sq2, &quot;男&quot;,16); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result2+&quot;条&quot;); &#125;/* * dbutil 删除数据库数据 */@Testpublic void delete() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run3 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句（这个sql语句的作用是每次删除ID号最大的数据） String sq3 = &quot;DELETE FROM student WHERE id IN &quot; + &quot;(SELECT a.id FROM &quot; + &quot;(SELECT MAX(id) id FROM student a WHERE id IN&quot; + &quot;(SELECT id FROM student b WHERE a.id=b.id ORDER BY id DESC)) a)&quot;; //3、执行SQL语句 int result3 = run3.update(sq3); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result3+&quot;条&quot;); &#125;/* * dbutil 查询，将结果封装成Object对象，返回第一行数据 */@Testpublic void query() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource链接池 //2、查询 String sq4 = &quot;Select * from student&quot;; Object[] var = run.query(sq4, new ArrayHandler()); if(var !=null)&#123; System.out.print(&quot;输出学生表查询的信息&quot;+&quot;\\n&quot;); for(Object o :var)&#123; System.out.print(o+&quot;\\n&quot;); &#125; &#125; &#125;/* * dbutil 查询 ，将结果封装成Object对象，返回所有的数据 * */@Testpublic void query2() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run5 = new QueryRunner(DbcpDataSource.getDataSource()); //2、书写sql语句 String sq5 = &quot;select * from student&quot;; //3、查询sql List&lt;Object[]&gt; list = run5.query(sq5, new ArrayListHandler()); //4、遍历结果 if(list!=null)&#123; for(Object[] os:list)&#123; for(Object o :os)&#123; System.out.println(&quot;ArrayListHandler()显示查询到的所有数据：&quot;+o+&quot;\\t&quot;); &#125; System.out.println(&quot;\\n--------------------------------------------&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Tomcat-servlet","slug":"Tomcat-servlet","date":"2023-07-11T01:34:13.000Z","updated":"2023-07-11T02:13:21.920Z","comments":true,"path":"2023/07/11/Tomcat-servlet/","link":"","permalink":"http://example.com/2023/07/11/Tomcat-servlet/","excerpt":"","text":"Tomcat是web容器。在进行web项目开发的时候，经常需要http协议，也就是基于请求和响应，比如你在百度输入一行内容搜索，那么百度服务器如何处理这个请求呢？它需要创建servlet来处理，servlet其实就是java程序，只是在服务器端的java程序，servlet通过配置文件拦截你的请求，并进行相应处理，然后展示给你相应界面。那么servlet如何创建？这时候就要用到tomcat了。 1.网络编程1.1 图解 1.2 Server123456789101112131415161718192021222324252627282930313233343536public class ServerApp &#123; public static void main(String[] args) throws IOException &#123; //忠告 数组 final String[] ADVICE_AY = &#123;&quot;每天吃钙，到老我也健康膝盖!&quot;,&quot;听人劝，吃饱饭！&quot;,&quot;代码写的好，要饭要到老！&quot;&#125;; //随机数 final Random RAND = new Random(); //创建服务器端 套接字 ServerSocket serverSocket = new ServerSocket(8080); //服务器端 一直接受 客户端的请求 死循环 while (true)&#123; //获得 客户端套接字 Socket socket = serverSocket.accept(); new Thread(()-&gt;&#123; try &#123; // 获得输出流 OutputStream os = socket.getOutputStream(); //输出 随机字符串 字节流数组 os.write(ADVICE_AY[RAND.nextInt(ADVICE_AY.length)].getBytes(&quot;UTF-8&quot;)); //清空 缓存 os.flush(); InputStream is = socket.getInputStream(); byte[] ay = new byte[1024] ; is.read(ay) ; System.out.println(&quot;来着客户端的消息:&quot;+new String(ay)); //释放流 os.close(); is.close(); //关闭套接字 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 1.3 Client1234567891011121314151617181920public class ClientApp &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080); //获得输入流 InputStream is = socket.getInputStream(); byte[] ay = new byte[1024]; is.read(ay) ; //打印 服务器端消息 System.out.println(&quot;来着服务器端消息:&quot;+new String(ay)); //获得输出流 OutputStream os = socket.getOutputStream(); os.write((&quot;hello Server !!!&quot;+Math.random()).getBytes()); os.flush(); is.close(); os.close(); socket.close(); &#125;&#125; 2. CS&#x2F;BS架构2.1 图解 2.2 C&#x2F;S与B&#x2F;S区别123456789101112131415161718191．硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的，不必是专门的网络硬件环境，例如电话上网，租用设备. 信息自己管理. 有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。2．对安全要求不同：C/S 一般面向相对固定的用户群，对信息安全的控制能力很强。 一般高度机密的信息系统采用C/S 结构适宜。可以通过B/S发布部分可公开信息。B/S 建立在广域网之上， 对安全的控制能力相对弱， 可能面向不可知的用户。3．对程序架构不同：C/S 程序可以更加注重流程， 可以对权限多层次校验， 对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑，建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统。SUN 和IBM推JavaBean 构件技术等，使 B/S更加成熟.。4．软件重用不同：C/S 程序可以不可避免的整体性考虑， 构件的重用性不如在B/S要求下的构件的重用性好。B/S 的多重结构，要求构件相对独立的功能， 能够相对较好的重用，就如买来的餐桌可以再利用，而不是做在墙上的石头桌子。5．系统维护不同：C/S 程序由于整体性，必须整体考察，处理出现的问题以及系统升级、升级难、 可能是再做一个全新的系统。B/S 构件组成，方便构件个别的更换，实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级。 3. 手动部署3.0 创建web应用 3.1 静态html http://localhost/web01/hello.html 3.2 动态jsp http://localhost/web01/hello.jsp 3.3 Servlet1234567891011121314151617Servlet = Server applet 运行在服务器 tomcat上的小程序1.必须 规范：必须实现 Servlet 接口 //直接实现 Servlet 接口 A implements Servlet&#123; &#125; HttpServlet implments Servlet&#123; &#125; //间接实现 Servlet 接口 A extends HttpServlet&#123; ... &#125; 源码参考： 123456789101112131415161718192021import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class HelloWorld extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;Hello World!&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;Hello World Servlet ... !&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125;&#125; 编译 javac -cp D:\\java168_2\\server\\apache-tomcat-8.5.73\\lib\\servlet-api.jar .\\HelloWorld.java 部署 121. 桌面： aa文件下/HelloWorld.class 放在 classess文件夹下2. tomcat/lib/servlet-api.jar lib 空着 配置12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 访问http://localhost/web01/hello.do 4. IDE web开发4.1 创建项目 4.2 创建Servlet123456789public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //控制台输出 IDE console System.out.println(&quot;=====HelloServlet===doGet 该方法被执行啦=======&quot;); //通过 流 浏览器 输出 hello ... resp.getWriter().println(&quot;&lt;h1&gt; hello ...&lt;/h1&gt;&quot;); &#125;&#125; 4.3 配置Servlet123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;!-- 注册 servlet 类 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wanho.java171.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 映射 servlet 类访问路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.4 访问Servlethttp://localhost/day10-01-servlet/hello.do 基于请求驱动 地址栏直接怼 超链接 location.href form action&#x3D;“” 基于事件驱动 5.Servlet API5.1 HttpServletRequest12345678//获得请求参数的值方法1： String name = request.getParameter(&quot;name&quot;);&quot;name&quot; 参数名： 注意：如果参数名 不存在 String name 的值？ null 如果参数名 存在 没有值 String name 的值？ &quot;&quot; //1.针对 post 请求有效 中文乱码 req.setCharacterEncoding(&quot;UTF-8&quot;); 12345678910111213141516//兼容： get/postpublic class TestRequestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException &#123; //获得用户请求参数 使用 HttpServletRequest req 对象 String name = request.getParameter(&quot;name&quot;); String age = request.getParameter(&quot;age&quot;); System.out.println(&quot;姓名:&quot;+name+&quot;,年龄:&quot;+age); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 注意：doPost与doGet的区别GET调用用于获取服务器信息，并将其做为响应返回给客户端。当经由Web浏览器或通过HTML、JSP直接访问Servlet的URL时，一般用GET调用。 POST用于客户端把数据传送到服务器端，是可以隐藏传送给服务器的任何数据。Post适合发送大量的数据。 区别： 1、生成方式 get生成方式有四种：1）直接在URL地址栏中输入URL。2）网页中的超链接。3）form中method为get。4）form中method为空时，默认是get提交。 post生成方式：form中method属性为post。 2、数据传送方式 get方式：表单数据存放在URL地址后面。所有get方式提交时HTTP中没有消息体。 post方式：表单数据存放在HTTP协议的消息体中以实体的方式传送到服务器。 3、服务器获取数据方式 GET方式：服务器采用request.QueryString来获取变量的值。 POST方式：服务器采用request.Form来获取数据。 4、传送的数据量 GET方式：数据量长度有限制，一般不超过2kb。因为是参数传递，且在地址栏中，故数据量有限制。 POST方式：适合大规模的数据传送。因为是以实体的方式传送的。 5、安全性 GET方式：安全性差。因为是直接将数据显示在地址栏中，浏览器有缓冲，可记录用户信息。所以安全性低。 POST方式：安全性高。因为post方式提交数据时是采用的HTTP post机制，是将表单中的字段与值放置在HTTP HEADER内一起传送到ACTION所指的URL中，用户是看不见的。 6、在用户刷新时 GET方式：不会有任何提示、 POST方式：会弹出提示框，问用户是否重新提交 5.2 HttpServletResponse响应字符流12345// 1.响应 [html内容] 字符输出流resp.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter out = resp.getWriter();//通过 流 浏览器 输出 hello ... 类似： js ： document.write(&quot;html代码&quot;)out.println(&quot;&lt;h1&gt; hello . 该方法被执行啦..&lt;/h1&gt;&quot;); 响应URL12//2. 响应URL 浏览器 根据响应URL 再次发送新的请求resp.sendRedirect(&quot;./request.do&quot;) ;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"}]},{"title":"Java-捕获异常","slug":"Java-捕获异常","date":"2023-07-03T11:09:06.000Z","updated":"2023-07-03T11:35:12.222Z","comments":true,"path":"2023/07/03/Java-捕获异常/","link":"","permalink":"http://example.com/2023/07/03/Java-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/","excerpt":"","text":"捕获异常使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方。try&#x2F;catch代码块中的代码称为保护代码，使用 try&#x2F;catch 的语法如下： 1234567try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 实例:下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第四个元素的时候就会抛出一个异常。 1234567891011121314// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest&#123; public static void main(String args[])&#123; try&#123; int a[] = new int[2]; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; System.out.println(&quot;Out of the block&quot;); &#125;&#125; 以上代码编译运行输出结果如下 12Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block 多重捕获块一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。多重捕获块的语法如下所示： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;catch(异常类型3 异常的变量名3)&#123; // 程序代码&#125; 上面的代码段包含了 3 个 catch块。可以在 try 语句后面添加任意数量的 catch 块。如果保护代码中发生异常，异常被抛给第一个 catch 块。如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。如果不匹配，它会被传递给第二个 catch 块。如此，直到异常被捕获或者通过所有的 catch 块。 实例:该实例展示了怎么使用多重 try&#x2F;catch。 12345678910try &#123; file = new FileInputStream(fileName); x = (byte) file.read();&#125; catch(FileNotFoundException f) &#123; // Not valid! f.printStackTrace(); return -1;&#125; catch(IOException i) &#123; i.printStackTrace(); return -1;&#125; throws&#x2F;throw 关键字在Java中， throw 和 throws 关键字是用于处理异常的。throw 关键字用于在代码中抛出异常，而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。 throw 关键字throw 关键字用于在当前方法中抛出一个异常。通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 throw 关键字抛出异常，以告知调用者当前代码的执行状态。例如，下面的代码中，在方法中判断 num 是否小于 0，如果是，则抛出一个 IllegalArgumentException 异常。 12345public void checkNumber(int num) &#123; if (num &lt; 0) &#123; throw new IllegalArgumentException(&quot;Number must be positive&quot;); &#125;&#125; throws 关键字throws 关键字用于在方法声明中指定该方法可能抛出的异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常。例如，下面的代码中，当 readFile 方法内部发生 IOException 异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理 IOException 异常。 123456789public void readFile(String filePath) throws IOException &#123; BufferedReader reader = new BufferedReader(new FileReader(filePath)); String line = reader.readLine(); while (line != null) &#123; System.out.println(line); line = reader.readLine(); &#125; reader.close();&#125; 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException： 12345678910import java.io.*;public class className&#123; public void withdraw(double amount) throws RemoteException, InsufficientFundsException &#123; // Method implementation &#125; //Remainder of class definition&#125; finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; 实例:123456789101112131415public class ExcepTest&#123; public static void main(String args[])&#123; int a[] = new int[2]; try&#123; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; finally&#123; a[0] = 6; System.out.println(&quot;First element value: &quot; +a[0]); System.out.println(&quot;The finally statement is executed&quot;); &#125; &#125;&#125; 以上实例编译运行结果如下： 123Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed 注意下面事项： 1.catch 不能独立于 try 存在。2.在 try&#x2F;catch 后面添加 finally 块并非强制性要求的。3.try 代码后不能既没 catch 块也没 finally 块。4.try, catch, finally 块之间不能添加任何代码。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-查询基础","slug":"Mysql-查询基础","date":"2023-07-03T10:27:29.000Z","updated":"2023-07-11T01:36:23.486Z","comments":true,"path":"2023/07/03/Mysql-查询基础/","link":"","permalink":"http://example.com/2023/07/03/Mysql-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 查询基础1.0 基本概念12345678DDL:[数据定义语言] create , alter , drop , truncate 语句 【事务自动提交】DML:[数据操作语言] insert ,update, delete 语句DQL:[数据查询语言] selectDCL:[数据控制语言] grant[授权] ，revoke[撤销] ,commit , rollback , savepoint 表结构 初始化脚本scott.sql 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394drop database if exists scott;create database scott;use scott;DROP TABLE IF EXISTS BONUS;CREATE TABLE BONUS (ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,SAL DOUBLE NULL ,COMM DOUBLE NULL ) ;-- ------------------------------ Records for BONUS-- ------------------------------ ------------------------------ Table structure for DEPT-- ----------------------------DROP TABLE IF EXISTS DEPT;CREATE TABLE DEPT (DEPTNO INT(2) PRIMARY KEY,DNAME VARCHAR(14) NULL ,LOC VARCHAR(13) NULL );-- ------------------------------ Records for DEPT-- ----------------------------INSERT INTO DEPT VALUES (&#x27;10&#x27;, &#x27;ACCOUNTING&#x27;, &#x27;NEW YORK&#x27;);INSERT INTO DEPT VALUES (&#x27;20&#x27;, &#x27;RESEARCH&#x27;, &#x27;DALLAS&#x27;);INSERT INTO DEPT VALUES (&#x27;30&#x27;, &#x27;SALES&#x27;, &#x27;CHICAGO&#x27;);INSERT INTO DEPT VALUES (&#x27;40&#x27;, &#x27;OPERATIONS&#x27;, &#x27;BOSTON&#x27;);-- ------------------------------ Table structure for EMP-- ----------------------------DROP TABLE IF EXISTS EMP;CREATE TABLE EMP (EMPNO INT(4) PRIMARY KEY ,ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,MGR INT(4) NULL ,HIREDATE DATETIME NULL ,SAL DOUBLE(7,2) NULL ,COMM DOUBLE(7,2) NULL ,DEPTNO INT(2) NULL );-- ------------------------------ Records for EMP-- ----------------------------INSERT INTO EMP VALUES (&#x27;7369&#x27;, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, &#x27;7902&#x27;, &#x27;1980-12-17 00:00:00&#x27;, &#x27;800&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7499&#x27;, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-20 00:00:00&#x27;, &#x27;1600&#x27;, &#x27;300&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7521&#x27;, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-22 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;500&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7566&#x27;, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-04-02 00:00:00&#x27;, &#x27;2975&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7654&#x27;, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-28 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;1400&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7698&#x27;, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-05-01 00:00:00&#x27;, &#x27;2850&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7782&#x27;, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-06-09 00:00:00&#x27;, &#x27;2450&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7788&#x27;, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1987-04-19 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7839&#x27;, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, null, &#x27;1981-11-17 00:00:00&#x27;, &#x27;5000&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7844&#x27;, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-08 00:00:00&#x27;, &#x27;1500&#x27;, &#x27;0&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7876&#x27;, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, &#x27;7788&#x27;, &#x27;1987-05-23 00:00:00&#x27;, &#x27;1100&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7900&#x27;, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, &#x27;7698&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;950&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7902&#x27;, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7934&#x27;, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, &#x27;7782&#x27;, &#x27;1982-01-23 00:00:00&#x27;, &#x27;1300&#x27;, null, &#x27;10&#x27;);-- ------------------------------ Table structure for &quot;SALGRADE&quot;-- ----------------------------DROP TABLE IF EXISTS SALGRADE;CREATE TABLE SALGRADE (GRADE INT(2) NULL ,LOSAL DOUBLE NULL ,HISAL DOUBLE NULL ) ;-- ------------------------------ Records for SALGRADE-- ----------------------------INSERT INTO SALGRADE VALUES (&#x27;1&#x27;, &#x27;700&#x27;, &#x27;1200&#x27;);INSERT INTO SALGRADE VALUES (&#x27;2&#x27;, &#x27;1201&#x27;, &#x27;1400&#x27;);INSERT INTO SALGRADE VALUES (&#x27;3&#x27;, &#x27;1401&#x27;, &#x27;2000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;4&#x27;, &#x27;2001&#x27;, &#x27;3000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;5&#x27;, &#x27;3001&#x27;, &#x27;9999&#x27;);-- ------------------------------ Foreign Key structure for table EMP-- ----------------------------ALTER TABLE EMP ADD FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO); 1.1 简单select所有行所有列1SELECT * FROM emp ; 限制列1SELECT empno,ename,sal FROM emp ; 限制行1SELECT * FROM emp WHERE deptno = 10 ; 1.2 算术运算符 + - * &#x2F;注意： null 值不参与计算 【null 未知值 不确定值 x？】 1SELECT sal+comm FROM emp ; -- comm null 值 + 【运算】1234SELECT 3+4 ;SELECT &#x27;3&#x27;+4 ;SELECT &#x27;3&#x27;+&#x27;4&#x27; ;SELECT &#x27;3&#x27;+&#x27;ABC&#x27; ; -- 3 [不报错] &#x2F; 【除法】1SELECT 5/2 ; -- 2.5000 1.3 别名 AS标准： AS “dept.dname” 1SELECT ename AS &quot;from&quot; ,sal AS &quot;员工 工资&quot; FROM emp AS e 1.4 null 空值安全 等于&#x2F;全等于 ：&lt;&#x3D;&gt; 与 &#x3D; 区别：可以判断null值 is null123SELECT * FROM emp WHERE comm IS NULL ;SELECT * FROM emp WHERE comm &lt;=&gt; NULL ; is not null123SELECT * FROM emp WHERE comm IS NOT NULL ;SELECT * FROM emp WHERE NOT comm IS NULL ; 1.5 去重复行 distinct1SELECT DISTINCT deptno ,job FROM emp ; 1.6 排序 order by堆表：快速插入数据 【搬家公司 –&gt; 家具】 默认： 升序 ASC 降序 DESC 基本排序12SELECT * FROM emp ORDER BY sal ASC;SELECT * FROM emp ORDER BY sal DESC; 结果集列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC; 排序多列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC ,1 ASC ; nullOracle 数据库有专用关键字，mysql没有 12345-- null firstSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),99999,comm) DESC ;-- null lastSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),-1,comm) DESC ; 1.7 比较运算符 &lt;&#x3D;&gt; 安全等于【比较null值】 &#x3D; 等于【不能比较null值】 !&#x3D; &lt;&gt; &lt; &lt;&#x3D; &gt; &gt;&#x3D; between and 1234SELECT * FROM emp WHERE deptno != 10 ;SELECT * FROM emp WHERE deptno &lt;&gt; 10 ;SELECT * FROM emp WHERE sal BETWEEN 800 AND 3000 ;SELECT * FROM emp WHERE sal&gt;=800 AND sal&lt;=3000 ; 1.8 in not inin12SELECT * FROM emp WHERE deptno IN (10,20) ;SELECT * FROM emp WHERE deptno =10 OR deptno =20 ; not in12-- 注意： not in (去null值)SELECT * FROM emp WHERE deptno NOT IN (10,20,NULL) ; 1.9 模糊查询_ 一个字符 % N个字符 1SELECT * FROM emp WHERE ename LIKE &#x27;__A%&#x27;; 1234-- zhang_san _进行转义 _不是 like 匹配字符 而是数据SELECT * FROM emp WHERE ename LIKE &#x27;%\\_%&#x27;;SELECT * FROM emp WHERE ename LIKE &#x27;%\\%%&#x27;; 1.10 正则 REGEXP12345^ 匹配开头$ 匹配结尾. 任何一个字符[abc] 范围匹配一个 [a-z] [0-9]* 匹配任意次 12345678-- s开头的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;^S&#x27; ;-- T结尾的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;T$&#x27; ;-- 第二个字母 CSELECT * FROM emp WHERE ename REGEXP &#x27;.C&#x27; ;-- 包含字母 OSELECT * FROM emp WHERE ename REGEXP &#x27;.*O.*&#x27; ; 1.11 逻辑运算符not ! and &amp;&amp; or || 1SELECT NOT 1=1 , ! (1=1) ; 1.12 limitTOPN 1234567-- limit 位置偏移量, 行数 -- 第一页SELECT * FROM emp LIMIT 0,5 ;SELECT * FROM emp LIMIT 5 ;-- 第二页SELECT * FROM emp LIMIT 5,5 ; 例1：123456789101112131415161718-- 1.选择在部门 30 中员工的所有信息 select * from emp where deptno = &#x27;30&#x27; ;-- 2 列出职位为（MANAGER）的员工的编号，姓名 select empno,ename from emp where job = &#x27;MANAGER&#x27; ;-- 3 找出奖金高于工资的员工 select * from emp where comm&gt;sal ;-- 4 找出每个员工奖金和工资的总和 select sal+if(isnull(comm),0,comm) month_sal ,ename from emp order by month_sal desc ;-- 5 找出部门 10 中的经理(MANAGER)和部门 20 中的普通员工(CLERK)select * from emp where (deptno,job) in ((10,&#x27;MANAGER&#x27;),(20,&#x27;CLERK&#x27;)) ;-- 6 找出部门 10 中既不是经理MANAGER也不是普通员工CLERK，而且工资大于等于 2000 的员工select * from emp where deptno = 10 and job not in (&#x27;MANAGER&#x27;,&#x27;CLERK&#x27;) and sal&gt;=2000 ;-- 7 找出有奖金的员工的不同工作select distinct job from emp where comm is not null ;-- 8 找出没有奖金或者奖金低于 500 的员工select * from emp where comm is null or comm&lt;500 ;-- 9 显示雇员姓名，根据其服务年限，将最老的雇员排在最前面select ename from emp order by hiredate asc ; 2. 单行函数2.1 数值函数绝对值 1SELECT ABS(-11.5) ; 平方根 1SELECT SQRT(100) ; 求余 1SELECT MOD(5,2) ; 向上取整 1SELECT CEIL(3.001) ,CEIL(3.000) ; 向下取整 1SELECT FLOOR(3.999) ,CEIL(3.000) ; 随机数 1SELECT RAND() ; 四舍五入 1SELECT ROUND(11.5),ROUND(-11.5) ; 2.2 字符函数字符个数 123SELECT * FROM emp WHERE CHAR_LENGTH(ename) = 5 ;SELECT * FROM emp WHERE ename LIKE &#x27;_____&#x27; ; 字符串连接 12345-- concat() null 值 返回 nullSELECT CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;,NULL) ;-- concat_ws() null值不参与 【第一个参数 连接符 】SELECT CONCAT_WS(&#x27;,&#x27;,&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT_WS(&#x27;*&#x27;,&#x27;hello&#x27;,NULL,&#x27;word&#x27;,&#x27;java167&#x27;) 字符串替换 12-- db 索引从 1 开始SELECT INSERT(&#x27;hellojava167&#x27;,3,2,&#x27;**&#x27;) ; 大小写转换 1SELECT UPPER(&#x27;hello java&#x27;),LOWER(&#x27;JAVA hello&#x27;) ; 左右截取字符串 1SELECT LEFT(&#x27;helloworld&#x27;,5),RIGHT(&#x27;helloworld&#x27;,5) ; 左右填充字符串 1SELECT LPAD(&#x27;helloworld&#x27;,15,&#x27;-&#x27;),RPAD(&#x27;helloworld&#x27;,15,&#x27;*&#x27;) ; 首尾去空格 12SELECT TRIM(&#x27; abc ddd &#x27;) ;SELECT TRIM(&#x27;abc&#x27; FROM &#x27;abcxxxyyyabc&#x27;) ; 重复生成字符串 1SELECT REPEAT(&#x27;hello&#x27;,5) ; 字符串比较 12-- 1 0 -1SELECT STRCMP(&#x27;abc&#x27;,&#x27;def&#x27;) ,STRCMP(&#x27;abc&#x27;,&#x27;abc&#x27;),STRCMP(&#x27;zzz&#x27;,&#x27;abc&#x27;); 字符串截取 1234SELECT SUBSTRING(&#x27;helloworld&#x27;,1,5) ,SUBSTRING(&#x27;helloworld&#x27;,5),SUBSTRING(&#x27;helloworld&#x27;,-5);SELECT MID(&#x27;helloworld&#x27;,1,5) ,MID(&#x27;helloworld&#x27;,5),MID(&#x27;helloworld&#x27;,-5); 查找索引 1SELECT LOCATE(&#x27;o&#x27;,&#x27;helloworld&#x27;) ,POSITION(&#x27;o&#x27; IN &#x27;helloworld&#x27;),INSTR(&#x27;helloworld&#x27;,&#x27;o&#x27;) ; 2.3 日期函数当前日期 123456-- 年月日SELECT CURRENT_DATE , CURRENT_DATE() , CURDATE();-- 时分秒SELECT CURRENT_TIME ,CURRENT_TIME(), CURTIME();-- 年月日 时分秒SELECT CURRENT_TIMESTAMP,CURRENT_TIMESTAMP(),LOCALTIME(),NOW(),SYSDATE() ; 日期之间相差天数 1SELECT DATEDIFF(NOW(),hiredate) FROM emp ; 当前日期该月最后一天 1SELECT LAST_DAY(NOW()) ; 日期加减 123SELECT DATE_ADD(NOW(),INTERVAL 1 DAY) ;SELECT DATE_SUB(NOW(),INTERVAL 1 DAY) ; 周 年 月 小时 分 12345SELECT WEEK(NOW()),YEAR(NOW()),MONTH(NOW()),HOUR(NOW()),MINUTE(NOW()) ;SELECT DAYOFMONTH(NOW()),DAY(NOW()),DAYOFYEAR(NOW()) ;-- 提取日期中 部分字段SELECT EXTRACT(YEAR FROM NOW()),EXTRACT(MONTH FROM NOW()) ; 日期格式化 12SELECT DATE_FORMAT(NOW(),&#x27;%Y/%m/%d %h:%i&#x27;);SELECT * FROM emp WHERE DATE_FORMAT(hiredate,&#x27;%m&#x27;) = &#x27;02&#x27; ; 2.4 条件判断函数if 12SELECT IF(3&lt;2,&#x27;aaa&#x27;,&#x27;bbb&#x27;);SELECT IF(STRCMP(&#x27;xyz&#x27;,&#x27;abc&#x27;),&#x27;yes&#x27;,&#x27;no&#x27;); ifnull 1SELECT sal+IFNULL(comm,0) FROM emp ; case 12345678910111213-- 根据部门 10 dev 20 test 30 public others SELECT empno, ename, CASE deptno WHEN 10 THEN &#x27;dev&#x27; WHEN 20 THEN &#x27;test&#x27; WHEN 30 THEN &#x27;public&#x27; ELSE &#x27;others&#x27; END dnameFROM emp ; 例2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546-- 1 找出每个月倒数第三天受雇的员工（如：2009-5-29） -- date_add last_dayselect * from emp where date_add(hiredate,INTERVAL 2 day) = last_day(hiredate);-- 2 找出 25 年前雇的员工 -- datediffselect * from emp where datediff(now(),hiredate)/365&gt;25 ;-- 3 所有员工名字前加上 Dear ,并且名字首字母大写 -- concat concat_ws upper substring midselect concat(&#x27;Dear&#x27;,upper(mid(ename,1,1)),mid(ename,2)) from emp ;-- 4 找出姓名为 5 个字母的员工 -- char_length like _select * from emp where char_length(ename) = 5 ;-- 5 找出姓名中不带 R 这个字母的员工 -- not likeselect * from emp where ename not like &#x27;%R%&#x27; ;-- 6 显示所有员工的姓名的第一个字 -- substringselect substring(ename,1,1) from emp ;-- 7 显示所有员工，按名字降序排列，若相同，则按工资升序排序 select ename,sal from emp order by ename desc , sal asc ;-- 8 假设一个月为 30 天，找出所有员工的日薪，不计小数 -- floor isnull if ifnullselect floor((sal+ifnull(comm,0))/30) from emp ;-- 9 找到 2 月份受雇的员工 -- month date_formatselect * from emp where month(hiredate) = 2 ;-- 10 列出员工加入公司的天数(四舍五入） select datediff(now(),hiredate) from emp ;-- 11 分别用 case 列出员工所在的部门，-- deptno=10 显示&#x27;部门 10&#x27;, -- deptno=20 显示&#x27;部门 20&#x27; -- deptno=30 显示&#x27;部门 30&#x27; -- deptno=40 显示&#x27;部门 40&#x27; -- 否则为&#x27;其他部门&#x27; select empno,ename ,case when deptno between 10 and 30 then &#x27;重要部门&#x27; when deptno&gt;40 then &#x27;辅助部门&#x27; else &#x27;其他部门&#x27; end dname from emp ; 3. 分组函数统计函数 组函数 聚合函数 count sum min max avg 3.1 注意：null值不参与统计 123SELECT COUNT(comm) FROM emp ; -- 4 表中数据 16行SELECT COUNT(0) FROM emp ; 分组函数不能出现where子句 12-- 查询工资大于平均工资的员工SELECT * FROM emp WHERE sal &gt; AVG(sal) ; 3.2 group by注意： 只要有group by 子句： ​ select 子句要求：只能写 group by 出现的列名 + 5 个分组函数 12345678910SELECT deptno, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno ; 多个分组条件： 12345678910SELECT deptno,job, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno,job ; 3.3 having123456789-- 根据部门分组 查询部门人数大于 2人的部门编号 人数-- 根据部门分组 查询部门人数大于 2人的部门编号 人数SELECT deptno, COUNT(0) dept_countFROM empGROUP BY deptnoHAVING COUNT(0)&gt;2 ; 3.4 完整的SQL1234567891011121314select 列名1 ,列名2...列名Nfrom 表1,表2 .... 表Nwhere 限制行【分组前过滤】group by 分组列having 分组后过滤order by 排序limit 偏移量,行数 12345678910111213-- 查询工资大于500 按照部门分组 如果部门相同按照工种分组 人数大于等于1 按照人数排降序 第2~5条SELECT deptno, job, COUNT(0) dept_count FROM emp WHERE sal &gt; 500 GROUP BY deptno, job HAVING COUNT(0) &gt;= 1 ORDER BY 3 DESC LIMIT 2, 3 ; 3.5 行列转换12345678910CREATE TABLE stu( sname VARCHAR(20), sub VARCHAR(20), score VARCHAR(20));INSERT INTO stu (sname,sub,score) VALUES (&#x27;zs&#x27;,&#x27;chinese&#x27;,&#x27;100&#x27;),(&#x27;zs&#x27;,&#x27;math&#x27;,&#x27;99&#x27;),(&#x27;zs&#x27;,&#x27;english&#x27;,&#x27;98&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;li&#x27;,&#x27;chinese&#x27;,&#x27;80&#x27;),(&#x27;li&#x27;,&#x27;math&#x27;,&#x27;89&#x27;),(&#x27;li&#x27;,&#x27;english&#x27;,&#x27;88&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;ww&#x27;,&#x27;chinese&#x27;,&#x27;70&#x27;),(&#x27;ww&#x27;,&#x27;math&#x27;,&#x27;79&#x27;),(&#x27;ww&#x27;,&#x27;english&#x27;,&#x27;78&#x27;);COMMIT ; 1234567SELECT sname, CASE sub WHEN &#x27;chinese&#x27; THEN score END chinese , CASE sub WHEN &#x27;math&#x27; THEN score END math , CASE sub WHEN &#x27;english&#x27; THEN score END english FROM stu 12345678SELECT sname, SUM(CASE sub WHEN &#x27;chinese&#x27; THEN score END) chinese , SUM(CASE sub WHEN &#x27;math&#x27; THEN score END) math , SUM(CASE sub WHEN &#x27;english&#x27; THEN score END) english FROM stu GROUP BY sname 例3:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-- 1 分组统计各部门下工资&gt;500 的员工的平均工资-- group by deptno 分组统计各部门-- where sal &gt; 500 工资&gt;500 的员工-- select avg(sal) 平均工资-- from emp 员工select deptno,avg(sal) avg_sal from emp where sal&gt;500 group by deptno ;-- 2 统计各部门下平均工资大于 500 的部门 -- group by deptno 统计各部门-- select avg(sal)-- having avg(sal)&gt;500 工资大于 500 select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;500 ;-- 3 算出部门 30 中得到最多奖金的员工奖金 -- where deptno = 30 部门 30-- select max(comm) 最多奖金select max(comm) from emp where deptno = 30 ;-- 4 算出部门 30 中得到最多奖金的员工姓名 -- where deptno = 30 部门 30 得到最多奖金-- select ename 员工姓名-- select ename,comm from emp where deptno=30 order by comm desc limit 0,1;-- select ename,comm from emp where deptno=30 and comm=(select max(comm) from emp where deptno = 30 ) ;select ename,comm from emp where (deptno,comm)=(select deptno,max(comm) from emp where deptno = 30 ) ;-- 5 算出每个职位的员工数和最低工资 -- group by job 每个职位-- select count(0) , min(sal) 员工数和最低工资select job,count(0) , min(sal) from emp group by job ;-- 6 算出每个部门,每个职位的平均工资和平均奖金(平均值包括没有奖金)，-- 如果平均奖金大于 300，显示“奖金不错”，-- 如果平均奖金 100 到 300，显示“奖金一般”，-- 如果平均奖金小于 100，显示“基本没有奖金”，-- 按部门编号降序，平均工资降序排列-- group by deptno,job 每个部门,每个职位-- select avg(sal) ,avg(ifnull(comm,0)) 平均工资和平均奖金-- case when then end .. 显示转换-- order by deptno desc ,avg(sal) desc 按部门编号降序，平均工资降序排列select deptno,job,avg(sal) ,case when avg(ifnull(comm,0))&gt;300 then &#x27;奖金不错&#x27; when avg(ifnull(comm,0))&gt;=100 and avg(ifnull(comm,0))&lt;=300 then &#x27;奖金一般&#x27; when avg(ifnull(comm,0))&lt;100 then &#x27;基本没有奖金&#x27; end comm_msg from emp group by deptno,job order by deptno desc ,avg(sal) desc;-- 7 列出员工表中每个部门的员工数，和部门 no -- group by deptno 每个部门-- select count(0) , deptno 员工数，和部门 noselect count(0) , deptno from emp group by deptno ;-- 8 得到工资大于自己部门平均工资的员工信息 -- 注意： 别名select * from emp e where sal &gt; (select avg(sal) from emp where deptno=e.deptno) ;-- 9 分组统计每个部门下，每种职位的平均奖金（也要算没奖金的人）和总工资(包括奖金) -- group by deptno,job ; 每个部门下，每种职位-- select avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) 平均奖金（也要算没奖金的人）和总工资(包括奖金) select deptno,job,avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) from emp group by deptno,job; 4. 多表查询 4.1 笛卡尔集【积】 Cross join行相乘 列相加 【大结果集】 bug 【避免该查询】忘记写 where 条件 ，或条件无效 1234-- 忘记写 where 条件SELECT * FROM emp,dept,salgrade ;-- 条件无效 SELECT * FROM emp,dept,salgrade WHERE emp.deptno=emp.deptno; 4.2 等值连接 Equi join&#x2F;Natural join两张表的数据 必须相关 【外键值 &#x3D; 另一张表的主键值】 等值连接 12-- 查询姓名 部门名称SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e , dept d WHERE e.deptno = d.deptno 自然连接【两表中同名的列】 12-- EMP deptno [emp 的 FK] Dept deptno [dept 的 PK]SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e NATURAL JOIN dept d ; 4.3 非等值连接 Non-Equijoin参考值 【emp表 sal 3000 salgrade表 3000 ？1201~4000】 1234567891011-- 查询工号，姓名 ，工资，工资等级SELECT e.empno, e.ename, e.sal, s.grade FROM emp e, salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal ; 4.4 自连接 Self join树型表 无限级分类表 【表的FK 指向自己表的主键】 必须使用别名 123456SELECT COUNT(0) FROM emp e,emp m ; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.empno = e.empno; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.mgr = m.empno; -- 自连接-- 查询员工姓名 工资 直接领导姓名 工资 SELECT e.ename emp_name,e.sal emp_sal,m.ename mgr_name,m.sal mgr_sal FROM emp e, emp m WHERE e.mgr = m.empno ; 4.5 左外连接 Left Outer Join123456789-- 查询所有员工姓名 部门名称 包括没有部门的员工SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno ; 4.6 右外连接 Right Outer Join123456789-- 查询所有部门名称 包括没有员工的 部门select e.ename, d.deptno, d.dname from emp e right outer join dept d on e.deptno = d.deptno ; 4.7 满外连接 Full Outer Joinmysql 不支持 Full join 【通过集合操作 union 合集】 12345678910111213141516171819-- 查询所有部门名称 包括没有员工的 部门 -- + 所有员工姓名 部门名称 包括没有部门的员工(SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno) UNION(SELECT e.ename, d.deptno, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno = d.deptno) 4.8 内连接 Inner Join12-- 查询 员工姓名 部门名SELECT e.ename,d.deptno,dname FROM emp e INNER JOIN dept d ON e.deptno = d.deptno ; 4.9 集合操作并集【UNION ，UNION ALL】 UNION 自动去重复 速度慢 UNION ALL 保留重复 速度快 注意： 列的个数相同 列的数据类型一致 无序 123456SELECT* FROM((SELECT * FROM emp WHERE deptno = 10 ORDER BY sal DESC )UNION(SELECT * FROM emp WHERE deptno = 20 ORDER BY sal DESC ))t ORDER BY t.sal DESC ; 5. 子查询子查询：where 子句 ，from子句，select 子句 , having 子句 123456789101112131415161718-- select 子句 [标量子查询]SELECT ename,(SELECT dname FROM dept WHERE deptno=e.deptno) dname FROM emp e;-- having 子句SELECT MIN(sal), deptno FROM emp GROUP BY deptno HAVING MIN(sal) = (SELECT MIN(min_sal) FROM (SELECT MIN(sal) min_sal FROM emp GROUP BY deptno) t) ; 子查询不返回 主查询不返回 12-- 查询工资比 工号8888 的员工还高员工姓名SELECT * FROM emp WHERE sal&gt;(SELECT sal FROM emp WHERE empno = 8888) ; 单列 对 多列 1SELECT * FROM emp WHERE sal&gt;(SELECT ename,sal FROM emp WHERE empno = 7788) ; 单行 对 多行 12-- Subquery returns more than 1 rowSELECT * FROM emp WHERE sal = (SELECT MIN(sal) FROM emp GROUP BY deptno) ; 5.1 单行子查询子查询结果【单行】 比较运算符 &#x3D; !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 12345678910111213-- 查询大于平均工资的员工SELECT * FROM emp WHERE sal &gt; (SELECT AVG(sal) FROM emp) ; -- 查询 7788 相同部门 工种的员工SELECT * FROM emp WHERE (deptno,job)=(SELECT deptno,job FROM emp WHERE empno = 7788) 注意：返回多行 【一行 对多行&#x2F;多值 ，一列对多列 ，NULL&#x2F;空值】 5.2 多行子查询返回 多行 【包含单行 –&gt; NULL值】 in 【 &#x3D; any ，&#x3D; some】 ，not in ， &gt; all &gt;&#x3D; all &lt; &lt;&#x3D; all ,&gt;any in ，not in 【无法使用索引查询，查询全表扫描】 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename,e.sal FROM emp e ,(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) tWHERE e.deptno = t.deptno AND e.sal = t.dept_min_sal ;-- 子查询SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) IN(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =ANY(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =SOME(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) exists ，not exists 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename, e.sal FROM emp e WHERE EXISTS (SELECT NULL FROM emp GROUP BY deptno HAVING deptno = e.deptno AND MIN(sal) = e.sal) ; in VS exists 1234in : 无法使用索引，全表扫描 not in 【注意去 null值】 主查询 3KW 子查询 1Kexists : 使用索引，不使用全表扫描 not exists 主查询 1k 子查询 3kw","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Mysql安装过程详解","slug":"Mysql安装过程详解","date":"2023-07-03T03:48:58.000Z","updated":"2023-07-11T01:36:53.605Z","comments":true,"path":"2023/07/03/Mysql安装过程详解/","link":"","permalink":"http://example.com/2023/07/03/Mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Mysql安装&#x2F;卸载1 卸载 2 安装下载https://downloads.mysql.com/archives/installer/ 安装 卸载不干净，无法安装 【解决方案】 https://blog.csdn.net/weixin_43147354/article/details/117241786 MicrosoftProgram_Install_and_Uninstall.meta.diagcab","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Java-IO流","slug":"Java-IO流","date":"2023-07-01T12:15:14.000Z","updated":"2023-07-01T14:36:24.329Z","comments":true,"path":"2023/07/01/Java-IO流/","link":"","permalink":"http://example.com/2023/07/01/Java-IO%E6%B5%81/","excerpt":"","text":"1. File1.1 File与流 1.2 File练习例11234567891011121314151617181920/*使用File对象，在C盘创建aaa/bbb/ccc的文件夹，在此文件夹下创建1.txt【C:/aaa/bbb/ccc/1.txt】 如果该文件存在，删除1.txt 如果该文件不存在，创建1.txt*/import java.io.File;import java.io.IOException;public class FileTest01 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\aaa\\\\bbb\\\\ccc\\\\1.txt&quot;); if (file.exists())&#123; file.delete(); &#125;else&#123; //创建文件夹 file.getParentFile().mkdirs(); //创建 文件 file.createNewFile(); &#125; &#125;&#125; 例21234567891011121314151617/*使用File对象 listFiles() 方法自定义类 implements FilenameFilterC:\\Program Files\\Java\\jdk1.8.0_321\\bin目录下，所有的 .exe结尾的文件打印出来。*/import java.io.File;import java.io.FilenameFilter;import java.io.IOException;import java.util.stream.Stream;public class FileTest02 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_361\\\\bin&quot;); String[] ay = file.list((dir, name) -&gt; name.endsWith(&quot;.exe&quot;)); Stream.of(ay).forEach(System.out::println); &#125;&#125; 2. 节点流2.1 字节流 2.2 节点流练习例312345678910111213141516171819202122232425/*使用FileOutputStream 向1.txt文件写入： A~Z 字符在 文件 结尾：a~z字符*/import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class FileOutputStreamTest03 &#123; public static void main(String[] args) throws IOException &#123; //输出流 自动创建文件 OutputStream os = new FileOutputStream(&quot;1.txt&quot;,true) ; //写 byte 比如：A for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125; /*for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125;*/ //建议： 可选 //os.flush(); os.close(); &#125;&#125; 例412345678910111213141516171819202122232425262728293031/*使用FileInputStream IDEA具体的JAVA文件 比如： Test1.java打印该Java文件中所有的内容*/import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class FileInputStreamTest04 &#123; public static void main(String[] args) throws IOException &#123; //输入流 注意：目标数据源 一定存在的 InputStream is = new FileInputStream(&quot;Test1.java&quot;) ; //读 /*while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; System.out.print((char)data); &#125;*/ int data = 0 ; while((data = is.read())!=-1)&#123; System.out.print((char)data); &#125; is.close(); &#125;&#125; 2.3 字符流 2.4 节点流 输入流 输出流 例51234567891011121314151617181920212223/*使用流 实现把图片从C盘拷贝D盘。*/import java.io.*;public class PicCopyTest05 &#123; public static void main(String[] args) throws IOException &#123; //1.输入流 怼到 目标数据源 InputStream is = new FileInputStream(&quot;D:\\\\Java180_2\\\\doc\\\\day01-html基础\\\\res\\\\mm.jpg&quot;) ; //2.输出流 项目下 OutputStream os = new FileOutputStream(&quot;meimei.jpg&quot;) ; //3. 读 while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; //4.写 os.write(data); &#125; System.out.println(&quot;====图片拷贝结束=========&quot;); &#125;&#125; 3. 处理流3.1 流嵌套 3.2 处理流 3.3 调包侠https://commons.apache.org/proper/commons-io/description.html 4. 对象流 例61234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用对象流 实现对对象实现读写功能*///写入import java.io.*;public class ObjectOutputStreamTest11 &#123; public static void main(String[] args) throws IOException &#123; //1.对象 创建商品对象 【A.瞬时状态 -- JVM 内存】 Goods goods = new Goods(&quot;G1001&quot;, &quot;苹果&quot;, 4.5D); //2. 写入 4.txt 文件 节点文件流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;4.txt&quot;)) ; /*OutputStream os = new FileOutputStream(&quot;4.txt&quot;) ; ObjectOutputStream oos = new ObjectOutputStream(os) ;*/ //【B.持久状态 -- 文件系统】 //goods.setName(&quot;香蕉&quot;); //对象流 写入 oos.writeObject(goods); oos.flush(); oos.close(); //【C.脱管状态 -- 脱离管理】 //goods.setName(&quot;菠萝&quot;); &#125;&#125;//读取import java.io.*;public class ObjectInputStreamTest12 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.读取 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;4.txt&quot;)) ; Object o = ois.readObject(); ois.close(); System.out.println(o); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-集合","slug":"Java-集合","date":"2023-06-29T14:07:43.000Z","updated":"2023-07-29T14:15:39.712Z","comments":true,"path":"2023/06/29/Java-集合/","link":"","permalink":"http://example.com/2023/06/29/Java-%E9%9B%86%E5%90%88/","excerpt":"","text":"1. Map集合框架类图 HashMap常用方法键值对（“key &#x3D; value”），顾名思义，每一个键会对应一个值。 APIAPI 是用于构建应用程序软件的一组子程序定义，协议和工具。一般来说，这是一套明确定义的各种软件组件之间的通信方法。 例1：1234567891011121314151617181920212223242526272829/*1.遍历集合，并将序号与对应人名打印。2.向该map插入一个编码为5姓名为李晓红3.移除该map中的编号为1的信息4.将map集合中编号为2的姓名信息修改为&quot;周琳&quot;*/import java.util.HashMap;import java.util.Map;public class Ex01 &#123; public static void main(String[] args) &#123; Map map =new HashMap();//多态 map.put(1,&quot;张三丰&quot;); map.put(2,&quot;周芷若&quot;); map.put(3,&quot;汪峰&quot;); map.put(4,&quot;灭绝师太&quot;); //1.循环遍历 map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); //2.插入 map.put(5,&quot;李晓红&quot;); //3.移除 map.remove(1); //4.修改 //map.put(2,&quot;周琳&quot;); map.replace(2,&quot;周琳&quot;); System.out.println(&quot;==============================&quot;); map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); &#125;&#125; java8 参考循环输出： 123456Map map = new HashMap() ;map.put(1,&quot;张三1&quot;) ;map.put(2,&quot;张三2&quot;) ;map.put(3,&quot;张三3&quot;) ;// java lambda表达式 类似 ES6 的箭头函数 【可推导即可省略】map.forEach((k,v)-&gt; System.out.println(&quot;序号:&quot;+k+&quot;,姓名:&quot;+v)); 例2：1234567891011121314151617181920212223242526/*有2个数组，第一个省份数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，第二个省会数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为key，第二个数组元素作为value存储到Map集合中。如&#123;黑龙江省=哈尔滨, 浙江省=杭州, …&#125;。*/import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class Ex02 &#123; public static void main(String[] args) &#123; String[] proAy = &#123;&quot;黑龙江省&quot;,&quot;浙江省&quot;,&quot;江西省&quot;,&quot;广东省&quot;,&quot;福建省&quot;&#125; ; String[] cityAy = &#123;&quot;哈尔滨&quot;,&quot;杭州&quot;,&quot;南昌&quot;,&quot;广州&quot;,&quot;福州&quot;&#125; ; Map map = new LinkedHashMap(); // 把 数组中的元素 存放在 map的 条目中 for (int i=0;i&lt;proAy.length;i++)&#123; map.put(proAy[i],cityAy[i]); &#125; //打印map 无需循环 &#123;key=value,key=value&#125; System.out.println(map); &#125;&#125; 例3：1234567891011/*定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。 List list = new ArrayList() ;例如：集合中有”abc”、”bcd”两个元素， list.add(“abc”) ; list.add(“bcd”) ;程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。 Map map = ... String 类 1. length() 字母个数 2. charAt() 根据索引 获得 字母*/ Hashtable1null值问题? 对比： 2. Iterator基本使用 例41234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用ArrayList存储多个学生信息1. 删除年龄&gt;18岁的学生2. 使用Iterator进行遍历 */import java.util.ArrayList;import java.util.Iterator;import java.util.function.Predicate;/** * 使用ArrayList存储多个学生信息 * 1. 删除年龄&gt;18岁的学生 * 2. 使用Iterator进行遍历 */public class Ex04 &#123; public static void main(String[] args) &#123; ArrayList&lt;Stu&gt; stuList = new ArrayList(); stuList.add(new Stu(19)) ; stuList.add(new Stu(39)) ; stuList.add(new Stu(14)) ; stuList.add(new Stu(16)) ; stuList.add(new Stu(26)) ; stuList.add(new Stu(12)) ; //推荐 java8的语法 removeIf(e-&gt;e.getAge()&gt;18) forEach(System.out::println) //stuList.removeIf( o -&gt; ((Stu)o).getAge()&gt;18 ) ; //stuList.removeIf( o -&gt; o.getAge()&gt;18 ) ; //stuList.forEach(System.out::println); //Iterator 判断有没有下一个元素 hasNext() 取出下一个元素 next() 删除当前元素 remove() Iterator&lt;Stu&gt; iterator = stuList.iterator(); while (iterator.hasNext()) &#123; //腐烂味道代码 坏味道代码 Stu stu = iterator.next(); if (stu.getAge()&gt;18)&#123; iterator.remove(); &#125; &#125; System.out.println(stuList); &#125;&#125; 参考java8 List 删除元素： 12345678List list = new ArrayList() ;list.add(new Stu(1,&quot;aaa&quot;,19)) ;list.add(new Stu(2,&quot;bbb&quot;,16)) ;list.add(new Stu(3,&quot;ccc&quot;,14)) ;//如果满足条件 进行删除list.removeIf(ele-&gt;((Stu)ele).getAge()&gt;18) ;//循环输出list.forEach(System.out::println); 3. 泛型为什么 怎么用 4. Set4.1 HashSet 例512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.HashSet;import java.util.Random;import java.util.Set;/** * 双色球规则： * 双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。 * 红色球号码从1—33中选择； * 蓝色球号码从1—16中选择； * 请随机生成一注双色球号码。 * （要求同色号码不重复） */public class Ex05 &#123; public static void main(String[] args) &#123; Random random = new Random(); // 蓝色球号码 int blueBall = random.nextInt(16)+1 ; HashSet&lt;Ball&gt; ballSet = new LinkedHashSet&lt;&gt;() ; // 一个 蓝色球 ballSet.add(new Ball(&quot;蓝球&quot;,blueBall)) ; while (ballSet.size() != 7) &#123; //红色球号码 int redBall = random.nextInt(33)+1 ; ballSet.add(new Ball(&quot;红球&quot;,redBall)) ; &#125; System.out.println(ballSet); &#125;&#125;class Ball&#123; private String color ; private Integer num ; public Ball(String color, Integer num) &#123; this.color = color; this.num = num; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Ball ball = (Ball) o; return Objects.equals(color, ball.color) &amp;&amp; Objects.equals(num, ball.num); &#125; @Override public int hashCode() &#123; return Objects.hash(color, num); &#125; @Override public String toString() &#123; return &quot;Ball&#123;&quot; + &quot;color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &quot;, num=&quot; + num + &#x27;&#125;&#x27;; &#125;&#125; 5. Map练习5.1 Map练习例61234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162一、利用Map，完成下面的功能：/*从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。如果该年没有举办世界杯，则输出：没有举办世界杯。*/import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Ex06 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //map.put(2023,null); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入年份:&quot;); //怼死 死去活来法 int year = scanner.nextInt(); String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg); scanner.close(); /*String team = map.get(year); if (team!=null)&#123; System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /*if (map.containsKey(year)) &#123; String team = map.get(year); System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /* String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg);*/ &#125;&#125; 例712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Scanner;/** * 二、在原有世界杯Map 的基础上， * 增加如下功能： * 读入一支球队的名字，输出该球队夺冠的年份列表。 * 例如， * 读入“巴西”，应当输出 1958 1962 1970 1994 2002 * 读入“荷兰”，应当输出 没有获得过世界杯 */public class Ex07 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //逆向思维 Map&lt;String, StringBuilder&gt; teamMap = new HashMap&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; //当前 队伍 map集合中 是否包含当前 队伍 if (teamMap.containsKey(name)) &#123; // 字符串 缓存中 添加新的年份 StringBuilder sb = teamMap.get(name); sb.append(year).append(&quot;\\t&quot;) ; &#125;else &#123; //如果不包含 直接存放当前年份 teamMap.put(name, new StringBuilder(year + &quot;\\t&quot;)); &#125; &#125;); // System.out.println(teamMap); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一支球队的名字:&quot;); //怼死 死去活来法 String year = scanner.next(); String msg = teamMap.getOrDefault(year, new StringBuilder(&quot;没有获得过世界杯&quot;)).toString(); System.out.println(msg); &#125;&#125; 123456789101112131415//另一种方法 String inputTeamName = scanner.next(); AtomicBoolean isPrint = new AtomicBoolean(true); map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; System.out.println(year); //System.exit(-1); isPrint.set(false); &#125; &#125;); if (isPrint.get()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; 123456789101112131415161718//第三种方法 String inputTeamName = scanner.next(); //存放 获得世界杯的年份集合 List&lt;Integer&gt; yearList = new ArrayList&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; yearList.add(year) ; &#125; &#125;); //集合为空 条件没有满足 if (yearList.isEmpty()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; yearList.forEach(System.out::println); 5.2 Map.Entry 5.3 Map综合案例1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * * 将以上对应关系的数据存储到map集合中，key：表示站编号，value：表示站名，并遍历打印(可以不按顺序打印)： * 例如： * 第10站: 森林公园南门 * 第6站: 育新 * 第12站: 奥体中心 * 第13站: 北土城 */public class EX &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); &#125;&#125; 例81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * *计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； */public class Ex08 &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); //站之间的数量 int money = caclMoney(13) ; System.out.println(&quot;共:&quot; + money); &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; Map&lt;Integer,Integer&gt; moneyMap = new HashMap&lt;&gt;() ; moneyMap.put(0,3) ; moneyMap.put(1,3) ; moneyMap.put(2,3) ; moneyMap.put(3,3) ; moneyMap.put(4,4) ; moneyMap.put(5,4) ; // .... moneyMap.put(0,3) ; moneyMap.put(0,3) ; return count ; /*if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ;*/ &#125;&#125; 例9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*计算地铁票价规则： 总行程 3站内（包含3站）收费3元， 3站以上但不超过5站（包含5站）的收费4元， 5站以上的，在4元的基础上，每多1站增加2元， 10元封顶；*/import java.util.ArrayList;import java.util.HashMap;import java.util.Map;public class Test09 &#123; public static void main(String[] args) &#123; ArrayList&lt;Num&gt; numList = new ArrayList(); Map map = new HashMap(); map.put(1,&quot;朱辛庄&quot;); map.put(2,&quot;育知路&quot;); map.put(3,&quot;平西府&quot;); map.put(4,&quot;回龙观东大街&quot;); map.put(5,&quot;霍营&quot;); map.put(6,&quot;育新&quot;); map.put(7,&quot;西小口&quot;); map.put(8,&quot;永泰庄&quot;); map.put(9,&quot;林萃桥&quot;); map.put(10,&quot;森林公园南门&quot;); map.put(11,&quot;奥林匹克公园&quot;); map.put(12,&quot;奥体中心&quot;); map.put(13,&quot;北土城&quot;); for (Object j : map.keySet())&#123; System.out.println(&quot;第&quot; +j +&quot;站: &quot; +map.get(j)); &#125; int i=1; numList.add(new Num(1,3)) ; numList.add(new Num(2,3)) ; numList.add(new Num(3,3)) ; numList.add(new Num(4,4)) ; numList.add(new Num(5,4)) ; numList.add(new Num(5+i,4+2*i)) ; /*numList.forEach((k,v)-&gt;&#123; if(k.equals()&lt;=3)&#123; System.out.println(k + &quot; &quot;); &#125; &#125;);*/ &#125;&#125;class Num&#123; int number ; int money; public int getMoney() &#123; return money; &#125; public int getNumber() &#123; return number; &#125; public Num(int number,int money) &#123; this.number = number; this.money = money; &#125; @Override public String toString() &#123; return &quot;homework.Num&#123;&quot; + &quot;number=&quot; + number + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 例1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * 打印格式（需要对键盘录入的上车站和到达站进行判断，如果没有该站，提示重新输入，直到站名存在为止）： 注意：每站需要2分钟 请输入上车站： 朱辛庄 请输入到达站： 西小口 从朱辛庄到西小口共经过6站收费6元，大约需要 12分钟； */public class Ex09 &#123; private static String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ; private static Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; public static void main(String[] args) &#123;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); String beginName = &quot;林萃桥&quot; ; String endName = &quot;平西府&quot;; int count = caclCount(beginName, endName); int time = count*2 ; //站之间的数量 int money = caclMoney(count) ; System.out.println(&quot;从&quot;+beginName+&quot;到&quot;+endName+&quot;共经过&quot;+count+&quot;站收费&quot;+money+&quot;元，大约需要 &quot;+time+&quot;分钟&quot;); &#125; /** * 根据 两站 站名 计算 之间 站之间的数量 * @param beginName * @param endName * @return */ private static int caclCount(String beginName,String endName)&#123; //map的 key站名 value 站序号 反转 Map&lt;String,Integer&gt; name2IndxMap = new HashMap&lt;&gt;() ; //站序号 站名 map.forEach((idx,name)-&gt; name2IndxMap.put(name,idx)); Integer beginIdx = name2IndxMap.get(beginName); Integer endIdx = name2IndxMap.get(endName); return Math.abs(beginIdx-endIdx) ; &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ; &#125;&#125; 6.Set扩展6.1 TreeSet 6.2 例11123456789101112131415161718192021222324252627/*学生类 姓名 分数 double 存放 TreeSet中 实现 根据 分数 从大到小 内部排序Comparable 外部排序 ComparatorSet&lt;Stu&gt; set = new TreeSet&lt;&gt;() ;set.add(new Stu(“aa”,98.5)) ;set.add(new Stu(“bb”,88.5)) ;*/package set;import java.util.*;public class Ex11 &#123; public static void main(String[] args) &#123; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; (int) (c1.getScore()-c2.getScore())) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; c1.getScore().compareTo(c2.getScore())) ;// Set&lt;Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparing(Customer::getScore)) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(set.Customer::getScore)) ; Set&lt;Customer&gt; set = new TreeSet&lt;&gt;() ; set.add(new Customer(&quot;小丽&quot;,500D)) ; set.add(new Customer(&quot;小红&quot;,400.8)) ; set.add(new Customer(&quot;小夏&quot;,400.3)) ; set.add(new Customer(&quot;小花&quot;,700D)) ; set.forEach(System.out::println); &#125;&#125; java8 外部排序写法： 1Set&lt;Stu&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(Stu::getAge)) ; 7. Collections7.1 辅助类 7.2 例1212345678910111213141516171819202122232425262728/* 1. List&lt;Stu&gt; Collections.sort(stuList) Comparable Collections.sort(stuList,...) Comparator 分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序， 如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。*/package collections;import set.Customer;import java.util.Arrays;import java.util.Collections;import java.util.List;public class Ex12 &#123; public static void main(String[] args) &#123; //集合中 存放 Customer List&lt;Customer&gt; customerList = Arrays.asList(new Customer(&quot;aaa&quot;,100D),new Customer(&quot;bbb&quot;,80.5D),new Customer(&quot;ccc&quot;,90D)) ; //jdk1.8 新特性 不使用辅助类 Collections //customerList.sort((c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); //使用 辅助类 Collections //Collections.sort(customerList); Collections.sort(customerList,(c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); customerList.forEach(System.out::println); &#125;&#125; 8. Map扩展8.1 LinkedHashSet 8.2 LinkedHashMap 8.3 ConcurrentHashMap 8.4 Properties 9.泛型扩展9.1 什么是泛型 9.2 泛型好处 9.3 使用前后对比 9.4 类型参数 9.5 方法参数 9.6 泛型不是协变的 9.7 类型通配符 9.8 泛型局限性","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java开发利器--idea安装过程详解","slug":"Java开发利器-idea安装过程详解","date":"2023-06-29T13:46:51.000Z","updated":"2023-07-03T05:31:41.850Z","comments":true,"path":"2023/06/29/Java开发利器-idea安装过程详解/","link":"","permalink":"http://example.com/2023/06/29/Java%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-idea%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"0. IDEA0.1 安装 0.2 配置破解11. 打开 readme.txt 安装步骤进行破解 JDK 字体 编码 0.3 运行创建项目 创建Java类 编写&#x2F;运行源代码 0.4 debug 0.5 卸载 删除安装目录：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"ES6及之后新特性一览","slug":"ES6及之后新特性一览","date":"2023-06-25T04:40:11.000Z","updated":"2023-07-01T08:40:14.329Z","comments":true,"path":"2023/06/25/ES6及之后新特性一览/","link":"","permalink":"http://example.com/2023/06/25/ES6%E5%8F%8A%E4%B9%8B%E5%90%8E%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/","excerpt":"","text":"let声明变量let 声明变量1.let 不允许重复声明变量 var 可以重复声明2.let 不支持变量的声明提升，var可以3.let声明的变量会被所有代码块（{}内的范围）限制作用范围 var只会受到函数影响4.let 声明的变量不和顶层变量挂钩 const 声明常量const 声明常量1.const 不可以重复声明2.不支持声明提升3.作用范围受{}影响4.不和最上层对象window挂钩const num &#x3D; 10;const num &#x3D; 20;&#x2F;&#x2F;Cannot redeclare block-scoped variable ‘num’if(true){ const a &#x3D; 20;}console.log(a); let和const区别1.let声明的变量可以被修改，const声明的是常量 不可以改变2.let声明时可以不赋值，const声明时必须赋值 变量的解构赋值解构赋值；就是快速的从对象或者数组中取出成员的一个语法方式 解构对象12345678const obj = &#123; name:&quot;zs&quot;, age:18, genders:&quot;男&quot;&#125;let name = obj.name;let age = obj.age;let genders = obj.genders; 123456789101112131415const obj2 = &#123; name:&quot;ls&quot;, age:18, genders:&quot;女&quot;&#125;//解构对象//前面的必须是&#123;&#125;表示要从obj2这个对象中获取对象成员//name age genders 都是obj2的现有成员//obj2必须是对象let&#123;name,age,genders&#125; = obj2;console.log(name,age,genders);let&#123;name:a,age:b,genders:c&#125; = obj2;console.log(a,b,c);let&#123;max,min,ceil,floor,random&#125;=Math;console.log(max(10,20,30)); 解构数组12345678//使用解构赋值的方式从数组中提取成员const arr2 = [&quot;一&quot;,&quot;二&quot;,&quot;三&quot;];//解构数组//a b c 分别对应这个数组中的索引下标0 1 2//arr2 必须是数组//如果解构失败，返回结果就是undefinedlet [a,b,c,d] = arr2;console.log(a,b,c,d); 模板字符串ES5中 表示字符串的时候使用’’或者””ES6中 还有一种可以表示字符串的方法 就是&#96;&#96;ES5 字符串 需要同行书写，换行后需要拼接字符串 12const str2 = &#x27;hello&#x27; +&#x27;world&#x27; ES6 可以直接换行使用 12const str3 = `hello world` &#96;&#96;的拼接方式与””不同 12console.log(&quot;我要&quot;+a+&quot;块钱&quot;)console.log(`我要$&#123;a&#125;块钱`) 字符串与数值拓展字符串12345678910111213let &#123;log&#125; = console;let str = &quot;Tom&quot;;//判断字符串中是否存在指定字符 返回true或者falselet res = str.includes(&quot;opm&quot;);//判断字符串中以指定字符开头 返回true或者falseres = str.startsWith(&quot;p&quot;)//判断字符串中以指定字符结尾 返回true或者falseres = str.endsWith(&quot;m&quot;)//repeat() 将字符串重复N次，返回一个新的字符串res = str.repeat(3)//TomTomTomres = str.repeat(2.5)//TomTomres = str.repeat(0)//&quot;&quot;log(res); 数值12345678910111213141516171819202122232425262728let&#123;log&#125; = console;//Number.isFinite() 判断被传入的内容是否为有限数值let res = Number.isFinite(100);//trueres = Number.isFinite(100/0);//falseres = Number.isFinite(Infinity);//falseres = Number.isFinite(NaN);//falseres = Number.isFinite(&quot;100&quot;)//false//Number.isInteger() 判断被传入的内容是否为整数res = Number.isInteger(100);//trueres = Number.isInteger(100.0);//trueres = Number.isInteger(100.1);//falseres = Number.isInteger(&quot;Tom&quot;);//falseres = Number.isInteger(&quot;100&quot;)//false//Math.trunc() 将括号内的参数转化为数字再去掉小数点res = Math.trunc(1.2);//1res = Math.trunc(1.8);//1res = Math.trunc(-1.8);//-1res = Math.trunc(&quot;Tom&quot;);//NaNres = Math.trunc(&quot;10.2&quot;);//10//Math.sign() 判断括号内的数是正数负数还是0res = Math.sign(200);//1res = Math.sign(-200);//-1res = Math.sign(0);//0res = Math.sign(-0);//-0res = Math.sign(&quot;asld&quot;);//NaN 数组拓展12345678910111213//...扩展运算符: let arr = [1,2,3]; let arr2 = [4,5,6]; let res =[...arr,...arr2]; console.log(res);//1，2，3，4，5，6function test()&#123; //arguments 是函数参数的集合 是个伪数组 console.log(arguments); //Array.from() 将 伪数组 转换为 真实数组 res = Array.from(arguments); console.log(res);&#125;test(1,2,3) document.querySelectorAll() 通过选择器获取所有相关元素 返回的是NodeList 伪数组document.querySelector() 通过选择器获取首个相关元素 直接返回元素对象find() 主要用于查找一个符合条件的数组元素findIndex() 主要用于查找一个符合条件的数组元素的下标它的参数是一个回调函数 在回调函数中可以制定寻找元素的条件当条件成立为true时间。返回该元素，如果没有符合的条件，返回undefined 123456let arr3 = [11,22,33,44,55]res = arr3.find(function(item)&#123;//item 表示数组内的每一个成员 return item&gt;20; console.log(item);&#125;)console.log(lis); fill() 使用括号内的参数，直接在数组内填充数据（替换和添加）第一个参数 是替换的新value值第二个参数 是替换的起始坐标第三个参数 是替换的结束坐标 123let arr5 = [1,&quot;纯爱&quot;,&quot;纯爱&quot;];arr5.fill(&quot;牛头人&quot;,1,2);console.log(arr5); 对象拓展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; let name = &quot;张三&quot; let obj = &#123; name:name, fn:function()&#123;&#125; &#125; console.log(obj) //如果对象的属性和value的变量相同，就可以只写一个属性名 let obj2 = &#123; name, //name:name getMessage()&#123;&#125;, getList()&#123;&#125; &#125; console.log(obj2) let msg = &quot;class&quot;; //对象的属性名可以使用表达式 需要用到符号 [表达式] let obj3 = &#123; [msg+&quot;one&quot;]:&quot;Tom&quot;, [`$&#123;msg&#125;xxx`]()&#123;&#125; &#125; console.log(obj3) let obj4 = &#123; name:&quot;jerry&quot;, age:14 &#125; //对象内可以使用拓展运算符 let obj5 = &#123; ...obj4//相当于通过for in遍历，属于深拷贝 &#125; console.log(obj5) //Object.assign() 将需要操作的元素复制到目标对象中 //第一个参数 目标参数 //第二个参数及后面所有额参数都是 需要操作的对象 //如果复制的数据是 值类型数据 实现的是深拷贝 //如果复制的数据是 引用类型数据 使用的任然是该数据的指针(引用地址)，实现的是浅拷贝(重点) let obj6 = &#123;&#125;; let obj7 = &#123; name:&quot;ggBANG&quot;,//值类型深拷贝 friends:[&quot;小A&quot;]//引用类型浅拷贝 &#125; Object.assign(obj6,obj7); obj6.age = 20; obj6.friends = &quot;小王&quot;; console.log(obj6) console.log(obj7)&lt;/script&gt; 函数拓展1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; function fn()&#123;&#125; let fn2 = function()&#123;&#125; // =&gt; const fn3 = (a,b) =&gt;&#123; console.log(a+b) &#125; fn3(1,2) // xxx.onclick = ()=&gt;&#123;&#125; // setInterval(()=&gt;&#123;&#125;) //传入一个参数a, 并且a为函数的返回值 //只有一个参数的情况下 小括号可以省略 //函数内 只有一行需要执行的代码的时候 花括号可以省略 const fn4 = a =&gt;a; fn4(10) //箭头函数制定参数默认值 const fn5 = (a=20,b=50) =&gt;&#123; console.log(a,b); &#125; fn5() let div = document.querySelector(&#x27;div&#x27;); //函数区别 //1.箭头函数的this指向 函数的声明处 //2.箭头函数中无法使用arguments //3.箭头函数不可以作为构造函数 使用 div.onclick= () =&gt;&#123; console.log(this); &#125; // const fn6 = () =&gt;&#123; // console.log(arguments); // &#125; // fn6(1,2,3) const Tom = () =&gt;&#123; console.log(&quot;123&quot;); &#125; new Tom() &lt;/script&gt; SymbolSymbol：表示独一无二的值 1234567891011121314151617var names = Symbol();console.log(names);//使用symbol 当作对象名var obj = &#123; [names]:&quot;Tom&quot;&#125;console.log(obj);//Symbol 函数可以接收一个字符串作为字符串，表示堆Symbol实例的描述//主要是为了在控制台上显示，比较容易区分const ages = Symbol(&quot;age&quot;)console.log(ages)var obj2 = &#123; [ages]:18, [names]:&quot;Tom&quot;&#125;//获取带有Symbol格式的属性console.log(obj2[ages]);//不要加.了 Reflect 是一个内置对象的反射机制，用来提供方法 拦截js的操作Reflect.ownKeys(obj)返回一个数组forEach（）实现遍历的方法 123Reflect.ownKeys(obj).forEach(function(item)&#123; console.log(item);&#125;) Iterator接口Iterator接口的作用为各种数据结构，提供一个统一的，简单的访问接口使数组格式的成员能够按照某种次序排列es6创造了一种新的遍历命令 for of 循环， Iterator接口主要供for…of循环Iterator接口遍历的过程创建一个指针对象，指向当前数据结构的起始位置,第一次调用指针对象的next方法，可以将指针指向该数据结构的第一个成员第二次调用指针对象的next方法，指针就指向该数据结构的第二个成员不断调用指针对象的next方法，直到他指向数据结构的结束位置 1234let item = arr[Symbol.iterator]();console.log(item);console.log(item.next());console.log(item.next()); ES6规定，默认的Iterator接口部署在数据结构[Symbol.iterator]属性或者说 只要有 数据结构 具备Symbol.iterator属性 就认为是可遍历的Symbol.iterator属性本身就是一个函数，就是当前数据结构默认的遍历器生成函数执行这个函数就会返回一个遍历器原生默认具备 iterator 接口的数据结构如下:Array Set Map String arguments NodeList Set数据结构Set类似于数组，成员的值是唯一的，没有重复的值Set.size() 返回Set实例的成员总数Set.add() 添加Set成员Set.delete()删除Set成员Set.has() 查看括号内的成员是否在Set中存在 返回布尔类型 1234567let s1 = new Set([1,2,3,4]);console.log(s1);let s2 = new Set();s2.add(&#x27;hello&#x27;);s2.add(&#x27;world&#x27;);s2.delete(&quot;world&quot;);s2.clear(); Set遍历Set.keys() 返回键名的遍历器Set.values() 返回键值的遍历器Set.entries() 返回键值对的遍历器 123456789let result =s2.keys();console.log(result); result =s2.values();console.log(result); result =s2.entries(); console.log(result); s1.forEach(function(item)&#123; console.log(item);&#125;) 数组去重方法一： 123456let arr = [19,20,19,19,20,21,30,90];let s1 = new Set(arr);console.log(s1);//输出的是一个对象//需要转换为数组的话s1 = Array.from(s1);//使用Array.from() 转换成数组console.log(s1); 方法二： 12let s2 = [...new Set(arr)];//...扩展运算符console.log(s2); Map12345678910111213141516171819202122232425&lt;script&gt; //Map 类型对象 键值对的集合，但是Map中的key不限于字符串，可以是各种类型的值 let M1 = new Map(); M1.set(&#x27;name&#x27;,&#x27;tom&#x27;); M1.set(&#123;a:1&#125;,&#x27;tom&#x27;); M1.set(&#x27;big&#x27;,&#x27;small&#x27;); //操作方法 //Map.set(key.value); 在Map对象中添加key和对应的value //Map.get(key); 在Map对象中获取key对象的value //Map.delete(key); 删除指定的key //Map.has(key); 查看key是否在map中存在 返回布尔类型 //Map.clear(); 清空 console.log(M1); console.log(M1.get(&quot;name&quot;)); M1.delete(&quot;name&quot;); console.log(M1); let res = M1.has(&#x27;big&#x27;); console.log(res); //Map遍历方法 与 Set相同 res = M1.keys() res = M1.values() res = M1.entries() console.log(M1); console.log(res);&lt;/script&gt; ProxyObject.defineProperty() 拦截并处理数据第一个参数 需要拦截处理的对象第二个对象 对象内的属性第三个对象 {}配置项，格式是个对象 1234567891011121314151617181920let obj = &#123; data: 111, name:&quot;zs&quot;, age:20 &#125;let box = document.getElementById(&quot;box&quot;)Object.defineProperty(obj, &quot;data&quot;, &#123; get() &#123;// 当使用对象内的指定属性时调用 console.log(&quot;get函数调用&quot;); &#125;, set(value)&#123; console.log(&quot;set函数接收到了:&quot;,value); if(value&gt;=1000)&#123; box.innerHTML =`数据较大,请重新输入`; &#125; else&#123; box.innerHTML = `数据合理放心使用`; &#125; &#125;&#125;) Proxy代理: 123456789101112131415let proxy = new Proxy(obj,&#123; get(target,key)&#123; //target 表示 需要代理的对象 //key 表示的是访问的属性 console.log(target,key); return target[key]; &#125;, set(target,key,value)&#123; //target 表示 需要代理的对象 //key 表示的是设置的属性 //value 设置的新值 console.log(&quot;set:&quot;,target,key,value); target[key] = value//确认操作 &#125;&#125;) ReflectReflect 主要用来获取目标对象的行为,它与Object类似，但更容易读 Promise对象回调地狱当一个回调函数嵌套另一个回调函数的时候就会出现嵌套结构当嵌套结构多的时候，就会出现回调地狱的情况回调地狱 其实就是由多个回调函数互相嵌套导致的，代码维护性非常差 同步异步异步 当一行代码还没有执行结束，就可以去执行另一行代码的顺序 叫做异步同步 当代码逐行执行过程就是同步的过程异步的操作：定时器 callbackpromise 是异步编程的一种统一的解决方案，比传统回调函数，更合理更强大 1234567891011121314151617const api = new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; if(true)&#123; resolve()//resolve 表示成功的回调函数 &#125; else&#123; reject()//reject 表示失败的回调函数 &#125; &#125;,1000)&#125;)api.then(()=&gt;&#123; console.log(&quot;yyyyy&quot;);//.then() 成功&#125;).catch(()=&gt;&#123; console.log(&quot;nnnnn&quot;);//.catch() 失败&#125;) Promise 对象通过自身的状态，来控制异步操作。Promise实例具有三种状态异步操作未完成(pending)异步操作完成(fulfilled)异步操作失败(rejected) 链式调用为什么promise可以实现链式调用因为当promise方法执行结束后仍然会返回一个promise对象 123456789101112131415const a = promise.then((res) =&gt; &#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 2000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 3000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 5000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;);&#125;).catch((err)=&gt;&#123; console.log(&quot;失败啦&quot;,err);&#125;)console.log(a) all方法Promise.all() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态都是fulfilled pAll的状态才是 fulfilled此时P1,P2,P3的返回值组成一个数组，传递给pAll中 race方法Promise.race() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态只要有一个fulfilled pRace的状态才是 fulfilled此时返回值是首次达到fulfilled状态的值除非全部reject否则不会触发.catch Generator函数ES6 提供的一种异步编程解决方案 123456789101112function *gen()&#123; console.log(1); yield;//yield 表示暂停执行标记，通过next方法恢复执行 console.log(2); yield; console.log(3);&#125;let g = gen()//next() 驱动下一步的执行g.next()g.next()g.next()console.log(g); Class语法与继承123456789101112131415class Person&#123;//创建一个Person类 也叫做 构造函数 //类中的属性需要使用constructor 构造器创建 constructor(name,age,height)&#123; this.name = name; this.age = age; this.height = height; &#125; // 在类中创造方法 say()&#123; console.log(&quot;这是Person类&quot;); &#125;&#125;let obj = new Person(&quot;zhangsan&quot;,19,&quot;180cm&quot;);console.log(obj);obj.say() class继承 123456789101112131415161718192021222324class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(&quot;这是&quot;,this.name,this.age,&quot;岁&quot;); &#125;&#125;const one = new Person(&quot;张飞&quot;,100);one.say();class Student extends Person&#123;//extends 表示StudentPerson类中继承 constructor(name,age,height)&#123; super(name,age);//super() 表示从父类中继承的属性内容 必须写在 construtor中 this.height = height; &#125; say()&#123; super.say(); console.log(&quot;是学生&quot;) &#125;&#125;let obj = new Student(&#x27;xz&#x27;,12,&#x27;120&#x27;);console.log(obj);obj.say();","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"Javascript 基础知识","slug":"Javascript-基础知识","date":"2023-06-12T05:11:08.000Z","updated":"2023-07-01T08:40:11.753Z","comments":true,"path":"2023/06/12/Javascript-基础知识/","link":"","permalink":"http://example.com/2023/06/12/Javascript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 JavaScrip简介JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。JavaScript 很容易学习。 ECMAScript 语法标准(es)JavaScript 输出JavaScript 可以通过不同的方式来输出数据：使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 外部的 JavaScript也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。 外部 JavaScript 文件的文件扩展名是 .js。 1&lt;script src=&quot;./01.js&quot;&gt;&lt;/script&gt; 变量1var a = 20; var 申明变量名a 变量名 用来存储变量20 变量&#x3D; 赋值符号 从右向左赋值 变量命名规则：1.可以是字母或者下划线_或者$开头2.长度不可超过255个字符3.名中不能含有空格，首字头不能是数字4.严格区分大小5.不能使用关键字或保留字6.汉字可使用不推荐当使用空的变量名时，得到的结果就是未定义 undefined使用不存在的变量名时，报错，d is not defined变量的声明提升:先使用变量再创建变量 得到的结果会是 undefined 只能提升变量名，不提升变量 12console.log(e);var e = 30; 相当于 123var e;console.log(e);var e = 30; 数据类型与转换基本数据类型:number 数字string 字符串 只要有引号包裹就是字符串boolean 布尔 true&#x2F;false将数据类型转化为number类型强制类型转换:Number（） 将数据类型转换成number转换字母等非数字内容的话会显示NaN (No a Number)parseFloat() 浮点型 将数据保留小数 并且转换为数字类型转换带数字的字符串时，必须开头为数字才能识别parseInt() 整型 将数据保留整数，并转换成数字类型isNaN()：判断内容是否是 非数字 如果是非数字 返回 true 反之为 false只查看数据内容，不查看数据类型数据类型转换为字符串强制类型转换String() 将数据类型转换为字符串xxx.toString() 将数据类型转换为字符串 需要转化的变量名写在前面将数据类型转换为布尔Boolean()0为false，其他为true值类型:number 数字string 字符串boolean 布尔null 空undefined未定义symbol 独一无二的引用数据类型：object 对象function函数array 数组tpyeof(undefined)&#x3D; undefined;tpyeof(null)&#x3D; object;tpyeof(error)&#x3D; object; 算数运算符+ 加法当符号两边都是数字的时候，会自动相加求和当符号两边有字符串时，会起到拼接字符串的作用（结果时字符串类型–隐式类型转换）当符号两边有布尔类型时，true为1，false为0 参与求和计算++ 自增加1++在后面 表示后加，处于正在加1的过程，还没加上，当再次使用变量时，才算自增结束++在前面 表示先加，直接自增结束，得到就是自增+1的结果- 减法当符号两边都是数字的时候，会自动相减求差当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算– 自减1，同自增* 乘法当符号两边都是数字的时候，会自动相乘求积当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算&#x2F; 除法当符号两边都是数字的时候，会自动相除求商当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算除数如果是0 得到的是 Infinity 无穷&#x2F;无限% 除余()优先运算符 比较运算符注意：&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D; 的不同&#x3D;&#x3D; 等号(只比较值，不比较数据类型)&#x3D;&#x3D;&#x3D; 全等号（值和数据类型都相同）&gt; 大于号&gt;&#x3D; 大于等于&lt; 小于&lt;&#x3D; 小于等于!&#x3D; 不等于!&#x3D;&#x3D; 不全等于 逻辑运算符&amp;&amp; 与 符号两边的表达都为true整个表达式的结果就是true 有一方为false，整个表达式的结果就是false|| 或 有一方为true，整个表达式的结果就是true！ 非 对象与事件实例化对象：var obj&#x3D;new Object();键值对（属性：属性值）obj.name&#x3D;”zs”;&#x2F;&#x2F;键值对就是XX&#x3D;XX字面量的方式创建对象: 12345var obj2 = &#123; name:&quot;1s&quot;, age:20, height:172&#125; 日期对象var&#x3D; new Date();date.getFullYear();获取当前年份getMonth 获取当前月份getDate日期getDay星期getHours小时getMinutes分钟getSeconds当前秒getMilliseconds 当前毫秒getTime从1970.1.1至今的毫秒数Math对象Math.max 返回最大数Math.min 返回最小数Math.ceil 天花板函数，有小数部分向上取整Math.floor 地板函数 舍掉小数部分Math.round(b) 四舍五入Math.random() 随机数字0-1 取不到1事件on绑定事件的关键字 click 点击事件box.onclick&#x3D;function(){}onblur 失去焦点 if else略 switchswitch 用来监视链路，捕获数据某种情况下需要执行的代码块switch 具有数据穿透性 需要break中断余下代码的执行default 相当于else 123456789101112switch(n)&#123; case 10: XXXX; break; case 20: XXXX; break; default: XXXX; break;&#125; 第二种情况：switch(true) 12345switch(true)&#123; case n&lt;10&amp;&amp;n&gt;=0: console.log(&quot;switch范围监测&quot;) break;&#125; 三目运算符表达式？ 结果1(true):结果2(false) 1a&gt;b ? console.log(&quot;a大&quot;):console.log(&quot;b大&quot;); for循环for循环执行顺序：for 首次执行 先创造变量 再判断条件 不走增量 直接执行代码块剩下的执行次数都是 先增量再判断 最后走代码块如果 变量不满足判断条件 循环结束for(初始化变量;判断条件；增量){重复执行代码块}break： 终止循环 终止整个循环体 余下代码不执行continue： 终止循环 终止当前次数的循环，余下代码不执行 while循环与do while循环1234while(i&lt;10)&#123; console.log(i); i++;&#125; 1234do &#123; i++; console.log(i); &#125; while (i &lt; 10) while 和 do while的区别while循环是 先判断再执行do while 循环 是先执行再判断 数组和数组api123456789101112131415161718192021222324252627282930313233var arr = new Array();//实例化数组// 数组内数据的序号 我们叫做下标（索引号）arr[0]=&quot;李白&quot;;arr[1]=&quot;白居易&quot;;console.log(arr);// 字面量的方式创建数组var arr2 = [&quot;ls&quot;,&quot;zs&quot;,123,false];console.log(arr2);// 数组的使用方式 数组名[下标]console.log(arr2[2]);// 数组名.length 数组内成员的个数console.log(arr2.length);//二维数组var arr4 = [1,3,4,[1,2,3]];console.log(arr4[3][1]);//多维数组var arr5 =[&#123; name:&quot;zs&quot;, age:18, friends:[&#x27;ls&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;ls&quot;, age:20, friends:[&#x27;zs&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;wr&quot;, age:22, friends:[&#x27;ls&#x27;,&#x27;zs&#x27;]&#125;] 数组的操作方法1.数组.includes() 查看数组内是否包含指定成员，如果是就返回true,如果不包含就返回false 2.Array.isArray() 判断是否是一个数组格式 返回 true 或 false 3.数组.indexOf() 查看数组内的成员，如果存在就返回首次出现的下标，如果不存在就返回-14.数组.lastIndexOf() 查看数组内的成员，如果存在就返回最后一次出现的下标，如果不存在就返回-15.数组.join() 在数组各元素之间插入相同的字符串拼接，将数组转换成字符串6.数组.push() 在原数组末尾添加新成员，返回新数组长度，原数组被改变7.数组.unshift() 在数组开头添加新成员，返回新数组长度，原数组被改变8.数组.pop() 删除数组最后一名成员，返回被删除内容，原数组被改变9.数组.shift() 删除数组开头的成员，返回被删除内容，原数组被改变 10.数组.reverse() 反转数据11.数组.splice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组改变当括号内有两个参数的时候，表示从当前下标开始一直截取到几个，返回被截取的内容，原数组改变当括号内有三个参数的时候，第三个参数表示在截取位置添加的新内容，返回被截取的内容，原数组改变12.数组.slice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组不改变当括号内有两个参数的时候，表示从当前下标开始到第二个参数下标结束，返回被截取的内容，原数组不改变var res &#x3D;arr.includes(“奥斯”); 字符串API字符串.length 获取字符串的长度字符串.split() 字符串转换成数组，根据括号的内容进行字符分割字符串.charAt() 返回指定下标处的字符字符串.indexOf() 返回查找首次出现字符的下标，如果不存在返回-1字符串.lastIndexOf() 返回查找最后一次出现字符的下标，如果不存在返回-1字符串.substr() 截取字符串 如果有一个参数 表示从当前下标开始截取到末尾 返回截取的内容如果有两个参数，表示从当前下标开始截取几个 返回截取的内容 函数匿名函数： 自调用 通过事件绑定在一起触发具名函数： function . 函数名()函数特性：不调用，不执行函数的使用叫做调用函数具有 预加载(函数的位置在定义先后不影响执行)具名函数的调用 函数名()return 返回值（余下代码不执行）function 函数名（形式参数）{}var a &#x3D; 函数名（实际参数）；封装函数 全局变量与局部变量变量是存在作用域的 分为 全局变量和局部变量局部变量： 在函数内部用var声明的变量就是局部变量（只在函数内部生效）全局变量：在函数外部用var声明的变量就是全局变量，可以在整个JS中生效不用var声明的，变量也是全局变量（不推荐使用）闭包：闭包的形式：多个函数互相嵌套闭包的目的：将内部函数的局部变量提到全局中去使用闭包的实现方式：不断地设置return 返回值闭包的缺点：会消耗电脑内存 影响性能 DOMdocument object model 文档对象模型 定时器1234567891011// setInterval(callback) 多次执行的定时器 callback参数 表示 回调函数start.onclick = function () &#123; timer = setInterval( function () &#123; console.log(1); &#125;, 1000) &#125; stop.onclick = function () &#123;// clearInterval(定时器的名字) 清除定时器 clearInterval(timer);&#125; thisthis 表示 这个this 在函数中 代指函数的调用者this在函数外 指向的是window对象，最大的对象 12345678910111213141516var lis = document.getElementsByTagName(&quot;li&quot;)console.log(this);for (var i = 0; i &lt; lis.length; i++)&#123; //属性绑定 写在循环的内部，事件的外部 // index 一般表示为下标 lis[i].index = i; lis[i].onclick = function() &#123; //先让所有颜色都变成蓝色 再让当前的这个变成红色 //这就是排他思想 for (var j = 0; j &lt; lis.length; j++)&#123; lis[j].style.background = &quot;skyblue&quot;; &#125; this.style.background = &quot;red&quot;; console.log(this.index);//获取到下标 &#125;&#125; 轮播图参考https://swiper.com.cn/ Node节点操作1.xx.parentNode 当前节点的父节点2.xx.childNodes 当前节点的所有子节点,包含文本节点(本次返回的text为回车造成的空格) 返回nodeList 伪数组3.xx.children 当前节点的所有子元素节点 返回HTMLCollection 伪数组4.xx.firstChild 当前节点的第一个子节点,包含文本节点5.xx.firstElementChild 当前节点的第一个子元素节点6.xx.lastChild 当前节点的最后一个子节点,包含文本节点7.xx.lastElementChild 当前节点的最后一个子元素节点8.xx.previousSibling 当前节点的前一个兄弟节点,包含文本节点9.xx.previousElementSibling 当前节点的前一个兄弟元素节点10.xx.nextSibling 当前节点的前一个兄弟节点,包含文本节点11.xx.nextElementSibling 当前节点的前一个兄弟元素节点节点的操作1.document.createElement() 创建节点2.xx.innerHTML 往节点内添加或替换内容(文本或标签)2.xx.innerText 往节点内添加或替换内容(文本)4.xx.appendChild() 往父节点的末尾添加新节点5.xx.insertBefore(新节点,目标节点) 将新节点添加到目标节点之前6.xx.cloneNode() 克隆节点,true的时候,将该节点及其子节点全部复制；flase的时候只复制节点本身。7.父节点.removeChild() 删除父节点的子节点 偏移量offsetWidth 元素自身的宽度 width+border+paddingoffsetHeight 元素自身的高度 同上offsetLeft 元素自身的位置offsetTop 元素自身的位置onscroll 滚动事件scroll卷曲的距离clientWidth可视区域的宽 width paddingclientWidth可视区域的宽 height padding document.body;&#x2F;&#x2F;获取body 标签document.documentElement&#x2F;&#x2F;获取html标签 事件对象event 事件对象 通过事件触发的时候调用函数内的参数该对象内包含了事件触发时的信息事件对象的兼容写法： 1var e = event || window.event;//兼容低版本ie浏览器 pageX 光标相对于网页的水平位置（ie无）*pageY 光标相对于网页的垂直位置（ie无）*screenX 光标相对于屏幕的水平位置screenY 光标相对于屏幕的垂直位置clientX 光标相对于可视区域的水平位置*clientY 光标相对于可视区域的垂直位置（重要且相同）xx.onkeypress 键盘按键 按下并且弹起xx.keyCode 表示键盘上对应按键的编码xx.onmouseenter 鼠标进入xx.onmouseleave 鼠标离开 事件冒泡和事件句柄事件冒泡：当一个元素的事件被触发的时候,比如鼠标点击了一个元素，同样的事件就会在这个元素的所有祖先元素上被触发这个过程就叫做事件冒泡,这个事件是从原始事件一直冒泡到dom树的最上层.不支持事件冒泡的事件: focus,blur,mouseenter,mouseleave,load,resize 12//阻止事件冒泡的兼容写法e.stopPropagation ? e.stopPropagation() :e.cancelBubble = true; 事件句柄:addEventLister 添加事件句柄第一个参数 事件的名称第二个参数 callback 回调函数第三个参数 false 触发的顺序是由内到外，叫做冒泡的顺序（默认）； true 触发的顺序是由外到内，叫做捕获的顺序同一个元素可以绑定多个相同事件，不会覆盖，挨个执行 123box.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;222&quot;); &#125;,true) 缓存注意：cookie localStorage sessionStorage的区别cookie 默认浏览器关闭时消失，存在于web服务器中，存储大小为4KBlocalStorage 本地储存 永久有效，除非手动删除，存储大小为5MBsessionStorage 会话存储 关闭浏览器或窗口事就消失，存储大小为5MBcookie缓存： 123456document.cookie=&quot;username = 李白&quot;//创建cookie缓存document.cookie=&quot;age = 30; expires = Tue, 20 Jun 2023 12:00:00 GMT&quot;//设置过期事件var res =document.cookie;var n = res.indexOf(&quot;=&quot;) +1 ;res = res.substr(n);console.log(res); localStorage缓存： 123456localStorage.setItem(&quot;NAME&quot;,&quot;TOM&quot;);//创建缓存 localStorage.setItem（key,value） localStorage.setItem(&quot;AGE&quot;,&quot;18&quot;);localStorage.removeItem(&quot;AGE&quot;);//删除指定缓存 localStorage.removeItem(key)var res = localStorage.getItem(&quot;NAME&quot;);//获取缓存 localStorage.getItem(key) var age = localStorage.getItem(&quot;AGE&quot;);localStorage.clear();//清空缓存 localStorage.clear() BOMbrowser object model 浏览器对象模型 Window对象window.open(“https://www.baidu.com&quot;//在当前窗口跳转window.close();&#x2F;&#x2F;关闭窗口 locationlocation.hostname web主机域名location.pathname 当前页面的路径location.port 端口号(0-65535)location.herf 整个URLlocation.protocol web协议常见的协议:http 和 https 的区别*http 免费 相对不安全，端口号默认80https 收费 比较安全，端口号默认443 secureftpfile history两种后退功能：history.back(); history.go(-1);两种前进功能：history.go(); history.go(1); navigatornavigator 设备信息对象navigator.appCodeName 浏览器代号navigator.appName 浏览器名称navigator.appVersion 浏览器版本navigator.vender 浏览器供应商navigator.cookieEnabled 浏览器是否启用了缓存navigator.platform 硬件平台navigator.userAgent 用户代理语言navigator.language 用户代理语言 正则表达式 实例化创建正则对象 1var reg = new RegExp(); &#x2F;&#x2F;字面量方式创造正则对象reg &#x3D; &#x2F;@&#x2F;; 含有@reg &#x3D; &#x2F;\\d&#x2F; 含有数字reg &#x3D; &#x2F;\\D&#x2F; 含有非数字reg &#x3D; &#x2F;\\s&#x2F; 含有不可见字符(空格，回车等)reg &#x3D; &#x2F;\\S&#x2F; 含有可见字符reg &#x3D; &#x2F;\\w&#x2F; 含有单词字符 字母 数字reg &#x3D; &#x2F;\\W&#x2F; 含有非单词字符 简单类reg &#x3D; &#x2F;[23]&#x2F; 含有2或者3负向类reg &#x3D; &#x2F;[^23]&#x2F; 含有非2或者3范围类reg.onblur &#x3D; &#x2F;[0-9]&#x2F; 含有0-9中的任意一个组合类reg &#x3D; &#x2F;[0-9a-z]&#x2F; 含有数字或者字母中的一个边界reg &#x3D; &#x2F;^12&#x2F; 必须以12开头reg &#x3D; &#x2F;23$&#x2F; 必须以23结束reg &#x3D; &#x2F;^123$&#x2F; 必须是123&#x2F;&#x2F;量词reg&#x3D; &#x2F;^123*$&#x2F; ‘3’的重复次数&gt;&#x3D;0次reg&#x3D; &#x2F;^123+$&#x2F; ‘3’的重复次数&gt;&#x3D;1次reg&#x3D; &#x2F;^123?$&#x2F; ‘3’的重复次数只能是0或1次reg&#x3D; &#x2F;^12{4}3$&#x2F; ‘2’的重复次数4次reg&#x3D; &#x2F;^12{4,}3$&#x2F; ‘2’的重复次数&gt;&#x3D;4次reg&#x3D; &#x2F;^12{4,10}3$&#x2F; ‘2’的重复次数4到10次 正则.test(需要校验的内容) 返回布尔类型 1var res = reg.test(inp.value); 高级JS(面向对象)值类型与引导类型值类型 ：number string boolean null undef symbol引用数据类型： array function object 值类型与引用数据类型的区别值类型 ：存储在栈中，内存空间固定当数据复制的时候，可以直接复制互不影响typeof 判断数据类型引用数据类型：存储在堆中，内存空间不固定浅拷贝：当数据复制的时候，只能复制数据的引用地址深拷贝：将数据复制并在堆中重新申请一片空间进行存储深拷贝实现的两种方式： 12var obj2 = JSON.stringify(obj);//对象 =&gt; string 将对象转换成json字符串var obj2 = JSON.parse(obj2);//string =&gt; 对象 将json字符串转换成对象 通过instanceof() 判断数据是哪一种引用类型（返回true&#x2F;false） 1var res = arr instanceof(Arry); 工厂模式和构造函数面向对象编程的基本特征封装： 将客观事物封装成抽象的类继承： 子类具有父类的公有属性多态： 对象的多功能，多方法，一个方法可以有多种表现形式字面量创建对象 创建量如果比较多就比较繁琐，并且对象之间没有关系 12345678var personOne = &#123; name:&quot;zs&quot;, age:20&#125;var personTwo = &#123; name:&quot;ls&quot;, age:24&#125; 通过封装的方式创建对象，解决代码重复的问题 123456function createPerson(name,age)&#123; return&#123; name:name, age:age &#125; &#125; 工厂模式 12345678function createPerson(name,age)&#123; var obj =new Object();//准备工厂环境 obj.name = name;//将属性进行加工 obj.age = age;//将属性进行加工 return obj;//将加工好的对象进行输出&#125;personOne = createPerson(&quot;王二&quot;,10);personTwo = createPerson(&quot;zy&quot;,30); 构造函数 12345678function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;var personOne = new CreatePerson(&quot;张三丰&quot;,&quot;108&quot;)var personTwo = new CreatePerson(&quot;孙悟空&quot;,&quot;正无穷&quot;)console.log(personOne);console.log(personTwo); 构造函数需要注意的事情：1.CreatePerson 称之为 构造函数 也叫做 类，构造函数就是类2.personOne 就是 CreatePerson 的实例对象3.构造函数中的this指向的是通过new实例化出来的4.必须使用new关键字 将函数实例化5.构造函数的开头必须大写6.构造函数会自动创造出来一个 constructor(构造器)属性，这是属性就是指向CreatePerson prototype原型属性，存在于每个构造函数之中通过prototype原型创建的方法可以在构造函数生成的实例中公用，有利于提升效率prototype 的顶端 是 object 123456789 function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;CreatePerson.prototype.say = function()&#123; console.log(&quot;yyy&quot;); return 0;&#125;var one = new CreatePerson(&quot;zs&quot;,20); 对象继承12345678910111213141516171819202122232425function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.run=function()&#123; console.log(&quot;啊啊啊啊啊&quot;);&#125;Person.prototype.findWork=function()&#123; console.log(&quot;working&quot;);&#125;function Man()&#123; console.log(&quot;nnnnn&quot;);&#125;//看似赋值的过程 =&gt; 实际上实现的是浅拷贝// Man.prototype = Person.prototype; //for in 循环（用来遍历对象）for(var k in Person.prototype)&#123; console.log(k);//k是对象的属性 Man.prototype[k] = Person.prototype[k]&#125;Man.prototype.jump = function()&#123; console.log(&quot;hhhhhhhhhhh&quot;); &#125;console.log(Man.prototype);console.log(Person.prototype); 多态多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态的实现方式：覆盖指子类重新定义父类方法，基于prototype继承就是。 call和apply和bind12345678910111213141516171819 //thiswindow.color = &quot;red&quot;;document.color = &quot;green&quot;;// console.log(window);var obj = &#123; color:&quot;white&quot;&#125;function changeColor(a,b)&#123; console.log(a+&quot;和&quot;+b+&quot;喜欢&quot;+this.color)&#125;//函数.call(this需要指向的对象，参数必须使用逗号分隔)changeColor(&quot;小王&quot;,&quot;小明&quot;);changeColor.call(document,&quot;小王&quot;,&quot;小明&quot;);changeColor.call(obj,&quot;小王&quot;,&quot;小明&quot;);//函数.apply(this需要指向的对象，参数必须使用数组)changeColor.apply(document,[&quot;小王&quot;,&quot;小明&quot;]);changeColor.apply(obj,[&quot;小王&quot;,&quot;小明&quot;]);//函数名.bind(this需要指向的对象，参数可以是任意形式)() 返回的是函数需要再次调用changeColor.bind(obj,[&quot;小李&quot;],[&quot;zs&quot;])()","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"MarkDown学习(一)","slug":"MarkDown学习-一","date":"2022-06-22T13:39:30.000Z","updated":"2023-07-02T17:10:54.433Z","comments":true,"path":"2022/06/22/MarkDown学习-一/","link":"","permalink":"http://example.com/2022/06/22/MarkDown%E5%AD%A6%E4%B9%A0-%E4%B8%80/","excerpt":"","text":"MarkDOwn初识标题要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 () (例如：### My Header)。 1234567# 1级标题## 2级标题### 3级标题#### 四级标题 ##### 五级标题 ###### 六级标题 字体1*斜体文本* 斜体文本 1**加粗文本** 加粗文本 1***加粗和斜体文本*** 加粗和斜体文本 1~~删除文本~~ 删除文本 1&gt; 引用文本 引用文本 列表有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 一： First item Second item Third item Fourth item 二： 12341. First item1. Second item2. Third item3. Fourth item First item Second item Third item Fourth item 三： 12341. First item8. Second item7. Third item3. Fourth item First item Second item Third item Fourth item 无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 123456- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 复选框列表（CheckBoxList） 123- [ ] List Item 1 unchecked- [x] List Item 2 checked- [X] List Item 3 checked List Item 1 unchecked List Item 2 checked List Item 3 checked 代码12345678910111213141516#[derive(Debug)]pub enum State &#123; Start, Transient, Closed,&#125;impl From&lt;&amp;&#x27;a str&gt; for State &#123; fn from(s: &amp;&#x27;a str) -&gt; Self &#123; match s &#123; &quot;start&quot; =&gt; State::Start, &quot;closed&quot; =&gt; State::Closed, _ =&gt; unreachable!(), &#125; &#125;&#125; 123456789101112[ &#123; &quot;title&quot;: &quot;apples&quot;, &quot;count&quot;: [12000, 20000], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;, &#123; &quot;title&quot;: &quot;oranges&quot;, &quot;count&quot;: [17500, null], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;] 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Gre\\&#x27;ater&#x27; return (param2 - param1 + 1 + 0b10l) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; 12345678910111213&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt; function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt; 123456789101112131415161718192021function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=&quot;$&#123;cls&#125;&quot;`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log(&#x27;undefined&#x27;); &#125; return ( &lt;div&gt; &lt;web-component&gt;&#123;block&#125;&lt;/web-component&gt; &lt;/div&gt; )&#125;export $initHighlight; 1234567891011121314#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125; 123456789101112CREATE TABLE &quot;topic&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;forum_id&quot; integer NOT NULL, &quot;subject&quot; varchar(255) NOT NULL);ALTER TABLE &quot;topic&quot;ADD CONSTRAINT forum_id FOREIGN KEY (&quot;forum_id&quot;)REFERENCES &quot;forum&quot; (&quot;id&quot;);-- Initialsinsert into &quot;topic&quot; (&quot;forum_id&quot;, &quot;subject&quot;)values (2, &#x27;D&#x27;&#x27;artagnian&#x27;); 12345678910111213#import &lt;UIKit/UIKit.h&gt;#import &quot;Dependency.h&quot;@protocol WorldDataSource@optional- (NSString*)worldName;@required- (BOOL)allowsToLive;@end@property (nonatomic, readonly) NSString *title;- (IBAction) show;@end 12345678910111213141516/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123; public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; 123456789101112131415import Foundation@objc class Person: Entity &#123; var name: String! var age: Int! init(name: String, age: Int) &#123; /* /* ... */ */ &#125; // Return a descriptive string for this person func description(offset: Int = 0) -&gt; String &#123; return &quot;\\(name) is \\(age + offset) years old&quot; &#125;&#125; 123456789101112131415@font-face &#123; font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123; color: #F0F0F0; background: #600; font-family: Chunkfive, sans;&#125;@import url(print.css);@media print &#123; a[href^=http]::after &#123; content: attr(href) &#125;&#125; 12345678910111213# The Greeter classclass Greeter def initialize(name) @name = name.capitalize end def salute puts &quot;Hello #&#123;@name&#125;!&quot; endendg = Greeter.new(&quot;world&quot;)g.salute 12345678910111213# MakefileBUILDDIR = _buildEXTRAS ?= $(BUILDDIR)/extras.PHONY: main cleanmain: @echo &quot;Building main facility...&quot; build_main $(BUILDDIR)clean: rm -rf $(BUILDDIR)/* 123456789101112package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan float64) ch &lt;- 1.0e10 // magic number x, ok := &lt;- ch defer fmt.Println(`exitting now\\`) go println(len(&quot;hello world!&quot;)) return&#125; 123456789101112131415#!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then echo &quot;Superuser rights required&quot; exit 2figenApacheConf()&#123; echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125; 123456789101112; boilerplate[package]name = &quot;some_name&quot;authors = [&quot;Author&quot;]description = &quot;This is \\a description&quot;[[lib]]name = $&#123;NAME&#125;default = Trueauto = nocounter = 1_000 超链接1这是一个链接 [百度](https://baidu.com)。 这是一个链接 百度。 图片1![图片alt](图片链接 &quot;图片title&quot;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2022-06-03T11:42:34.000Z","updated":"2023-07-02T17:10:41.054Z","comments":true,"path":"2022/06/03/我的第一篇博客文章/","link":"","permalink":"http://example.com/2022/06/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"一年前，就试着搭建了这个Hexo框架的微博，但是只是部署到了Github上，并没有打理自己的博客，也没有写一些内容，这和当初搭建博客的目的有点南辕北辙了。这段时间确实是让人比较疲惫且受挫，但还是得打起精神，继续前进。","categories":[],"tags":[]}],"categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]}