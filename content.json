{"meta":{"title":"YukiCCC的博客","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-07-01T08:25:01.917Z","updated":"2023-07-01T08:25:01.917Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2023-07-01T08:25:42.219Z","updated":"2023-07-01T08:25:42.219Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-07-01T08:26:59.883Z","updated":"2023-07-01T08:26:59.883Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-01T08:54:37.410Z","updated":"2023-07-01T08:54:37.410Z","comments":true,"path":"data/friends.json","permalink":"http://example.com/data/friends.json","excerpt":"","text":"[{\"group\":\"分组1# 分组标题\",\"description\":\"友情链接\",\"items\":[{\"title\":\"Google\",\"avatar\":\"https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png\",\"url\":\"https://www.google.com/\",\"screenshot\":null,\"keywords\":null,\"description\":null},{\"title\":null,\"avatar\":null,\"url\":null,\"screenshot\":null,\"keywords\":null,\"description\":null}]}]"},{"title":"我的朋友们","date":"2023-07-01T08:26:42.238Z","updated":"2023-07-01T08:26:42.238Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"jQuery","slug":"jQuery","date":"2023-07-13T02:52:36.000Z","updated":"2023-07-13T02:58:04.316Z","comments":true,"path":"2023/07/13/jQuery/","link":"","permalink":"http://example.com/2023/07/13/jQuery/","excerpt":"","text":"1. JQ1.1 jQ概述jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。JavaScript库：是一个封装好的特定的集合包大量的方法。从封装函数的角度理解库，就是在JavaScrip库中，封装了很多预先定义好的函数在里面JQuery就是这样的一个js文件: 本质上就是对我们之前原生js代码封装后的一个js文件j 代表js Query 代表查询 优点： 轻量级。核心文件才几十kb，不会影响页面加载速度 跨浏览器兼容。基本兼容了现在主流的浏览器 链式编程、隐式迭代 对事件、样式、动画支持，大大简化了DOM操作 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等 免费、开源 初体验1234567891011121314151617181920212223242526272829303132&lt;!-- 使用 原生js 与 JQ PK 点击事件 --&gt; &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 隐式循环 2. 链式操作 3. $(dom对象) 转成 jq对象 调用 jq 的方法 $(&quot;li&quot;).mouseover(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;)).mouseout(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;&#x27;)) &lt;/script&gt; &lt;script&gt; //原生 let liCompAy = document.querySelectorAll(&#x27;li&#x27;) liCompAy.forEach((liComp) =&gt; &#123; liComp.addEventListener(&#x27;mouseover&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `pink` console.log(`鼠标覆盖`) &#125;) liComp.addEventListener(&#x27;mouseout&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `` console.log(`鼠标离开`) &#125;) &#125;) &lt;/script&gt; 入口函数12无需关心JS代码书写顺序 DOM中如果在HTML结构之前写JS代码,需要设置加载事件,获取HTML元素 【加载事件 window.onload】 123456789101112131415&lt;script&gt; //原生 window.addEventListener(&quot;load&quot;,()=&gt;&#123; let inputComp = document.querySelector(&quot;#name&quot;) console.log(`姓名 原生 :$&#123;inputComp.value&#125;`); &#125;) &lt;/script&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //JQ $(()=&gt;console.log(`姓名JQ: $&#123;$(&quot;#name&quot;).val()&#125;`)) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; DOM JQ转换12345678910DOM对象: 通过 document 方式获取到的元素都叫DOM对象jQuery对象 通过 $ 方式获取到的元素都叫 JQ对象将JQ对象转为DOM对象方式: JQ对象[索引] JQ对象.get(索引)将DOM对象转化为JQ对象: $(dom对象)注意： 只能由DOM对象 调用DOM的属性及方法，只能使用JQ对象调用 JQ的属性及方法 12345678910111213141516171819202122&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //dom对象 // let inputComp = document.querySelector(&quot;#name&quot;) // .val() jq的方法 必须 jq对象调用 .value dom的属性 必须 dom对象调用 // console.log(`姓名:$&#123;inputComp.value&#125;`); // jq对象 使用$开头 dom对象 // let $input = $(&quot;#name&quot;) // console.log(`姓名: $&#123;$input.val()&#125;`); //dom 转 jq let jq = $(dom) // let $input = $(inputComp) // console.log(`姓名: $&#123;$input.val()&#125;`); // jq 转 dom [0] .get(0) let $input = $(&quot;#name&quot;) // let input = $input[0] let input = $input.get(0) console.log(`姓名:$&#123;input.value&#125;`); &lt;/script&gt; 1.2 JQ 选择器基本选择器1234561. id选择器 #id值 $(&quot;#name&quot;)2. class选择器 .class值 $(&quot;.a&quot;)3. 标签选择器 标签名 $(&quot;li&quot;)4. 并集 OR , $(&quot;h1,#name,.a&quot;) 5. 交集 AND 直接写 $(&quot;li.c1&quot;)6. 适配 * $(&quot;*&quot;) 123456789101112131415161718192021&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li class=&quot;red&quot;&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data7&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`id选择器:$&#123;$(&#x27;#d5&#x27;).html()&#125;`) console.log(`class选择器:$&#123;$(&#x27;.red&#x27;).html()&#125;`) console.log(`标签选择器:$&#123;$(&#x27;ul&#x27;).html()&#125;`) console.log(`并集选择器===========`) $(&#x27;.red,#d5&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) $(&#x27;li.blue&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;) $(&#x27;*&#x27;).css(&#x27;fontSize&#x27;, &#x27;80px&#x27;)&lt;/script&gt; 层次选择器12345678910111. 儿子 &gt; $(&quot;tr&gt;td&quot;) $(&#x27;元素&#x27;).children([选择器]); 2. 后代 空格 $(&quot;table td&quot;) $(&#x27;元素&#x27;).find(选择器); 3. 下一个弟弟 + $(&quot;#data2+li&quot;) next() $(&quot;#data2&quot;).next(&quot;li&quot;)4. 所有的弟弟 ~ $(&quot;#data2~li&quot;) nextAll() $(&quot;#data2&quot;).nextAll(&quot;li&quot;)5. 上一个哥哥 prev() $(&quot;#data2&quot;).prev(&quot;li&quot;)6. 所有的哥哥 prevAll() $(&quot;#data2&quot;).prevAll(&quot;li&quot;)7. 同胞【哥哥弟弟们】 siblings() $(&quot;#data2&quot;).siblings(&quot;li&quot;) 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;ul&gt;li&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&quot;html li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5+li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).next(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5~li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).nextAll(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prev(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prevAll(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).siblings(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;)&lt;/script&gt; 属性选择器123451.拥有该属性 [attr] $(&quot;[name]&quot;)2.等于属性值 [attr=value] $(&quot;[name=&#x27;sid&#x27;]&quot;)3.使用属性值开头 [attr^=value] $(&quot;[name^=&#x27;s&#x27;]&quot;)4.使用属性值结尾 [attr$=value] $(&quot;[name$=&#x27;s&#x27;]&quot;)5.包含该属性值 [attr*=value] $(&quot;[name*=&#x27;s&#x27;]&quot;) 123456789101112131415&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;abc.html&quot;&gt;data1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;aaa.html&quot;&gt;data2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;ccc.html&quot;&gt;data3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;abcd.html&quot;&gt;data4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a&gt;data5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;[href]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href=&#x27;aaa.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href^=&#x27;a&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href$=&#x27;c.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href*=&#x27;c&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;)&lt;/script&gt; 过滤选择器基本过滤选择器12345671. 第一个 :first $(&quot;li:first&quot;)2. 最后一个 :last $(&quot;li:last&quot;)3. 偶数 :even $(&quot;li:even&quot;)4. 奇数 :odd $(&quot;li:odd&quot;)5. 等于索引 :eq(idx) 或 .eq(idx) $(&quot;li:eq(1)&quot;) 或 $(&quot;li&quot;).eq(1) 从0开始6. 小于索引 :lt(idx) $(&quot;li:lt(3)&quot;)7. 大于索引 :gt(idx) $(&quot;li:gt(3)&quot;) 123456789101112131415161718 &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li:first&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:last&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:even&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:odd&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:eq(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li&#x27;).eq(2).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:lt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:gt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;)&lt;/script&gt; 可见性过滤选择器121. 隐藏 :hidden2. 可见 :visible 1234567891011121314151617&lt;!-- 1. 隐藏 :hidden2. 可见 :visible--&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;显示&lt;/button&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).click(() =&gt; &#123; $(&#x27;img:visible&#x27;).hide(1000) &#125;) $(&#x27;button:eq(1)&#x27;).click(() =&gt; &#123; $(&#x27;img:hidden&#x27;).show(1000) &#125;)&lt;/script&gt; 表单过滤选择器12345678910111213141. input标签 :input $(&quot;input&quot;) &lt;input /&gt;2. type=&#x27;text&#x27; :text $(&quot;input[type=&#x27;text&#x27;]&quot;) &lt;input type=&#x27;text&#x27;/&gt;3. type=&#x27;password&#x27;:password $(&quot;input[type=&#x27;password&#x27;]&quot;) &lt;input type=&#x27;password&#x27;/&gt;4. type=&#x27;radio&#x27; :radio $(&quot;input[type=&#x27;radio&#x27;]&quot;) &lt;input type=&#x27;radio&#x27;/&gt;5. type=&#x27;checkbox&#x27;:checkbox $(&quot;input[type=&#x27;checkbox&#x27;]&quot;) &lt;input type=&#x27;checkbox&#x27;/&gt;6. type=&#x27;submit&#x27; :submit $(&quot;input[type=&#x27;submit&#x27;]&quot;) &lt;input type=&#x27;submit&#x27;/&gt;7. type=&#x27;image&#x27; :image $(&quot;input[type=&#x27;image&#x27;]&quot;) &lt;input type=&#x27;image&#x27;/&gt;8. type=&#x27;reset&#x27; :reset $(&quot;input[type=&#x27;reset&#x27;]&quot;) &lt;input type=&#x27;reset&#x27;/&gt;9. type=&#x27;button&#x27; :button $(&quot;input[type=&#x27;button&#x27;]&quot;) &lt;input type=&#x27;button&#x27;/&gt;10.type=&#x27;file&#x27; :file $(&quot;input[type=&#x27;file&#x27;]&quot;) &lt;input type=&#x27;file&#x27;/&gt;===========================布尔值属性==================11.被选中的单选/复选按钮 :checked $(&quot;:radio:checked&quot;)12.下拉框被选中 :selected $(&quot;:selected&quot;)13.被禁用 :disabled $(&quot;:disabled&quot;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;form action=&quot;xxController&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;admin1&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; value=&quot;admin2&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;hidden&quot; value=&quot;S1001&quot; /&gt; &lt;input type=&quot;text&quot; value=&quot;S1001&quot; disabled /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; value=&quot;123&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;CS&quot; /&gt;CS &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;LOL&quot; checked /&gt;LOL &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;DOTA&quot; checked /&gt;DOTA &lt;br /&gt; &lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt; &lt;br /&gt; &lt;select name=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;data1&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;data2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;data3&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;image&quot; src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`第一文本输入框:$&#123;$(&quot;input&quot;).val()&#125;`); console.log(`第一文本输入框:$&#123;$(&quot;:input&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;input[type=&#x27;text&#x27;]:eq(1)&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;:input:text:eq(1)&quot;).val()&#125;`); console.log(`密码输入框:$&#123;$(&quot;:password&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio:checked&quot;).val()&#125;`); $(&quot;:radio[value=&#x27;1&#x27;]&quot;)[0].checked = true $(&quot;:checkbox:checked&quot;).each((idx,e)=&gt;&#123; // console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); console.log(`索引:$&#123;idx&#125;========value:$&#123;$(e).val()&#125;`); &#125;) $.each($(&quot;:checkbox:checked&quot;),(idx,e)=&gt;&#123; console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); &#125;) $(&#x27;:submit&#x27;).val(&#x27;我是提交按钮&#x27;) $(&quot;:image&quot;).attr(&quot;src&quot;,&#x27;./images/html-css-js.png&#x27;) $(&quot;:reset&quot;).val(`回到解放前`) console.log(`file的name属性值:$&#123;$(&#x27;:file&#x27;).attr(&#x27;name&#x27;)&#125;`) console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).val()&#125;`); console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).text()&#125;`); console.log(`获得禁用的值:$&#123;$(&#x27;:disabled&#x27;).val()&#125;`) console.log(`获得隐藏的值:$&#123;$(&#x27;input:hidden&#x27;).val()&#125;`)&lt;/script&gt; 1.3 JQ注册事件鼠标事件121. 鼠标进入 mouseover = mouseenter2. 鼠标离开 mouseout = mouseleave 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* $(&#x27;li&#x27;) .mouseover(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) &#125;) .mouseout((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;)) */ $(&#x27;li&#x27;) .mouseenter((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;)) .mouseleave((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;))&lt;/script&gt; 123456789101112131415161718192021&lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;ul class=&quot;ul1&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;联系我们&lt;/a&gt; &lt;ul class=&quot;u2&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;邮件联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;电话联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;微信联系&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;.nav .ul1&gt;li:last&quot;).mouseenter(()=&gt;$(&quot;.u2&quot;).show()).mouseleave(()=&gt;$(&quot;.u2&quot;).hide()) &lt;/script&gt; 键盘事件121. 键盘按下 keydown2. 键盘释放 keyup 1234567&lt;input type=&quot;text&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;input&#x27;) .keydown((e) =&gt; console.log(e.keyCode)) .keyup(() =&gt; console.log(`释放`))&lt;/script&gt; 表单事件1234561.单击 click2.双击 dblclick3.值改变 change4.失去焦点 blur5.获得焦点 focus6.表单提交 submit 1234567891011121314151617181920212223242526272829&lt;form action=&quot;logcontroller&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;span id=&quot;accountError&quot;&gt;&lt;/span&gt;&lt;br /&gt; &lt;input type=&quot;password&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;:text&#x27;).focus((e) =&gt; $(e.target).css(&#x27;borderColor&#x27;, &#x27;red&#x27;)) $(&#x27;:text&#x27;).blur(() =&gt; &#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return &#125; console.log(`======用户名=====`) $(&#x27;#accountError&#x27;).html(``) &#125;) $(&quot;form&quot;).submit((e)=&gt;&#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return e.preventDefault() &#125; &#125;)&lt;/script&gt; 事件绑定1234561.绑定 bind(&quot;事件名&quot;,事件处理函数) = on (&quot;事件名&quot;,事件处理函数) 【结构固定,内容多变】 $(&quot;button:eq(0)&quot;).click(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;click&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).dblclick(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;dblclick&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).blur(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;blur&quot;,()=&gt;&#123;...&#125;)2.解绑 unbind(&quot;事件名&quot;) = off(&quot;事件名&quot;)3.只执行一次 one(&quot;事件名&quot;,事件处理函数) 1234567891011&lt;button&gt;绑定 click 按钮1&lt;/button&gt;&lt;button&gt;解除 click 按钮2&lt;/button&gt;&lt;button&gt;只绑定一次 click 按钮3&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).on(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).on(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).off(&#x27;click&#x27;)) $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).unbind(&#x27;click&#x27;)) $(&#x27;button:eq(2)&#x27;).one(&#x27;click&#x27;, () =&gt; console.log(`按钮3 被点击了..11.`))&lt;/script&gt; 复合事件12该事件由2个或2个以上的函数hover(fnOver,fnOut) 1234567891011121314151617&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li&#x27;).hover( (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;), (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) )&lt;/script&gt; 123456789101112131415161718 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;价格与包装&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;售后保障&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品评价&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;.box li&#x27;).hover( (e) =&gt; (e.target.className = &#x27;active&#x27;), (e) =&gt; (e.target.className = &#x27;&#x27;) )&lt;/script&gt; 事件冒泡1234触发子元素事件 级联 触发 父元素的事件【阻止事件冒泡:】1. event.stopPropagation()2. event.cancelBubble = true 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; #d1 &#123; width: 200px; height: 200px; background-color: pink; &#125; #d2 &#123; width: 100px; height: 100px; background-color: yellowgreen; &#125; #d3 &#123; width: 40px; height: 40px; background-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;d1&quot;&gt; &lt;div id=&quot;d2&quot;&gt; &lt;div id=&quot;d3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;#d1&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`爷爷被点击了`)) $(&#x27;#d2&#x27;).bind(&#x27;click&#x27;, function () &#123; console.log(`爸爸被点击了`) // event 内置对象 浏览器中 内置 对象 event.cancelBubble = true &#125;) $(&#x27;#d3&#x27;).bind(&#x27;click&#x27;, (e) =&gt; &#123; console.log(`你小子被点击了`) //e.stopPropagation() event.stopPropagation() &#125;)&lt;/script&gt; 事件默认行为1234默认事件行为： 比如 &lt;a href=&quot;addStu()&quot;&gt;...&lt;/a&gt; 默认链接到目标地址【阻止事件默认行为】1. javaScript:2. event.preventDefault() 12345678&lt;a href=&quot;http://www.baidu.com&quot;&gt;去百度 1 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:&quot;&gt;去百度 2 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:void(0)&quot;&gt;去百度 3 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;&quot;&gt;去百度 4 &lt;/a&gt; &lt;br /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;a&#x27;).bind(&#x27;click&#x27;, () =&gt; event.preventDefault())&lt;/script&gt; 表单序列化1234567序列化: 一次获取到表单中所有元素内容$(&#x27;form&#x27;).on(&#x27;submit&#x27;, function () &#123; // 通过 jQuery 对象的 serialize 方法，获取所有表单元素的数据 $(this).serialize(); // 阻止表单默认提交 return false;&#125;) 12345678910111213141516171819202122 &lt;form action=&quot;02-login-rs.html&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;account&quot; placeholder=&quot;请输入账号&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;pswd&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; placeholder=&quot;请输入年龄&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; location.href = `xxController?$&#123;$(&#x27;form&#x27;).serialize()&#125;` //阻止默认行为 event.preventDefault() &#125;) /* $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; let account = $(&quot;input[name=&#x27;account&#x27;]&quot;).val() let pswd = $(&quot;input[name=&#x27;pswd&#x27;]&quot;).val() location.href = `xxController?account=$&#123;account&#125;&amp;pswd=$&#123;pswd&#125;` //阻止默认行为 event.preventDefault() &#125;) */&lt;/script&gt; 1.4 JQ操作样式1234561.$(&#x27;元素&#x27;).css(&#x27;属性&#x27;, 值); 设置单个属性样式 $(&#x27;元素&#x27;).css(&#123;&#x27;属性&#x27;: &#x27;值&#x27;,&#x27;属性&#x27;: &#x27;值&#x27;&#125;) 设置多个属性样式2.$(&#x27;元素&#x27;).addClass(&#x27;类名 类名&#x27;); 3.$(&#x27;元素&#x27;).hasClass(&#x27;类名&#x27;);4.$(&#x27;元素&#x27;).removeClass(&#x27;类名&#x27;);5.$(&#x27;元素&#x27;).toggleClass(&#x27;类名&#x27;); 123456789101112131415161718192021222324&lt;style&gt; .pic &#123; width: 400px; height: 400px; border: 10px solid #000; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;/&gt;&lt;button&gt;添加样式1&lt;/button&gt;&lt;button&gt;添加样式2&lt;/button&gt;&lt;button&gt;添加样式3&lt;/button&gt;&lt;button&gt;删除样式4&lt;/button&gt;&lt;button&gt;切换样式5&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#x27;width&#x27;, &#x27;80px&#x27;)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#123; width: &#x27;80px&#x27; &#125;)) $(&#x27;button:eq(2)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).addClass(&#x27;pic&#x27;)) $(&#x27;button:eq(3)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).removeClass(&#x27;pic&#x27;)) $(&#x27;button:eq(4)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).toggleClass(&#x27;pic&#x27;)) console.log(`是否拥有pic样式: $&#123;$(&#x27;img&#x27;).hasClass(&#x27;pic&#x27;)&#125;`)&lt;/script&gt; 1.5 jQ操作属性12345678910111. 操作内置属性 获取: $(对象).prop(&#x27;属性名&#x27;); 设置: $(对象).prop(&#x27;属性名&#x27;, 值);2.操作自定义属性 获取: $(对象).attr(自定义属性名); 设置: $(对象).attr(自定义属性名, 值);3. 获取表单控件中的值 $(对象).val() $(对象).val(值);4. 操作普通标签中的值 $(对象).text(值); $(对象).html(值); 12345678910111213141516171819202122232425&lt;input type=&quot;text&quot; value=&quot;admin&quot; name=&quot;username&quot; data-user-id=&quot;S1001&quot; /&gt;&lt;span&gt;111111&lt;/span&gt;&lt;div&gt;&lt;h1&gt;2222&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`获得内置属性: $&#123;$(&#x27;input&#x27;).prop(&#x27;name&#x27;)&#125;`) $(&#x27;input&#x27;).prop(&#x27;name&#x27;, &#x27;uname&#x27;) console.log(`获得自定义属性: $&#123;$(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;)&#125;`) $(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;, &#x27;S6666&#x27;) console.log(`获得value属性: $&#123;$(&#x27;input&#x27;).val()&#125;`) $(&#x27;input&#x27;).val(&#x27;zhang3&#x27;) console.log(`获得innerText: $&#123;$(&#x27;span&#x27;).text()&#125;`) $(&#x27;span&#x27;).text(&#x27;span&#x27;) console.log(`获得innerHTML: $&#123;$(&#x27;div&#x27;).html()&#125;`) $(&#x27;div&#x27;).html(`&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt;&lt;/ul&gt;`)&lt;/script&gt; 1.6 jQ操作元素删除元素1231. $对象.remove(); 从页面中将当前标签删除2. $对象.empty(); 将标签中的所有内容清空3. $对象.html(&#x27;&#x27;); 将标签中的所有内容清空 创建元素121. $对象.html(&#x27;html标签名&#x27;); 直接在标签中添加新标签2. let res = $(&#x27;html标签&#x27;); 创建标签, 返回: JQ标签对象 添加元素1234567891. $父元素.append(元素); 将创建元素添加到父元素末尾2. $父元素.prepend(元素); 将创建元素添加到父元素开始1.尾部添加 父.append(子) 子.appendTo(父) 2.开始添加 父.prepend(子) 子.prependTo(父) 12345678910111213141516171819202122232425262728293031&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;p&gt;我的div中p&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.删除元素 $(&#x27;ul li:first&#x27;).remove() $(&#x27;ul li:last&#x27;).empty() $(&#x27;ul li:last&#x27;).html(``) //2.创建元素 $(&quot;ul li:first&quot;).html(`&lt;p&gt;aaaa&lt;/p&gt;`) let btn = $(`&lt;button&gt;按钮&lt;/button&gt;`) //3.添加元素 $(&#x27;div&#x27;).append(btn) btn.appendTo($(&#x27;div&#x27;)) $(&#x27;div&#x27;).prepend(btn) btn.prependTo($(&#x27;div&#x27;))&lt;/script&gt; 例：根据素材： 03-信息发布.html 实现元素添加&#x2F;删除功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; .msg &#123; width: 980px; padding-bottom: 10px; border: 1px solid #ccc; margin: 50px auto; &#125; textarea &#123; width: 880px; height: 100px; border: 0 none; border: 1px solid orange; resize: none; outline-style: none; border-radius: 10px; display: block; margin: 50px auto 0 auto; padding-left: 20px; padding-top: 20px; box-sizing: border-box; &#125; .btn &#123; width: 80px; height: 40px; display: block; float: right; margin-right: 50px; margin-top: 20px; background-color: blue; color: #fff; text-align: center; text-decoration: none; line-height: 40px; border-radius: 10px; clear: both; &#125; .content &#123; width: 880px; margin: 80px auto 0 auto; &#125; .item &#123; height: 50px; line-height: 50px; border-bottom: 1px dashed #ccc; padding-left: 20px; &#125; .item p &#123; float: left; &#125; .del &#123; float: right; text-decoration: none; color: #999; &#125; .del:hover &#123; color: orange; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;msg&quot;&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;btn&quot;&gt;发布&lt;/a&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;三天没吃肉啦&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //发布 $(`a.btn`).bind(`click`, () =&gt; &#123; //创建 元素 let divItemElt = $(`&lt;div class=&quot;item&quot;&gt; &lt;p&gt;$&#123;$(&#x27;textarea&#x27;).val()&#125;&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt;`) //添加元素 $(`div.content`).prepend(divItemElt) //清空输入框 $(&#x27;textarea&#x27;).val(``) console.log(`===发布=======`) &#125;) //删除 使用 事件委托 代理 $(`div.content`).on(`click`, `.del`, () =&gt; &#123; if (confirm(`确认删除吗?`)) &#123; $(event.target).parent().remove() &#125; console.log(`===删除=========`) &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"JDBC","slug":"JDBC","date":"2023-07-11T10:37:55.000Z","updated":"2023-07-11T16:45:26.895Z","comments":true,"path":"2023/07/11/JDBC/","link":"","permalink":"http://example.com/2023/07/11/JDBC/","excerpt":"","text":"JDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。 1. JDBC1.1 简介 1.2 工作原理 1.3 JDBC API 1.4 JDBC 驱动 1.5 Connection[会话] 1.6 Statement【执行SQL】Statement用于执行静态 SQL 语句 PreparedStatement表示预编译的 SQL 语句的对象。 CallableStatement用于执行 SQL 存储过程的接口。 存储过程定义1234567891011121314151617DELIMITER $$CREATE PROCEDURE p_save_dept(v_deptno INT,v_dname VARCHAR(20),v_loc VARCHAR(20) ,OUT v_rs INT ) BEGIN DECLARE cut INT(1) ; SELECT COUNT(0) INTO cut FROM dept WHERE deptno = v_deptno ; IF cut = 1 THEN SET v_rs = -1 ; END IF ; IF cut = 0 THEN SET v_rs = 1 ; INSERT INTO dept (deptno,dname,loc) VALUES (v_deptno,v_dname,v_loc) ; COMMIT ; END IF ;END $$DELIMITER ; 数据库直接调用12CALL p_save_dept(11,&#x27;aa&#x27;,&#x27;NJ&#x27;,@rs) ;SELECT @rs ; JDBC调用1234567891011Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;root&quot;);CallableStatement cs = conn.prepareCall(&quot;&#123;call p_save_dept(?,?,?,?)&#125;&quot;);cs.setInt(1,12);cs.setString(2,&quot;dev&quot;);cs.setString(3,&quot;NJ&quot;);cs.registerOutParameter(4, JDBCType.INTEGER);cs.execute() ;int out = cs.getInt(4);System.out.println(out);cs.close();conn.close(); 1.7 ResultSet 【查询结果集】 2. DAO2.1 什么是DAO 2.2 DAO作用 2.3 组成部分 2.4 示例 3.DbutilsDbutils：主要是封装了JDBC的代码，简化dao层的操作。作用：帮助java程序员，开发Dao层代码的简单框架。框架的作用：帮助程序员，提高程序的开发效率。 3.1 环境搭建jar包下载 https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils/1.7 3.2 官网地址https://commons.apache.org/proper/commons-dbutils/examples.html 3.3 Dbutils三个核心类介绍1：DbUtils：连接数据库对象—-jdbc辅助方法的集合类，线程安全构造方法：DbUtils()作用：控制连接，控制事务，控制驱动加载额一个类。 2：QueryRunner：SQL语句的操作对象，可以设置查询结果集的封装策略，线程安全。构造方法：（1）QueryRunner()：创建一个与数据库无关的QueryRunner对象，后期再操作数据库的会后，需要手动给一个Connection对象，它可以手动控制事务。Connection.setAutoCommit(false); 设置手动管理事务Connection.commit(); 提交事务 （2）QueryRunner(DataSource ds)：创建一个与数据库关联的queryRunner对象，后期再操作数据库的时候，不需要Connection对象，自动管理事务。DataSource：数据库连接池对象。 12345678 //构造函数与增删改查方法的组合：QueryRunner() update(Connection conn, String sql, Object... params) query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) QueryRunner(DataSource ds) update(String sql, Object... params) query(String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) 3：ResultSetHandle：封装数据的策略对象——将封装结果集中的数据，转换到另一个对象策略：封装数据到对象的方式（示例：将数据库保存在User、保存到数组、保存到集合）方法介绍：handle（ResultSet rs） 3.4 创建DBCP连接池1、创建DBCP链接池配置文件：名称为 dbcp.properties 内容如下： 12345driverClassName=com.mysql.jdbc.Driverusername=rootpassword=123456url=jdbc:mysql://127.0.0.1:3306/long1?characterEncoding=UTF8maxActive=2 2、读取配置文件，创建 DataSource 连接池实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.test.dbcp;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;public class DbcpDataSource &#123;/* * 重点：创建一个DataSource * 步骤为：1、用Properties类读取配置文件。 * 2、通过工厂类，读取这个Properties类获取的配置文件，创建出DataSource * DataSource作用： * 创建DataSource可以返回多个连接。可以实现dbutil简化操作数据库的流程。 *///1、创建一个静态的datasourceprivate static DataSource ds;//2、在静态代码块中，给ds赋值static&#123; //读取资源文件 try&#123; Properties p = new Properties(); p.load(DbcpDataSource.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;)); //在dbcp中有一个工厂类，读取一个资源文件,创建一个datasource ds = BasicDataSourceFactory.createDataSource(p); System.out.println(&quot;创建DataSource为&quot;+ds); &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125; &#125;//提供一个方法用于获取整个datasource对象public static DataSource getDataSource()&#123; return ds; &#125;//提供一个方法，获取connection连接public static Connection getConnection()&#123; Connection con = null; try&#123; con = ds.getConnection(); System.out.println(&quot;通过DataSource获取connection连接&quot;+con); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return con; &#125;&#125; 另外也可以不配置文件直接使用 1234567891011121314static &#123; //模拟初始化数据 Properties prop = new Properties(); prop.setProperty(&quot;driverClassName&quot;,&quot;com.mysql.jdbc.Driver&quot;); prop.setProperty(&quot;url&quot;,&quot;jdbc:mysql://localhost:3306/customer?useSSL=false&amp;characterEncoding=utf8&quot;); prop.setProperty(&quot;password&quot;,&quot;root&quot;); prop.setProperty(&quot;username&quot;,&quot;root&quot;); try&#123; dataSource = DruidDataSourceFactory.createDataSource(prop); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; //初始化 连接池&#125; 3.5 DBUtil 增删改查12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.test.ts;import java.sql.SQLException;import java.util.List;import javax.persistence.Version;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayHandler;import org.apache.commons.dbutils.handlers.ArrayListHandler;import org.junit.Test;import com.test.dbcp.DbcpDataSource;public class DbutilTests &#123;/* * dbutil向数据库新增数据 */@Testpublic void add() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run1 = new QueryRunner(DbcpDataSource.getDataSource()); //申明对象，获取DataSource链接池 //2、书写SQL字符串语句 String sq1 = &quot;INSERT INTO student(id,namee,sex,birth,department,address)&quot; + &quot;VALUES(3,&#x27;王思&#x27;,&#x27;男&#x27;,1995,&#x27;英文系&#x27;,&#x27;山东沧州&#x27;)&quot;; //3、执行sql语句 int result1 = run1.update(sq1); System.out.println(&quot;新增数据库结果，更新了数据有：&quot;+result1+&quot;条&quot;); &#125;/* * dbutil 修改数据库数据 * */@Testpublic void update() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run2 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句 String sq2 = &quot;UPDATE student SET sex=? WHERE id=?&quot;; //3、执行SQL语句 int result2 = run2.update(sq2, &quot;男&quot;,16); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result2+&quot;条&quot;); &#125;/* * dbutil 删除数据库数据 */@Testpublic void delete() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run3 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句（这个sql语句的作用是每次删除ID号最大的数据） String sq3 = &quot;DELETE FROM student WHERE id IN &quot; + &quot;(SELECT a.id FROM &quot; + &quot;(SELECT MAX(id) id FROM student a WHERE id IN&quot; + &quot;(SELECT id FROM student b WHERE a.id=b.id ORDER BY id DESC)) a)&quot;; //3、执行SQL语句 int result3 = run3.update(sq3); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result3+&quot;条&quot;); &#125;/* * dbutil 查询，将结果封装成Object对象，返回第一行数据 */@Testpublic void query() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource链接池 //2、查询 String sq4 = &quot;Select * from student&quot;; Object[] var = run.query(sq4, new ArrayHandler()); if(var !=null)&#123; System.out.print(&quot;输出学生表查询的信息&quot;+&quot;\\n&quot;); for(Object o :var)&#123; System.out.print(o+&quot;\\n&quot;); &#125; &#125; &#125;/* * dbutil 查询 ，将结果封装成Object对象，返回所有的数据 * */@Testpublic void query2() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run5 = new QueryRunner(DbcpDataSource.getDataSource()); //2、书写sql语句 String sq5 = &quot;select * from student&quot;; //3、查询sql List&lt;Object[]&gt; list = run5.query(sq5, new ArrayListHandler()); //4、遍历结果 if(list!=null)&#123; for(Object[] os:list)&#123; for(Object o :os)&#123; System.out.println(&quot;ArrayListHandler()显示查询到的所有数据：&quot;+o+&quot;\\t&quot;); &#125; System.out.println(&quot;\\n--------------------------------------------&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Tomcat-servlet","slug":"Tomcat-servlet","date":"2023-07-11T01:34:13.000Z","updated":"2023-07-11T02:13:21.920Z","comments":true,"path":"2023/07/11/Tomcat-servlet/","link":"","permalink":"http://example.com/2023/07/11/Tomcat-servlet/","excerpt":"","text":"Tomcat是web容器。在进行web项目开发的时候，经常需要http协议，也就是基于请求和响应，比如你在百度输入一行内容搜索，那么百度服务器如何处理这个请求呢？它需要创建servlet来处理，servlet其实就是java程序，只是在服务器端的java程序，servlet通过配置文件拦截你的请求，并进行相应处理，然后展示给你相应界面。那么servlet如何创建？这时候就要用到tomcat了。 1.网络编程1.1 图解 1.2 Server123456789101112131415161718192021222324252627282930313233343536public class ServerApp &#123; public static void main(String[] args) throws IOException &#123; //忠告 数组 final String[] ADVICE_AY = &#123;&quot;每天吃钙，到老我也健康膝盖!&quot;,&quot;听人劝，吃饱饭！&quot;,&quot;代码写的好，要饭要到老！&quot;&#125;; //随机数 final Random RAND = new Random(); //创建服务器端 套接字 ServerSocket serverSocket = new ServerSocket(8080); //服务器端 一直接受 客户端的请求 死循环 while (true)&#123; //获得 客户端套接字 Socket socket = serverSocket.accept(); new Thread(()-&gt;&#123; try &#123; // 获得输出流 OutputStream os = socket.getOutputStream(); //输出 随机字符串 字节流数组 os.write(ADVICE_AY[RAND.nextInt(ADVICE_AY.length)].getBytes(&quot;UTF-8&quot;)); //清空 缓存 os.flush(); InputStream is = socket.getInputStream(); byte[] ay = new byte[1024] ; is.read(ay) ; System.out.println(&quot;来着客户端的消息:&quot;+new String(ay)); //释放流 os.close(); is.close(); //关闭套接字 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 1.3 Client1234567891011121314151617181920public class ClientApp &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080); //获得输入流 InputStream is = socket.getInputStream(); byte[] ay = new byte[1024]; is.read(ay) ; //打印 服务器端消息 System.out.println(&quot;来着服务器端消息:&quot;+new String(ay)); //获得输出流 OutputStream os = socket.getOutputStream(); os.write((&quot;hello Server !!!&quot;+Math.random()).getBytes()); os.flush(); is.close(); os.close(); socket.close(); &#125;&#125; 2. CS&#x2F;BS架构2.1 图解 2.2 C&#x2F;S与B&#x2F;S区别123456789101112131415161718191．硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的，不必是专门的网络硬件环境，例如电话上网，租用设备. 信息自己管理. 有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。2．对安全要求不同：C/S 一般面向相对固定的用户群，对信息安全的控制能力很强。 一般高度机密的信息系统采用C/S 结构适宜。可以通过B/S发布部分可公开信息。B/S 建立在广域网之上， 对安全的控制能力相对弱， 可能面向不可知的用户。3．对程序架构不同：C/S 程序可以更加注重流程， 可以对权限多层次校验， 对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑，建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统。SUN 和IBM推JavaBean 构件技术等，使 B/S更加成熟.。4．软件重用不同：C/S 程序可以不可避免的整体性考虑， 构件的重用性不如在B/S要求下的构件的重用性好。B/S 的多重结构，要求构件相对独立的功能， 能够相对较好的重用，就如买来的餐桌可以再利用，而不是做在墙上的石头桌子。5．系统维护不同：C/S 程序由于整体性，必须整体考察，处理出现的问题以及系统升级、升级难、 可能是再做一个全新的系统。B/S 构件组成，方便构件个别的更换，实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级。 3. 手动部署3.0 创建web应用 3.1 静态html http://localhost/web01/hello.html 3.2 动态jsp http://localhost/web01/hello.jsp 3.3 Servlet1234567891011121314151617Servlet = Server applet 运行在服务器 tomcat上的小程序1.必须 规范：必须实现 Servlet 接口 //直接实现 Servlet 接口 A implements Servlet&#123; &#125; HttpServlet implments Servlet&#123; &#125; //间接实现 Servlet 接口 A extends HttpServlet&#123; ... &#125; 源码参考： 123456789101112131415161718192021import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class HelloWorld extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;Hello World!&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;Hello World Servlet ... !&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125;&#125; 编译 javac -cp D:\\java168_2\\server\\apache-tomcat-8.5.73\\lib\\servlet-api.jar .\\HelloWorld.java 部署 121. 桌面： aa文件下/HelloWorld.class 放在 classess文件夹下2. tomcat/lib/servlet-api.jar lib 空着 配置12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 访问http://localhost/web01/hello.do 4. IDE web开发4.1 创建项目 4.2 创建Servlet123456789public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //控制台输出 IDE console System.out.println(&quot;=====HelloServlet===doGet 该方法被执行啦=======&quot;); //通过 流 浏览器 输出 hello ... resp.getWriter().println(&quot;&lt;h1&gt; hello ...&lt;/h1&gt;&quot;); &#125;&#125; 4.3 配置Servlet123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;!-- 注册 servlet 类 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wanho.java171.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 映射 servlet 类访问路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.4 访问Servlethttp://localhost/day10-01-servlet/hello.do 基于请求驱动 地址栏直接怼 超链接 location.href form action&#x3D;“” 基于事件驱动 5.Servlet API5.1 HttpServletRequest12345678//获得请求参数的值方法1： String name = request.getParameter(&quot;name&quot;);&quot;name&quot; 参数名： 注意：如果参数名 不存在 String name 的值？ null 如果参数名 存在 没有值 String name 的值？ &quot;&quot; //1.针对 post 请求有效 中文乱码 req.setCharacterEncoding(&quot;UTF-8&quot;); 12345678910111213141516//兼容： get/postpublic class TestRequestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException &#123; //获得用户请求参数 使用 HttpServletRequest req 对象 String name = request.getParameter(&quot;name&quot;); String age = request.getParameter(&quot;age&quot;); System.out.println(&quot;姓名:&quot;+name+&quot;,年龄:&quot;+age); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 注意：doPost与doGet的区别GET调用用于获取服务器信息，并将其做为响应返回给客户端。当经由Web浏览器或通过HTML、JSP直接访问Servlet的URL时，一般用GET调用。 POST用于客户端把数据传送到服务器端，是可以隐藏传送给服务器的任何数据。Post适合发送大量的数据。 区别： 1、生成方式 get生成方式有四种：1）直接在URL地址栏中输入URL。2）网页中的超链接。3）form中method为get。4）form中method为空时，默认是get提交。 post生成方式：form中method属性为post。 2、数据传送方式 get方式：表单数据存放在URL地址后面。所有get方式提交时HTTP中没有消息体。 post方式：表单数据存放在HTTP协议的消息体中以实体的方式传送到服务器。 3、服务器获取数据方式 GET方式：服务器采用request.QueryString来获取变量的值。 POST方式：服务器采用request.Form来获取数据。 4、传送的数据量 GET方式：数据量长度有限制，一般不超过2kb。因为是参数传递，且在地址栏中，故数据量有限制。 POST方式：适合大规模的数据传送。因为是以实体的方式传送的。 5、安全性 GET方式：安全性差。因为是直接将数据显示在地址栏中，浏览器有缓冲，可记录用户信息。所以安全性低。 POST方式：安全性高。因为post方式提交数据时是采用的HTTP post机制，是将表单中的字段与值放置在HTTP HEADER内一起传送到ACTION所指的URL中，用户是看不见的。 6、在用户刷新时 GET方式：不会有任何提示、 POST方式：会弹出提示框，问用户是否重新提交 5.2 HttpServletResponse响应字符流12345// 1.响应 [html内容] 字符输出流resp.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter out = resp.getWriter();//通过 流 浏览器 输出 hello ... 类似： js ： document.write(&quot;html代码&quot;)out.println(&quot;&lt;h1&gt; hello . 该方法被执行啦..&lt;/h1&gt;&quot;); 响应URL12//2. 响应URL 浏览器 根据响应URL 再次发送新的请求resp.sendRedirect(&quot;./request.do&quot;) ;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"}]},{"title":"Java-捕获异常","slug":"Java-捕获异常","date":"2023-07-03T11:09:06.000Z","updated":"2023-07-03T11:35:12.222Z","comments":true,"path":"2023/07/03/Java-捕获异常/","link":"","permalink":"http://example.com/2023/07/03/Java-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/","excerpt":"","text":"捕获异常使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方。try&#x2F;catch代码块中的代码称为保护代码，使用 try&#x2F;catch 的语法如下： 1234567try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 实例:下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第四个元素的时候就会抛出一个异常。 1234567891011121314// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest&#123; public static void main(String args[])&#123; try&#123; int a[] = new int[2]; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; System.out.println(&quot;Out of the block&quot;); &#125;&#125; 以上代码编译运行输出结果如下 12Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block 多重捕获块一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。多重捕获块的语法如下所示： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;catch(异常类型3 异常的变量名3)&#123; // 程序代码&#125; 上面的代码段包含了 3 个 catch块。可以在 try 语句后面添加任意数量的 catch 块。如果保护代码中发生异常，异常被抛给第一个 catch 块。如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。如果不匹配，它会被传递给第二个 catch 块。如此，直到异常被捕获或者通过所有的 catch 块。 实例:该实例展示了怎么使用多重 try&#x2F;catch。 12345678910try &#123; file = new FileInputStream(fileName); x = (byte) file.read();&#125; catch(FileNotFoundException f) &#123; // Not valid! f.printStackTrace(); return -1;&#125; catch(IOException i) &#123; i.printStackTrace(); return -1;&#125; throws&#x2F;throw 关键字在Java中， throw 和 throws 关键字是用于处理异常的。throw 关键字用于在代码中抛出异常，而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。 throw 关键字throw 关键字用于在当前方法中抛出一个异常。通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 throw 关键字抛出异常，以告知调用者当前代码的执行状态。例如，下面的代码中，在方法中判断 num 是否小于 0，如果是，则抛出一个 IllegalArgumentException 异常。 12345public void checkNumber(int num) &#123; if (num &lt; 0) &#123; throw new IllegalArgumentException(&quot;Number must be positive&quot;); &#125;&#125; throws 关键字throws 关键字用于在方法声明中指定该方法可能抛出的异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常。例如，下面的代码中，当 readFile 方法内部发生 IOException 异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理 IOException 异常。 123456789public void readFile(String filePath) throws IOException &#123; BufferedReader reader = new BufferedReader(new FileReader(filePath)); String line = reader.readLine(); while (line != null) &#123; System.out.println(line); line = reader.readLine(); &#125; reader.close();&#125; 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException： 12345678910import java.io.*;public class className&#123; public void withdraw(double amount) throws RemoteException, InsufficientFundsException &#123; // Method implementation &#125; //Remainder of class definition&#125; finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; 实例:123456789101112131415public class ExcepTest&#123; public static void main(String args[])&#123; int a[] = new int[2]; try&#123; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; finally&#123; a[0] = 6; System.out.println(&quot;First element value: &quot; +a[0]); System.out.println(&quot;The finally statement is executed&quot;); &#125; &#125;&#125; 以上实例编译运行结果如下： 123Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed 注意下面事项： 1.catch 不能独立于 try 存在。2.在 try&#x2F;catch 后面添加 finally 块并非强制性要求的。3.try 代码后不能既没 catch 块也没 finally 块。4.try, catch, finally 块之间不能添加任何代码。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-查询基础","slug":"Mysql-查询基础","date":"2023-07-03T10:27:29.000Z","updated":"2023-07-11T01:36:23.486Z","comments":true,"path":"2023/07/03/Mysql-查询基础/","link":"","permalink":"http://example.com/2023/07/03/Mysql-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 查询基础1.0 基本概念12345678DDL:[数据定义语言] create , alter , drop , truncate 语句 【事务自动提交】DML:[数据操作语言] insert ,update, delete 语句DQL:[数据查询语言] selectDCL:[数据控制语言] grant[授权] ，revoke[撤销] ,commit , rollback , savepoint 表结构 初始化脚本scott.sql 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394drop database if exists scott;create database scott;use scott;DROP TABLE IF EXISTS BONUS;CREATE TABLE BONUS (ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,SAL DOUBLE NULL ,COMM DOUBLE NULL ) ;-- ------------------------------ Records for BONUS-- ------------------------------ ------------------------------ Table structure for DEPT-- ----------------------------DROP TABLE IF EXISTS DEPT;CREATE TABLE DEPT (DEPTNO INT(2) PRIMARY KEY,DNAME VARCHAR(14) NULL ,LOC VARCHAR(13) NULL );-- ------------------------------ Records for DEPT-- ----------------------------INSERT INTO DEPT VALUES (&#x27;10&#x27;, &#x27;ACCOUNTING&#x27;, &#x27;NEW YORK&#x27;);INSERT INTO DEPT VALUES (&#x27;20&#x27;, &#x27;RESEARCH&#x27;, &#x27;DALLAS&#x27;);INSERT INTO DEPT VALUES (&#x27;30&#x27;, &#x27;SALES&#x27;, &#x27;CHICAGO&#x27;);INSERT INTO DEPT VALUES (&#x27;40&#x27;, &#x27;OPERATIONS&#x27;, &#x27;BOSTON&#x27;);-- ------------------------------ Table structure for EMP-- ----------------------------DROP TABLE IF EXISTS EMP;CREATE TABLE EMP (EMPNO INT(4) PRIMARY KEY ,ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,MGR INT(4) NULL ,HIREDATE DATETIME NULL ,SAL DOUBLE(7,2) NULL ,COMM DOUBLE(7,2) NULL ,DEPTNO INT(2) NULL );-- ------------------------------ Records for EMP-- ----------------------------INSERT INTO EMP VALUES (&#x27;7369&#x27;, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, &#x27;7902&#x27;, &#x27;1980-12-17 00:00:00&#x27;, &#x27;800&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7499&#x27;, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-20 00:00:00&#x27;, &#x27;1600&#x27;, &#x27;300&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7521&#x27;, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-22 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;500&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7566&#x27;, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-04-02 00:00:00&#x27;, &#x27;2975&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7654&#x27;, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-28 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;1400&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7698&#x27;, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-05-01 00:00:00&#x27;, &#x27;2850&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7782&#x27;, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-06-09 00:00:00&#x27;, &#x27;2450&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7788&#x27;, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1987-04-19 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7839&#x27;, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, null, &#x27;1981-11-17 00:00:00&#x27;, &#x27;5000&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7844&#x27;, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-08 00:00:00&#x27;, &#x27;1500&#x27;, &#x27;0&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7876&#x27;, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, &#x27;7788&#x27;, &#x27;1987-05-23 00:00:00&#x27;, &#x27;1100&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7900&#x27;, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, &#x27;7698&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;950&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7902&#x27;, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7934&#x27;, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, &#x27;7782&#x27;, &#x27;1982-01-23 00:00:00&#x27;, &#x27;1300&#x27;, null, &#x27;10&#x27;);-- ------------------------------ Table structure for &quot;SALGRADE&quot;-- ----------------------------DROP TABLE IF EXISTS SALGRADE;CREATE TABLE SALGRADE (GRADE INT(2) NULL ,LOSAL DOUBLE NULL ,HISAL DOUBLE NULL ) ;-- ------------------------------ Records for SALGRADE-- ----------------------------INSERT INTO SALGRADE VALUES (&#x27;1&#x27;, &#x27;700&#x27;, &#x27;1200&#x27;);INSERT INTO SALGRADE VALUES (&#x27;2&#x27;, &#x27;1201&#x27;, &#x27;1400&#x27;);INSERT INTO SALGRADE VALUES (&#x27;3&#x27;, &#x27;1401&#x27;, &#x27;2000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;4&#x27;, &#x27;2001&#x27;, &#x27;3000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;5&#x27;, &#x27;3001&#x27;, &#x27;9999&#x27;);-- ------------------------------ Foreign Key structure for table EMP-- ----------------------------ALTER TABLE EMP ADD FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO); 1.1 简单select所有行所有列1SELECT * FROM emp ; 限制列1SELECT empno,ename,sal FROM emp ; 限制行1SELECT * FROM emp WHERE deptno = 10 ; 1.2 算术运算符 + - * &#x2F;注意： null 值不参与计算 【null 未知值 不确定值 x？】 1SELECT sal+comm FROM emp ; -- comm null 值 + 【运算】1234SELECT 3+4 ;SELECT &#x27;3&#x27;+4 ;SELECT &#x27;3&#x27;+&#x27;4&#x27; ;SELECT &#x27;3&#x27;+&#x27;ABC&#x27; ; -- 3 [不报错] &#x2F; 【除法】1SELECT 5/2 ; -- 2.5000 1.3 别名 AS标准： AS “dept.dname” 1SELECT ename AS &quot;from&quot; ,sal AS &quot;员工 工资&quot; FROM emp AS e 1.4 null 空值安全 等于&#x2F;全等于 ：&lt;&#x3D;&gt; 与 &#x3D; 区别：可以判断null值 is null123SELECT * FROM emp WHERE comm IS NULL ;SELECT * FROM emp WHERE comm &lt;=&gt; NULL ; is not null123SELECT * FROM emp WHERE comm IS NOT NULL ;SELECT * FROM emp WHERE NOT comm IS NULL ; 1.5 去重复行 distinct1SELECT DISTINCT deptno ,job FROM emp ; 1.6 排序 order by堆表：快速插入数据 【搬家公司 –&gt; 家具】 默认： 升序 ASC 降序 DESC 基本排序12SELECT * FROM emp ORDER BY sal ASC;SELECT * FROM emp ORDER BY sal DESC; 结果集列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC; 排序多列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC ,1 ASC ; nullOracle 数据库有专用关键字，mysql没有 12345-- null firstSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),99999,comm) DESC ;-- null lastSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),-1,comm) DESC ; 1.7 比较运算符 &lt;&#x3D;&gt; 安全等于【比较null值】 &#x3D; 等于【不能比较null值】 !&#x3D; &lt;&gt; &lt; &lt;&#x3D; &gt; &gt;&#x3D; between and 1234SELECT * FROM emp WHERE deptno != 10 ;SELECT * FROM emp WHERE deptno &lt;&gt; 10 ;SELECT * FROM emp WHERE sal BETWEEN 800 AND 3000 ;SELECT * FROM emp WHERE sal&gt;=800 AND sal&lt;=3000 ; 1.8 in not inin12SELECT * FROM emp WHERE deptno IN (10,20) ;SELECT * FROM emp WHERE deptno =10 OR deptno =20 ; not in12-- 注意： not in (去null值)SELECT * FROM emp WHERE deptno NOT IN (10,20,NULL) ; 1.9 模糊查询_ 一个字符 % N个字符 1SELECT * FROM emp WHERE ename LIKE &#x27;__A%&#x27;; 1234-- zhang_san _进行转义 _不是 like 匹配字符 而是数据SELECT * FROM emp WHERE ename LIKE &#x27;%\\_%&#x27;;SELECT * FROM emp WHERE ename LIKE &#x27;%\\%%&#x27;; 1.10 正则 REGEXP12345^ 匹配开头$ 匹配结尾. 任何一个字符[abc] 范围匹配一个 [a-z] [0-9]* 匹配任意次 12345678-- s开头的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;^S&#x27; ;-- T结尾的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;T$&#x27; ;-- 第二个字母 CSELECT * FROM emp WHERE ename REGEXP &#x27;.C&#x27; ;-- 包含字母 OSELECT * FROM emp WHERE ename REGEXP &#x27;.*O.*&#x27; ; 1.11 逻辑运算符not ! and &amp;&amp; or || 1SELECT NOT 1=1 , ! (1=1) ; 1.12 limitTOPN 1234567-- limit 位置偏移量, 行数 -- 第一页SELECT * FROM emp LIMIT 0,5 ;SELECT * FROM emp LIMIT 5 ;-- 第二页SELECT * FROM emp LIMIT 5,5 ; 例1：123456789101112131415161718-- 1.选择在部门 30 中员工的所有信息 select * from emp where deptno = &#x27;30&#x27; ;-- 2 列出职位为（MANAGER）的员工的编号，姓名 select empno,ename from emp where job = &#x27;MANAGER&#x27; ;-- 3 找出奖金高于工资的员工 select * from emp where comm&gt;sal ;-- 4 找出每个员工奖金和工资的总和 select sal+if(isnull(comm),0,comm) month_sal ,ename from emp order by month_sal desc ;-- 5 找出部门 10 中的经理(MANAGER)和部门 20 中的普通员工(CLERK)select * from emp where (deptno,job) in ((10,&#x27;MANAGER&#x27;),(20,&#x27;CLERK&#x27;)) ;-- 6 找出部门 10 中既不是经理MANAGER也不是普通员工CLERK，而且工资大于等于 2000 的员工select * from emp where deptno = 10 and job not in (&#x27;MANAGER&#x27;,&#x27;CLERK&#x27;) and sal&gt;=2000 ;-- 7 找出有奖金的员工的不同工作select distinct job from emp where comm is not null ;-- 8 找出没有奖金或者奖金低于 500 的员工select * from emp where comm is null or comm&lt;500 ;-- 9 显示雇员姓名，根据其服务年限，将最老的雇员排在最前面select ename from emp order by hiredate asc ; 2. 单行函数2.1 数值函数绝对值 1SELECT ABS(-11.5) ; 平方根 1SELECT SQRT(100) ; 求余 1SELECT MOD(5,2) ; 向上取整 1SELECT CEIL(3.001) ,CEIL(3.000) ; 向下取整 1SELECT FLOOR(3.999) ,CEIL(3.000) ; 随机数 1SELECT RAND() ; 四舍五入 1SELECT ROUND(11.5),ROUND(-11.5) ; 2.2 字符函数字符个数 123SELECT * FROM emp WHERE CHAR_LENGTH(ename) = 5 ;SELECT * FROM emp WHERE ename LIKE &#x27;_____&#x27; ; 字符串连接 12345-- concat() null 值 返回 nullSELECT CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;,NULL) ;-- concat_ws() null值不参与 【第一个参数 连接符 】SELECT CONCAT_WS(&#x27;,&#x27;,&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT_WS(&#x27;*&#x27;,&#x27;hello&#x27;,NULL,&#x27;word&#x27;,&#x27;java167&#x27;) 字符串替换 12-- db 索引从 1 开始SELECT INSERT(&#x27;hellojava167&#x27;,3,2,&#x27;**&#x27;) ; 大小写转换 1SELECT UPPER(&#x27;hello java&#x27;),LOWER(&#x27;JAVA hello&#x27;) ; 左右截取字符串 1SELECT LEFT(&#x27;helloworld&#x27;,5),RIGHT(&#x27;helloworld&#x27;,5) ; 左右填充字符串 1SELECT LPAD(&#x27;helloworld&#x27;,15,&#x27;-&#x27;),RPAD(&#x27;helloworld&#x27;,15,&#x27;*&#x27;) ; 首尾去空格 12SELECT TRIM(&#x27; abc ddd &#x27;) ;SELECT TRIM(&#x27;abc&#x27; FROM &#x27;abcxxxyyyabc&#x27;) ; 重复生成字符串 1SELECT REPEAT(&#x27;hello&#x27;,5) ; 字符串比较 12-- 1 0 -1SELECT STRCMP(&#x27;abc&#x27;,&#x27;def&#x27;) ,STRCMP(&#x27;abc&#x27;,&#x27;abc&#x27;),STRCMP(&#x27;zzz&#x27;,&#x27;abc&#x27;); 字符串截取 1234SELECT SUBSTRING(&#x27;helloworld&#x27;,1,5) ,SUBSTRING(&#x27;helloworld&#x27;,5),SUBSTRING(&#x27;helloworld&#x27;,-5);SELECT MID(&#x27;helloworld&#x27;,1,5) ,MID(&#x27;helloworld&#x27;,5),MID(&#x27;helloworld&#x27;,-5); 查找索引 1SELECT LOCATE(&#x27;o&#x27;,&#x27;helloworld&#x27;) ,POSITION(&#x27;o&#x27; IN &#x27;helloworld&#x27;),INSTR(&#x27;helloworld&#x27;,&#x27;o&#x27;) ; 2.3 日期函数当前日期 123456-- 年月日SELECT CURRENT_DATE , CURRENT_DATE() , CURDATE();-- 时分秒SELECT CURRENT_TIME ,CURRENT_TIME(), CURTIME();-- 年月日 时分秒SELECT CURRENT_TIMESTAMP,CURRENT_TIMESTAMP(),LOCALTIME(),NOW(),SYSDATE() ; 日期之间相差天数 1SELECT DATEDIFF(NOW(),hiredate) FROM emp ; 当前日期该月最后一天 1SELECT LAST_DAY(NOW()) ; 日期加减 123SELECT DATE_ADD(NOW(),INTERVAL 1 DAY) ;SELECT DATE_SUB(NOW(),INTERVAL 1 DAY) ; 周 年 月 小时 分 12345SELECT WEEK(NOW()),YEAR(NOW()),MONTH(NOW()),HOUR(NOW()),MINUTE(NOW()) ;SELECT DAYOFMONTH(NOW()),DAY(NOW()),DAYOFYEAR(NOW()) ;-- 提取日期中 部分字段SELECT EXTRACT(YEAR FROM NOW()),EXTRACT(MONTH FROM NOW()) ; 日期格式化 12SELECT DATE_FORMAT(NOW(),&#x27;%Y/%m/%d %h:%i&#x27;);SELECT * FROM emp WHERE DATE_FORMAT(hiredate,&#x27;%m&#x27;) = &#x27;02&#x27; ; 2.4 条件判断函数if 12SELECT IF(3&lt;2,&#x27;aaa&#x27;,&#x27;bbb&#x27;);SELECT IF(STRCMP(&#x27;xyz&#x27;,&#x27;abc&#x27;),&#x27;yes&#x27;,&#x27;no&#x27;); ifnull 1SELECT sal+IFNULL(comm,0) FROM emp ; case 12345678910111213-- 根据部门 10 dev 20 test 30 public others SELECT empno, ename, CASE deptno WHEN 10 THEN &#x27;dev&#x27; WHEN 20 THEN &#x27;test&#x27; WHEN 30 THEN &#x27;public&#x27; ELSE &#x27;others&#x27; END dnameFROM emp ; 例2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546-- 1 找出每个月倒数第三天受雇的员工（如：2009-5-29） -- date_add last_dayselect * from emp where date_add(hiredate,INTERVAL 2 day) = last_day(hiredate);-- 2 找出 25 年前雇的员工 -- datediffselect * from emp where datediff(now(),hiredate)/365&gt;25 ;-- 3 所有员工名字前加上 Dear ,并且名字首字母大写 -- concat concat_ws upper substring midselect concat(&#x27;Dear&#x27;,upper(mid(ename,1,1)),mid(ename,2)) from emp ;-- 4 找出姓名为 5 个字母的员工 -- char_length like _select * from emp where char_length(ename) = 5 ;-- 5 找出姓名中不带 R 这个字母的员工 -- not likeselect * from emp where ename not like &#x27;%R%&#x27; ;-- 6 显示所有员工的姓名的第一个字 -- substringselect substring(ename,1,1) from emp ;-- 7 显示所有员工，按名字降序排列，若相同，则按工资升序排序 select ename,sal from emp order by ename desc , sal asc ;-- 8 假设一个月为 30 天，找出所有员工的日薪，不计小数 -- floor isnull if ifnullselect floor((sal+ifnull(comm,0))/30) from emp ;-- 9 找到 2 月份受雇的员工 -- month date_formatselect * from emp where month(hiredate) = 2 ;-- 10 列出员工加入公司的天数(四舍五入） select datediff(now(),hiredate) from emp ;-- 11 分别用 case 列出员工所在的部门，-- deptno=10 显示&#x27;部门 10&#x27;, -- deptno=20 显示&#x27;部门 20&#x27; -- deptno=30 显示&#x27;部门 30&#x27; -- deptno=40 显示&#x27;部门 40&#x27; -- 否则为&#x27;其他部门&#x27; select empno,ename ,case when deptno between 10 and 30 then &#x27;重要部门&#x27; when deptno&gt;40 then &#x27;辅助部门&#x27; else &#x27;其他部门&#x27; end dname from emp ; 3. 分组函数统计函数 组函数 聚合函数 count sum min max avg 3.1 注意：null值不参与统计 123SELECT COUNT(comm) FROM emp ; -- 4 表中数据 16行SELECT COUNT(0) FROM emp ; 分组函数不能出现where子句 12-- 查询工资大于平均工资的员工SELECT * FROM emp WHERE sal &gt; AVG(sal) ; 3.2 group by注意： 只要有group by 子句： ​ select 子句要求：只能写 group by 出现的列名 + 5 个分组函数 12345678910SELECT deptno, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno ; 多个分组条件： 12345678910SELECT deptno,job, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno,job ; 3.3 having123456789-- 根据部门分组 查询部门人数大于 2人的部门编号 人数-- 根据部门分组 查询部门人数大于 2人的部门编号 人数SELECT deptno, COUNT(0) dept_countFROM empGROUP BY deptnoHAVING COUNT(0)&gt;2 ; 3.4 完整的SQL1234567891011121314select 列名1 ,列名2...列名Nfrom 表1,表2 .... 表Nwhere 限制行【分组前过滤】group by 分组列having 分组后过滤order by 排序limit 偏移量,行数 12345678910111213-- 查询工资大于500 按照部门分组 如果部门相同按照工种分组 人数大于等于1 按照人数排降序 第2~5条SELECT deptno, job, COUNT(0) dept_count FROM emp WHERE sal &gt; 500 GROUP BY deptno, job HAVING COUNT(0) &gt;= 1 ORDER BY 3 DESC LIMIT 2, 3 ; 3.5 行列转换12345678910CREATE TABLE stu( sname VARCHAR(20), sub VARCHAR(20), score VARCHAR(20));INSERT INTO stu (sname,sub,score) VALUES (&#x27;zs&#x27;,&#x27;chinese&#x27;,&#x27;100&#x27;),(&#x27;zs&#x27;,&#x27;math&#x27;,&#x27;99&#x27;),(&#x27;zs&#x27;,&#x27;english&#x27;,&#x27;98&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;li&#x27;,&#x27;chinese&#x27;,&#x27;80&#x27;),(&#x27;li&#x27;,&#x27;math&#x27;,&#x27;89&#x27;),(&#x27;li&#x27;,&#x27;english&#x27;,&#x27;88&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;ww&#x27;,&#x27;chinese&#x27;,&#x27;70&#x27;),(&#x27;ww&#x27;,&#x27;math&#x27;,&#x27;79&#x27;),(&#x27;ww&#x27;,&#x27;english&#x27;,&#x27;78&#x27;);COMMIT ; 1234567SELECT sname, CASE sub WHEN &#x27;chinese&#x27; THEN score END chinese , CASE sub WHEN &#x27;math&#x27; THEN score END math , CASE sub WHEN &#x27;english&#x27; THEN score END english FROM stu 12345678SELECT sname, SUM(CASE sub WHEN &#x27;chinese&#x27; THEN score END) chinese , SUM(CASE sub WHEN &#x27;math&#x27; THEN score END) math , SUM(CASE sub WHEN &#x27;english&#x27; THEN score END) english FROM stu GROUP BY sname 例3:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-- 1 分组统计各部门下工资&gt;500 的员工的平均工资-- group by deptno 分组统计各部门-- where sal &gt; 500 工资&gt;500 的员工-- select avg(sal) 平均工资-- from emp 员工select deptno,avg(sal) avg_sal from emp where sal&gt;500 group by deptno ;-- 2 统计各部门下平均工资大于 500 的部门 -- group by deptno 统计各部门-- select avg(sal)-- having avg(sal)&gt;500 工资大于 500 select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;500 ;-- 3 算出部门 30 中得到最多奖金的员工奖金 -- where deptno = 30 部门 30-- select max(comm) 最多奖金select max(comm) from emp where deptno = 30 ;-- 4 算出部门 30 中得到最多奖金的员工姓名 -- where deptno = 30 部门 30 得到最多奖金-- select ename 员工姓名-- select ename,comm from emp where deptno=30 order by comm desc limit 0,1;-- select ename,comm from emp where deptno=30 and comm=(select max(comm) from emp where deptno = 30 ) ;select ename,comm from emp where (deptno,comm)=(select deptno,max(comm) from emp where deptno = 30 ) ;-- 5 算出每个职位的员工数和最低工资 -- group by job 每个职位-- select count(0) , min(sal) 员工数和最低工资select job,count(0) , min(sal) from emp group by job ;-- 6 算出每个部门,每个职位的平均工资和平均奖金(平均值包括没有奖金)，-- 如果平均奖金大于 300，显示“奖金不错”，-- 如果平均奖金 100 到 300，显示“奖金一般”，-- 如果平均奖金小于 100，显示“基本没有奖金”，-- 按部门编号降序，平均工资降序排列-- group by deptno,job 每个部门,每个职位-- select avg(sal) ,avg(ifnull(comm,0)) 平均工资和平均奖金-- case when then end .. 显示转换-- order by deptno desc ,avg(sal) desc 按部门编号降序，平均工资降序排列select deptno,job,avg(sal) ,case when avg(ifnull(comm,0))&gt;300 then &#x27;奖金不错&#x27; when avg(ifnull(comm,0))&gt;=100 and avg(ifnull(comm,0))&lt;=300 then &#x27;奖金一般&#x27; when avg(ifnull(comm,0))&lt;100 then &#x27;基本没有奖金&#x27; end comm_msg from emp group by deptno,job order by deptno desc ,avg(sal) desc;-- 7 列出员工表中每个部门的员工数，和部门 no -- group by deptno 每个部门-- select count(0) , deptno 员工数，和部门 noselect count(0) , deptno from emp group by deptno ;-- 8 得到工资大于自己部门平均工资的员工信息 -- 注意： 别名select * from emp e where sal &gt; (select avg(sal) from emp where deptno=e.deptno) ;-- 9 分组统计每个部门下，每种职位的平均奖金（也要算没奖金的人）和总工资(包括奖金) -- group by deptno,job ; 每个部门下，每种职位-- select avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) 平均奖金（也要算没奖金的人）和总工资(包括奖金) select deptno,job,avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) from emp group by deptno,job; 4. 多表查询 4.1 笛卡尔集【积】 Cross join行相乘 列相加 【大结果集】 bug 【避免该查询】忘记写 where 条件 ，或条件无效 1234-- 忘记写 where 条件SELECT * FROM emp,dept,salgrade ;-- 条件无效 SELECT * FROM emp,dept,salgrade WHERE emp.deptno=emp.deptno; 4.2 等值连接 Equi join&#x2F;Natural join两张表的数据 必须相关 【外键值 &#x3D; 另一张表的主键值】 等值连接 12-- 查询姓名 部门名称SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e , dept d WHERE e.deptno = d.deptno 自然连接【两表中同名的列】 12-- EMP deptno [emp 的 FK] Dept deptno [dept 的 PK]SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e NATURAL JOIN dept d ; 4.3 非等值连接 Non-Equijoin参考值 【emp表 sal 3000 salgrade表 3000 ？1201~4000】 1234567891011-- 查询工号，姓名 ，工资，工资等级SELECT e.empno, e.ename, e.sal, s.grade FROM emp e, salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal ; 4.4 自连接 Self join树型表 无限级分类表 【表的FK 指向自己表的主键】 必须使用别名 123456SELECT COUNT(0) FROM emp e,emp m ; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.empno = e.empno; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.mgr = m.empno; -- 自连接-- 查询员工姓名 工资 直接领导姓名 工资 SELECT e.ename emp_name,e.sal emp_sal,m.ename mgr_name,m.sal mgr_sal FROM emp e, emp m WHERE e.mgr = m.empno ; 4.5 左外连接 Left Outer Join123456789-- 查询所有员工姓名 部门名称 包括没有部门的员工SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno ; 4.6 右外连接 Right Outer Join123456789-- 查询所有部门名称 包括没有员工的 部门select e.ename, d.deptno, d.dname from emp e right outer join dept d on e.deptno = d.deptno ; 4.7 满外连接 Full Outer Joinmysql 不支持 Full join 【通过集合操作 union 合集】 12345678910111213141516171819-- 查询所有部门名称 包括没有员工的 部门 -- + 所有员工姓名 部门名称 包括没有部门的员工(SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno) UNION(SELECT e.ename, d.deptno, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno = d.deptno) 4.8 内连接 Inner Join12-- 查询 员工姓名 部门名SELECT e.ename,d.deptno,dname FROM emp e INNER JOIN dept d ON e.deptno = d.deptno ; 4.9 集合操作并集【UNION ，UNION ALL】 UNION 自动去重复 速度慢 UNION ALL 保留重复 速度快 注意： 列的个数相同 列的数据类型一致 无序 123456SELECT* FROM((SELECT * FROM emp WHERE deptno = 10 ORDER BY sal DESC )UNION(SELECT * FROM emp WHERE deptno = 20 ORDER BY sal DESC ))t ORDER BY t.sal DESC ; 5. 子查询子查询：where 子句 ，from子句，select 子句 , having 子句 123456789101112131415161718-- select 子句 [标量子查询]SELECT ename,(SELECT dname FROM dept WHERE deptno=e.deptno) dname FROM emp e;-- having 子句SELECT MIN(sal), deptno FROM emp GROUP BY deptno HAVING MIN(sal) = (SELECT MIN(min_sal) FROM (SELECT MIN(sal) min_sal FROM emp GROUP BY deptno) t) ; 子查询不返回 主查询不返回 12-- 查询工资比 工号8888 的员工还高员工姓名SELECT * FROM emp WHERE sal&gt;(SELECT sal FROM emp WHERE empno = 8888) ; 单列 对 多列 1SELECT * FROM emp WHERE sal&gt;(SELECT ename,sal FROM emp WHERE empno = 7788) ; 单行 对 多行 12-- Subquery returns more than 1 rowSELECT * FROM emp WHERE sal = (SELECT MIN(sal) FROM emp GROUP BY deptno) ; 5.1 单行子查询子查询结果【单行】 比较运算符 &#x3D; !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 12345678910111213-- 查询大于平均工资的员工SELECT * FROM emp WHERE sal &gt; (SELECT AVG(sal) FROM emp) ; -- 查询 7788 相同部门 工种的员工SELECT * FROM emp WHERE (deptno,job)=(SELECT deptno,job FROM emp WHERE empno = 7788) 注意：返回多行 【一行 对多行&#x2F;多值 ，一列对多列 ，NULL&#x2F;空值】 5.2 多行子查询返回 多行 【包含单行 –&gt; NULL值】 in 【 &#x3D; any ，&#x3D; some】 ，not in ， &gt; all &gt;&#x3D; all &lt; &lt;&#x3D; all ,&gt;any in ，not in 【无法使用索引查询，查询全表扫描】 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename,e.sal FROM emp e ,(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) tWHERE e.deptno = t.deptno AND e.sal = t.dept_min_sal ;-- 子查询SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) IN(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =ANY(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =SOME(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) exists ，not exists 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename, e.sal FROM emp e WHERE EXISTS (SELECT NULL FROM emp GROUP BY deptno HAVING deptno = e.deptno AND MIN(sal) = e.sal) ; in VS exists 1234in : 无法使用索引，全表扫描 not in 【注意去 null值】 主查询 3KW 子查询 1Kexists : 使用索引，不使用全表扫描 not exists 主查询 1k 子查询 3kw","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Mysql安装过程详解","slug":"Mysql安装过程详解","date":"2023-07-03T03:48:58.000Z","updated":"2023-07-11T01:36:53.605Z","comments":true,"path":"2023/07/03/Mysql安装过程详解/","link":"","permalink":"http://example.com/2023/07/03/Mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Mysql安装&#x2F;卸载1 卸载 2 安装下载https://downloads.mysql.com/archives/installer/ 安装 卸载不干净，无法安装 【解决方案】 https://blog.csdn.net/weixin_43147354/article/details/117241786 MicrosoftProgram_Install_and_Uninstall.meta.diagcab","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java-IO流","slug":"Java-IO流","date":"2023-07-01T12:15:14.000Z","updated":"2023-07-01T14:36:24.329Z","comments":true,"path":"2023/07/01/Java-IO流/","link":"","permalink":"http://example.com/2023/07/01/Java-IO%E6%B5%81/","excerpt":"","text":"1. File1.1 File与流 1.2 File练习例11234567891011121314151617181920/*使用File对象，在C盘创建aaa/bbb/ccc的文件夹，在此文件夹下创建1.txt【C:/aaa/bbb/ccc/1.txt】 如果该文件存在，删除1.txt 如果该文件不存在，创建1.txt*/import java.io.File;import java.io.IOException;public class FileTest01 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\aaa\\\\bbb\\\\ccc\\\\1.txt&quot;); if (file.exists())&#123; file.delete(); &#125;else&#123; //创建文件夹 file.getParentFile().mkdirs(); //创建 文件 file.createNewFile(); &#125; &#125;&#125; 例21234567891011121314151617/*使用File对象 listFiles() 方法自定义类 implements FilenameFilterC:\\Program Files\\Java\\jdk1.8.0_321\\bin目录下，所有的 .exe结尾的文件打印出来。*/import java.io.File;import java.io.FilenameFilter;import java.io.IOException;import java.util.stream.Stream;public class FileTest02 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_361\\\\bin&quot;); String[] ay = file.list((dir, name) -&gt; name.endsWith(&quot;.exe&quot;)); Stream.of(ay).forEach(System.out::println); &#125;&#125; 2. 节点流2.1 字节流 2.2 节点流练习例312345678910111213141516171819202122232425/*使用FileOutputStream 向1.txt文件写入： A~Z 字符在 文件 结尾：a~z字符*/import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class FileOutputStreamTest03 &#123; public static void main(String[] args) throws IOException &#123; //输出流 自动创建文件 OutputStream os = new FileOutputStream(&quot;1.txt&quot;,true) ; //写 byte 比如：A for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125; /*for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125;*/ //建议： 可选 //os.flush(); os.close(); &#125;&#125; 例412345678910111213141516171819202122232425262728293031/*使用FileInputStream IDEA具体的JAVA文件 比如： Test1.java打印该Java文件中所有的内容*/import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class FileInputStreamTest04 &#123; public static void main(String[] args) throws IOException &#123; //输入流 注意：目标数据源 一定存在的 InputStream is = new FileInputStream(&quot;Test1.java&quot;) ; //读 /*while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; System.out.print((char)data); &#125;*/ int data = 0 ; while((data = is.read())!=-1)&#123; System.out.print((char)data); &#125; is.close(); &#125;&#125; 2.3 字符流 2.4 节点流 输入流 输出流 例51234567891011121314151617181920212223/*使用流 实现把图片从C盘拷贝D盘。*/import java.io.*;public class PicCopyTest05 &#123; public static void main(String[] args) throws IOException &#123; //1.输入流 怼到 目标数据源 InputStream is = new FileInputStream(&quot;D:\\\\Java180_2\\\\doc\\\\day01-html基础\\\\res\\\\mm.jpg&quot;) ; //2.输出流 项目下 OutputStream os = new FileOutputStream(&quot;meimei.jpg&quot;) ; //3. 读 while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; //4.写 os.write(data); &#125; System.out.println(&quot;====图片拷贝结束=========&quot;); &#125;&#125; 3. 处理流3.1 流嵌套 3.2 处理流 3.3 调包侠https://commons.apache.org/proper/commons-io/description.html 4. 对象流 例61234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用对象流 实现对对象实现读写功能*///写入import java.io.*;public class ObjectOutputStreamTest11 &#123; public static void main(String[] args) throws IOException &#123; //1.对象 创建商品对象 【A.瞬时状态 -- JVM 内存】 Goods goods = new Goods(&quot;G1001&quot;, &quot;苹果&quot;, 4.5D); //2. 写入 4.txt 文件 节点文件流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;4.txt&quot;)) ; /*OutputStream os = new FileOutputStream(&quot;4.txt&quot;) ; ObjectOutputStream oos = new ObjectOutputStream(os) ;*/ //【B.持久状态 -- 文件系统】 //goods.setName(&quot;香蕉&quot;); //对象流 写入 oos.writeObject(goods); oos.flush(); oos.close(); //【C.脱管状态 -- 脱离管理】 //goods.setName(&quot;菠萝&quot;); &#125;&#125;//读取import java.io.*;public class ObjectInputStreamTest12 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.读取 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;4.txt&quot;)) ; Object o = ois.readObject(); ois.close(); System.out.println(o); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-集合","slug":"Java-集合","date":"2023-06-29T14:07:43.000Z","updated":"2023-07-01T08:40:15.066Z","comments":true,"path":"2023/06/29/Java-集合/","link":"","permalink":"http://example.com/2023/06/29/Java-%E9%9B%86%E5%90%88/","excerpt":"","text":"1. Map集合框架类图 HashMap常用方法 API 例1：1234567891011121314151617181920212223242526272829/*1.遍历集合，并将序号与对应人名打印。2.向该map插入一个编码为5姓名为李晓红3.移除该map中的编号为1的信息4.将map集合中编号为2的姓名信息修改为&quot;周琳&quot;*/import java.util.HashMap;import java.util.Map;public class Ex01 &#123; public static void main(String[] args) &#123; Map map =new HashMap();//多态 map.put(1,&quot;张三丰&quot;); map.put(2,&quot;周芷若&quot;); map.put(3,&quot;汪峰&quot;); map.put(4,&quot;灭绝师太&quot;); //1.循环遍历 map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); //2.插入 map.put(5,&quot;李晓红&quot;); //3.移除 map.remove(1); //4.修改 //map.put(2,&quot;周琳&quot;); map.replace(2,&quot;周琳&quot;); System.out.println(&quot;==============================&quot;); map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); &#125;&#125; java8 参考循环输出： 123456Map map = new HashMap() ;map.put(1,&quot;张三1&quot;) ;map.put(2,&quot;张三2&quot;) ;map.put(3,&quot;张三3&quot;) ;// java lambda表达式 类似 ES6 的箭头函数 【可推导即可省略】map.forEach((k,v)-&gt; System.out.println(&quot;序号:&quot;+k+&quot;,姓名:&quot;+v)); 例2：1234567891011121314151617181920212223242526/*有2个数组，第一个省份数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，第二个省会数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为key，第二个数组元素作为value存储到Map集合中。如&#123;黑龙江省=哈尔滨, 浙江省=杭州, …&#125;。*/import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class Ex02 &#123; public static void main(String[] args) &#123; String[] proAy = &#123;&quot;黑龙江省&quot;,&quot;浙江省&quot;,&quot;江西省&quot;,&quot;广东省&quot;,&quot;福建省&quot;&#125; ; String[] cityAy = &#123;&quot;哈尔滨&quot;,&quot;杭州&quot;,&quot;南昌&quot;,&quot;广州&quot;,&quot;福州&quot;&#125; ; Map map = new LinkedHashMap(); // 把 数组中的元素 存放在 map的 条目中 for (int i=0;i&lt;proAy.length;i++)&#123; map.put(proAy[i],cityAy[i]); &#125; //打印map 无需循环 &#123;key=value,key=value&#125; System.out.println(map); &#125;&#125; 例3：1234567891011/*定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。 List list = new ArrayList() ;例如：集合中有”abc”、”bcd”两个元素， list.add(“abc”) ; list.add(“bcd”) ;程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。 Map map = ... String 类 1. length() 字母个数 2. charAt() 根据索引 获得 字母*/ Hashtable1null值问题? 对比： 2. Iterator基本使用 例41234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用ArrayList存储多个学生信息1. 删除年龄&gt;18岁的学生2. 使用Iterator进行遍历 */import java.util.ArrayList;import java.util.Iterator;import java.util.function.Predicate;/** * 使用ArrayList存储多个学生信息 * 1. 删除年龄&gt;18岁的学生 * 2. 使用Iterator进行遍历 */public class Ex04 &#123; public static void main(String[] args) &#123; ArrayList&lt;Stu&gt; stuList = new ArrayList(); stuList.add(new Stu(19)) ; stuList.add(new Stu(39)) ; stuList.add(new Stu(14)) ; stuList.add(new Stu(16)) ; stuList.add(new Stu(26)) ; stuList.add(new Stu(12)) ; //推荐 java8的语法 removeIf(e-&gt;e.getAge()&gt;18) forEach(System.out::println) //stuList.removeIf( o -&gt; ((Stu)o).getAge()&gt;18 ) ; //stuList.removeIf( o -&gt; o.getAge()&gt;18 ) ; //stuList.forEach(System.out::println); //Iterator 判断有没有下一个元素 hasNext() 取出下一个元素 next() 删除当前元素 remove() Iterator&lt;Stu&gt; iterator = stuList.iterator(); while (iterator.hasNext()) &#123; //腐烂味道代码 坏味道代码 Stu stu = iterator.next(); if (stu.getAge()&gt;18)&#123; iterator.remove(); &#125; &#125; System.out.println(stuList); &#125;&#125; 参考java8 List 删除元素： 12345678List list = new ArrayList() ;list.add(new Stu(1,&quot;aaa&quot;,19)) ;list.add(new Stu(2,&quot;bbb&quot;,16)) ;list.add(new Stu(3,&quot;ccc&quot;,14)) ;//如果满足条件 进行删除list.removeIf(ele-&gt;((Stu)ele).getAge()&gt;18) ;//循环输出list.forEach(System.out::println); 3. 泛型为什么 怎么用 4. Set4.1 HashSet 例512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.HashSet;import java.util.Random;import java.util.Set;/** * 双色球规则： * 双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。 * 红色球号码从1—33中选择； * 蓝色球号码从1—16中选择； * 请随机生成一注双色球号码。 * （要求同色号码不重复） */public class Ex05 &#123; public static void main(String[] args) &#123; Random random = new Random(); // 蓝色球号码 int blueBall = random.nextInt(16)+1 ; HashSet&lt;Ball&gt; ballSet = new LinkedHashSet&lt;&gt;() ; // 一个 蓝色球 ballSet.add(new Ball(&quot;蓝球&quot;,blueBall)) ; while (ballSet.size() != 7) &#123; //红色球号码 int redBall = random.nextInt(33)+1 ; ballSet.add(new Ball(&quot;红球&quot;,redBall)) ; &#125; System.out.println(ballSet); &#125;&#125;class Ball&#123; private String color ; private Integer num ; public Ball(String color, Integer num) &#123; this.color = color; this.num = num; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Ball ball = (Ball) o; return Objects.equals(color, ball.color) &amp;&amp; Objects.equals(num, ball.num); &#125; @Override public int hashCode() &#123; return Objects.hash(color, num); &#125; @Override public String toString() &#123; return &quot;Ball&#123;&quot; + &quot;color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &quot;, num=&quot; + num + &#x27;&#125;&#x27;; &#125;&#125; 5. Map练习5.1 Map练习例61234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162一、利用Map，完成下面的功能：/*从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。如果该年没有举办世界杯，则输出：没有举办世界杯。*/import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Ex06 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //map.put(2023,null); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入年份:&quot;); //怼死 死去活来法 int year = scanner.nextInt(); String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg); scanner.close(); /*String team = map.get(year); if (team!=null)&#123; System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /*if (map.containsKey(year)) &#123; String team = map.get(year); System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /* String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg);*/ &#125;&#125; 例712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Scanner;/** * 二、在原有世界杯Map 的基础上， * 增加如下功能： * 读入一支球队的名字，输出该球队夺冠的年份列表。 * 例如， * 读入“巴西”，应当输出 1958 1962 1970 1994 2002 * 读入“荷兰”，应当输出 没有获得过世界杯 */public class Ex07 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //逆向思维 Map&lt;String, StringBuilder&gt; teamMap = new HashMap&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; //当前 队伍 map集合中 是否包含当前 队伍 if (teamMap.containsKey(name)) &#123; // 字符串 缓存中 添加新的年份 StringBuilder sb = teamMap.get(name); sb.append(year).append(&quot;\\t&quot;) ; &#125;else &#123; //如果不包含 直接存放当前年份 teamMap.put(name, new StringBuilder(year + &quot;\\t&quot;)); &#125; &#125;); // System.out.println(teamMap); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一支球队的名字:&quot;); //怼死 死去活来法 String year = scanner.next(); String msg = teamMap.getOrDefault(year, new StringBuilder(&quot;没有获得过世界杯&quot;)).toString(); System.out.println(msg); &#125;&#125; 123456789101112131415//另一种方法 String inputTeamName = scanner.next(); AtomicBoolean isPrint = new AtomicBoolean(true); map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; System.out.println(year); //System.exit(-1); isPrint.set(false); &#125; &#125;); if (isPrint.get()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; 123456789101112131415161718//第三种方法 String inputTeamName = scanner.next(); //存放 获得世界杯的年份集合 List&lt;Integer&gt; yearList = new ArrayList&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; yearList.add(year) ; &#125; &#125;); //集合为空 条件没有满足 if (yearList.isEmpty()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; yearList.forEach(System.out::println); 5.2 Map.Entry 5.3 Map综合案例1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * * 将以上对应关系的数据存储到map集合中，key：表示站编号，value：表示站名，并遍历打印(可以不按顺序打印)： * 例如： * 第10站: 森林公园南门 * 第6站: 育新 * 第12站: 奥体中心 * 第13站: 北土城 */public class EX &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); &#125;&#125; 例81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * *计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； */public class Ex08 &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); //站之间的数量 int money = caclMoney(13) ; System.out.println(&quot;共:&quot; + money); &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; Map&lt;Integer,Integer&gt; moneyMap = new HashMap&lt;&gt;() ; moneyMap.put(0,3) ; moneyMap.put(1,3) ; moneyMap.put(2,3) ; moneyMap.put(3,3) ; moneyMap.put(4,4) ; moneyMap.put(5,4) ; // .... moneyMap.put(0,3) ; moneyMap.put(0,3) ; return count ; /*if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ;*/ &#125;&#125; 例9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*计算地铁票价规则： 总行程 3站内（包含3站）收费3元， 3站以上但不超过5站（包含5站）的收费4元， 5站以上的，在4元的基础上，每多1站增加2元， 10元封顶；*/import java.util.ArrayList;import java.util.HashMap;import java.util.Map;public class Test09 &#123; public static void main(String[] args) &#123; ArrayList&lt;Num&gt; numList = new ArrayList(); Map map = new HashMap(); map.put(1,&quot;朱辛庄&quot;); map.put(2,&quot;育知路&quot;); map.put(3,&quot;平西府&quot;); map.put(4,&quot;回龙观东大街&quot;); map.put(5,&quot;霍营&quot;); map.put(6,&quot;育新&quot;); map.put(7,&quot;西小口&quot;); map.put(8,&quot;永泰庄&quot;); map.put(9,&quot;林萃桥&quot;); map.put(10,&quot;森林公园南门&quot;); map.put(11,&quot;奥林匹克公园&quot;); map.put(12,&quot;奥体中心&quot;); map.put(13,&quot;北土城&quot;); for (Object j : map.keySet())&#123; System.out.println(&quot;第&quot; +j +&quot;站: &quot; +map.get(j)); &#125; int i=1; numList.add(new Num(1,3)) ; numList.add(new Num(2,3)) ; numList.add(new Num(3,3)) ; numList.add(new Num(4,4)) ; numList.add(new Num(5,4)) ; numList.add(new Num(5+i,4+2*i)) ; /*numList.forEach((k,v)-&gt;&#123; if(k.equals()&lt;=3)&#123; System.out.println(k + &quot; &quot;); &#125; &#125;);*/ &#125;&#125;class Num&#123; int number ; int money; public int getMoney() &#123; return money; &#125; public int getNumber() &#123; return number; &#125; public Num(int number,int money) &#123; this.number = number; this.money = money; &#125; @Override public String toString() &#123; return &quot;homework.Num&#123;&quot; + &quot;number=&quot; + number + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 例1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * 打印格式（需要对键盘录入的上车站和到达站进行判断，如果没有该站，提示重新输入，直到站名存在为止）： 注意：每站需要2分钟 请输入上车站： 朱辛庄 请输入到达站： 西小口 从朱辛庄到西小口共经过6站收费6元，大约需要 12分钟； */public class Ex09 &#123; private static String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ; private static Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; public static void main(String[] args) &#123;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); String beginName = &quot;林萃桥&quot; ; String endName = &quot;平西府&quot;; int count = caclCount(beginName, endName); int time = count*2 ; //站之间的数量 int money = caclMoney(count) ; System.out.println(&quot;从&quot;+beginName+&quot;到&quot;+endName+&quot;共经过&quot;+count+&quot;站收费&quot;+money+&quot;元，大约需要 &quot;+time+&quot;分钟&quot;); &#125; /** * 根据 两站 站名 计算 之间 站之间的数量 * @param beginName * @param endName * @return */ private static int caclCount(String beginName,String endName)&#123; //map的 key站名 value 站序号 反转 Map&lt;String,Integer&gt; name2IndxMap = new HashMap&lt;&gt;() ; //站序号 站名 map.forEach((idx,name)-&gt; name2IndxMap.put(name,idx)); Integer beginIdx = name2IndxMap.get(beginName); Integer endIdx = name2IndxMap.get(endName); return Math.abs(beginIdx-endIdx) ; &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ; &#125;&#125; 6.Set扩展6.1 TreeSet 6.2 例11123456789101112131415161718192021222324252627/*学生类 姓名 分数 double 存放 TreeSet中 实现 根据 分数 从大到小 内部排序Comparable 外部排序 ComparatorSet&lt;Stu&gt; set = new TreeSet&lt;&gt;() ;set.add(new Stu(“aa”,98.5)) ;set.add(new Stu(“bb”,88.5)) ;*/package set;import java.util.*;public class Ex11 &#123; public static void main(String[] args) &#123; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; (int) (c1.getScore()-c2.getScore())) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; c1.getScore().compareTo(c2.getScore())) ;// Set&lt;Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparing(Customer::getScore)) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(set.Customer::getScore)) ; Set&lt;Customer&gt; set = new TreeSet&lt;&gt;() ; set.add(new Customer(&quot;小丽&quot;,500D)) ; set.add(new Customer(&quot;小红&quot;,400.8)) ; set.add(new Customer(&quot;小夏&quot;,400.3)) ; set.add(new Customer(&quot;小花&quot;,700D)) ; set.forEach(System.out::println); &#125;&#125; java8 外部排序写法： 1Set&lt;Stu&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(Stu::getAge)) ; 7. Collections7.1 辅助类 7.2 例1212345678910111213141516171819202122232425262728/* 1. List&lt;Stu&gt; Collections.sort(stuList) Comparable Collections.sort(stuList,...) Comparator 分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序， 如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。*/package collections;import set.Customer;import java.util.Arrays;import java.util.Collections;import java.util.List;public class Ex12 &#123; public static void main(String[] args) &#123; //集合中 存放 Customer List&lt;Customer&gt; customerList = Arrays.asList(new Customer(&quot;aaa&quot;,100D),new Customer(&quot;bbb&quot;,80.5D),new Customer(&quot;ccc&quot;,90D)) ; //jdk1.8 新特性 不使用辅助类 Collections //customerList.sort((c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); //使用 辅助类 Collections //Collections.sort(customerList); Collections.sort(customerList,(c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); customerList.forEach(System.out::println); &#125;&#125; 8. Map扩展8.1 LinkedHashSet 8.2 LinkedHashMap 8.3 ConcurrentHashMap 8.4 Properties 9.泛型扩展9.1 什么是泛型 9.2 泛型好处 9.3 使用前后对比 9.4 类型参数 9.5 方法参数 9.6 泛型不是协变的 9.7 类型通配符 9.8 泛型局限性","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java开发利器--idea安装过程详解","slug":"Java开发利器-idea安装过程详解","date":"2023-06-29T13:46:51.000Z","updated":"2023-07-03T05:31:41.850Z","comments":true,"path":"2023/06/29/Java开发利器-idea安装过程详解/","link":"","permalink":"http://example.com/2023/06/29/Java%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-idea%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"0. IDEA0.1 安装 0.2 配置破解11. 打开 readme.txt 安装步骤进行破解 JDK 字体 编码 0.3 运行创建项目 创建Java类 编写&#x2F;运行源代码 0.4 debug 0.5 卸载 删除安装目录：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"ES6及之后新特性一览","slug":"ES6及之后新特性一览","date":"2023-06-25T04:40:11.000Z","updated":"2023-07-01T08:40:14.329Z","comments":true,"path":"2023/06/25/ES6及之后新特性一览/","link":"","permalink":"http://example.com/2023/06/25/ES6%E5%8F%8A%E4%B9%8B%E5%90%8E%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/","excerpt":"","text":"let声明变量let 声明变量1.let 不允许重复声明变量 var 可以重复声明2.let 不支持变量的声明提升，var可以3.let声明的变量会被所有代码块（{}内的范围）限制作用范围 var只会受到函数影响4.let 声明的变量不和顶层变量挂钩 const 声明常量const 声明常量1.const 不可以重复声明2.不支持声明提升3.作用范围受{}影响4.不和最上层对象window挂钩const num &#x3D; 10;const num &#x3D; 20;&#x2F;&#x2F;Cannot redeclare block-scoped variable ‘num’if(true){ const a &#x3D; 20;}console.log(a); let和const区别1.let声明的变量可以被修改，const声明的是常量 不可以改变2.let声明时可以不赋值，const声明时必须赋值 变量的解构赋值解构赋值；就是快速的从对象或者数组中取出成员的一个语法方式 解构对象12345678const obj = &#123; name:&quot;zs&quot;, age:18, genders:&quot;男&quot;&#125;let name = obj.name;let age = obj.age;let genders = obj.genders; 123456789101112131415const obj2 = &#123; name:&quot;ls&quot;, age:18, genders:&quot;女&quot;&#125;//解构对象//前面的必须是&#123;&#125;表示要从obj2这个对象中获取对象成员//name age genders 都是obj2的现有成员//obj2必须是对象let&#123;name,age,genders&#125; = obj2;console.log(name,age,genders);let&#123;name:a,age:b,genders:c&#125; = obj2;console.log(a,b,c);let&#123;max,min,ceil,floor,random&#125;=Math;console.log(max(10,20,30)); 解构数组12345678//使用解构赋值的方式从数组中提取成员const arr2 = [&quot;一&quot;,&quot;二&quot;,&quot;三&quot;];//解构数组//a b c 分别对应这个数组中的索引下标0 1 2//arr2 必须是数组//如果解构失败，返回结果就是undefinedlet [a,b,c,d] = arr2;console.log(a,b,c,d); 模板字符串ES5中 表示字符串的时候使用’’或者””ES6中 还有一种可以表示字符串的方法 就是&#96;&#96;ES5 字符串 需要同行书写，换行后需要拼接字符串 12const str2 = &#x27;hello&#x27; +&#x27;world&#x27; ES6 可以直接换行使用 12const str3 = `hello world` &#96;&#96;的拼接方式与””不同 12console.log(&quot;我要&quot;+a+&quot;块钱&quot;)console.log(`我要$&#123;a&#125;块钱`) 字符串与数值拓展字符串12345678910111213let &#123;log&#125; = console;let str = &quot;Tom&quot;;//判断字符串中是否存在指定字符 返回true或者falselet res = str.includes(&quot;opm&quot;);//判断字符串中以指定字符开头 返回true或者falseres = str.startsWith(&quot;p&quot;)//判断字符串中以指定字符结尾 返回true或者falseres = str.endsWith(&quot;m&quot;)//repeat() 将字符串重复N次，返回一个新的字符串res = str.repeat(3)//TomTomTomres = str.repeat(2.5)//TomTomres = str.repeat(0)//&quot;&quot;log(res); 数值12345678910111213141516171819202122232425262728let&#123;log&#125; = console;//Number.isFinite() 判断被传入的内容是否为有限数值let res = Number.isFinite(100);//trueres = Number.isFinite(100/0);//falseres = Number.isFinite(Infinity);//falseres = Number.isFinite(NaN);//falseres = Number.isFinite(&quot;100&quot;)//false//Number.isInteger() 判断被传入的内容是否为整数res = Number.isInteger(100);//trueres = Number.isInteger(100.0);//trueres = Number.isInteger(100.1);//falseres = Number.isInteger(&quot;Tom&quot;);//falseres = Number.isInteger(&quot;100&quot;)//false//Math.trunc() 将括号内的参数转化为数字再去掉小数点res = Math.trunc(1.2);//1res = Math.trunc(1.8);//1res = Math.trunc(-1.8);//-1res = Math.trunc(&quot;Tom&quot;);//NaNres = Math.trunc(&quot;10.2&quot;);//10//Math.sign() 判断括号内的数是正数负数还是0res = Math.sign(200);//1res = Math.sign(-200);//-1res = Math.sign(0);//0res = Math.sign(-0);//-0res = Math.sign(&quot;asld&quot;);//NaN 数组拓展12345678910111213//...扩展运算符: let arr = [1,2,3]; let arr2 = [4,5,6]; let res =[...arr,...arr2]; console.log(res);//1，2，3，4，5，6function test()&#123; //arguments 是函数参数的集合 是个伪数组 console.log(arguments); //Array.from() 将 伪数组 转换为 真实数组 res = Array.from(arguments); console.log(res);&#125;test(1,2,3) document.querySelectorAll() 通过选择器获取所有相关元素 返回的是NodeList 伪数组document.querySelector() 通过选择器获取首个相关元素 直接返回元素对象find() 主要用于查找一个符合条件的数组元素findIndex() 主要用于查找一个符合条件的数组元素的下标它的参数是一个回调函数 在回调函数中可以制定寻找元素的条件当条件成立为true时间。返回该元素，如果没有符合的条件，返回undefined 123456let arr3 = [11,22,33,44,55]res = arr3.find(function(item)&#123;//item 表示数组内的每一个成员 return item&gt;20; console.log(item);&#125;)console.log(lis); fill() 使用括号内的参数，直接在数组内填充数据（替换和添加）第一个参数 是替换的新value值第二个参数 是替换的起始坐标第三个参数 是替换的结束坐标 123let arr5 = [1,&quot;纯爱&quot;,&quot;纯爱&quot;];arr5.fill(&quot;牛头人&quot;,1,2);console.log(arr5); 对象拓展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; let name = &quot;张三&quot; let obj = &#123; name:name, fn:function()&#123;&#125; &#125; console.log(obj) //如果对象的属性和value的变量相同，就可以只写一个属性名 let obj2 = &#123; name, //name:name getMessage()&#123;&#125;, getList()&#123;&#125; &#125; console.log(obj2) let msg = &quot;class&quot;; //对象的属性名可以使用表达式 需要用到符号 [表达式] let obj3 = &#123; [msg+&quot;one&quot;]:&quot;Tom&quot;, [`$&#123;msg&#125;xxx`]()&#123;&#125; &#125; console.log(obj3) let obj4 = &#123; name:&quot;jerry&quot;, age:14 &#125; //对象内可以使用拓展运算符 let obj5 = &#123; ...obj4//相当于通过for in遍历，属于深拷贝 &#125; console.log(obj5) //Object.assign() 将需要操作的元素复制到目标对象中 //第一个参数 目标参数 //第二个参数及后面所有额参数都是 需要操作的对象 //如果复制的数据是 值类型数据 实现的是深拷贝 //如果复制的数据是 引用类型数据 使用的任然是该数据的指针(引用地址)，实现的是浅拷贝(重点) let obj6 = &#123;&#125;; let obj7 = &#123; name:&quot;ggBANG&quot;,//值类型深拷贝 friends:[&quot;小A&quot;]//引用类型浅拷贝 &#125; Object.assign(obj6,obj7); obj6.age = 20; obj6.friends = &quot;小王&quot;; console.log(obj6) console.log(obj7)&lt;/script&gt; 函数拓展1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; function fn()&#123;&#125; let fn2 = function()&#123;&#125; // =&gt; const fn3 = (a,b) =&gt;&#123; console.log(a+b) &#125; fn3(1,2) // xxx.onclick = ()=&gt;&#123;&#125; // setInterval(()=&gt;&#123;&#125;) //传入一个参数a, 并且a为函数的返回值 //只有一个参数的情况下 小括号可以省略 //函数内 只有一行需要执行的代码的时候 花括号可以省略 const fn4 = a =&gt;a; fn4(10) //箭头函数制定参数默认值 const fn5 = (a=20,b=50) =&gt;&#123; console.log(a,b); &#125; fn5() let div = document.querySelector(&#x27;div&#x27;); //函数区别 //1.箭头函数的this指向 函数的声明处 //2.箭头函数中无法使用arguments //3.箭头函数不可以作为构造函数 使用 div.onclick= () =&gt;&#123; console.log(this); &#125; // const fn6 = () =&gt;&#123; // console.log(arguments); // &#125; // fn6(1,2,3) const Tom = () =&gt;&#123; console.log(&quot;123&quot;); &#125; new Tom() &lt;/script&gt; SymbolSymbol：表示独一无二的值 1234567891011121314151617var names = Symbol();console.log(names);//使用symbol 当作对象名var obj = &#123; [names]:&quot;Tom&quot;&#125;console.log(obj);//Symbol 函数可以接收一个字符串作为字符串，表示堆Symbol实例的描述//主要是为了在控制台上显示，比较容易区分const ages = Symbol(&quot;age&quot;)console.log(ages)var obj2 = &#123; [ages]:18, [names]:&quot;Tom&quot;&#125;//获取带有Symbol格式的属性console.log(obj2[ages]);//不要加.了 Reflect 是一个内置对象的反射机制，用来提供方法 拦截js的操作Reflect.ownKeys(obj)返回一个数组forEach（）实现遍历的方法 123Reflect.ownKeys(obj).forEach(function(item)&#123; console.log(item);&#125;) Iterator接口Iterator接口的作用为各种数据结构，提供一个统一的，简单的访问接口使数组格式的成员能够按照某种次序排列es6创造了一种新的遍历命令 for of 循环， Iterator接口主要供for…of循环Iterator接口遍历的过程创建一个指针对象，指向当前数据结构的起始位置,第一次调用指针对象的next方法，可以将指针指向该数据结构的第一个成员第二次调用指针对象的next方法，指针就指向该数据结构的第二个成员不断调用指针对象的next方法，直到他指向数据结构的结束位置 1234let item = arr[Symbol.iterator]();console.log(item);console.log(item.next());console.log(item.next()); ES6规定，默认的Iterator接口部署在数据结构[Symbol.iterator]属性或者说 只要有 数据结构 具备Symbol.iterator属性 就认为是可遍历的Symbol.iterator属性本身就是一个函数，就是当前数据结构默认的遍历器生成函数执行这个函数就会返回一个遍历器原生默认具备 iterator 接口的数据结构如下:Array Set Map String arguments NodeList Set数据结构Set类似于数组，成员的值是唯一的，没有重复的值Set.size() 返回Set实例的成员总数Set.add() 添加Set成员Set.delete()删除Set成员Set.has() 查看括号内的成员是否在Set中存在 返回布尔类型 1234567let s1 = new Set([1,2,3,4]);console.log(s1);let s2 = new Set();s2.add(&#x27;hello&#x27;);s2.add(&#x27;world&#x27;);s2.delete(&quot;world&quot;);s2.clear(); Set遍历Set.keys() 返回键名的遍历器Set.values() 返回键值的遍历器Set.entries() 返回键值对的遍历器 123456789let result =s2.keys();console.log(result); result =s2.values();console.log(result); result =s2.entries(); console.log(result); s1.forEach(function(item)&#123; console.log(item);&#125;) 数组去重方法一： 123456let arr = [19,20,19,19,20,21,30,90];let s1 = new Set(arr);console.log(s1);//输出的是一个对象//需要转换为数组的话s1 = Array.from(s1);//使用Array.from() 转换成数组console.log(s1); 方法二： 12let s2 = [...new Set(arr)];//...扩展运算符console.log(s2); Map12345678910111213141516171819202122232425&lt;script&gt; //Map 类型对象 键值对的集合，但是Map中的key不限于字符串，可以是各种类型的值 let M1 = new Map(); M1.set(&#x27;name&#x27;,&#x27;tom&#x27;); M1.set(&#123;a:1&#125;,&#x27;tom&#x27;); M1.set(&#x27;big&#x27;,&#x27;small&#x27;); //操作方法 //Map.set(key.value); 在Map对象中添加key和对应的value //Map.get(key); 在Map对象中获取key对象的value //Map.delete(key); 删除指定的key //Map.has(key); 查看key是否在map中存在 返回布尔类型 //Map.clear(); 清空 console.log(M1); console.log(M1.get(&quot;name&quot;)); M1.delete(&quot;name&quot;); console.log(M1); let res = M1.has(&#x27;big&#x27;); console.log(res); //Map遍历方法 与 Set相同 res = M1.keys() res = M1.values() res = M1.entries() console.log(M1); console.log(res);&lt;/script&gt; ProxyObject.defineProperty() 拦截并处理数据第一个参数 需要拦截处理的对象第二个对象 对象内的属性第三个对象 {}配置项，格式是个对象 1234567891011121314151617181920let obj = &#123; data: 111, name:&quot;zs&quot;, age:20 &#125;let box = document.getElementById(&quot;box&quot;)Object.defineProperty(obj, &quot;data&quot;, &#123; get() &#123;// 当使用对象内的指定属性时调用 console.log(&quot;get函数调用&quot;); &#125;, set(value)&#123; console.log(&quot;set函数接收到了:&quot;,value); if(value&gt;=1000)&#123; box.innerHTML =`数据较大,请重新输入`; &#125; else&#123; box.innerHTML = `数据合理放心使用`; &#125; &#125;&#125;) Proxy代理: 123456789101112131415let proxy = new Proxy(obj,&#123; get(target,key)&#123; //target 表示 需要代理的对象 //key 表示的是访问的属性 console.log(target,key); return target[key]; &#125;, set(target,key,value)&#123; //target 表示 需要代理的对象 //key 表示的是设置的属性 //value 设置的新值 console.log(&quot;set:&quot;,target,key,value); target[key] = value//确认操作 &#125;&#125;) ReflectReflect 主要用来获取目标对象的行为,它与Object类似，但更容易读 Promise对象回调地狱当一个回调函数嵌套另一个回调函数的时候就会出现嵌套结构当嵌套结构多的时候，就会出现回调地狱的情况回调地狱 其实就是由多个回调函数互相嵌套导致的，代码维护性非常差 同步异步异步 当一行代码还没有执行结束，就可以去执行另一行代码的顺序 叫做异步同步 当代码逐行执行过程就是同步的过程异步的操作：定时器 callbackpromise 是异步编程的一种统一的解决方案，比传统回调函数，更合理更强大 1234567891011121314151617const api = new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; if(true)&#123; resolve()//resolve 表示成功的回调函数 &#125; else&#123; reject()//reject 表示失败的回调函数 &#125; &#125;,1000)&#125;)api.then(()=&gt;&#123; console.log(&quot;yyyyy&quot;);//.then() 成功&#125;).catch(()=&gt;&#123; console.log(&quot;nnnnn&quot;);//.catch() 失败&#125;) Promise 对象通过自身的状态，来控制异步操作。Promise实例具有三种状态异步操作未完成(pending)异步操作完成(fulfilled)异步操作失败(rejected) 链式调用为什么promise可以实现链式调用因为当promise方法执行结束后仍然会返回一个promise对象 123456789101112131415const a = promise.then((res) =&gt; &#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 2000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 3000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 5000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;);&#125;).catch((err)=&gt;&#123; console.log(&quot;失败啦&quot;,err);&#125;)console.log(a) all方法Promise.all() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态都是fulfilled pAll的状态才是 fulfilled此时P1,P2,P3的返回值组成一个数组，传递给pAll中 race方法Promise.race() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态只要有一个fulfilled pRace的状态才是 fulfilled此时返回值是首次达到fulfilled状态的值除非全部reject否则不会触发.catch Generator函数ES6 提供的一种异步编程解决方案 123456789101112function *gen()&#123; console.log(1); yield;//yield 表示暂停执行标记，通过next方法恢复执行 console.log(2); yield; console.log(3);&#125;let g = gen()//next() 驱动下一步的执行g.next()g.next()g.next()console.log(g); Class语法与继承123456789101112131415class Person&#123;//创建一个Person类 也叫做 构造函数 //类中的属性需要使用constructor 构造器创建 constructor(name,age,height)&#123; this.name = name; this.age = age; this.height = height; &#125; // 在类中创造方法 say()&#123; console.log(&quot;这是Person类&quot;); &#125;&#125;let obj = new Person(&quot;zhangsan&quot;,19,&quot;180cm&quot;);console.log(obj);obj.say() class继承 123456789101112131415161718192021222324class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(&quot;这是&quot;,this.name,this.age,&quot;岁&quot;); &#125;&#125;const one = new Person(&quot;张飞&quot;,100);one.say();class Student extends Person&#123;//extends 表示StudentPerson类中继承 constructor(name,age,height)&#123; super(name,age);//super() 表示从父类中继承的属性内容 必须写在 construtor中 this.height = height; &#125; say()&#123; super.say(); console.log(&quot;是学生&quot;) &#125;&#125;let obj = new Student(&#x27;xz&#x27;,12,&#x27;120&#x27;);console.log(obj);obj.say();","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"Javascript 基础知识","slug":"Javascript-基础知识","date":"2023-06-12T05:11:08.000Z","updated":"2023-07-01T08:40:11.753Z","comments":true,"path":"2023/06/12/Javascript-基础知识/","link":"","permalink":"http://example.com/2023/06/12/Javascript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 JavaScrip简介JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。JavaScript 很容易学习。 ECMAScript 语法标准(es)JavaScript 输出JavaScript 可以通过不同的方式来输出数据：使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 外部的 JavaScript也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。 外部 JavaScript 文件的文件扩展名是 .js。 1&lt;script src=&quot;./01.js&quot;&gt;&lt;/script&gt; 变量1var a = 20; var 申明变量名a 变量名 用来存储变量20 变量&#x3D; 赋值符号 从右向左赋值 变量命名规则：1.可以是字母或者下划线_或者$开头2.长度不可超过255个字符3.名中不能含有空格，首字头不能是数字4.严格区分大小5.不能使用关键字或保留字6.汉字可使用不推荐当使用空的变量名时，得到的结果就是未定义 undefined使用不存在的变量名时，报错，d is not defined变量的声明提升:先使用变量再创建变量 得到的结果会是 undefined 只能提升变量名，不提升变量 12console.log(e);var e = 30; 相当于 123var e;console.log(e);var e = 30; 数据类型与转换基本数据类型:number 数字string 字符串 只要有引号包裹就是字符串boolean 布尔 true&#x2F;false将数据类型转化为number类型强制类型转换:Number（） 将数据类型转换成number转换字母等非数字内容的话会显示NaN (No a Number)parseFloat() 浮点型 将数据保留小数 并且转换为数字类型转换带数字的字符串时，必须开头为数字才能识别parseInt() 整型 将数据保留整数，并转换成数字类型isNaN()：判断内容是否是 非数字 如果是非数字 返回 true 反之为 false只查看数据内容，不查看数据类型数据类型转换为字符串强制类型转换String() 将数据类型转换为字符串xxx.toString() 将数据类型转换为字符串 需要转化的变量名写在前面将数据类型转换为布尔Boolean()0为false，其他为true值类型:number 数字string 字符串boolean 布尔null 空undefined未定义symbol 独一无二的引用数据类型：object 对象function函数array 数组tpyeof(undefined)&#x3D; undefined;tpyeof(null)&#x3D; object;tpyeof(error)&#x3D; object; 算数运算符+ 加法当符号两边都是数字的时候，会自动相加求和当符号两边有字符串时，会起到拼接字符串的作用（结果时字符串类型–隐式类型转换）当符号两边有布尔类型时，true为1，false为0 参与求和计算++ 自增加1++在后面 表示后加，处于正在加1的过程，还没加上，当再次使用变量时，才算自增结束++在前面 表示先加，直接自增结束，得到就是自增+1的结果- 减法当符号两边都是数字的时候，会自动相减求差当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算– 自减1，同自增* 乘法当符号两边都是数字的时候，会自动相乘求积当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算&#x2F; 除法当符号两边都是数字的时候，会自动相除求商当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算除数如果是0 得到的是 Infinity 无穷&#x2F;无限% 除余()优先运算符 比较运算符注意：&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D; 的不同&#x3D;&#x3D; 等号(只比较值，不比较数据类型)&#x3D;&#x3D;&#x3D; 全等号（值和数据类型都相同）&gt; 大于号&gt;&#x3D; 大于等于&lt; 小于&lt;&#x3D; 小于等于!&#x3D; 不等于!&#x3D;&#x3D; 不全等于 逻辑运算符&amp;&amp; 与 符号两边的表达都为true整个表达式的结果就是true 有一方为false，整个表达式的结果就是false|| 或 有一方为true，整个表达式的结果就是true！ 非 对象与事件实例化对象：var obj&#x3D;new Object();键值对（属性：属性值）obj.name&#x3D;”zs”;&#x2F;&#x2F;键值对就是XX&#x3D;XX字面量的方式创建对象: 12345var obj2 = &#123; name:&quot;1s&quot;, age:20, height:172&#125; 日期对象var&#x3D; new Date();date.getFullYear();获取当前年份getMonth 获取当前月份getDate日期getDay星期getHours小时getMinutes分钟getSeconds当前秒getMilliseconds 当前毫秒getTime从1970.1.1至今的毫秒数Math对象Math.max 返回最大数Math.min 返回最小数Math.ceil 天花板函数，有小数部分向上取整Math.floor 地板函数 舍掉小数部分Math.round(b) 四舍五入Math.random() 随机数字0-1 取不到1事件on绑定事件的关键字 click 点击事件box.onclick&#x3D;function(){}onblur 失去焦点 if else略 switchswitch 用来监视链路，捕获数据某种情况下需要执行的代码块switch 具有数据穿透性 需要break中断余下代码的执行default 相当于else 123456789101112switch(n)&#123; case 10: XXXX; break; case 20: XXXX; break; default: XXXX; break;&#125; 第二种情况：switch(true) 12345switch(true)&#123; case n&lt;10&amp;&amp;n&gt;=0: console.log(&quot;switch范围监测&quot;) break;&#125; 三目运算符表达式？ 结果1(true):结果2(false) 1a&gt;b ? console.log(&quot;a大&quot;):console.log(&quot;b大&quot;); for循环for循环执行顺序：for 首次执行 先创造变量 再判断条件 不走增量 直接执行代码块剩下的执行次数都是 先增量再判断 最后走代码块如果 变量不满足判断条件 循环结束for(初始化变量;判断条件；增量){重复执行代码块}break： 终止循环 终止整个循环体 余下代码不执行continue： 终止循环 终止当前次数的循环，余下代码不执行 while循环与do while循环1234while(i&lt;10)&#123; console.log(i); i++;&#125; 1234do &#123; i++; console.log(i); &#125; while (i &lt; 10) while 和 do while的区别while循环是 先判断再执行do while 循环 是先执行再判断 数组和数组api123456789101112131415161718192021222324252627282930313233var arr = new Array();//实例化数组// 数组内数据的序号 我们叫做下标（索引号）arr[0]=&quot;李白&quot;;arr[1]=&quot;白居易&quot;;console.log(arr);// 字面量的方式创建数组var arr2 = [&quot;ls&quot;,&quot;zs&quot;,123,false];console.log(arr2);// 数组的使用方式 数组名[下标]console.log(arr2[2]);// 数组名.length 数组内成员的个数console.log(arr2.length);//二维数组var arr4 = [1,3,4,[1,2,3]];console.log(arr4[3][1]);//多维数组var arr5 =[&#123; name:&quot;zs&quot;, age:18, friends:[&#x27;ls&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;ls&quot;, age:20, friends:[&#x27;zs&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;wr&quot;, age:22, friends:[&#x27;ls&#x27;,&#x27;zs&#x27;]&#125;] 数组的操作方法1.数组.includes() 查看数组内是否包含指定成员，如果是就返回true,如果不包含就返回false 2.Array.isArray() 判断是否是一个数组格式 返回 true 或 false 3.数组.indexOf() 查看数组内的成员，如果存在就返回首次出现的下标，如果不存在就返回-14.数组.lastIndexOf() 查看数组内的成员，如果存在就返回最后一次出现的下标，如果不存在就返回-15.数组.join() 在数组各元素之间插入相同的字符串拼接，将数组转换成字符串6.数组.push() 在原数组末尾添加新成员，返回新数组长度，原数组被改变7.数组.unshift() 在数组开头添加新成员，返回新数组长度，原数组被改变8.数组.pop() 删除数组最后一名成员，返回被删除内容，原数组被改变9.数组.shift() 删除数组开头的成员，返回被删除内容，原数组被改变 10.数组.reverse() 反转数据11.数组.splice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组改变当括号内有两个参数的时候，表示从当前下标开始一直截取到几个，返回被截取的内容，原数组改变当括号内有三个参数的时候，第三个参数表示在截取位置添加的新内容，返回被截取的内容，原数组改变12.数组.slice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组不改变当括号内有两个参数的时候，表示从当前下标开始到第二个参数下标结束，返回被截取的内容，原数组不改变var res &#x3D;arr.includes(“奥斯”); 字符串API字符串.length 获取字符串的长度字符串.split() 字符串转换成数组，根据括号的内容进行字符分割字符串.charAt() 返回指定下标处的字符字符串.indexOf() 返回查找首次出现字符的下标，如果不存在返回-1字符串.lastIndexOf() 返回查找最后一次出现字符的下标，如果不存在返回-1字符串.substr() 截取字符串 如果有一个参数 表示从当前下标开始截取到末尾 返回截取的内容如果有两个参数，表示从当前下标开始截取几个 返回截取的内容 函数匿名函数： 自调用 通过事件绑定在一起触发具名函数： function . 函数名()函数特性：不调用，不执行函数的使用叫做调用函数具有 预加载(函数的位置在定义先后不影响执行)具名函数的调用 函数名()return 返回值（余下代码不执行）function 函数名（形式参数）{}var a &#x3D; 函数名（实际参数）；封装函数 全局变量与局部变量变量是存在作用域的 分为 全局变量和局部变量局部变量： 在函数内部用var声明的变量就是局部变量（只在函数内部生效）全局变量：在函数外部用var声明的变量就是全局变量，可以在整个JS中生效不用var声明的，变量也是全局变量（不推荐使用）闭包：闭包的形式：多个函数互相嵌套闭包的目的：将内部函数的局部变量提到全局中去使用闭包的实现方式：不断地设置return 返回值闭包的缺点：会消耗电脑内存 影响性能 DOMdocument object model 文档对象模型 定时器1234567891011// setInterval(callback) 多次执行的定时器 callback参数 表示 回调函数start.onclick = function () &#123; timer = setInterval( function () &#123; console.log(1); &#125;, 1000) &#125; stop.onclick = function () &#123;// clearInterval(定时器的名字) 清除定时器 clearInterval(timer);&#125; thisthis 表示 这个this 在函数中 代指函数的调用者this在函数外 指向的是window对象，最大的对象 12345678910111213141516var lis = document.getElementsByTagName(&quot;li&quot;)console.log(this);for (var i = 0; i &lt; lis.length; i++)&#123; //属性绑定 写在循环的内部，事件的外部 // index 一般表示为下标 lis[i].index = i; lis[i].onclick = function() &#123; //先让所有颜色都变成蓝色 再让当前的这个变成红色 //这就是排他思想 for (var j = 0; j &lt; lis.length; j++)&#123; lis[j].style.background = &quot;skyblue&quot;; &#125; this.style.background = &quot;red&quot;; console.log(this.index);//获取到下标 &#125;&#125; 轮播图参考https://swiper.com.cn/ Node节点操作1.xx.parentNode 当前节点的父节点2.xx.childNodes 当前节点的所有子节点,包含文本节点(本次返回的text为回车造成的空格) 返回nodeList 伪数组3.xx.children 当前节点的所有子元素节点 返回HTMLCollection 伪数组4.xx.firstChild 当前节点的第一个子节点,包含文本节点5.xx.firstElementChild 当前节点的第一个子元素节点6.xx.lastChild 当前节点的最后一个子节点,包含文本节点7.xx.lastElementChild 当前节点的最后一个子元素节点8.xx.previousSibling 当前节点的前一个兄弟节点,包含文本节点9.xx.previousElementSibling 当前节点的前一个兄弟元素节点10.xx.nextSibling 当前节点的前一个兄弟节点,包含文本节点11.xx.nextElementSibling 当前节点的前一个兄弟元素节点节点的操作1.document.createElement() 创建节点2.xx.innerHTML 往节点内添加或替换内容(文本或标签)2.xx.innerText 往节点内添加或替换内容(文本)4.xx.appendChild() 往父节点的末尾添加新节点5.xx.insertBefore(新节点,目标节点) 将新节点添加到目标节点之前6.xx.cloneNode() 克隆节点,true的时候,将该节点及其子节点全部复制；flase的时候只复制节点本身。7.父节点.removeChild() 删除父节点的子节点 偏移量offsetWidth 元素自身的宽度 width+border+paddingoffsetHeight 元素自身的高度 同上offsetLeft 元素自身的位置offsetTop 元素自身的位置onscroll 滚动事件scroll卷曲的距离clientWidth可视区域的宽 width paddingclientWidth可视区域的宽 height padding document.body;&#x2F;&#x2F;获取body 标签document.documentElement&#x2F;&#x2F;获取html标签 事件对象event 事件对象 通过事件触发的时候调用函数内的参数该对象内包含了事件触发时的信息事件对象的兼容写法： 1var e = event || window.event;//兼容低版本ie浏览器 pageX 光标相对于网页的水平位置（ie无）*pageY 光标相对于网页的垂直位置（ie无）*screenX 光标相对于屏幕的水平位置screenY 光标相对于屏幕的垂直位置clientX 光标相对于可视区域的水平位置*clientY 光标相对于可视区域的垂直位置（重要且相同）xx.onkeypress 键盘按键 按下并且弹起xx.keyCode 表示键盘上对应按键的编码xx.onmouseenter 鼠标进入xx.onmouseleave 鼠标离开 事件冒泡和事件句柄事件冒泡：当一个元素的事件被触发的时候,比如鼠标点击了一个元素，同样的事件就会在这个元素的所有祖先元素上被触发这个过程就叫做事件冒泡,这个事件是从原始事件一直冒泡到dom树的最上层.不支持事件冒泡的事件: focus,blur,mouseenter,mouseleave,load,resize 12//阻止事件冒泡的兼容写法e.stopPropagation ? e.stopPropagation() :e.cancelBubble = true; 事件句柄:addEventLister 添加事件句柄第一个参数 事件的名称第二个参数 callback 回调函数第三个参数 false 触发的顺序是由内到外，叫做冒泡的顺序（默认）； true 触发的顺序是由外到内，叫做捕获的顺序同一个元素可以绑定多个相同事件，不会覆盖，挨个执行 123box.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;222&quot;); &#125;,true) 缓存注意：cookie localStorage sessionStorage的区别cookie 默认浏览器关闭时消失，存在于web服务器中，存储大小为4KBlocalStorage 本地储存 永久有效，除非手动删除，存储大小为5MBsessionStorage 会话存储 关闭浏览器或窗口事就消失，存储大小为5MBcookie缓存： 123456document.cookie=&quot;username = 李白&quot;//创建cookie缓存document.cookie=&quot;age = 30; expires = Tue, 20 Jun 2023 12:00:00 GMT&quot;//设置过期事件var res =document.cookie;var n = res.indexOf(&quot;=&quot;) +1 ;res = res.substr(n);console.log(res); localStorage缓存： 123456localStorage.setItem(&quot;NAME&quot;,&quot;TOM&quot;);//创建缓存 localStorage.setItem（key,value） localStorage.setItem(&quot;AGE&quot;,&quot;18&quot;);localStorage.removeItem(&quot;AGE&quot;);//删除指定缓存 localStorage.removeItem(key)var res = localStorage.getItem(&quot;NAME&quot;);//获取缓存 localStorage.getItem(key) var age = localStorage.getItem(&quot;AGE&quot;);localStorage.clear();//清空缓存 localStorage.clear() BOMbrowser object model 浏览器对象模型 Window对象window.open(“https://www.baidu.com&quot;//在当前窗口跳转window.close();&#x2F;&#x2F;关闭窗口 locationlocation.hostname web主机域名location.pathname 当前页面的路径location.port 端口号(0-65535)location.herf 整个URLlocation.protocol web协议常见的协议:http 和 https 的区别*http 免费 相对不安全，端口号默认80https 收费 比较安全，端口号默认443 secureftpfile history两种后退功能：history.back(); history.go(-1);两种前进功能：history.go(); history.go(1); navigatornavigator 设备信息对象navigator.appCodeName 浏览器代号navigator.appName 浏览器名称navigator.appVersion 浏览器版本navigator.vender 浏览器供应商navigator.cookieEnabled 浏览器是否启用了缓存navigator.platform 硬件平台navigator.userAgent 用户代理语言navigator.language 用户代理语言 正则表达式 实例化创建正则对象 1var reg = new RegExp(); &#x2F;&#x2F;字面量方式创造正则对象reg &#x3D; &#x2F;@&#x2F;; 含有@reg &#x3D; &#x2F;\\d&#x2F; 含有数字reg &#x3D; &#x2F;\\D&#x2F; 含有非数字reg &#x3D; &#x2F;\\s&#x2F; 含有不可见字符(空格，回车等)reg &#x3D; &#x2F;\\S&#x2F; 含有可见字符reg &#x3D; &#x2F;\\w&#x2F; 含有单词字符 字母 数字reg &#x3D; &#x2F;\\W&#x2F; 含有非单词字符 简单类reg &#x3D; &#x2F;[23]&#x2F; 含有2或者3负向类reg &#x3D; &#x2F;[^23]&#x2F; 含有非2或者3范围类reg.onblur &#x3D; &#x2F;[0-9]&#x2F; 含有0-9中的任意一个组合类reg &#x3D; &#x2F;[0-9a-z]&#x2F; 含有数字或者字母中的一个边界reg &#x3D; &#x2F;^12&#x2F; 必须以12开头reg &#x3D; &#x2F;23$&#x2F; 必须以23结束reg &#x3D; &#x2F;^123$&#x2F; 必须是123&#x2F;&#x2F;量词reg&#x3D; &#x2F;^123*$&#x2F; ‘3’的重复次数&gt;&#x3D;0次reg&#x3D; &#x2F;^123+$&#x2F; ‘3’的重复次数&gt;&#x3D;1次reg&#x3D; &#x2F;^123?$&#x2F; ‘3’的重复次数只能是0或1次reg&#x3D; &#x2F;^12{4}3$&#x2F; ‘2’的重复次数4次reg&#x3D; &#x2F;^12{4,}3$&#x2F; ‘2’的重复次数&gt;&#x3D;4次reg&#x3D; &#x2F;^12{4,10}3$&#x2F; ‘2’的重复次数4到10次 正则.test(需要校验的内容) 返回布尔类型 1var res = reg.test(inp.value); 高级JS(面向对象)值类型与引导类型值类型 ：number string boolean null undef symbol引用数据类型： array function object 值类型与引用数据类型的区别值类型 ：存储在栈中，内存空间固定当数据复制的时候，可以直接复制互不影响typeof 判断数据类型引用数据类型：存储在堆中，内存空间不固定浅拷贝：当数据复制的时候，只能复制数据的引用地址深拷贝：将数据复制并在堆中重新申请一片空间进行存储深拷贝实现的两种方式： 12var obj2 = JSON.stringify(obj);//对象 =&gt; string 将对象转换成json字符串var obj2 = JSON.parse(obj2);//string =&gt; 对象 将json字符串转换成对象 通过instanceof() 判断数据是哪一种引用类型（返回true&#x2F;false） 1var res = arr instanceof(Arry); 工厂模式和构造函数面向对象编程的基本特征封装： 将客观事物封装成抽象的类继承： 子类具有父类的公有属性多态： 对象的多功能，多方法，一个方法可以有多种表现形式字面量创建对象 创建量如果比较多就比较繁琐，并且对象之间没有关系 12345678var personOne = &#123; name:&quot;zs&quot;, age:20&#125;var personTwo = &#123; name:&quot;ls&quot;, age:24&#125; 通过封装的方式创建对象，解决代码重复的问题 123456function createPerson(name,age)&#123; return&#123; name:name, age:age &#125; &#125; 工厂模式 12345678function createPerson(name,age)&#123; var obj =new Object();//准备工厂环境 obj.name = name;//将属性进行加工 obj.age = age;//将属性进行加工 return obj;//将加工好的对象进行输出&#125;personOne = createPerson(&quot;王二&quot;,10);personTwo = createPerson(&quot;zy&quot;,30); 构造函数 12345678function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;var personOne = new CreatePerson(&quot;张三丰&quot;,&quot;108&quot;)var personTwo = new CreatePerson(&quot;孙悟空&quot;,&quot;正无穷&quot;)console.log(personOne);console.log(personTwo); 构造函数需要注意的事情：1.CreatePerson 称之为 构造函数 也叫做 类，构造函数就是类2.personOne 就是 CreatePerson 的实例对象3.构造函数中的this指向的是通过new实例化出来的4.必须使用new关键字 将函数实例化5.构造函数的开头必须大写6.构造函数会自动创造出来一个 constructor(构造器)属性，这是属性就是指向CreatePerson prototype原型属性，存在于每个构造函数之中通过prototype原型创建的方法可以在构造函数生成的实例中公用，有利于提升效率prototype 的顶端 是 object 123456789 function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;CreatePerson.prototype.say = function()&#123; console.log(&quot;yyy&quot;); return 0;&#125;var one = new CreatePerson(&quot;zs&quot;,20); 对象继承12345678910111213141516171819202122232425function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.run=function()&#123; console.log(&quot;啊啊啊啊啊&quot;);&#125;Person.prototype.findWork=function()&#123; console.log(&quot;working&quot;);&#125;function Man()&#123; console.log(&quot;nnnnn&quot;);&#125;//看似赋值的过程 =&gt; 实际上实现的是浅拷贝// Man.prototype = Person.prototype; //for in 循环（用来遍历对象）for(var k in Person.prototype)&#123; console.log(k);//k是对象的属性 Man.prototype[k] = Person.prototype[k]&#125;Man.prototype.jump = function()&#123; console.log(&quot;hhhhhhhhhhh&quot;); &#125;console.log(Man.prototype);console.log(Person.prototype); 多态多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态的实现方式：覆盖指子类重新定义父类方法，基于prototype继承就是。 call和apply和bind12345678910111213141516171819 //thiswindow.color = &quot;red&quot;;document.color = &quot;green&quot;;// console.log(window);var obj = &#123; color:&quot;white&quot;&#125;function changeColor(a,b)&#123; console.log(a+&quot;和&quot;+b+&quot;喜欢&quot;+this.color)&#125;//函数.call(this需要指向的对象，参数必须使用逗号分隔)changeColor(&quot;小王&quot;,&quot;小明&quot;);changeColor.call(document,&quot;小王&quot;,&quot;小明&quot;);changeColor.call(obj,&quot;小王&quot;,&quot;小明&quot;);//函数.apply(this需要指向的对象，参数必须使用数组)changeColor.apply(document,[&quot;小王&quot;,&quot;小明&quot;]);changeColor.apply(obj,[&quot;小王&quot;,&quot;小明&quot;]);//函数名.bind(this需要指向的对象，参数可以是任意形式)() 返回的是函数需要再次调用changeColor.bind(obj,[&quot;小李&quot;],[&quot;zs&quot;])()","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"MarkDown学习(一)","slug":"MarkDown学习-一","date":"2022-06-22T13:39:30.000Z","updated":"2023-07-02T17:10:54.433Z","comments":true,"path":"2022/06/22/MarkDown学习-一/","link":"","permalink":"http://example.com/2022/06/22/MarkDown%E5%AD%A6%E4%B9%A0-%E4%B8%80/","excerpt":"","text":"MarkDOwn初识标题要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 () (例如：### My Header)。 1234567# 1级标题## 2级标题### 3级标题#### 四级标题 ##### 五级标题 ###### 六级标题 字体1*斜体文本* 斜体文本 1**加粗文本** 加粗文本 1***加粗和斜体文本*** 加粗和斜体文本 1~~删除文本~~ 删除文本 1&gt; 引用文本 引用文本 列表有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 一： First item Second item Third item Fourth item 二： 12341. First item1. Second item2. Third item3. Fourth item First item Second item Third item Fourth item 三： 12341. First item8. Second item7. Third item3. Fourth item First item Second item Third item Fourth item 无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 123456- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 复选框列表（CheckBoxList） 123- [ ] List Item 1 unchecked- [x] List Item 2 checked- [X] List Item 3 checked List Item 1 unchecked List Item 2 checked List Item 3 checked 代码12345678910111213141516#[derive(Debug)]pub enum State &#123; Start, Transient, Closed,&#125;impl From&lt;&amp;&#x27;a str&gt; for State &#123; fn from(s: &amp;&#x27;a str) -&gt; Self &#123; match s &#123; &quot;start&quot; =&gt; State::Start, &quot;closed&quot; =&gt; State::Closed, _ =&gt; unreachable!(), &#125; &#125;&#125; 123456789101112[ &#123; &quot;title&quot;: &quot;apples&quot;, &quot;count&quot;: [12000, 20000], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;, &#123; &quot;title&quot;: &quot;oranges&quot;, &quot;count&quot;: [17500, null], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;] 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Gre\\&#x27;ater&#x27; return (param2 - param1 + 1 + 0b10l) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; 12345678910111213&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt; function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt; 123456789101112131415161718192021function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=&quot;$&#123;cls&#125;&quot;`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log(&#x27;undefined&#x27;); &#125; return ( &lt;div&gt; &lt;web-component&gt;&#123;block&#125;&lt;/web-component&gt; &lt;/div&gt; )&#125;export $initHighlight; 1234567891011121314#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125; 123456789101112CREATE TABLE &quot;topic&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;forum_id&quot; integer NOT NULL, &quot;subject&quot; varchar(255) NOT NULL);ALTER TABLE &quot;topic&quot;ADD CONSTRAINT forum_id FOREIGN KEY (&quot;forum_id&quot;)REFERENCES &quot;forum&quot; (&quot;id&quot;);-- Initialsinsert into &quot;topic&quot; (&quot;forum_id&quot;, &quot;subject&quot;)values (2, &#x27;D&#x27;&#x27;artagnian&#x27;); 12345678910111213#import &lt;UIKit/UIKit.h&gt;#import &quot;Dependency.h&quot;@protocol WorldDataSource@optional- (NSString*)worldName;@required- (BOOL)allowsToLive;@end@property (nonatomic, readonly) NSString *title;- (IBAction) show;@end 12345678910111213141516/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123; public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; 123456789101112131415import Foundation@objc class Person: Entity &#123; var name: String! var age: Int! init(name: String, age: Int) &#123; /* /* ... */ */ &#125; // Return a descriptive string for this person func description(offset: Int = 0) -&gt; String &#123; return &quot;\\(name) is \\(age + offset) years old&quot; &#125;&#125; 123456789101112131415@font-face &#123; font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123; color: #F0F0F0; background: #600; font-family: Chunkfive, sans;&#125;@import url(print.css);@media print &#123; a[href^=http]::after &#123; content: attr(href) &#125;&#125; 12345678910111213# The Greeter classclass Greeter def initialize(name) @name = name.capitalize end def salute puts &quot;Hello #&#123;@name&#125;!&quot; endendg = Greeter.new(&quot;world&quot;)g.salute 12345678910111213# MakefileBUILDDIR = _buildEXTRAS ?= $(BUILDDIR)/extras.PHONY: main cleanmain: @echo &quot;Building main facility...&quot; build_main $(BUILDDIR)clean: rm -rf $(BUILDDIR)/* 123456789101112package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan float64) ch &lt;- 1.0e10 // magic number x, ok := &lt;- ch defer fmt.Println(`exitting now\\`) go println(len(&quot;hello world!&quot;)) return&#125; 123456789101112131415#!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then echo &quot;Superuser rights required&quot; exit 2figenApacheConf()&#123; echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125; 123456789101112; boilerplate[package]name = &quot;some_name&quot;authors = [&quot;Author&quot;]description = &quot;This is \\a description&quot;[[lib]]name = $&#123;NAME&#125;default = Trueauto = nocounter = 1_000 超链接1这是一个链接 [百度](https://baidu.com)。 这是一个链接 百度。 图片1![图片alt](图片链接 &quot;图片title&quot;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2022-06-03T11:42:34.000Z","updated":"2023-07-02T17:10:41.054Z","comments":true,"path":"2022/06/03/我的第一篇博客文章/","link":"","permalink":"http://example.com/2022/06/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"一年前，就试着搭建了这个Hexo框架的微博，但是只是部署到了Github上，并没有打理自己的博客，也没有写一些内容，这和当初搭建博客的目的有点南辕北辙了。这段时间确实是让人比较疲惫且受挫，但还是得打起精神，继续前进。","categories":[],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]}