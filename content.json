{"meta":{"title":"YukiCCC的博客","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-07-01T08:25:42.219Z","updated":"2023-07-01T08:25:42.219Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-18T17:09:14.605Z","updated":"2023-07-18T17:09:14.605Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"自己想做的XXX件事： 干一份自己值得为之倾尽全力的工作 邂逅真爱 自驾游环游中国 考取研究生 研究生顺利毕业 学会射箭 学会写一手花体英文字 去日本旅行一次 学会骑马 去内蒙古玩一次 去舟山群岛到普陀山登顶 学会开车 拥有一台旗舰级顶级配置的电脑 让父母放心为他们分一次忧 开一次大排量摩托车 坐一次倒悬式的过山车 作为长辈给晚辈精心准备一次礼物 给家里坏掉的房门装锁 自己自驾游一座城市 写好中国字练一手好字"},{"title":"所有标签","date":"2023-07-01T08:26:59.883Z","updated":"2023-07-01T08:26:59.883Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-07-01T08:26:42.238Z","updated":"2023-07-01T08:26:42.238Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2023-07-01T08:54:37.410Z","updated":"2023-07-01T08:54:37.410Z","comments":true,"path":"data/friends.json","permalink":"http://example.com/data/friends.json","excerpt":"","text":"[{\"group\":\"分组1# 分组标题\",\"description\":\"友情链接\",\"items\":[{\"title\":\"Google\",\"avatar\":\"https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png\",\"url\":\"https://www.google.com/\",\"screenshot\":null,\"keywords\":null,\"description\":null},{\"title\":null,\"avatar\":null,\"url\":null,\"screenshot\":null,\"keywords\":null,\"description\":null}]}]"}],"posts":[{"title":"Spring Cloud","slug":"Spring-Cloud","date":"2023-10-11T11:35:51.000Z","updated":"2023-10-11T11:46:58.596Z","comments":true,"path":"2023/10/11/Spring-Cloud/","link":"","permalink":"http://example.com/2023/10/11/Spring-Cloud/","excerpt":"","text":"springcloud和springboot的区别springboot专注于开发单个服务 springcloud用来开发多个服务，关注全局的服务的协调和治理工作，将springboot开发的单个微服务整合起来，给各个服务之间提供配置管理，服务发现，断路器，路由，事件总线，配置等继承服务。 springboot是springcloud的基础。 什么是springcloudSpring Cloud是一个基于Spring boot实现的微服务架构开发工具,微服务架构是SOA架构的发展。它为微服务架构中提供配置管理、服务治理、智能路由、断路器以及集群状态管理等等。Spring cloud是基于HTTP协议的架构。 Springboot只用来开发单个服务 Springcloud可以开发多个服务 核心组件： ​ 注册中心：Eureka ，Nacos，Consul ​ 负载均衡：Ribbon，sentinel， loadbalancer ​ 容错保护：Hystrix，resilience4j，sentinel ​ 服务调用：feign，openfeign ​ 网关：Zuul，Gateway ​ 配置中心：config，Nacos 入门案例有一个服务（提供者），提供图书的检索功能。 有另外一个服务（消费者），需要买书时，按照编号查看书的信息。 公共模块创建普通maven工程base00-common，并编写实体类 123456789@Data@NoArgsConstructor@AllArgsConstructorpublic class Book &#123; String isbn; String name; String author; double price;&#125; 服务提供者创建一个spring boot的web工程，并增加base00-common的依赖 依赖文件123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.wanho&lt;/groupId&gt; &lt;artifactId&gt;base00-common&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; service12345678910111213141516@Servicepublic class BookService &#123; static Map&lt;String,Book&gt; map = new HashMap&lt;&gt;(); static &#123; map.put(&quot;SB1001&quot;,new Book(&quot;SB1001&quot;,&quot;随便&quot;,&quot;佚名&quot;,50)); map.put(&quot;SB1002&quot;,new Book(&quot;SB1002&quot;,&quot;浮士德&quot;,&quot;歌德&quot;,60)); map.put(&quot;SB1003&quot;,new Book(&quot;SB1003&quot;,&quot;我们仨&quot;,&quot;杨绛&quot;,25)); &#125; public Book findByIsbn(String isbn) &#123; //查询数据库 return map.get(isbn); &#125;&#125; controller1234567@ResourceBookService bookService;@GetMapping(&quot;book/&#123;isbn&#125;&quot;)public Book findBookByIsbn(@PathVariable(&quot;isbn&quot;) String isbn)&#123; return bookService.findByIsbn(isbn);&#125; 服务的调用者创建一个普通springboot的web工程，并增加base00-common的依赖 用户服务 依赖文件123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.wanho&lt;/groupId&gt; &lt;artifactId&gt;base00-common&lt;/artifactId&gt;c &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;c 注册RestTemplate1234@Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; 编写Service，调用别人提供的服务12345678910111213141516@Servicepublic class UserService &#123; //服务提供者的服务URL //String host = &quot;http://localhost:8080&quot;; @Resource RestTemplate restTemplate; public Book searchBook(String isbn)&#123; System.out.println(&quot;用户查找图书&quot;); String url = host + &quot;/book/&quot; + isbn; Book book = restTemplate.getForObject(url, Book.class); return book; &#125;&#125; 编写控制器测试1234567891011@RestControllerpublic class UserController &#123; @Resource UserService userService; @GetMapping(&quot;borrow/&#123;isbn&#125;&quot;) public Book searchBook(@PathVariable(&quot;isbn&quot;) String isbn) &#123; return userService.searchBook(isbn); &#125;&#125; Eureka（注册中心）是Spring cloud中的一个服务治理模块。 NetFlix公司一系列开源产品中的其中之一，它的主要作用是服务的注册和发现。 服务器端：也称为服务注册中心，提供服务的注册和发现。Eureka支持高可用的配置，当集群当中有节点（分片）出现故障时，Eureka会自动进入自我保护模式，它允许故障期间提供服务的发现和注册，当故障分片（节点）恢复后，集群的其他节点（分片）会把数据同步过来。 客户端：主要包含服务的生产者和服务消费者。服务的提供者要和服务器端维持心跳，来更新它的服务租约。可以将服务器端的注册信息缓存到本地，并周期性的更新服务状态。 服务端创建一个普通springboot工程base01-eureka，注意不要选择web依赖，增加Eureka服务端依赖 依赖1234567891011121314151617181920212223242526272829303132333435363738&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;net.wanho&lt;/groupId&gt; &lt;artifactId&gt;base01-eureka&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;base01-eureka&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;2021.0.6&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 配置文件123456789101112131415server: port: 7100spring: application: name: eureka-servereureka: client: service-url: defaultZone: http://localhost:7100/eureka #是否从注册中心拉取信息，本身就是注册中心，不需要拉取信息 fetch-registry: false #当前工程是否要到注册中心去注册， 本身就是注册中心，所以不需要 register-with-eureka: false instance: hostname: localhost 启动类增加@EnableEurekaServer注解 12345678910@SpringBootApplication@EnableEurekaServer //启用Eureka的服务器端public class Base01EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01EurekaApplication.class, args); &#125;&#125; 服务提供者在原来的base01-provider上进行修改 增加依赖在各自的节点内，增加以下相关内容，注意不要覆盖 12345678910111213141516171819202122232425&lt;properties&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 配置文件1234567891011server: port: 8090spring: application: name: bookappeureka: client: service-url: defaultZone: http://localhost:7100/eureka register-with-eureka: true fetch-registry: true 修改主启动类增加@EnableEurekaClient注解或者@EnableDiscoveryClient 1234567891011@SpringBootApplication@EnableEurekaClient //启用Eureka的客户端//@EnableDiscoveryClient //使用于Eureka以及其他非Eureka的卡护短public class Base01ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01ProviderApplication.class, args); &#125;&#125; 服务消费者在原来的base01-consumer上进行修改 增加依赖参考服务提供者 配置文件1234567891011server: port: 8081spring: application: name: userappeureka: client: service-url: defaultZone: http://localhost:7100/eureka register-with-eureka: true fetch-registry: true 修改主启动类增加@EnableEurekaClient注解 123456789101112131415@SpringBootApplication@EnableEurekaClientpublic class Base01ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01ConsumerApplication.class, args); &#125; @Bean @LoadBalanced //启用ribbon的负载均衡 public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改RestTemplate增加负载均衡 12345@Bean@LoadBalanced //启用ribbon的负载均衡public RestTemplate restTemplate()&#123; return new RestTemplate();&#125; 修改调用host用服务名替换原来的具体节点URL 123456789101112131415161718@Servicepublic class UserService &#123; //服务提供者的服务URL //String host = &quot;http://localhost:8080&quot;; //用服务名替换具体的服务器的URL String host = &quot;http://BOOKAPP&quot;; @Resource RestTemplate restTemplate; public Book searchBook(String isbn)&#123; System.out.println(&quot;用户查找图书&quot;); String url = host + &quot;/book/&quot; + isbn; Book book = restTemplate.getForObject(url, Book.class); return book; &#125;&#125; 指定服务的IP地址使用eureka.instance.prefer-ip-address&#x3D;true显示ip eureka.instance.ip-address&#x3D;127.0.0.1来指定ip地址 1234567891011121314server: port: 8070spring: application: name: bookappeureka: client: service-url: defaultZone: http://localhost:7100/eureka register-with-eureka: true fetch-registry: true instance: prefer-ip-address: true ip-address: 127.0.0.1 服务端添加用户验证整合spring security，要求客户端注册时，提供服务端需要的用户名和密码 服务器端引入依赖引入spring-boot-starter-security依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 修改配置配置文件当中指定用户名和密码，并且修改defaultZone配置 1234567891011121314151617server: port: 7100spring: application: name: eureka-server security: user: name: admin password: 123456eureka: client: service-url: defaultZone: http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@localhost:$&#123;server.port&#125;/eureka #是否要到注册中心拉取服务 fetch-registry: false #当前的服务是否要注册到指定的注册中心，由于现在时server自身，不需要注册 register-with-eureka: false 增加springsecurity的配置项12345678910111213@Configuration@EnableWebSecuritypublic class SecurityConfig &#123; @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123; http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); http.csrf().disable(); http.authorizeRequests().anyRequest().authenticated().and().httpBasic(); return http.build(); &#125;&#125; 客户端在注册配置时，提供用户名和密码 1234567891011121314server: port: 8090spring: application: name: GOODSeureka: client: service-url: defaultZone: http://admin:123456@localhost:7100/eureka register-with-eureka: true fetch-registry: true instance: prefer-ip-address: true ip-address: 192.168.40.251 取消刷新默认情况下，Eureka client是可以刷新的。当刷新客户端时，客户端暂时从服务器中取消注册，可能在短暂的时间内不提供给定的服务实例。设置配置：eureka.client.refresh.enable&#x3D;false ，则不刷新客户端 自我保护默认情况下，Eureka服务器端在一定的时间内如没有接收某个服务端实例的心跳，EurekaServer将会注销该实例。当网络发生故障的时候，微服务就可能无法正常通信。Eureka通过自我保护来解决这个，在短时间内失去过多的客户端的时候，进入自我保护模式，一但进入该模式，就会保护服务列表，不再删除服务注册列表中的数据。当故障恢复以后，退出自我保护模式。 负载均衡器LoadBalancer客户端的负载均衡器，进程内部的负载均衡器。默认的策略是轮询，还有一个是随机。可以自定义策略。 使用方式，在RestTemplate对象上加入@LoadBalanced 随机策略定义一个类（不能使用@Configuration注解），在此类当中增加一个@Bean注解的方法。返回RactorLoadbalancer接口的对象。 在配置类或者主启动类上使用@@LoadBalancerClients或者@LoadBalancerClient，指定上述定义的类为配置类 定义配置注意：千万不要增加@Configuration注解 1234567891011public class LoadBalancerConfig &#123; @Bean ReactorLoadBalancer&lt;ServiceInstance&gt; randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory) &#123; String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new RandomLoadBalancer(loadBalancerClientFactory .getLazyProvider(name, ServiceInstanceListSupplier.class), name); &#125;&#125; 启动类修改1234567891011121314151617181920212223@SpringBootApplication@EnableEurekaClient//配置单个服务的负载均衡策略//@LoadBalancerClient(value = &quot;GOODS&quot;,configuration = LoadBalancerConfig.class)//多个服务，采用同一个策略@LoadBalancerClients(defaultConfiguration = LoadBalancerConfig.class)//@LoadBalancerClients(value = &#123;@LoadBalancerClient(value = &quot;GOODS&quot;,configuration =LoadBalancerConfig.class )&#125;// , defaultConfiguration = LoadBalancerConfig.class)public class Base01OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01OrderApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 自定义负载均衡策略需求：使用轮询方式访问服务器，每个服务器访问三次之后换下一个服务器 需要两个属性：1）用来记录当前的服务器被调用了几次 ​ 2）记录当前服务器是第几台服务器 如果当前的服务器已经被调用三次，换下一台服务器（i ） 编写负载均衡策略类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MyRRLoadBalancer implements ReactorServiceInstanceLoadBalancer &#123; private static final Log log = LogFactory.getLog(RoundRobinLoadBalancer.class); final AtomicInteger position; final String serviceId; ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider; int count=0; int MAX=3; public MyRRLoadBalancer(String serviceId, ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider) &#123; this((new Random()).nextInt(1000),serviceId,serviceInstanceListSupplierProvider); &#125; public MyRRLoadBalancer(int position, String serviceId, ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider) &#123; this.position = new AtomicInteger(position);; this.serviceId = serviceId; this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider; &#125; public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123; ServiceInstanceListSupplier supplier = (ServiceInstanceListSupplier)this.serviceInstanceListSupplierProvider.getIfAvailable(NoopServiceInstanceListSupplier::new); return supplier.get(request).next().map((serviceInstances) -&gt; &#123; return this.processInstanceResponse(supplier, serviceInstances); &#125;); &#125; private Response&lt;ServiceInstance&gt; processInstanceResponse(ServiceInstanceListSupplier supplier, List&lt;ServiceInstance&gt; serviceInstances) &#123; Response&lt;ServiceInstance&gt; serviceInstanceResponse = this.getInstanceResponse(serviceInstances); if (supplier instanceof SelectedInstanceCallback &amp;&amp; serviceInstanceResponse.hasServer()) &#123; ((SelectedInstanceCallback)supplier).selectedServiceInstance((ServiceInstance)serviceInstanceResponse.getServer()); &#125; return serviceInstanceResponse; &#125; private Response&lt;ServiceInstance&gt; getInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123; if (instances.isEmpty()) &#123; if (log.isWarnEnabled()) &#123; log.warn(&quot;No servers available for service: &quot; + this.serviceId); &#125; return new EmptyResponse(); &#125; else if (instances.size() == 1) &#123; return new DefaultResponse((ServiceInstance)instances.get(0)); &#125; else &#123; int pos; if(count&lt;MAX) &#123; pos = this.position.get(); &#125; else &#123; pos = this.position.incrementAndGet() &amp; 2147483647; count=0; &#125; ServiceInstance instance = (ServiceInstance)instances.get(pos % instances.size()); count++; return new DefaultResponse(instance); &#125; &#125;&#125; 配置类修改1234567891011121314151617181920public class LoadBalancerConfig &#123; //@Bean //ReactorLoadBalancer&lt;ServiceInstance&gt; randomLoadBalancer(Environment environment, // LoadBalancerClientFactory loadBalancerClientFactory) &#123; // String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); // return new RandomLoadBalancer(loadBalancerClientFactory // .getLazyProvider(name, ServiceInstanceListSupplier.class), // name); //&#125; @Bean ReactorLoadBalancer&lt;ServiceInstance&gt; randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory) &#123; String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new MyRRLoadBalancer(name,loadBalancerClientFactory .getLazyProvider(name, ServiceInstanceListSupplier.class) ); &#125;&#125; Ribbon（旧）Ribbon是NetFlix发布的客户端负载均衡器，主要是用来控制HTTP和TCP客户端的行为。为Ribbon配置了服务提供者的地址列表后，Ribbon就可以基于某种负载均衡算法，自动地帮助服务消费者去请求对应的服务实例。Ribbon提供很多的负载均衡策略：轮询，随机，最少使用等。 Nginx和Ribbon的区别： Nginx：是集中式的负载均衡设备（软件），Ribbon是进程内的负载均衡器，只是一个类库，集成在消费方的进程当中，消费方通过它来获取服务提供者的位置。 Nignx是服务器端负载均衡器，客户端的请求都是交给Nginx，然后由Nginx进行转发。 Ribbon：在调用微服务接口的时候，会在注册中心上获取注册的服务列表，缓存到本地。 如何负载均衡策略123456789@Configurationpublic class AppConfig &#123; @Bean public IRule iRule()&#123; return new RandomRule(); &#125;&#125; 自带的负载均衡策略RoundRobinRule：轮询，尝试超过10次以后，直接不提供服务。 RandomRule: 随机策略 Retry：先按照轮询的策略获取服务，如果服务失败，则在指定的时间内进行重试，获取可用的服务 WeightedResponseTimeRule：是对轮询策略的扩展，每30秒钟计算一次服务器的响应时间，以响应时间作为权重，响应时间越短，响应速度越快的服务器被选中的概率越大。 BestAvailableRule：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，在可用列表中选择一个并发量最小的服务实例。 AvailabilityFilteringRule：：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，再选择一个相对并发量较小的实例。 ZoneAvoidanceRule：根据服务提供者实例的所在区域以及响应的可用性选择服务器。 自定义负载均衡策略需求：使用轮询方式访问服务器，每个服务器访问三次之后换下一个服务器 需要两个属性：1）用来记录当前的服务器被调用了几次 ​ 2）记录当前服务器是第几台服务器 如果当前的服务器已经被调用三次，换下一台服务器（i ） 定义策略12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CustomizeRule extends AbstractLoadBalancerRule &#123; //当前服务器索引的访问次数 private int total=0; //当前的服务器索引 private int currentIndex = 0; @Override public void initWithNiwsConfig(IClientConfig iClientConfig) &#123; &#125; @Override public Server choose(Object o) &#123; return choose(getLoadBalancer(),o); &#125; public Server choose(ILoadBalancer lb,Object key) &#123; if(lb == null) &#123; return null; &#125; Server server = null; //隐形风险：如果一直找不到可用的服务器实例，导致死循环 while (server==null)&#123; //获取可用的服务器列表 List&lt;Server&gt; reachableServers = lb.getReachableServers(); //获取所有的服务器列表 List&lt;Server&gt; allServers = lb.getAllServers(); int upCount = reachableServers.size(); int serverCount = allServers.size(); //没有可用的服务器实例，直接返回 if (upCount==0) &#123; return null; &#125; if(total &lt; 3) &#123; server=reachableServers.get(currentIndex); if (server==null) &#123; Thread.yield(); continue; &#125; total++; &#125; else &#123; currentIndex = (currentIndex + 1) % upCount; //currentIndex++; //if (currentIndex== upCount) &#123; // currentIndex=0; //&#125; server = reachableServers.get(currentIndex); if (server==null) &#123; Thread.yield(); continue; &#125; total =1; &#125; &#125; return server; &#125;&#125; 配置123456789@Configurationpublic class AppConfig &#123; @Bean public IRule iRule()&#123; //return new RandomRule(); return new CustomizeRule(); &#125;&#125; OpenFeign（Http服务调用）OpenFeign是NetFlix开发的声明式、模板化的HTTP客户端，用于HTTP请求调用的轻量级的框架，以Java接口注解的方式调用HTTP请求。OpenFeign支持SpringMVC注解，可以和Eureka，nacos等整合一起使用。 使用方法比较简单，主要是创建一个接口。接口上增加openfeign注解，并通过启动类进行注解的启用。通过注解，将请求模板化，根据参数对应到请求上。 使用步骤 导入依赖 在消费者端编写Openfeign的客户端（接口） 导入依赖增加以下依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 编写接口使用@FeignClient注解 123456789@Service//name指定要调用的服务名@FeignClient(name=&quot;bookapp&quot;)public interface UserServiceFeign &#123; @RequestMapping(value = &quot;book/&#123;isbn&#125;&quot;) Book findByIsbn(@PathVariable(&quot;isbn&quot;) String isbn);&#125; 修改控制器调用接口1234567891011121314@RestControllerpublic class UserController &#123; @Resource UserServiceFeign userServiceFeign; @GetMapping(&quot;borrow/&#123;isbn&#125;&quot;) public Book searchBook(@PathVariable(&quot;isbn&quot;) String isbn) &#123; return userServiceFeign.findByIsbn(isbn); &#125;&#125; 修改主启动类增加@EnableFeignClient注解 12345678910111213141516@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class Base01ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01ConsumerApplication.class, args); &#125; @Bean @LoadBalanced //启用ribbon的负载均衡 public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 特殊属性说明fallback和fallbackFactory，主要用于熔断机制，调用失败时，走的回退方法，可以用来抛出异常或者给出默认的数据。 decode404:配置响应状态为404时，是否抛出FeignException 调用的原理OpenFeign基于JDK的动态代理。 @EnableFeignClients：加上该注解，Springboot启动的时候，会导入FeignClientsRegistrar，扫描所有带有@FeignClient注解的接口 解析到@FeignClient的配置属性后，扩展Spring Bean Definition的注册逻辑上面，最终注册一个FeignClientFactoryBean，此对象会产生一个代理类对象。 设置超时时间可以参考在FeignClientProperties中的数据，主要是其内部类FeignClientConfiguration 123456feign: client: config: GOODS: #指定服务 connectTimeout: 1000 readTimeout: 1000 Hystrix（容错保护、断路器）背景在微服务的架构当中，原本一个大的服务会拆分成多个小服务单元，服务单元之间无法避免会有相互的依赖关系。由于这种依赖关系，当某一个服务单元出现故障，容易引起故障的蔓延，最终有可能导致整个系统的瘫痪。 雪崩效应：当某一个服务单元出现故障，容易引起故障的蔓延，顺着调用链向上传递，最终有可能导致整个系统的瘫痪的现象。 产生场景 硬件故障：服务器宕机，机房断电，光纤被挖断… 流量激增：异常流量激增，重试也会增加流量 缓存问题：由于缓存的问题，导致服务提供者的负荷增加了，引起服务的不可用。 程序BUG: 程序逻辑错误导致内存泄漏，JVM长时间进行FullGC。 同步等待：服务间采用同步调用机制，同步等待导致资源的耗尽。 Hystrix的目标：在于通过控制哪些远程访问、服务以及第三方的节点，从而对延迟或者故障提供更强大的容错能力。 Hystrix是干什么的NetFlix公司开源的，用于分布式系统的延迟和容错处理的开源库。用于隔离远程访问、服务以及第三方的库，防止级联失败，从而提升系统的可用性以及容错性。 CAP: C: 一致性。分布式集群中节点（broker）上的数据要保持一致。 A：可用性，要求服务端能够在指定的时间快速响应用户。 P: 分区容错性，当集群或者分布式系统中的某一个节点（服务）出现问题后，整个集群或分布式系统的使用不能收到影响。 要么是CP，要么AP 服务降级： 假设系统比较忙或者不可用的情况下，给一个友好提示或者默认处理。触发降级的场合：程序运行异常、超时、服务熔断触发服务降级，线程池当中并发量达到阈值也可能导致服务降级。 服务熔断：达到最大服务访问量以后，直接拒绝访问，然后调用服务降级的方法给出友好提示。 服务限流：秒杀，抢红包等一系列高并发操作，严控一窝蜂的过来拥挤，让大家排队有序进行。 RestTemplate方法依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; service中的方法 降级方法的参数和返回值要和原来方法一致 12345678910111213141516171819202122232425262728293031@Servicepublic class UserService &#123; //服务提供者的服务URL //String host = &quot;http://localhost:8080&quot;; //用服务名替换具体的服务器的URL String host = &quot;http://BOOKAPP&quot;; @Resource RestTemplate restTemplate; @HystrixCommand(fallbackMethod = &quot;fallback&quot;) public Book searchBook(String isbn)&#123; System.out.println(&quot;用户查找图书&quot;); String url = host + &quot;/book/&quot; + isbn; Book book = restTemplate.getForObject(url, Book.class); return book; &#125; public String getServer()&#123; String url = host + &quot;/server&quot;; String server = restTemplate.getForObject(url, String.class); return server; &#125; public Book fallback(String isbn)&#123; return new Book(&quot;XXXX&quot;,&quot;服务器出现异常&quot;,&quot;&quot;,0.0); &#125;&#125; 启动类 增加@EnableHystrix或者@EnableCircuitBreaker注解 123456789101112131415161718@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableHystrix //启动Hystrix断路器//@EnableCircuitBreaker //启用容错保护组件（）public class Base01ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01ConsumerApplication.class, args); &#125; @Bean @LoadBalanced //启用ribbon的负载均衡 public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 统一处理在Service类上使用@DefaultProperties注解，指定默认的服务降级的方法。 全局降级的方法，不能带有参数。 需要降级处理的方法上，不指定降级目标方法（回退方法），但是@HystrixCommand注解需要保留 OpenFeign方式开启Hystrix12345feign: httpclient: connection-timeout: 2000 #连接服务端的时间 + 实际读取的时间 hystrix: enabled: true #开启容错保护组件 fallback属性使用@FeignClient的fallback属性，设置成指定的类 处理降级的类，需要实现对应的接口 1234567@Componentpublic class UserServiceFeignException implements UserServiceFeign &#123; @Override public Book findByIsbn(String isbn) &#123; return new Book(&quot;110&quot;,&quot;我是服务器，现在挂机中&quot;,&quot;&quot;,0.0); &#125;&#125; fallbackFactory属性使用@FeignClient的fallbackFactory属性，设置成指定的类 处理降级的类，实现FallbackFactory接口 123456789101112@Componentpublic class UserServiceFeignFactory implements FallbackFactory&lt;UserServiceFeign&gt; &#123; @Override public UserServiceFeign create(Throwable throwable) &#123; return new UserServiceFeign() &#123; @Override public Book findByIsbn(String isbn) &#123; return new Book(&quot;666&quot;,&quot;光纤被挖断了&quot;,&quot;&quot;,0.0); &#125; &#125;; &#125;&#125; 熔断演示HystrixCommandProperties：普通参数HystrixThreadPoolProperties：和线程池相关参数 看板（仪表盘）仪表盘项目创建一个web项目，要把web依赖去掉，增加hystrix-dashboard的依赖 配置项目增加hystrix.dashboard.proxy-stream-allow-list&#x3D;* 在主启动类上要增@EnableHystrixDash注解 配置HystrixMetricsStreamServlet （可以使用配置文件，也可以在启动类当中注册） 被监控项目增加两个依赖 hystrix-dashboard actuator依赖 配置项目 12345management: endpoints: web: exposure: include: hystrix.stream 启动项目测试 启动dashboard，输入localhost:端口号&#x2F;hystrix 启动被监控项目，在前面的页面窗口，输入 localhost:被监控项目端口号&#x2F;actuator&#x2F;hystrix.stream Resilience4J依赖增加springboot-aop以及actuator依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-circuitbreaker-resilience4j&lt;/artifactId&gt;&lt;/dependency&gt; 配置服务可用的配置项目：CircuitBreakerConfig当中，可以去参考 使用断路器网关GatewayGateway是Spring Cloud的子项目，Spring2.X提供的，Spring1.X用的是zuul（已经停更，进入维护期），提供简单有效的API路由管理方式。 Gateway作为zuul的替代品，是Springcloud生态中的网管。是基于WebFlux，高效能的Reactor模式。 Gateway的特点： ​ 支持动态路由：能够匹配路由的任何请求属性 ​ 集成Spring Cloud的服务发现功能 ​ 支持限流功能 ​ 支持路径重写 ​ 提供断言（Predicate）以及过滤器（Filter），可以设置路由的一些条件 功能服务网关：路由转发 + 过滤器 路由转发：接收客户端的请求，将请求转发到指定的微服务上。 过滤器：可以帮助网关实现一些类似于AOP可以完成的一些操作，认证，服务的监控，限流。 案例： 有四个微服务，每个微服务都需要权限的认证 ​ 方案一：每个微服务都实现一下权限认证的代码&#x3D;&#x3D;&#x3D;&gt;基本不会使用 ​ 方案二：将认证服务写成一个公共的服务，每个业务相关的微服务都来调用公共的服务。 ​ 方案三：将认证服务写到网关的过滤器 核心概念路由（Route）：路由是构建网关的基本模块。它由ID,目标URI,一系列的断言和过滤器组成。 断言（Predicate）：开发人员可以通过断言的相关设置，匹配HTTP请求中的参数内容，设置访问路由的条件 过滤器（Filter）：通过过滤器，可以在路由前后进行一些修改 如何编写网关创建一个springcloud项目 增加网关依赖，eureka客户端 配置相应的网关 动态路由1234567891011121314151617181920212223spring: application: name: base03-gateway cloud: gateway: routes: - id: gt-bookapp #id值需要位置# uri: http://localhost:8070 uri: lb://bookapp #lb为固定值，表示负载均衡，bookapp为服务名 predicates: - Path=/** discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由server: port: 10000 #作为eureka的客户端的配置eureka: client: service-url: defaultZone: http://localhost:7100/eureka register-with-eureka: true fetch-registry: true 断言断言（Predicates）是一组匹配规则，请求只有和规则相匹配时才可以访问 -Path : 匹配路径 -After ： - After&#x3D;时间 （在某个时间之后可以访问）由于是ZoneDateTime， 时间需要带有时区 ​ - After&#x3D;2021-11-24T11:35:57.557+08:00[Asia&#x2F;Shanghai] Before： - Before&#x3D;时间 （在某个时间之前可以访问） -Between: - Before&#x3D;时间1, 时间2 -Cookie, phone为key，15911111111 -Header： 表示请求头当中，需要包含某些内容，请求才可以访问 ​ -Header&#x3D;authenticator, 1111 -Method: 匹配请求方式，如 -Method&#x3D;POST,GET -Query：匹配请求的参数 -Query&#x3D;price,\\d+ : 请求当中需要携带price参数，且值必须数字才可以访问 过滤器Spring cloud通过过滤器在请求的前后进行一部分分更新 抽象类AbstractGatewayFilterFactory的子类对象，配置的时候，去掉GatewayFilterFactory后缀 12345678910111213141516171819spring: application: name: base03-gateway cloud: gateway: routes: - id: gt-bookapp #id值需要位置# uri: http://localhost:8070 uri: lb://bookapp #lb为固定值，表示负载均衡，bookapp为服务名 predicates: - Path=/book/** #限制访问的路径 - After=2021-11-24T11:35:57.557+08:00[Asia/Shanghai] filters: - AddRequestHeader=username,xiaoming - RedirectTo=302,http://www.baidu.com discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由 自定义全局过滤器实现GlobalFilter接口，对所有的路由均有效。 123456789101112131415@Componentpublic class MyGlobalFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; //要求访问网关时，必须带有user参数，如果为null，则不放行，拒绝，不为null，则放行 String user = exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;); if (user == null) &#123; System.out.println(&quot;===用户参数user没有设置&quot;); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); exchange.getResponse().setComplete(); //设置拒绝 &#125; return chain.filter(exchange); //放行 &#125;&#125; 局部过滤器实现AbstractGatewayFilterFactory，要以GatewayFilterFactory作为类的后缀名 在指定路由的filters下定义对应的过滤器即可。 123456789101112131415//定义过滤器@Componentpublic class MyTestGatewayFilterFactory extends AbstractGatewayFilterFactory &#123; @Override public GatewayFilter apply(Object config) &#123; return new GatewayFilter() &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;=========局部过滤器=====================&quot;); return chain.filter(exchange); &#125; &#125;; &#125;&#125; 配置过滤器 1234567891011121314151617181920spring: application: name: base03-gateway cloud: gateway: routes: - id: gt-bookapp #id值需要位置# uri: http://localhost:8070 uri: lb://bookapp #lb为固定值，表示负载均衡，bookapp为服务名 predicates: - Path=/book/** #限制访问的路径 - After=2021-11-24T11:35:57.557+08:00[Asia/Shanghai] filters: - MyTest #- AddRequestHeader=username,xiaoming #- RedirectTo=302,http://www.baidu.com discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由 nacosNaming Configuration Service： 注册中心 + 配置中心 + 配置总线的组合组件 中文官网：https://nacos.io/zh-cn/index.html 英文spring： spring.io 下载：https://github.com/alibaba/nacos 使用nacos，不需要单独在编写一个nacos服务器端，已经提供。nacos是基于java代码实现。阿里出品。 注册中心依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2021.0.4.0&lt;/version&gt; &lt;/dependency&gt; 注册配置1234567891011server: port: 8082spring: application: name: GOODS cloud: nacos: discovery: server-addr: http://localhost:8848 namespace: java180 group: dev 主启动类注解123456789@SpringBootApplication@EnableDiscoveryClientpublic class Base04GoodsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base04GoodsApplication.class, args); &#125;&#125; 配置中心步骤增加依赖 配置 在主启动类增加@EnableDiscoveryClient注解 读取属性的类上，使用@RefreshScope来进行动态属性的拉取 依赖123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2021.0.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;2021.0.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springcloud 2020.x只用去掉了bootstrap，需要重新加上 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; 配置文件配置bootstrap.ymlbootstrap.yml ：会在application.yml读取之前先读，其中的内容是不会被覆盖 123456789101112131415spring: cloud: nacos: discovery: #注册中心 server-addr: http://localhost:8848 namespace: java180 group: dev service: configinfo config: #配置中心 server-addr: http://localhost:8848 namespace: java180 #默认情况下是public，不能写public，不进行此属性的配置即可 group: dev #配置文件定义的profile（group）s file-extension: yaml #需要进行 application: name: configinfo 配置application.yml123spring: profiles: active: test nacos配置中心文件名的命名规则在nacos配置中心设置配置文件时，文件的dataId由三个部分组成，prefix，profile（dev，test，prod），file-extension（yaml或者properties，根据选择的文件类型来决定） ​ prefix-profile.file-extension prefix: 默认为spring.application.name的值(例：项目：nacos-config)，也可以通过配置项spring.cloud.nacos.config.prefix profile: spring.profiles.active对应的环境，如果没有设置多环境，则文件名 prefix.file-extension file-extension: 目前只支持properties和yaml namespace：项目隔离的作用 配置案例configinfo-dev.yaml123456server: port: 10086user: name: zhangsan age: 10 scholl: 五老村小学 属性获取类12345678910@Component@RefreshScope //用于读取远程的配置文件，支持动态刷新@ConfigurationProperties(prefix = &quot;user&quot;)@Datapublic class User &#123; String name; int age; String school;&#125; 主启动类1234567891011@SpringBootApplication@EnableDiscoveryClient //标记是一个nacos的客户端public class Base05ConfiginfoApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext ctx = SpringApplication.run(Base05ConfiginfoApplication.class, args); User bean = ctx.getBean(User.class); System.out.println(bean); &#125;&#125; sentinelSentinel是alibaba提供的用于实时监控、流量控制、异常熔断等管理工具，它可以于nacos进行组合使用，可以对项目进行图形化的配置和管理。 运行启动sentinel，可以通过–server.port指定端口号 1java -jar sentinel-dashboard-1.8.2.jar --server.port=8081 依赖流量控制监控应用流量的QPS(每秒请求次数)或者并发线程数，当达到指定阈值的时候进行流量控制，以避免被瞬间的流量高峰击垮，从而保证应用的高可用性。 资源源：唯一，默认是请求的路径 针对来源：sentinel可以对调用者进行限流，默认是default（不区分来源），想要区分来源的情况，填写来源的服务名 阈值类型： ​ QPS: 每秒请求数量，达到此阈值的时候会限流 ​ 并发线程数 流控模式： ​ 直接：直接限流 ​ 关联：如果请求m1关联m2, 如果m2达到阈值，则限流m1 ​ 链路：需要设置入口资源，对整个链路进行流量限制 流控效果： ​ 快速失败：超出阈值后，直接抛出异常，请求失败 ​ warm up：预热&#x2F;冷启动模式，经过一定的市场（n秒），从codeFactor（&#x3D;3）阈值慢慢达到指定的阈值 ​ 排队等待：当请求超出阈值之后，需要进行排队等待，等待的时间可以进行设置。 123456789101112@GetMapping(&quot;test&quot;) // /test //@SentinelResource(value = &quot;test&quot;,fallback = &quot;fallbackMethod&quot;) @SentinelResource(value = &quot;test&quot;,fallback = &quot;fallbackMethod&quot; ,fallbackClass = InfoFallBackComponent.class) public String test()&#123; System.out.println(&quot;test: &quot; + LocalDateTime.now()); return &quot;game over&quot;; &#125; //public String fallbackMethod(Throwable e)&#123; // return &quot;方法被限流&quot;; //&#125; 熔断降级Sentinel熔断降级主要是适用某个资源请求处理不稳定的情况下，对此资源进行调用限制。 不稳定的因素：调用时间比较常，异常出现的频率高 统计1秒种（1000ms）时间内，如果请求的次数达到2次以上（最小请求数），慢调用（请求的时间超过100猫喵）的比例，达到0.5的情况，就会熔断20秒。 热点key设置调用后端接口的参数，根据方法上来，0为第一个参数，1为第二个参数。 资源名：可以是请求的url，也可以是@SentinelResource的value值。 blockHandler对应的方法，除了参数以及返回值之外，还需要增加一个BlockException参数 sentinel和openfeign进行整合，如何进行服务降级处理。 12345678@GetMapping(&quot;/testHotkey&quot;) @SentinelResource(value = &quot;/testHotkey&quot;,blockHandler = &quot;blockHandler&quot;) public String testHotKey(String p1,String p2) &#123; return &quot;success&quot;; &#125; public String blockHandler(String p1, String p2, BlockException ex) &#123; return &quot;blockHandler&quot;; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"MyBatis面试题","slug":"MyBatis面试题","date":"2023-10-05T10:39:11.000Z","updated":"2023-10-05T10:42:58.476Z","comments":true,"path":"2023/10/05/MyBatis面试题/","link":"","permalink":"http://example.com/2023/10/05/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"MyBatis简介MyBatis是什么？MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 ORM是什么ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。 而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。 传统JDBC开发存在的问题 频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。 sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。 JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？ 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。 解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。 解决： Mybatis自动将java对象映射至sql语句。 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。 解决：Mybatis自动将sql执行结果映射至java对象。 Mybatis优缺点优点 与传统的数据库访问技术相比，ORM有以下优点： 基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用 与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持） 提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护 能够与Spring很好的集成 缺点 SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求 SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库 MyBatis框架适用场景 MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。 对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。 Hibernate 和 MyBatis 的区别相同点 都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。 不同点 映射关系 MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单 Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂 SQL优化和移植性 Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。 MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。 开发难易程度和学习成本 Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统 MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统 总结 MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架， Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。 MyBatis的解析和运行原理MyBatis编程步骤是什么样的？ 创建SqlSessionFactory 通过SqlSessionFactory创建SqlSession 通过sqlsession执行数据库操作 调用session.commit()提交事务 调用session.close()关闭会话 请说说MyBatis的工作原理在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis 的工作原理如下图 MyBatis工作原理 读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。 加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。 构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。 创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。 Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。 MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。 输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。 输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。 MyBatis的功能架构是怎样的 Mybatis功能框架 我们把Mybatis的功能架构分为三层： API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。 MyBatis的框架架构设计是怎么样的 Mybatis框架架构 这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。 (1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。 (2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。 (3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。 (4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。 为什么需要预编译 定义：SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。 为什么需要预编译JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。 Mybatis都有哪些Executor执行器？它们之间的区别是什么？Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。 SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。 Mybatis中如何指定使用哪一种Executor执行器？在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。 当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。 映射器#{}和${}的区别 #{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。 Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。 Mybatis在处理 {}时，是原值传入，就是把 时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译 变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’ #{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入 #{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外 模糊查询like语句该怎么写（1）’%${question}%’ 可能引起SQL注入，不推荐 （2）”%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。 （3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐 （4）使用bind标签 1234&lt;select id=&quot;listUserLikeUsername&quot; resultType=&quot;com.jourwon.pojo.User&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot; /&gt; select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;&lt;/select&gt; 在mapper中如何传递多个参数方法1：顺序传参法 123456public User selectUser(String name, int deptId);&lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt; select * from user where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;&lt;/select&gt; #{}里面的数字代表传入参数的顺序。 这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。 方法2：@Param注解传参法 123456public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptId&quot;) deptId);&lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt; select * from user where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;&lt;/select&gt; #{}里面的名称对应的是注解@Param括号里面修饰的名称。 这种方法在参数不多的情况还是比较直观的，推荐使用。 方法3：Map传参法 123456public User selectUser(Map&lt;String, Object&gt; params);&lt;select id=&quot;selectUser&quot; parameterType=&quot;java.util.Map&quot; resultMap=&quot;UserResultMap&quot;&gt; select * from user where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;&lt;/select&gt; #{}里面的名称对应的是Map里面的key名称。 这种方法适合传递多个参数，且参数易变能灵活传递的情况。 方法4：Java Bean传参法 123456public User selectUser(User user);&lt;select id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot; resultMap=&quot;UserResultMap&quot;&gt; select * from user where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;&lt;/select&gt; #{}里面的名称对应的是User类里面的成员属性。 这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。 Mybatis如何执行批量操作使用foreach标签 foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。 item 表示集合中每一个元素进行迭代时的别名，随便起的变量名； index 指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用； open 表示该语句以什么开始，常用“(”； separator表示在每次进行迭代之间以什么符号作为分隔符，常用“,”； close 表示以什么结束，常用“)”。 在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key 具体用法如下： 12345678910111213141516&lt;!-- 批量保存(foreach插入多条数据两种方法) int addEmpsBatch(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); --&gt;&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt; //推荐使用&lt;insert id=&quot;addEmpsBatch&quot;&gt; INSERT INTO emp(ename,gender,email,did) VALUES &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt;&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持 如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&gt; &lt;insert id=&quot;addEmpsBatch&quot;&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt; INSERT INTO emp(ename,gender,email,did) VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 使用ExecutorType.BATCH Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的 具体用法如下 1234567891011121314151617181920212223242526//批量保存方法测试@Test public void testBatch() throws IOException&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); //可以执行批量操作的sqlSession SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH); //批量保存执行前时间 long start = System.currentTimeMillis(); try &#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); for (int i = 0; i &lt; 1000; i++) &#123; mapper.addEmp(new Employee(UUID.randomUUID().toString().substring(0, 5), &quot;b&quot;, &quot;1&quot;)); &#125; openSession.commit(); long end = System.currentTimeMillis(); //批量保存执行后的时间 System.out.println(&quot;执行时长&quot; + (end - start)); //批量 预编译sql一次==》设置参数==》10000次==》执行1次 677 //非批量 （预编译=设置参数=执行 ）==》10000次 1121 &#125; finally &#123; openSession.close(); &#125;&#125; mapper和mapper.xml如下 12345678910public interface EmployeeMapper &#123; //批量保存员工 Long addEmp(Employee employee);&#125;&lt;mapper namespace=&quot;com.jourwon.mapper.EmployeeMapper&quot; &lt;!--批量保存员工 --&gt; &lt;insert id=&quot;addEmp&quot;&gt; insert into employee(lastName,email,gender) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;) &lt;/insert&gt;&lt;/mapper&gt; 如何获取生成的主键对于支持主键自增的数据库（MySQL） 12345&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;userId&quot; &gt; insert into user( user_name, user_password, create_time) values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)&lt;/insert&gt; parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那么应当parameterType 应当是java实体或者Map。这样数据在插入之后 可以通过ava实体或者Map 来获取主键值。通过 getUserId获取主键 不支持主键自增的数据库（Oracle） 对于像Oracle这样的数据，没有提供主键自增的功能，而是使用序列的方式获取自增主键。可以使用＜selectKey＞标签来获取主键的值，这种方式不仅适用于不提供主键自增功能的数据库，也适用于提供主键自增功能的数据库＜selectKey＞一般的用法 12&lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;id&quot; order=&quot;BEFORE&quot;&gt;&lt;/selectKey&gt; 属性 描述 keyProperty selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn 匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 resultType 结果的类型，MyBatis 通常可以推算出来。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。 order 值可为BEFORE 或 AFTER。如果是 BEFORE，那么它会先执行selectKey设置 keyProperty 然后执行插入语句。如果为AFTER则相反。 statementType 使用何种语句类型，默认PREPARED。 有STATEMENT，PREPARED 和 CALLABLE 语句的映射类型。 12345678&lt;insert id=&quot;insertUser&quot; &gt; &lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;userId&quot; order=&quot;BEFORE&quot;&gt; SELECT USER_ID.nextval as id from dual &lt;/selectKey&gt; insert into user( user_id,user_name, user_password, create_time) values(#&#123;userId&#125;,#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)&lt;/insert&gt; 此时会将Oracle生成的主键值赋予userId变量。这个userId 就是USER对象的属性，这样就可以将生成的主键值返回了。如果仅仅是在insert语句中使用但是不返回，此时keyProperty&#x3D;“任意自定义变量名”，resultType 可以不写。Oracle 数据库中的值要设置为 BEFORE ，这是因为 Oracle中需要先从序列获取值，然后将值作为主键插入到数据库中。 扩展如果Mysql 使用selectKey的方式获取主键，需要注意下面两点： order ： AFTER获取递增主键值 ：SELECT LAST_INSERT_ID() 当实体类中的属性名和表中的字段名不一样 ，怎么办第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。 123&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultType=&quot;com.jourwon.pojo.Order&quot;&gt; select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;&lt;/select&gt; 第2种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。 123456789101112&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderResultMap&quot;&gt; select * from orders where order_id=#&#123;id&#125;&lt;/select&gt;&lt;resultMap type=&quot;com.jourwon.pojo.Order&quot; id=&quot;orderResultMap&quot;&gt; &lt;!–用id属性来映射主键字段–&gt; &lt;id property=&quot;id&quot; column=&quot;order_id&quot;&gt; &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt; &lt;result property =&quot;orderno&quot; column =&quot;order_no&quot;/&gt; &lt;result property=&quot;price&quot; column=&quot;order_price&quot; /&gt;&lt;/reslutMap&gt; Mapper 编写有哪几种方式？第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。 （1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置 1234&lt;mappers&gt; &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt; &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;&lt;/mappers&gt; （2）定义 mapper 接口 （3）实现类集成 SqlSessionDaoSupport mapper 方法中可以 this.getSqlSession()进行数据增删改查。 （4）spring 配置 123&lt;bean id=&quot; &quot; class=&quot;mapper 接口的实现&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean： （1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置 1234&lt;mappers&gt; &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt; &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;&lt;/mappers&gt; （2）定义 mapper 接口： （3）mapper.xml 中的 namespace 为 mapper 接口的地址 （4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致 （5）Spring 中定义 1234&lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;mapper 接口地址&quot; /&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; 第三种：使用 mapper 扫描器： （1）mapper.xml 文件编写： mapper.xml 中的 namespace 为 mapper 接口的地址； mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致； 如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。 （2）定义 mapper 接口： 注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录 （3）配置 mapper 扫描器： 1234&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;mapper 接口包地址 &quot;&gt;&lt;/property&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; （4）使用扫描器后从 spring 容器中获取 mapper 的实现对象。 什么是MyBatis的接口绑定？有哪些实现方式？接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。 接口绑定有两种实现方式 通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定； 通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。 使用MyBatis的mapper接口调用时有哪些要求？ Mapper接口方法名和mapper.xml中定义的每个sql的id相同。 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。 Mapper.xml文件中的namespace即是mapper接口的类路径。 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id &#x3D; findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。 Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。 Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。 原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt;resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。 Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？第一种是使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。 第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。 有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。 Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？还有很多其他的标签，&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、&lt;selectKey&gt;，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中&lt;sql&gt;为sql片段标签，通过&lt;include&gt;标签引入sql片段，&lt;selectKey&gt;为不支持自增的主键生成策略标签。 Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。 原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。 高级查询MyBatis实现一对一，一对多有几种方式，怎么操作的？有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成 嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。 Mybatis是否可以映射Enum枚举类？Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。 TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。 动态SQLMybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。 插件模块Mybatis是如何进行分页的？分页插件的原理是什么？Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10 简述Mybatis的插件运行原理，以及如何编写一个插件。Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。 实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。 缓存Mybatis的一级、二级缓存 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置&lt;cache/&gt; ； 对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"SpringMVC面试题","slug":"SpringMVC面试题","date":"2023-10-05T10:34:06.000Z","updated":"2023-10-05T10:35:33.496Z","comments":true,"path":"2023/10/05/SpringMVC面试题/","link":"","permalink":"http://example.com/2023/10/05/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"概述什么是Spring MVC？简单介绍下你对Spring MVC的理解？Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。 Spring MVC的优点（1）可以支持各种视图技术,而不仅仅局限于JSP； （2）与Spring框架集成（如IoC容器、AOP等）； （3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。 （4） 支持各种请求资源的映射策略。 核心组件Spring MVC的主要组件？（1）前端控制器 DispatcherServlet（不需要程序员开发） 作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。 （2）处理器映射器HandlerMapping（不需要程序员开发） 作用：根据请求的URL来查找Handler （3）处理器适配器HandlerAdapter 注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。 （4）处理器Handler（需要程序员开发） （5）视图解析器 ViewResolver（不需要程序员开发） 作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view） （6）视图View（需要程序员开发jsp） View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等） 什么是DispatcherServletSpring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。 什么是Spring MVC框架的控制器？控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。 Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。 工作原理请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？（1）用户发送请求至前端控制器DispatcherServlet； （2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle； （3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet； （4）DispatcherServlet 调用 HandlerAdapter处理器适配器； （5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)； （6）Handler执行完成返回ModelAndView； （7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet； （8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析； （9）ViewResolver解析后返回具体View； （10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中） （11）DispatcherServlet响应用户。 img MVC框架MVC是什么？MVC设计模式的好处有哪些mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。 mvc设计模式的好处 1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。 2.有利于系统的并行开发，提升开发效率。 常用注解注解原理是什么注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。 Spring MVC常用的注解有哪些？@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。 @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。 @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。 SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。 @Controller注解的作用在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。 @Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式： 在Spring MVC 的配置文件中定义MyController 的bean 对象。 在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。 @RequestMapping注解的作用RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。 value， method value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）； method： 指定请求的method类型， GET、POST、PUT、DELETE等； consumes，produces consumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params，headers params： 指定request中必须包含某些参数值是，才让该方法处理。 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 @ResponseBody注解的作用作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； @PathVariable和@RequestParam的区别请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value &#x3D; “&#x2F;page&#x2F;{id}”, method &#x3D; RequestMethod.GET) @RequestParam用来获得静态的URL请求入参 spring注解时action里用到。 其他Spring MVC怎么样设定重定向和转发的？（1）转发：在返回值前面加”forward:”，譬如”forward:user.do?name&#x3D;method4” （2）重定向：在返回值前面加”redirect:”，譬如”redirect:http://www.baidu.com“ Spring MVC怎么和AJAX相互调用的？通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ： （1）加入Jackson.jar （2）在配置文件中配置json的映射 （3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。 如何解决POST请求中文乱码问题，GET的又如何处理呢？（1）解决post请求乱码问题： 在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8； 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; （2）get请求中文参数出现乱码解决方法有两个： ①修改tomcat配置文件添加编码与工程编码一致，如下： 1&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; ②另外一种方法对参数进行重新编码： String userName &#x3D; new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”) ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。 Spring MVC的异常处理？答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。 如果在拦截请求中，我想拦截get方式提交的方法,怎么配置答：可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET。 怎样在方法里面得到Request,或者Session？答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。 如果想在拦截的方法里面得到从前台传入的参数,怎么得到？答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。 Spring MVC中函数的返回值是什么？答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。 Spring MVC用什么对象从后台向前台传递数据的？答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。 怎么样把ModelMap里面的数据放入Session里面？答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。 Spring MVC里面拦截器是怎么写的有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可： 12345678910&lt;!-- 配置Spring MVC的拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt; &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.zwp.action.MyHandlerInterceptor&quot;&gt;&lt;/bean&gt; &lt;!-- 只针对部分请求拦截 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt; &lt;bean class=&quot;com.zwp.action.MyHandlerInterceptorAdapter&quot; /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 介绍一下 WebApplicationContextWebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Spring面试题","slug":"Spring面试题","date":"2023-10-05T10:26:57.000Z","updated":"2023-10-05T10:31:53.688Z","comments":true,"path":"2023/10/05/Spring面试题/","link":"","permalink":"http://example.com/2023/10/05/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"Spring概述（10）什么是spring?Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。 Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是**依赖注入（dependency injection，DI）**和**面向切面编程（aspect-oriented programming，AOP）**。 为了降低Java开发的复杂性，Spring采取了以下4种关键策略 基于POJO的轻量级和最小侵入性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模板减少样板式代码。 Spring框架的设计目标，设计理念，和核心是什么Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台； Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦； Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。 IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。 Spring的优缺点是什么？优点 方便解耦，简化开发 Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。 AOP编程的支持 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程。 方便程序的测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。 降低JavaEE API的使用难度 Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。 缺点 Spring明明一个很轻量级的框架，却给人感觉大而全 Spring依赖反射，反射影响性能 使用门槛升高，入门Spring需要较长时间 Spring有哪些应用场景应用场景：JavaEE企业应用开发，包括SSH、SSM等 Spring价值： Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化； Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来； Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性； Spring由哪些模块组成？Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图： 在这里插入图片描述 spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。 spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。 spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。 spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。 spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。 spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。 spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。 Spring 框架中都用到了哪些设计模式？ 工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例； 单例模式：Bean默认为单例模式。 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术； 模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。 详细讲解一下核心容器（spring context应用上下文) 模块这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。 Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。 Spring框架中有哪些不同类型的事件Spring 提供了以下5种标准的事件： 上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。 上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。 上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。 上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。 请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。 Spring 应用程序有哪些不同组件？Spring 应用一般有以下组件： 接口 - 定义功能。 Bean 类 - 它包含属性，setter 和 getter 方法，函数等。 Bean 配置文件 - 包含类的信息以及如何配置它们。 Spring 面向切面编程（AOP） - 提供面向切面编程的功能。 用户程序 - 它使用接口。 使用 Spring 有哪些方式？使用 Spring 有以下方式： 作为一个成熟的 Spring Web 应用程序。 作为第三方 Web 框架，使用 Spring Frameworks 中间层。 作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。 用于远程使用。 Spring控制反转(IOC)（13）什么是Spring IOC 容器？控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。 Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。 控制反转(IoC)有什么作用 管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的 解耦，由容器去维护具体的对象 托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的 IOC的优点是什么？ IOC 或 依赖注入把应用的代码量降到最低。 它使应用容易测试，单元测试不再需要单例和JNDI查找机制。 最小的代价和最小的侵入性使松散耦合得以实现。 IOC容器支持加载服务时的饿汉式初始化和懒加载。 Spring IoC 的实现机制Spring 中的 IoC 的实现原理就是工厂模式加反射机制。 示例： 123456789101112131415161718192021222324252627282930313233343536interface Fruit &#123; public abstract void eat(); &#125;class Apple implements Fruit &#123; public void eat()&#123; System.out.println(&quot;Apple&quot;); &#125;&#125;class Orange implements Fruit &#123; public void eat()&#123; System.out.println(&quot;Orange&quot;); &#125;&#125;class Factory &#123; public static Fruit getInstance(String ClassName) &#123; Fruit f=null; try &#123; f=(Fruit)Class.forName(ClassName).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return f; &#125;&#125;class Client &#123; public static void main(String[] a) &#123; Fruit f=Factory.getInstance(&quot;io.github.dunwu.spring.Apple&quot;); if(f!=null)&#123; f.eat(); &#125; &#125;&#125; Spring 的 IoC支持哪些功能Spring 的 IoC 设计支持以下功能： 依赖注入 依赖检查 自动装配 支持集合 指定初始化方法和销毁方法 支持回调某些方法（但是需要实现 Spring 接口，略有侵入） 其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。 对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。 BeanFactory 和 ApplicationContext有什么区别？BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。 依赖关系 BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。 ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能： 继承MessageSource，因此支持国际化。 统一的资源文件访问方式。 提供在监听器中注册bean的事件。 同时加载多个配置文件。 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。 加载方式 BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。 ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。 创建方式 BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。 注册方式 BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。 Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解Spring 作者 Rod Johnson 设计了两个接口用以表示容器。 BeanFactory ApplicationContext BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。 ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载&#x2F;刷新所有的 bean。 当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。 BeanFactory和ApplicationContext的关系 为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。 img 有点复杂？ 先不要慌，我来解释一下。 最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。 看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。 通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！ 左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。 小结 说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤： 加载配置文件，解析成 BeanDefinition 放在 Map 里。 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。 上面就是 Spring 低级容器（BeanFactory）的 IoC。 至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。 ApplicationContext通常的实现是什么？FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。 WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。 什么是Spring的依赖注入？控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找 依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。 依赖注入的基本原则依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。 依赖注入有什么优势依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为： 查找定位操作与应用代码完全无关。 不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。 不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。 有哪些不同类型的依赖注入实现方式？依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 构造器依赖注入和 Setter方法注入的区别 构造函数注入 setter 注入 没有部分注入 有部分注入 不会覆盖 setter 属性 会覆盖 setter 属性 任意修改都会创建一个新实例 任意修改不会创建一个新实例 适用于设置很多属性 适用于设置少量属性 两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。 Spring Beans（19）什么是Spring beans？Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。 一个 Spring Bean 定义 包含什么？一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。 如何给Spring 容器提供配置元数据？Spring有几种配置方式这里有三种重要的方法给Spring 容器提供配置元数据。 XML配置文件。 基于注解的配置。 基于java的配置。 Spring配置文件包含了哪些信息Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。 Spring基于xml注入bean的几种方式 Set方法注入； 构造器注入：①通过index设置参数的位置；②通过type设置参数类型； 静态工厂注入； 实例工厂； 你怎样定义类的作用域？当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。 解释Spring支持的几种bean的作用域Spring框架支持以下五种bean的作用域： singleton : bean在每个Spring ioc 容器中只有一个实例。 prototype：一个bean的定义可以有多个实例。 request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。 Spring框架中的单例bean是线程安全的吗？不是，Spring框架中的单例bean不是线程安全的。 spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。 实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。 有状态就是有数据存储功能。 无状态就是不会保存数据。 Spring如何处理线程并发问题？在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。 ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。 ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 解释Spring框架中bean的生命周期在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。 img bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。 正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。 我们对上图进行详细描述： Spring对bean进行实例化； Spring将值和bean的引用注入到bean对应的属性中； 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法； 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入； 如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来； 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法； 如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用； 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法； 此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁； 如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。 现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。 哪些是重要的bean生命周期方法？ 你能重载它们吗？有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。 bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。 什么是Spring的内部bean？什么是Spring inner beans？在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。 在 Spring中如何注入一个java集合？Spring提供以下几种集合的配置元素： 类型用于注入一列值，允许有相同的值。 类型用于注入一组值，不允许有相同的值。 类型用于注入一组键值对，键和值都可以为任意类型。 类型用于注入一组键值对，键和值都只能为String类型。 什么是bean装配？装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。 什么是bean的自动装配？在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。 在Spring框架xml配置中共有5种自动装配： no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。 byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。 byType：通过参数的数据类型进行自动装配。 constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。 autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。 使用@Autowired注解自动装配的过程是怎样的？使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。 在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean： 如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据； 如果查询的结果不止一个，那么@Autowired会根据名称来查找； 如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。 自动装配有哪些局限性？自动装配的局限性是： 重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。 基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。 模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。 你可以在Spring中注入一个null 和一个空字符串吗？可以。 Spring注解（8）什么是基于Java的Spring注解配置? 给一些注解的例子基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。 以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。 另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。 1234567@Configurationpublic class StudentConfig &#123; @Bean public StudentBean myStudent() &#123; return new StudentBean(); &#125;&#125; 怎样开启注解装配？注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 &lt;context:annotation-config/&gt;元素。 @Component, @Controller, @Repository, @Service 有何区别？@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。 @Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。 @Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。 @Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。 @Required 注解有什么作用这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例： 12345678910public class Employee &#123; private String name; @Required public void setName(String name)&#123; this.name=name; &#125; public string getName()&#123; return name; &#125;&#125; @Autowired 注解有什么作用@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和&#x2F;或多个参数的PN方法。 12345678910public class Employee &#123; private String name; @Autowired public void setName(String name) &#123; this.name=name; &#125; public string getName()&#123; return name; &#125;&#125; @Autowired和@Resource之间的区别@Autowired可用于：构造函数、成员变量、Setter方法 @Autowired和@Resource之间的区别 @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。 @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。 @Qualifier 注解有什么作用当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。 @RequestMapping 注解有什么用？@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别： 类级别：映射请求的 URL 方法级别：映射 URL 以及 HTTP 请求方法 Spring数据访问（14）解释对象&#x2F;关系映射集成模块Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象&#x2F;关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。 在Spring框架中如何更有效地使用JDBC？使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate 解释JDBC抽象和DAO模块通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。 spring DAO 有什么用？Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。 spring JDBC API 中存在哪些类？JdbcTemplate SimpleJdbcTemplate NamedParameterJdbcTemplate SimpleJdbcInsert SimpleJdbcCall JdbcTemplate是什么JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？在Spring中有两种方式访问Hibernate： 使用 Hibernate 模板和回调进行控制反转 扩展 HibernateDAOSupport 并应用 AOP 拦截器节点 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步： 配置the Hibernate SessionFactory 继承HibernateDaoSupport实现一个DAO 在AOP支持的事务中装配 Spring支持的事务管理类型， spring 事务实现方式有哪些？Spring支持两种类型的事务管理： 编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。 声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。 Spring事务的实现方式和实现原理Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。 说一下Spring的事务传播行为spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。 ① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。 ② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。 ③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。 ④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。 ⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 ⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 ⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。 说一下 spring 的事务隔离？spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致： ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么； ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）； ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别； ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别； ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。 脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。 不可重复读 ：是指在一个事务内，多次读同一数据。 幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。 Spring框架的事务管理有哪些优点？ 为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。 为编程式事务管理提供了一套简单的API而不是一些复杂的事务API 支持声明式事务管理。 和Spring各种数据访问抽象层很好得集成。 你更倾向用那种事务管理类型？大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。 Spring面向切面编程(AOP)（13）什么是AOPOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。 AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。 Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。 （1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。 （2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。 JDK动态代理和CGLIB动态代理的区别Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理： JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。 如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。 静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。 InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。 如何理解 Spring 中的代理？将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。 Advice + Target Object &#x3D; Proxy 解释一下Spring AOP里面的几个名词（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。 （2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。 （3）通知（Advice）：在AOP术语中，切面的工作被称为通知。 （4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。 （5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。 （6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。 （7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入： 编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。 Spring在运行时通知对象通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。 直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。 Spring只支持方法级别的连接点因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。 在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。 Spring通知有哪些类型？在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。 Spring切面可以应用5种类型的通知： 前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning ）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 同一个aspect，不同advice的执行顺序： ①没有异常情况下的执行顺序： around before advicebefore advicetarget method 执行around after adviceafter adviceafterReturning ②有异常情况下的执行顺序： around before advicebefore advicetarget method 执行around after adviceafter adviceafterThrowing:异常发生java.lang.RuntimeException: 异常发生 什么是切面 Aspect？aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作: 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上 如何在 advice 中编写切面代码. 可以简单地认为, 使用 @Aspect 注解的类就是切面. 在这里插入图片描述 解释基于XML Schema方式的切面实现在这种情况下，切面由常规类以及基于XML的配置实现。 解释基于注解的切面实现在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。 有几种不同类型的自动代理？BeanNameAutoProxyCreator DefaultAdvisorAutoProxyCreator Metadata autoproxying 阿里网盘内测链接","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"MySQL面试题","slug":"MySQL面试题","date":"2023-10-05T10:22:44.000Z","updated":"2023-10-05T10:26:23.107Z","comments":true,"path":"2023/10/05/MySQL面试题/","link":"","permalink":"http://example.com/2023/10/05/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"MySQL执行引擎 图片 MySQL分页优化mysql使用limit分页优化方案测试实验mysql分页直接用limit start, count分页语句： 1select * from product limit start, count 当起始页较小时，查询没有性能问题，我们分别看下从10， 100， 1000， 10000开始分页的执行时间（每页取20条），如下： 1234select * from product limit 10, 20 0.016秒select * from product limit 100, 20 0.016秒select * from product limit 1000, 20 0.047秒select * from product limit 10000, 20 0.094秒 我们已经看出随着起始记录的增加，时间也随着增大， 这说明分页语句limit跟起始页码是有很大关系的，那么我们把起始记录改为40w看下（也就是记录的一半左右） 1select * from product limit 400000, 20 3.229秒 再看我们取最后一页记录的时间 1select * from product limit 866613, 20 37.44秒 像这种分页最大的页码页显然这种时间是无法忍受的。 从中我们也能总结出两件事情： limit语句的查询时间与起始记录的位置成正比。 mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。 对limit分页问题的性能优化方法利用表的覆盖索引来加速分页查询 我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。 因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。 另外Mysql中也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。 在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何：这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下： 1select id from product limit 866613, 20 查询时间为0.2秒，相对于查询了所有列的37.44秒，提升了大概100多倍的速度。 那么如果我们也要查询所有列，有两种方法， id&gt;&#x3D;的形式： 12SELECT * FROM product WHERE ID &gt; =(select id from product limit 866613, 1) limit 20 查询时间为0.2秒，简直是一个质的飞跃啊。 利用join 12SELECT * FROM product a JOIN (select id from product limit 866613, 20) b ON a.ID = b.id 查询时间也很短，赞！其实两者用的都是一个原理嘛，所以效果也差不多。 MVCC多版本并发控制前提概要 什么是MVCC? MVCC**MVCC**，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。mvcc - @百度百科 MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读 什么是当前读和快照读？在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读? 当前读像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁 快照读像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本 说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现 当前读，快照读和MVCC的关系 准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念 而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现 要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，**Read View** 等去完成的，具体可以看下面的MVCC实现原理 MVCC能解决什么问题，好处是？数据库并发场景有三种，分别为： 读-读：不存在任何问题，也不需要并发控制 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失 MVCC带来的好处是？多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题 小结一下咯总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合： MVCC + 悲观锁MVCC解决读写冲突，悲观锁解决写写冲突 MVCC + 乐观锁MVCC解决读写冲突，乐观锁解决写写冲突 这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题 MVCC的实现原理 MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，**Read View** 来实现的。所以我们先来看看这个三个point的概念 隐式字段每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段 DB_TRX_ID6byte，最近修改(修改/插入)事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID DB_ROLL_PTR7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里） DB_ROW_ID6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引 实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了 在这里插入图片描述 如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本 undo日志undo log主要分为两种： insert undo log代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃 update undo log事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除 purge 从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。 为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。 对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下： *一、* 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL img *二、* 现在来了一个事务1对该记录的name做出了修改，改为Tom 在事务1修改该行(记录)数据时，数据库会先对该行加排他锁 然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本 拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它 事务提交后，释放锁 img *三、* 又来了个事务2修改person表的同一个记录，将age修改为30岁 在事务2修改该行数据时，数据库也先为该行加锁 然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面 修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录 事务提交，释放锁 img 从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里） Read View(读视图)什么是Read View? 什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大) 所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。 Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本 那么这个判断条件是什么呢？ 在这里插入图片描述 我们这里盗窃@呵呵一笑百媚生一张源码图，如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较 在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性 trx_list（名字我随便取的）一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID up_limit_id记录trx_list列表中事务ID最小的ID low_limit_idReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1 首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断 接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断 判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的 整体流程我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了 整体的流程是怎么样的呢？我们可以模拟一下 当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list 事务1 事务2 事务3 事务4 事务开始 事务开始 事务开始 事务开始 … … … 修改且已提交 进行中 快照读 进行中 … … … Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者 &gt;&gt;&gt;资料传送门 | 呵呵一笑百媚生的回答) ；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 &#x3D; 5，trx_list集合的值是1,3，Read View如下图 img 我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。 img 所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本 在这里插入图片描述 也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同 MVCC相关问题 RR是如何在RC级的基础上解决不可重复读的？当前读和快照读在RR级别下的区别：1表1: 事务A 事务B 开启事务 开启事务 快照读(无影响)查询金额为500 快照读查询金额为500 更新金额为400 提交事务 select 快照读金额为500 select lock in share mode当前读金额为400 在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400 1表2: 事务A 事务B 开启事务 开启事务 快照读（无影响）查询金额为500 更新金额为400 提交事务 select 快照读金额为400 select lock in share mode当前读金额为400 而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？ 这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。 所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力 我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的 RC,RR级别下的InnoDB快照读有什么不同？正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见； 即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见 而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因 总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。 MySQL中innodb引擎，主键索引和非主键索引在数据存储方面有什么差异在 InnoDB 里，主键索引的叶子节点存的是整行数据。主键索引也被称为聚簇索引（clustered index）。非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 分库分表分库：因为单个物理数据库的资源跟连接数是有限制的，所以在数据量或者并发量较大的情况下，需要将一个数据库拆分成多个数据库。 分表：垂直分表、水平分表。 什么是垂直分表，什么是水平分表垂直分表：适用于一个表有很多个字段的情况，将原先一个表中的某些字段拆出来，单独放到一个或者多个表。 水平分表：根据具体的切分规则，将数据划分到不同的表上面。 水平切分的切分策略范围切分：比如根据日期的范围进行切分，2019年的数据放一个表，2020年的数据放一个表。 哈希切分：根据数据的某个字段（通常是id）哈希值，进行取模，由此决定某条数据应该被路由到哪张表里。 分布式id怎么生成一般有以下几种方案： redis自增； 雪花算法； MySQL自增主键； uuid； 号段模式（每次生成一个id区间，并缓存在本地，用完了再去取新的id区间） 分库分表有什么问题？分布式事务、跨库join、count、全局排序 分库分表如何不停机做数据迁移？需求说明 类似订单表，用户表这种未来规模上亿甚至上十亿百亿的海量数据表，在项目初期为了快速上线，一般只是单表设计，不需要考虑分库分表。随着业务的发展，单表容量超过千万甚至达到亿级别以上，这时候就需要考虑分库分表这个问题了，而不停机分库分表迁移，这应该是分库分表最基本的需求，毕竟互联网项目不可能挂个广告牌**”今晚10:00~次日10:00系统停机维护”**，这得多low呀，以后跳槽面试，你跟面试官说这个迁移方案，面试官怎么想呀？ 借鉴codis笔者正好曾经碰到过这个问题，并借鉴了codis一些思想实现了不停机分库分表迁移方案；codis不是这篇文章的重点，这里只提及借鉴codis的地方–rebalance： 当迁移过程中发生数据访问时，Proxy会发送“SLOTSMGRTTAGSLOT”迁移命令给Redis，强制将客户端要访问的Key立刻迁移，然后再处理客户端的请求。（ SLOTSMGRTTAGSLOT 是codis基于redis定制的） 分库分表明白这个方案后，了解不停机分库分表迁移就比较容易了，接下来详细介绍笔者当初对installed_app表的实施方案；即用户已安装的APP信息表； 确定sharding column确定sharding column绝对是分库分表最最最重要的环节，没有之一。sharding column直接决定整个分库分表方案最终是否能成功落地；一个合适的sharding column的选取，基本上能让与这个表相关的绝大部分流量接口都能通过这个sharding column访问分库分表后的单表，而不需要跨库跨表，最常见的sharding column就是user_id，笔记这里选取的也是user_id； 分库分表方案根据自身的业务选取最合适的sharding column后，就要确定分库分表方案了。笔者采用主动迁移与被动迁移相结合的方案： 主动迁移就是一个独立程序，遍历需要分库分表的installed_app表，将数据迁移到分库分表后的目标表中。 被动迁移就是与installed_app表相关的业务代码自身将数据迁移到分库分表后对应的表中。 接下来详细介绍这两个方案； 主动迁移主动迁移就是一个独立的外挂迁移程序，其作用是遍历需要分库分表的installed_app表，将这里的数据复制到分库分表后的目标表中，由于主动迁移和被动迁移会一起运行，所以需要处理主动迁移和被动迁移碰撞的问题，笔者的主动迁移伪代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void migrate()&#123; // 查询出当前表的最大ID, 用于判断是否迁移完成 long maxId = execute(&quot;select max(id) from installed_app&quot;); long tempMinId = 0L; long stepSize = 1000; long tempMaxId = 0L; do&#123; try &#123; tempMaxId = tempMinId + stepSize; // 根据InnoDB索引特性, where id&gt;=? and id&lt;?这种SQL性能最高 String scanSql = &quot;select * from installed_app where id&gt;=#&#123;tempMinId&#125; and id&lt;#&#123;tempMaxId&#125;&quot;; List&lt;InstalledApp&gt; installedApps = executeSql(scanSql); Iterator&lt;InstalledApp&gt; iterator = installedApps.iterator(); while (iterator.hasNext()) &#123; InstalledApp installedApp = iterator.next(); // help GC iterator.remove(); long userId = installedApp.getUserId(); String status = executeRedis(&quot;get MigrateStatus:$&#123;userId&#125;&quot;); if (&quot;COMPLETED&quot;.equals(status)) &#123; // migration finish, nothing to do continue; &#125; if (&quot;MIGRATING&quot;.equals(status)) &#123; // &quot;被动迁移&quot; migrating, nothing to do continue; &#125; // 迁移前先获取锁: set MigrateStatus:18 MIGRATING ex 3600 nx String result = executeRedis(&quot;set MigrateStatus:$&#123;userId&#125; MIGRATING ex 86400 nx&quot;); if (&quot;OK&quot;.equals(result)) &#123; // 成功获取锁后, 先将这个用户所有已安装的app查询出来[即迁移过程以用户ID维度进行迁移] String sql = &quot;select * from installed_app where user_id=#&#123;user_id&#125;&quot;; List&lt;InstalledApp&gt; userInstalledApps = executeSql(sql); // 将这个用户所有已安装的app迁移到分库分表后的表中(有user_id就能得到分库分表后的具体的表) shardingInsertSql(userInstalledApps); // 迁移完成后, 修改缓存状态 executeRedis(&quot;setex MigrateStatus:$&#123;userId&#125; 864000 COMPLETED&quot;); &#125; else &#123; // 如果没有获取到锁, 说明被动迁移已经拿到了锁, 那么迁移交给被动迁移即可[这种概率很低] // 也可以加强这里的逻辑, &quot;被动迁移&quot;过程不可能持续很长时间, 可以尝试循环几次获取状态判断是否迁移完 logger.info(&quot;Migration conflict. userId = &#123;&#125;&quot;, userId); &#125; &#125; if (tempMaxId &gt;= maxId) &#123; // 更新max(id)，最终确认是否遍历完成 maxId = execute(&quot;select max(id) from installed_app&quot;); &#125; logger.info(&quot;Migration process id = &#123;&#125;&quot;, tempMaxId); &#125;catch (Throwable e)&#123; // 如果执行过程中有任何异常(这种异常只可能是redis和mysql抛出来的), 那么退出, 修复问题后再迁移 // 并且将tempMinId的值置为logger.info(&quot;Migration process id=&quot;+tempMaxId);日志最后一次记录的id, 防止重复迁移 System.exit(0); &#125; tempMinId += stepSize; &#125;while (tempMaxId &lt; maxId);&#125; 这里有几点需要注意： 第一步查询出max(id)是为了尽量减少max(id)的查询次数，假如第一次查询max(id)为10000000，那么直到遍历的id到10000000以前，都不需要再次查询max(id)； 根据id&gt;=? and id遍历，而不要根据id&gt;&#x3D;? limit n或者limit m, n进行遍历，因为limit性能一般，且会随着遍历越往后，性能越差。而id&gt;&#x3D;? and id这种遍历方式即使会有一些踩空，也没有任何影响，且整个性能曲线非常平顺，不会有任何抖动；迁移程序毕竟是辅助程序，不能对业务程序有过多的影响； 根据id区间范围查询出来的List要转换为Iterator，每迭代处理完一个userId，要remove掉，否则可能导致GC异常，甚至OOM； 被动迁移被动迁移就是在正常与installed_app表相关的业务逻辑前插入了迁移逻辑，以新增用户已安装APP为例，其伪代码如下： 1234567891011121314151617181920212223242526272829303132333435// 被动迁移方法是公用逻辑，所以与`installed_app`表相关的业务逻辑前都需要调用这个方法；public void migratePassive(long userId)throws Exception&#123; String status = executeRedis(&quot;get MigrateStatus:$&#123;userId&#125;&quot;); if (&quot;COMPLETED&quot;.equals(status)) &#123; // 该用户数据已经迁移完成, nothing to do logger.info(&quot;user&#x27;s installed app migration completed. user_id = &#123;&#125;&quot;, userId); &#125;else if (&quot;MIGRATING&quot;.equals(status)) &#123; // &quot;被动迁移&quot; migrating, 等待直到迁移完成; 为了防止死循环, 可以增加最大等待时间逻辑 do&#123; Thread.sleep(10); status = executeRedis(&quot;get MigrateStatus:$&#123;userId&#125;&quot;); &#125;while (&quot;COMPLETED&quot;.equals(status)); &#125;else &#123; // 准备迁移 String result = executeRedis(&quot;set MigrateStatus:$&#123;userId&#125; MIGRATING ex 86400 nx&quot;); if (&quot;OK&quot;.equals(result)) &#123; // 成功获取锁后, 先将这个用户所有已安装的app查询出来[即迁移过程以用户ID维度进行迁移] String sql = &quot;select * from installed_app where user_id=#&#123;user_id&#125;&quot;; List&lt;InstalledApp&gt; userInstalledApps = executeSql(sql); // 将这个用户所有已安装的app迁移到分库分表后的表中(有user_id就能得到分库分表后的具体的表) shardingInsertSql(userInstalledApps); // 迁移完成后, 修改缓存状态 executeRedis(&quot;setex MigrateStatus:$&#123;userId&#125; 864000 COMPLETED&quot;); &#125;else &#123; // 如果没有获取到锁, 应该是其他地方先获取到了锁并正在迁移, 可以尝试等待, 直到迁移完成 &#125; &#125;&#125;// 与`installed_app`表相关的业务--新增用户已安装的APPpublic void addInstalledApp(InstalledApp installedApp) throws Exception&#123; // 先尝试被动迁移 migratePassive(installedApp.getUserId()); // 将用户已安装app信息(installedApp)插入到分库分表后的目标表中 shardingInsertSql(installedApp);&#125; 无论是CRUD中哪种操作，先根据缓存中MigrateStatus:$&#123;userId&#125;的值进行判断： 如果值为COMPLETED，表示已经迁移完成，那么将请求转移到分库分表后的表中进行处理即可； 如果值为MIGRATING，表示正在迁移中，可以循环等待直到值为COMPLETED即迁移完成后，再将请求转移到分库分表后的表中进行处理处理； 否则值为空，那么尝试获取锁再进行数据迁移。迁移完成后，将缓存值更新为COMPLETED，最后再将请求转移到分库分表后的表中进行处理处理； 方案完善当所有数据迁移完成后，CRUD操作还是会先根据缓存中MigrateStatus:$&#123;userId&#125;的值进行判断，数据迁移完成后这一步已经是多余的。可以加个总开关，当所有数据迁移完成后，将这个开关的值通过类似TOPIC的方式发送，所有服务接收到TOPIC后将开关local cache化。那么接下来服务的CRUD都不需要先根据缓存中MigrateStatus:$&#123;userId&#125;的值进行判断； 遗留工作迁移完成后，将主动迁移程序下线，并将被动迁移程序中对migratePassive()的调用全部去掉，并可以集成一些第三方分库分表中间件，例如sharding-jdbc，可以参考sharding-jdbc集成实战 回顾总结回顾这个方案，最大的缺点就是如果碰到sharding column（例如userId）的总记录数比较多，且主动迁移正在进行中，被动迁移与主动迁移碰撞，那么被动迁移可能需要等待较长时间。 不过根据DB性能，一般批量插入1000条数据都是10ms级别，并且同一sharding column的记录分库分表后只属于一张表，不涉及跨表。所以，只要在迁移前先通过sql统计待迁移表中没有这类异常sharding column即可放心迁移； 笔者当初迁移installed_app表时，用户最多也只拥有不超过200个APP，所以不需要过多考虑碰撞带来的性能问题；没有万能的方案，但是有适合自己的方案； 如果有那种上万条记录的sharding column，可以把这些sharding column先缓存起来，迁移程序在夜间上线，优先迁移这些缓存的sharding column的数据，就可以尽可能的降低迁移程序对这些用户的体验。当然你也可以使用你想出来的更好的方案。 innodb里删除一条记录，内部是怎么处理的？记录头信息里的delete_mask标记位设置为1（表示该记录已删除），同时将记录从记录行链表中断开，并加入到垃圾链表中，垃圾链表的空间后续可以复用。 两大类索引 使用的存储引擎：MySQL5.7 InnoDB 聚簇索引1如果表设置了主键，则主键就是聚簇索引* 如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引* 以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引 InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），InnoDB必须要有至少一个聚簇索引。 由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。 普通索引 普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引。 InnoDB的普通索引叶子节点存储的是主键（聚簇索引）的值，而MyISAM的普通索引存储的是记录指针。 示例建表1mysql&gt; create table user( -&gt; id int(10) auto_increment, -&gt; name varchar(30), -&gt; age tinyint(4), -&gt; primary key (id), -&gt; index idx_age (age) -&gt; )engine=innodb charset=utf8mb4; id 字段是聚簇索引，age 字段是普通索引（二级索引） 填充数据12insert into user(name,age) values(&#x27;张三&#x27;,30);insert into user(name,age) values(&#x27;李四&#x27;,20);insert into user(name,age) values(&#x27;王五&#x27;,40);insert into user(name,age) values(&#x27;刘八&#x27;,10);mysql&gt; select * from user;+----+--------+------+| id | name | age |+----+--------+------+| 1 | 张三 | 30 || 2 | 李四 | 20 || 3 | 王五 | 40 || 4 | 刘八 | 10 |+----+--------+------+ 索引存储结构 id 是主键，所以是聚簇索引，其叶子节点存储的是对应行记录的数据 图片 聚簇索引（ClusteredIndex） age 是普通索引（二级索引），非聚簇索引，其叶子节点存储的是聚簇索引的的值 图片 普通索引（SecondaryIndex） 如果查询条件为主键（聚簇索引），则只需扫描一次B+树即可通过聚簇索引定位到要查找的行记录数据。 如：select * from user where id &#x3D; 1; 图片 聚簇索引查找过程 如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。 如：select * from user where age &#x3D; 30; 11. 先通过普通索引 age=30 定位到主键值 id=12. 再通过聚集索引 id=1 定位到行记录数据 图片 普通索引查找过程第一步 图片 普通索引查找过程第二步 回表查询 先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。 索引覆盖 只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。 例如：select id,age from user where age &#x3D; 10; 如何实现覆盖索引 常见的方法是：将被查询的字段，建立到联合索引里去。 1、如实现：select id,age from user where age &#x3D; 10; explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引 图片 2、实现：select id,age,name from user where age &#x3D; 10; explain分析：age是普通索引，但name列不在索引树上，所以通过age索引在查询到id和age的值后，需要进行回表再查询name的值。此时的Extra列的NULL表示进行了回表查询 图片 为了实现索引覆盖，需要建组合索引idx_age_name(age,name) 1drop index idx_age on user;create index idx_age_name on user(`age`,`name`); explain分析：此时字段age和name是组合索引idx_age_name，查询的字段id、age、name的值刚刚都在索引树上，只需扫描一次组合索引B+树即可，这就是实现了索引覆盖，此时的Extra字段为Using index表示使用了索引覆盖。 图片 哪些场景适合使用索引覆盖来优化SQL全表count查询优化1mysql&gt; create table user( -&gt; id int(10) auto_increment, -&gt; name varchar(30), -&gt; age tinyint(4), -&gt; primary key (id), -&gt; )engine=innodb charset=utf8mb4; 例如：select count(age) from user; 图片 使用索引覆盖优化：创建age字段索引 1create index idx_age on user(age); 图片 列查询回表优化 前文在描述索引覆盖使用的例子就是 例如：select id,age,name from user where age &#x3D; 10; 使用索引覆盖：建组合索引idx_age_name(age,name)即可 分页查询 例如：select id,age,name from user order by age limit 100,2; 因为name字段不是索引，所以在分页查询需要进行回表查询，此时Extra为Using filesort文件排序，查询性能低下。 图片 使用索引覆盖：建组合索引idx_age_name(age,name)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Java面试题-五(会话技术)","slug":"Java面试题-五-会话技术","date":"2023-10-05T09:58:07.000Z","updated":"2023-10-05T10:10:25.374Z","comments":true,"path":"2023/10/05/Java面试题-五-会话技术/","link":"","permalink":"http://example.com/2023/10/05/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%94-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/","excerpt":"","text":"session机制术语session在我的经验里，session这个词被滥用的程度大概仅次于transaction，更加有趣的是transaction与session在某些语境下的含义是相同的。 session，中文经常翻译为会话，其本来的含义是指有始有终的一系列动作&#x2F;消息，比如打电话时从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个session。有时候我们可以看到这样的话“在一个浏览器会话期间，…”，这里的会话一词用的就是其本义，是指从一个浏览器窗口打开到关闭这个期间。最混乱的是“用户（客户端）在一次会话期间”这样一句话，它可能指用户的一系列动作（一般情况下是同某个具体目的相关的一系列动作，比如从登录到选购商品到结账登出这样一个网上购物的过程，有时候也被称为一个transaction），然而有时候也可能仅仅是指一次连接，也有可能是指含义，其中的差别只能靠上下文来推断。 然而当session一词与网络协议相关联时，它又往往隐含了“面向连接”和&#x2F;或“保持状态”这样两个含义，“面向连接”指的是在通信双方在通信之前要先建立一个通信的渠道，比如打电话，直到对方接了电话通信才能开始，与此相对的是写信，在你把信发出去的时候你并不能确认对方的地址是否正确，通信渠道不一定能建立，但对发信人来说，通信已经开始了。“保持状态”则是指通信的一方能够把一系列的消息关联起来，使得消息之间可以互相依赖，比如一个服务员能够认出再次光临的老顾客并且记得上次这个顾客还欠店里一块钱。这一类的例子有“一个TCP session”或者“一个POP3 session”。 而到了web服务器蓬勃发展的时代，session在web开发语境下的语义又有了新的扩展，它的含义是指一类用来在客户端与服务器之间保持状态的解决方案。有时候session也用来指这种解决方案的存储结构，如“把xxx保存在session里”。由于各种用于web开发的语言在一定程度上都提供了对这种解决方案的支持，所以在某种特定语言的语境下，session也被用来指代该语言的解决方案，比如经常把Java里提供的javax.servlet.http.HttpSession简称为session。 HTTP协议与状态保持HTTP协议本身是无状态的，这与HTTP协议本来的目的是相符的，客户端只需要简单的向服务器请求下载某些文件，无论是客户端还是服务器都没有必要纪录彼此过去的行为，每一次请求之间都是独立的，好比一个顾客和一个自动售货机或者一个普通的（非会员制）大卖场之间的关系一样。 然而聪明（或者贪心？）的人们很快发现如果能够提供一些按需生成的动态信息会使web变得更加有用，就像给有线电视加上点播功能一样。这种需求一方面迫使HTML逐步添加了表单、脚本、DOM等客户端行为，另一方面在服务器端则出现了CGI规范以响应客户端的动态请求，作为传输载体的HTTP协议也添加了文件上载、cookie这些特性。其中cookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。至于后来出现的session机制则是又一种在客户端与服务器之间保持状态的解决方案。 让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： 该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。 由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 理解cookie机制cookie机制的基本原理就如上面的例子一样简单，但是还有几个问题需要解决：“会员卡”如何分发；“会员卡”的内容；以及客户如何使用“会员卡”。 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。 而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。意思是麦当劳的会员卡只能在麦当劳的店里出示，如果某家分店还发行了自己的会员卡，那么进这家店的时候除了要出示麦当劳的会员卡，还要出示这家店的会员卡。 cookie的内容主要包括：名字，值，过期时间，路径和域。 其中域可以指定某一个域比如.google.com，相当于总店招牌，比如宝洁公司，也可以指定一个域下的具体某台机器比如www.google.com或者froogle.google.com，可以用飘柔来做比。 路径就是跟在域名后面的URL路径，比如&#x2F;或者&#x2F;foo等等，可以用某飘柔专柜做比。路径与域合在一起就构成了cookie的作用范围。如果不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。 存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。对于IE，在一个打开的窗口上按Ctrl-N（或者从文件菜单）打开的窗口可以与原窗口共享，而使用其他方式新开的IE进程则不能共享已经打开的窗口的内存cookie；对于Mozilla Firefox0.8，所有的进程和标签页都可以共享同样的cookie。一般来说是用javascript的window.open打开的窗口会与原窗口共享内存cookie。浏览器对于会话cookie的这种只认cookie不认人的处理方式经常给采用session机制的web应用程序开发者造成很大的困扰。 下面就是一个goolge设置cookie的响应头的例子 HTTP&#x2F;1.1 302 Found​ Location: http://www.google.com/intl/zh-CN/Set-Cookie: PREF&#x3D;ID&#x3D;0565f77e132de138:NW&#x3D;1:TM&#x3D;1098082649:LM&#x3D;1098082649:S&#x3D;KaeaCFPo49RiA_d8;expires&#x3D;Sun, 17-Jan-2038 19:14:07 GMT; path&#x3D;&#x2F;; domain&#x3D;.google.comContent-Type: text&#x2F;html img 这是使用HTTPLook这个HTTP Sniffer软件来俘获的HTTP通讯纪录的一部分： img 浏览器在再次访问goolge的资源时自动向外发送cookie： img 使用Firefox可以很容易的观察现有的cookie的值，使用HTTPLook配合Firefox可以很容易的理解cookie的工作原理。 img IE也可以设置在接受cookie前询问： 这是一个询问接受cookie的对话框。 理解session机制session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID，而。比如weblogic对于web应用程序生成的cookie，JSESSIONID&#x3D;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是JSESSIONID。 由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为http:&#x2F;&#x2F;…..&#x2F;xxx;jsessionid&#x3D;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764另一种是作为查询字符串附加在URL后面，表现形式为http:&#x2F;&#x2F;…..&#x2F;xxx?jsessionid&#x3D;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。 另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如下面的表单： 123&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; 在被传递给客户端之前将被改写成： 1234&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; 这种技术现在已较少应用，笔者接触过的很古老的iPlanet6(SunONE应用服务器的前身)就使用了这种技术。 实际上这种技术可以简单的用对action应用URL重写来代替。 在谈论session机制的时候，常常听到这样一种误解“只要关闭浏览器，session就消失了”。其实可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对session来说也是一样的，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够找到原来的session。 恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 理解javax.servlet.http.HttpSessionHttpSession是Java平台对session机制的实现规范，因为它仅仅是个接口，具体到每个web应用服务器的提供商，除了对规范支持之外，仍然会有一些规范里没有规定的细微差异。这里我们以BEA的Weblogic Server8.1作为例子来演示。 首先，Weblogic Server提供了一系列的参数来控制它的HttpSession的实现，包括使用cookie的开关选项，使用URL重写的开关选项，session持久化的设置，session失效时间的设置，以及针对cookie的各种设置，比如设置cookie的名字、路径、域，cookie的生存时间等。 一般情况下，session都是存储在内存里，当服务器进程被停止或者重启的时候，内存里的session也会被清空，如果设置了session的持久化特性，服务器就会把session保存到硬盘上，当服务器进程重新启动或这些信息将能够被再次使用，Weblogic Server支持的持久性方式包括文件、数据库、客户端cookie保存和复制。 复制严格说来不算持久化保存，因为session实际上还是保存在内存里，不过同样的信息被复制到各个cluster内的服务器进程中，这样即使某个服务器进程停止工作也仍然可以从其他进程中取得session。 cookie生存时间的设置则会影响浏览器生成的cookie是否是一个会话cookie。默认是使用会话cookie。有兴趣的可以用它来试验我们在第四节里提到的那个误解。 cookie的路径对于web应用程序来说是一个非常重要的选项，Weblogic Server对这个选项的默认处理方式使得它与其他服务器有明显的区别。后面我们会专题讨论。 HttpSession常见问题session在何时被创建一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建，注意如果JSP没有显示的使用 &lt;%@page session&#x3D;”false”%&gt; 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句HttpSession session &#x3D; HttpServletRequest.getSession(true);这也是JSP中隐含的session对象的来历。 由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。 session何时被删除综合前面的讨论，session在下列情况下被删除a.程序调用HttpSession.invalidate();或b.距离上一次收到客户端发送的session id时间间隔超过了session的超时设置;或c.服务器进程被停止（非持久session） 如何做到在浏览器关闭时删除session严格的讲，做不到这一点。可以做一点努力的办法是在所有的客户端页面里使用javascript代码window.oncolose来监视浏览器的关闭动作，然后向服务器发送一个请求来删除session。但是对于浏览器崩溃或者强行杀死进程这些非常规手段仍然无能为力。 有个HttpSessionListener是怎么回事你可以创建这样的listener去监控session的创建和销毁事件，使得在发生这样的事件时你可以做一些相应的工作。注意是session的创建和销毁动作触发listener，而不是相反。类似的与HttpSession有关的listener还有HttpSessionBindingListener，HttpSessionActivationListener和HttpSessionAttributeListener。 存放在session中的对象必须是可序列化的吗不是必需的。要求对象可序列化只是为了session能够在集群中被复制或者能够持久保存或者在必要时server能够暂时把session交换出内存。在Weblogic Server的session中放置一个不可序列化的对象在控制台上会收到一个警告。我所用过的某个iPlanet版本如果session中有不可序列化的对象，在session销毁时会有一个Exception，很奇怪。 如何才能正确的应付客户端禁止cookie的可能性对所有的URL使用URL重写，包括超链接，form的action，和重定向的URL 开两个浏览器窗口访问应用程序会使用同一个session还是不同的session参见第三小节对cookie的讨论，对session来说是只认id不认人，因此不同的浏览器，不同的窗口打开方式以及不同的cookie存储方式都会对这个问题的答案有影响。 如何防止用户打开两个浏览器窗口操作导致的session混乱这个问题与防止表单多次提交是类似的，可以通过设置客户端的令牌来解决。就是在服务器每次生成一个不同的id返回给客户端，同时保存在session里，客户端提交表单时必须把这个id也返回服务器，程序首先比较返回的id与保存在session里的值是否一致，如果不一致则说明本次操作已经被提交过了。可以参看《J2EE核心模式》关于表示层模式的部分。需要注意的是对于使用javascript window.open打开的窗口，一般不设置这个id，或者使用单独的id，以防主窗口无法操作，建议不要再window.open打开的窗口里做修改操作，这样就可以不用设置。 为什么在Weblogic Server中改变session的值后要重新调用一次session.setValue这个动作主要是为了在集群环境中提示Weblogic Server session中的值发生了改变，需要向其他服务器进程复制新的session值。 、为什么session不见了排除session正常失效的因素之外，服务器本身的可能性应该是微乎其微的，虽然笔者在iPlanet6SP1加若干补丁的Solaris版本上倒也遇到过；浏览器插件的可能性次之，笔者也遇到过3721插件造成的问题；理论上防火墙或者代理服务器在cookie处理上也有可能会出现问题。出现这一问题的大部分原因都是程序的错误，最常见的就是在一个应用程序中去访问另外一个应用程序。我们在下一节讨论这个问题。 跨应用程序的session共享常常有这样的情况，一个大项目被分割成若干小项目开发，为了能够互不干扰，要求每个小项目作为一个单独的web应用程序开发，可是到了最后突然发现某几个小项目之间需要共享一些信息，或者想使用session来实现SSO(single sign on)，在session中保存login的用户信息，最自然的要求是应用程序间能够访问彼此的session。 然而按照Servlet规范，session的作用范围应该仅仅限于当前应用程序下，不同的应用程序之间是不能够互相访问对方的session的。各个应用服务器从实际效果上都遵守了这一规范，但是实现的细节却可能各有不同，因此解决跨应用程序session共享的方法也各不相同。 首先来看一下Tomcat是如何实现web应用程序之间session的隔离的，从Tomcat设置的cookie路径来看，它对不同的应用程序设置的cookie路径是不同的，这样不同的应用程序所用的session id是不同的，因此即使在同一个浏览器窗口里访问不同的应用程序，发送给服务器的session id也可以是不同的。 img img 根据这个特性，我们可以推测Tomcat中session的内存结构大致如下。 img 笔者以前用过的iPlanet也采用的是同样的方式，估计SunONE与iPlanet之间不会有太大的差别。对于这种方式的服务器，解决的思路很简单，实际实行起来也不难。要么让所有的应用程序共享一个session id，要么让应用程序能够获得其他应用程序的session id。 iPlanet中有一种很简单的方法来实现共享一个session id，那就是把各个应用程序的cookie路径都设为&#x2F;（实际上应该是&#x2F;NASApp，对于应用程序来讲它的作用相当于根）。 123&lt;session-info&gt; &lt;path&gt;/NASApp&lt;/path&gt; &lt;/session-info&gt; 需要注意的是，操作共享的session应该遵循一些编程约定，比如在session attribute名字的前面加上应用程序的前缀，使得setAttribute(“name”, “neo”)变成setAttribute(“app1.name”, “neo”)，以防止命名空间冲突，导致互相覆盖。 在Tomcat中则没有这么方便的选择。在Tomcat版本3上，我们还可以有一些手段来共享session。对于版本4以上的Tomcat，目前笔者尚未发现简单的办法。只能借助于第三方的力量，比如使用文件、数据库、JMS或者客户端cookie，URL参数或者隐藏字段等手段。 我们再看一下Weblogic Server是如何处理session的。 img img 从截屏画面上可以看到Weblogic Server对所有的应用程序设置的cookie的路径都是&#x2F;，这是不是意味着在Weblogic Server中默认的就可以共享session了呢？然而一个小实验即可证明即使不同的应用程序使用的是同一个session，各个应用程序仍然只能访问自己所设置的那些属性。这说明Weblogic Server中的session的内存结构可能如下： img 对于这样一种结构，在session机制本身上来解决session共享的问题应该是不可能的了。除了借助于第三方的力量，比如使用文件、数据库、JMS或者客户端cookie，URL参数或者隐藏字段等手段，还有一种较为方便的做法，就是把一个应用程序的session放到ServletContext中，这样另外一个应用程序就可以从ServletContext中取得前一个应用程序的引用。示例代码如下， 123456//应用程序A ： context.setAttribute(&quot;appA&quot;, session); // 应用程序B ： contextA = context.getContext(&quot;/appA&quot;); HttpSession sessionA = (HttpSession)contextA.getAttribute(&quot;appA&quot;); 值得注意的是这种用法不可移植，因为根据ServletContext的JavaDoc，应用服务器可以处于安全的原因对于context.getContext(“&#x2F;appA”);返回空值，以上做法在Weblogic Server 8.1中通过。 那么Weblogic Server为什么要把所有的应用程序的cookie路径都设为&#x2F;呢？原来是为了SSO，凡是共享这个session的应用程序都可以共享认证的信息。一个简单的实验就可以证明这一点，修改首先登录的那个应用程序的描述符weblogic.xml，把cookie路径修改为&#x2F;appA访问另外一个应用程序会重新要求登录，即使是反过来，先访问cookie路径为&#x2F;的应用程序，再访问修改过路径的这个，虽然不再提示登录，但是登录的用户信息也会丢失。注意做这个实验时认证方式应该使用FORM，因为浏览器和web服务器对basic认证方式有其他的处理方式，第二次请求的认证不是通过session来实现的。具体请参看[7] secion 14.8 Authorization，你可以修改所附的示例程序来做这些试验。 总结session机制本身并不复杂，然而其实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当作普遍适用的经验，而是始终需要具体情况具体分析。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2023-09-19T15:32:04.000Z","updated":"2023-09-19T15:48:26.314Z","comments":true,"path":"2023/09/19/Linux常用命令/","link":"","permalink":"http://example.com/2023/09/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"操作系统操作系统是实现控制和管理计算机软硬件资源的系统软件。它可以有效地组织多个程序的运行，方便用户操作。常见的操作系统：windows,mac,linux,OS&#x2F;2,以及各种嵌入式操作系统。目前操作系统的分类：批处理操作系统，分时操作系统，实时操作系统，网络操作系统和分布式操作系统。 操作系统的性能指标：吞吐量，资源利用率，公平性，实时性，可靠性以及安全性。 操作系统功能： ​ 存储管理：内存分配，地址映射，内存的保护以及扩充 ​ 进程管理：进程调度，进程控制，进程之间的通信 ​ 文件管理：文件存储空间管理、文件操作、目录、读写权限等 ​ 设备管理：缓冲设备、设备分配、设备驱动 ​ 用户接口：图形用户接口，命令行接口 LinuxLinux，全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds）于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它支持32位和64位硬件，能运行主要的Unix工具软件、应用程序和网络协议。 在国内用的比较多的版本：Ubuntu，Centos，RedHat Linux的文件基础linux系统以文件为基础，系统子目录当中的文件主要是保证系统的正常运行。 &#x2F;，&#x2F;home &#x2F;usr &#x2F;var &#x2F;bin &#x2F;sbin &#x2F;etc &#x2F;dev &#x2F;lib &#x2F; : linux系统的根目录（主目录） &#x2F;bin &#x2F;sbin: 用于存放linux的系统命令和工具 &#x2F;boot: linux的启动目录，从此开始启动 &#x2F;dev：存放linux当中的所有设备文件 &#x2F;etc: 系统配置文件所在的位置 &#x2F;lib，&#x2F;lib64: 存放操作系统的库文件 &#x2F;home ：用户目录，linux当中每增加一个用户，都会在此目录下相应地增加一个文件，文件名和用户名相同（root除外），给每个用户自己的空间 &#x2F;mnt: 外部设备的挂载点，可以挂载光驱和软盘 &#x2F;root： root用户的目录 &#x2F;usr：通常用来安装各种软件的地方 &#x2F;var：通常用来放置一些变化的文件 &#x2F;var&#x2F;log： 存放系统的日志文件 &#x2F;run: Linux系统中用于存放运行文件的临时目录,通常情况下它会包含一些程序运行时需要的文件,例如PID文件、锁文件、socket文件等等。这些文件的作用是协助程序运行时的交互,确保程序能够顺利地完成任务。 &#x2F;proc: Linux 内核提供了一种通过 &#x2F;proc 文件系统,在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统,它只存在内存当中,而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。 &#x2F;srv&#x2F;:系统服务数据的目录。一些系统服务启动之后,可以在这个目录中保存所需要的数据。 Linux系统是区分大小写，Linux文件没有扩展名 常用命令补全和帮助tab补全：linux当中的命令比较多，无法记全的情况下，可以使用tab键进行提示。当只有一个匹配命令时，tab键可以帮助不全，当有个匹配，双按tab，会提示命令。 当命令的参数或者option信息不清楚，可以使用man命令或者help进行帮助查看。 ​ man 命令（man ls） ​ 命令 –help 目录命令目录和路径主目录和工作目录：每一个用户都有自己的主目录，这个是管理员在创建用户的时候指定的。用户在自己的home目录当中可以进行各种操作，用户对自己的主目录拥有最大的权限。 工作目录：指当前所在的位置，进入linux之后，用户始终都会有一个工作目录。可以使用cd命令切换工作目录。 ​ 可以使用pwd命令查看当前所在的工作目录的完整路径。 目录命令cdls [options]options比较多，无法记住，使用man ls 或者 ls –help方式进行求助 命令比较常，记不住的情况，可以使用tab求助。 1234567-a 显示目录中所有文件大小-k 以KB为单位显示文件大小-m 以MB为单位显示文件大小-g 以GB为单位显示文件大小-h 以易读方式显示文件大小-s 仅显示总计-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和 几个特殊路径： ​ cd &#x2F; :进入根目录 ​ cd ~: 进入当前用户的主目录 ​ cd .. :返回到上一级目录 ​ cd -: 返回上一次所在目录 绝对路径： 从文件的根目录开始的路径，始终以 &#x2F;开头 相对路径：从当前的工作目录开始的路径，要和工作目录结合起来，才能确定所在的位置。 ls：列举指定目录中的文件和目录 mkdir：创建新目录 rmdir：删除指定的目录（必须是空目录，如果不是空，可以先删除此目录中的对象，再删除，还可以使用rm命令） 常用文件命令touch：创建空文件cp：复制文件。可将文件复制到不同的目录，也可将指定目录中的文件复制到其他位置mv：将文件或目录移动至一个新的位置rm: 删除文件或目录ln ： 创建链接（类似与windows的快捷方式）whereis：查找文件。可以查找文件的源、二进制文件或手册which: 查找二进制文件find：查找文件location：查找文件grep ：所有文本 touch：创建空文件用touch命令可以创建一个没有任何内容的空文件。 1touch file01 cp：复制文件类似与DOS命令中的copy语法：cp 选项 源文件或目录 目标文件或目录可以将文件复制到不同的目录，也可以将指定目录中的文件复制到其他位置。常用参数-a：相当与-dpr参数-d：保留链接-f：强制复制，覆盖目标文件-i：覆盖时询问用户-p：保留修改时间和访问权限-r，-R：递归复制（目录到目录）-l：创建链接-v：显示过程 12345678#当前文件夹下复制一个文件cp 3.txt 4.txt #将当前目录下的txt复制到根目录下cp *.txt / #将data目录（文件）复制到2目录下 cp -r data data1/ #将hello文件复制到/opt目录下cp -p hello.java /opt/hello.java mv：移动文件或目录将文件或目录移到一个新的位子。也可以用来修改文件名称mv 选项 源文件或目标 目标文件或目录常用参数：-i：交互方式操作，如果mv操作将导致对已存在文件的覆盖，此时系统询问是否重写，要求用户回答y或n-f：禁止交互操作。覆盖时不会提示。 1mv -i hello.java hello1.java rm： 删除文件或目录​ rm [选项] 文件​ 常用参数：​ -i : 为了避免误删除文件，可以使用此项，进行用户确认删除​ -f: 强制删除，使用该选项后将不提示所删除的文件​ -v: 显示文件的删除速度​ -r: 删除某个目录以及其中所有的文件和子目录。 1234#删除文件rm aa#删除目录rm -rf a 在Linux中可以创建链接文件，当使用rm删除链接文件时，只是删除该链接文件，实际的文件仍旧继续存在。 ln：创建链接文件​ Linux中的链接类似于windows的快捷方式，分两种：软连接和硬链接。​ 创建软链接，只是在指定的位置上生成一个镜像，不会占用磁盘空间。​ 语法： ln -s 目标文件 链接文件名​ 创建硬链接，将在指定的位置上生成一个和源文件大小相同的文件。​ 语法： ln 目标文件 链接文件名​ 无论是软链接还是硬链接，链接文件和目录文件都将保持同步变化。​ 不能创建目录的硬链接。 1234#创建软链接ln -s hello hellolink#查找文件find -name hello whereis：查找文件whereis用来查找程序的源、二进制文件或手册。whereis 选项 文件名常用选项-b：搜索文件的二进制部分-m：搜索文件的手册部分-s：搜索文件的源部分。 不带选项，查找二进制文件和手册的位置 1whereis ls which：查找二进制文件。which 选项 文件名常用选项-n：指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p：与-n参数相同，但此处包含文件路径-w：指定输出时栏位的宽度-V：显示版本信息 1which -V ls find（会问到）：查找文件可以按照文件名、文件类型、用户等去查找。find 路径 选项 [-print] [-exec –ok command] {};常用选项-name filename :查找名为filename的文件-perm：按执行权限来查找-user username：按照文件的所属用户来查找-group groupname：按照组来查找-size n[c] 查长度为n块（n字节）的文件。 123456#根据文件名查找find /home -name 123.sh#根据文件大小查找 (+大于 -小于)find /home -size +20000#根据文件所有者查找：查找所有者为jp的文件find /home -user jp locate：查找文件locate：从已经创建好的一个索引数据库中查找。比find命令的查找速度更快。locate 选项 文件名-b, –basename – 仅匹配路径名的基本名称-c, –count – 只输出找到的数量-d, – 数据库路径 – 使用 DB PATH 指定的数据库，而不是默认数据库 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db-q, – 安静模式，不会显示任何错误讯息。一般不使用参数。 locate 与 find 不同: find 是去硬盘找，locate 只在 &#x2F;var&#x2F;lib&#x2F;slocate 资料库中找。locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 &#x2F;var&#x2F;lib&#x2F;slocate&#x2F;slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为：updatedb 常见问题：无法执行 stat () &#96;&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db’: 没有那个文件或目录解决方案：执行：updatedb命令 123456789[root@centos601 桌面]# locate /etc/shlocate: can not stat () `/var/lib/mlocate/mlocate.db&#x27;: 没有那个文件或目录[root@centos601 桌面]# update locatebash: update: command not found[root@centos601 桌面]# updatedb[root@centos601 桌面]# locate /etc/sh/etc/shadow/etc/shadow-/etc/shells grep（面试常问）：查找文件对查找目标中的具体内容进行查找，是一个强大的文本搜索工具。它是一个管道命令，和其它命令结合使用。工作方式：在一个或多个文件中搜索字符串模板，可以使用正则表达式进行搜索。 在linux或unix系统中，|就是管道命令，把上一个命令的结果交给管道命令（|）后面的命令处理 12#查找/etc/hosts中包含localhost4的内容cat /etc/hosts | grep localhost4 文本内容查看命令cat：文件内容查看输出cat：将文件中的内容输出到设备上，若是多个文件，则按顺序输出。 cat 选项 文件名常用选项 -n：由1开始对所有输出的行数编号 -b：和-n相似，只是对于空白行不进行编号 -s：若遇到连续两行以上的空白行，就替换成一行空白行输出。若准备将多个文件合并为一个文件，则使用以下方式Cat 选项 文件名1 文件名2…… &gt; 新文件 1234#将/etc/hosts文件中的内容输出到/opt/a文件中cat /etc/hosts &gt; /opt/a#查看/opt/a文件的内容cat /opt/a more：分屏显示more分屏显示 ，可以和其它命令结合使用，也可以单独使用。在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； &#x2F;字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管道无用。 12more /etc/profilecat day522 | more less：分屏显示less分屏显示 ，可以和其它命令结合使用，也可以单独使用。less运行时可以输入的命令有： 空白键 ：向下翻动一页； 上下箭头：上一行&#x2F;下一行 [page down]：向下翻动一页； [page up] ：向上翻动一页； &#x2F;字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！) N ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！) q ：离开 less 这个程序； 1more /etc/profile head：显示前几行语法：head [-n number] 文件 1head -n 3 /etc/profile tail（面试常问）：最后几行语法：tail [-n number] 文件 ，常用来读取日志文件 ​ -f : 循环读取 tail -f 文件名 ​ -n ：数字 读取最后几行 1234tail -n 10 /etc/profile#循环读取ping 192.168.66.211 &gt; ping.log &amp;tail -f ping.log 4. 用户管理在Linux中，用户和组的相关信息保存在对应的文件中，一共有三个文件，分别是passwd、shadow和group passwd文件 用户信息文件 &#x2F;etc&#x2F;目录下。 系统中的每一个合法用户账号对应于该文件中的一行记录。 每一行由7个部分组成：注册名:口令：用户标识号：组标识号：备注：用户主目录：命令解释程序 注册名：登陆账户，不能重复，区分大小写。 口令：登陆系统的口令。若第一个字符是“*”，表示禁止该账号登陆。 用户标志号：Linux中唯一的用户标识 组标志号：当行用户的默认工作组标记 备注：保存一些用户的信息 用户主目录：个人用户的主目录，该用户登陆后，将该目录作为用户的工作目录 命令解释程序：当前用户登陆系统时运行的程序名称，通常是一个shell程序的全路径名。 shadow文件 保存用户的口令。&#x2F;etc&#x2F;目录下 该文件不能被普通用户读取，只有超级用户root才有权读取。 group文件 保存在&#x2F;etc&#x2F;group当中 每一行数据内容 用户组名称：用户组密码：用户组标识号：用户列表 用户组管理 添加组：groupaddgroupadd policeman 查看组：通过vi或cat命令vi &#x2F;etc&#x2F;groupcat &#x2F;etc&#x2F;group 删除组：groupdelgroupdel policeman 将现有用户增加到组中usermod -g 组名 用户名 从组中删除用户gpasswd -d 用户名 组名 查看当前用户所在组：groups 用户管理 创建用户：useradduseradd 用户名：创建一个新的用户useradd 用户名 -g 组名 ：添加用户，并加入到某个组当中useradd –m –g 组名 用户名：创建一个新的用户并创建家目录，指定组 修改用户：usermodusermod -g 组名 用户名 ：修改用户信息 创建密码：passwordpasswd 用户名 ：为用户创建密码 删除用户：userdeluserdel 用户名 ：删除用户名userdel -r 用户名 ：删除用户以及用户主目录 su 用户名称 切换用户 管理员权限修改 &#x2F;etc&#x2F;sudoers文件，给对应的用户增加root权限，用户在执行命令式，使用sudo 命令 即可执行管理员的所有权限。 1234## Allow root to run any commands anywhere root ALL=(ALL) ALL#给huangyy增加root权限huangyy ALL=(ALL) ALL 5. 文件权限Linux的文件类型大致可以分为5种：普通文件：用于存储数据、程序等信息的文件。文本文件和二进制文件。目录文件：由文件系统中的一个目录项组成的文件。用户进行只能对其进行读取，不能进行修改设备文件：用于与IO设备提供连接的文件，可以分为字符设备文件和块设备文件。每一种I&#x2F;O设备对应于一个设备文件，存放于&#x2F;dev&#x2F;目录中。链接文件：通过链接文件中指向文件的指针来实现对文件的访问。管道文件：用于进程间传递数据。Linux对管道的操作与对普通文件的操作相同。 drwx r-xr-x test : 第一组 rwx表示test文件的用户所有者(vagrant,vagrant所在的组vgroup（v1,v2,v3,vagrant）)的权限 ​ r-x(黑色) : 文件所有者的同组其他用户的权限（v1,v3,v2） ​ r-x: vgroup组以外的其他用户的权限 操作权限分为三种：R：读取权限 （４），如果是目录，用户可以浏览目录W ：写权限 （２），如果是目录，用户可以删除、移动目录内的文件X: ：执行权限（１），如果是目录，则表示可进入此目录，如果是bash命令，则表示可以执行 改变文件权限使用chmod命令可以修改文件的权限。通过权限字母和操作符表达式的方法来设置权限 语法：chmod [用户类型] [+|-|&#x3D;] [权限字符] 文件名 u&#x3D;用户权限 g&#x3D;组权限 o&#x3D;不同组其他 +：添加权限；-：取消权限 &#x3D;：赋予给定权限并取消其他所有权限。 权限字符：可以使用r、w、x组合，也可以使用s 使用数字来设置权限 chmod [数字组合] 文件名 用3位八进制数来表示文件的3类用户的权限组合 例如751：表示用户权限为rwx，当前用户组权限：r-x 其他用户组权限为–x 12345678910#赋予abc权限rwxr-xr-xchmod 755 abc#同上chmod u=rwx,g=rx,o=rx abc#给abc增加组写权限chmod go+w abc#给abc去除用户执行权限，增加当前组写权限chmod u-x,g+w abc#给所有用户添加读的权限chmod a+r abc 修改文件所有者和组使用chown命令可以修改文件的所有者和组，只有root用户可以更改用户的所有者。只有root用户或文件所有者可以更改文件的组，如果是文件所有者但不是root用户，则只能将组改为当前用户所在组。语法：chown 所有者:组 文件 123#修改文件所有者为xiaohuang#新的用户组为rootchown xiaohuang:root hello.java 6. 进程管理在Linux中，每个执行的程序都称为一个进程。每一个进程都分配一个ID号。每一个进程，都会对应一个父进程。而这个父进程可以复制多个子进程。每个进程都可能以两种方式存在的，前台与后台。所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于在屏幕上无法看到的进程，通常使用后台方式执行。一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。 ps：查看进程ps命令是用来查看系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。显示详细的进程信息(终端上的所有进程，包括其它用户)：ps -a以用户的格式显示进程信息：ps -u显示后台进程运行参数：px –x查看更全面信息 ps -aux 12345678910USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 485 0.0 0.0 0 0 ? S Nov02 0:00 [ext4-dio-unwrit]root 593 0.0 0.0 11248 1372 ? S&lt;s Nov02 0:00 /sbin/udevd -droot 1800 0.1 0.4 260836 8524 ? Sl Nov02 0:20 /usr/sbin/vmtoolsdroot 2044 0.0 0.0 27596 832 ? S&lt;sl Nov02 0:00 auditdrpc 2179 0.0 0.0 18980 876 ? Ss Nov02 0:00 rpcbinddbus 2199 0.0 0.1 32556 2088 ? Ssl Nov02 0:00 dbus-daemon --systemroot 2213 0.0 0.2 84960 4864 ? Ss Nov02 0:00 NetworkManager --pid-file=/var/run/NetworkManager/NetworkManager.pidroot 2220 0.0 0.1 58120 2608 ? S Nov02 0:00 /usr/sbin/modem-managerrpcuser 2237 0.0 0.0 23352 1380 ? Ss Nov02 0:00 rpc.statd USER：用户PID: 进程的IDPPID:父进程的ID%CPU:进程占用的CPU百分比%MEM：进程占用的内存百分比VSZ:使用的虚拟内存量（KB)RSS：该进程占用的固定内存量（KB)STAT:进程的状态。TTY:该进程在哪个终端上运行，若与终端无关，则显示？ 若为pst&#x2F;0等，则表示由网络连接主机进程。TIME:使用CPU的时间 其中STAT常见的值如下： 值 含义 值 含义 D 无法中断的休眠状态（通常 IO 的进程） R 正在运行可中在队列中可过行的 S 处于休眠状态 T 停止或被追踪 &lt; 优先级高的进程 X 死掉的进程 （基本很少见） N 优先级较低的进程 L 有些页被锁进内存 s 进程的领导者（在它之下有子进程） l 多线程，克隆线程（使用 CLONE_THREAD） + 位于后台的进程组 kill（面试常问）：终止进程对于前台进程，在推出程序后该进程将自动结束。在前台进程运行过程中，也可按快捷键Ctrl + C 退出。对于后台进程，需要使用kill命令来终止。 信号量：15，9，默认为15 ，告诉进程需要终止，并不一定立刻终止，如果是9，表示强制终止进程 12#终止pid为4217的进程kill -9 4217 top（面试常问）查看系统当前正在执行的进程的相关信息，包括进程id，内存的使用率，CPU的占有率等（动态，实时） load average: 0.00, 0.01, 0.04，分别表示最近一分钟，五分钟，以及十五分钟的负载状况。 是否load average大于1就是系统负载比较高。不一定。要看CPU的核数和线程数，如果是单核cpu，值等于1就是满负荷，如果是四核，八核，负载大于1说明负载不算太高。 12345-c: 显示完整的进程命令-s: 保密模式-p PID 指定进程显示-n &lt;次数&gt; 执行循环显示次数-H 显示线程数 &amp;字符可以将命令的最后加上“&amp;”，使得程序放到后台运行。 基本用于需要一直运行的服务类进程，比如说tomcat，nginx，mysql 7. 防火墙centos7中采用以下命令对防火墙进行处理。 查看防火墙状态：firewall-cmd –state 停止防火墙： systemctl stop firewalld.service 启动防火墙： systemctl start firewalld.service 重启防火墙： systemctl restart firewalld.service 永久关闭防火墙：systemctl disable firewalld.service 永久关闭后重启：systemctl enable firewalld.service 查看开机防火墙：systemctl is-enabled firewalld.service 端口操作： 开启端口：firewall-cmd –zone&#x3D;public –remove-port&#x3D;80&#x2F;tcp –permanent 刷新：firewall-cmd –reload 查看端口状态：firewall-cmd –zone&#x3D;public –query-port&#x3D;80&#x2F;tcp yes表示端口开放，no表示端口不开放 关闭端口：firewall-cmd –zone&#x3D;public –remove-port&#x3D;80&#x2F;tcp –permanent 12345678910111213141516[root@centos701 etc]# firewall-cmd --zone=public --query-port=80/tcpno[root@centos701 etc]# firewall-cmd --zone=public --add-port=80/tcp --permanentsuccess[root@centos701 etc]# firewall-cmd --reloadsuccess[root@centos701 etc]# firewall-cmd --zone=public --query-port=80/tcpyes [root@centos701 etc]# firewall-cmd --zone=public --remove-port=80/tcp --permanentsuccess[root@centos701 etc]# firewall-cmd --reloadsuccess[root@centos701 etc]# firewall-cmd --zone=public --query-port=80/tcpno 8. 启动以及关机注销logout：注销系统login：回到登录界面shutdown –h now ：立刻关机shutdown +5 ：5分钟后关机shutdown 10:30：在10：30关机shutdown –r now ：立刻关闭系统并重启reboot ：重新启动系统 五. vi的常用指令vi编辑器是Linux下最有名的编辑器，也是我们学习linux必须掌握的工具，在unix下也可以进行程序的开发。开发步骤：vi 文件名输入i，进入插入模式，输入Esc键输入冒号:,再输入wq，保存并退出，如果不保存退出，则输入q! 基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 1. 命令模式用户刚刚启动 vi&#x2F;vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。以下是常用的几个命令： i, I字符 ：切换到输入模式，以输入字符。i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』 a, A字符 ：进入输入模式(Insert mode)，a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』 o, O字符 ：进入输入模式(Insert mode)，这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！ r, R：进入取代模式(Replace mode)，r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止 x字符 ：删除当前光标所在处的字符。 :字符 ：切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 2. 输入模式在命令模式下按下i就进入了输入模式。在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符大小写转换 ENTER：回车键，换行 BACK SPACE：退格键，删除光标前一个字符 DEL：删除键，删除光标后一个字符 方向键：在文本中移动光标 HOME&#x2F;END：移动光标到行首&#x2F;行尾 Page Up&#x2F;Page Down：上&#x2F;下翻页 Insert：切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线 ESC：退出输入模式，切换到命令模式 3. 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。按ESC键可随时退出底线命令模式。在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序，如果文件内容被修改了，会出现错误，要求使用“!”强制退出。 q! ：强制退出vim，并且不保存文件 w： 保存文件 wq：将修改过的文件存储，并且离开vim set nu:在文件中每行加入行号 set nonu：取消行号 输入数字：直接输入数字再按enter，就可以将光标定位到改行行首。 &#x2F;字符串：利用&#x2F;字符串来查找特定的内容，如果查找不是想要的的，可以按“n”键盘继续查找。 ?字符串：同&#x2F;字符串 删除命令命令模式下： ​ x：删除当前字符 ​ 3x: 删除当前光标开始的3个字符，如果想要删除n个字符，将3替换成n ​ X：删除当前光标的前一个字符 ​ dd: 删除当前行 ​ dj：删除下一行 ​ dk：删除上一行 ​ 3d：删除当前行开始往后的3行 底线模式下 ​ :5, 10d: 将5~10的数据删除掉 ​ :5,$d: 将5行以后的数据全部删除掉 拷贝命令行拷贝： ​ yy：拷贝当前行 ​ nyy：拷贝当前行开始的n行，5yy，从当前行开始拷贝5行的数据 ​ p：再当前光标后粘贴 ​ shift +p：在当前行前面进行粘贴 ​ :1,5 co 20: 将1~5行copy放到20行之后 部分拷贝 ​ yw：拷贝一个单词 ​ 2yl：拷贝当前光标开始的2个字符 ​ 3yh：拷贝当前光标前面的3个字符（不包括光标的相关字符） 六. 文件压缩和解压命令tar：将指定目录中的所有文件和目录全部进行备份gzip和gunzip：压缩和解压缩文件Zip和unzip：压缩文件和解压文件 tar命令tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。 -A或–catenate 新增文件到已存在的备份文件。-c或–create 建立新的备份文件。-C&lt;目的目录&gt;或–directory&#x3D;&lt;目的目录&gt; 切换到指定的目录。-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。-v或–verbose 显示指令执行过程。-x或–extract或–get 从备份文件中还原文件。-z或–gzip或–ungzip 通过gzip指令处理备份文件。-Z或–compress或–uncompress 通过compress指令处理备份文件。–delete 从备份文件中删除指定的文件。–exclude&#x3D;&lt;范本样式&gt; 排除符合范本样式的文件。 实际使用时经常联合多个选项一起使用，例如 -zcvf 创建一个压缩文件 -zxvf 还原并解压缩文件 12345678910111213141516#归档文件，将tmp文件夹打包成tmp.tgztar -zcvf tmp.tgz tmp#归档文件，排除tmp目录中的w文件，压缩文件名为tmp.tgz,压缩打包放入tmptar --exclude=tmp/w -zcvf tmp.tgz tmp#创建tmp01目录，并将tmp.tgz解压缩到tmp01目录中。mkdir tmp01tar -zxvf tmp.tgz -C tmp01#将tmp打包成u1.tartar -cf u1.tar tmp#将tmp01打包成u2.tartar -cf u2.tar tmp01#将u1.tar的内容追加到u2.tar当中（u2当中包含tmp和tmp01）tar -A u1.tar -vf u2.tar gzip和gunzip命令gzip gzip命令用于压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。常用选项如下： -d或–decompress或—-uncompress 解开压缩文件。 -f或–force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 -l或–list 列出压缩文件的相关信息。 -v或–verbose 显示指令执行过程。 -V或–version 显示版本信息。 gunzip命令 gunzip命令用于解压文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为”.gz”。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。常用选项如下： -c或–stdout或–to-stdout 把解压后的文件输出到标准输出设备。 -f或-force 强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 -l或–list 列出压缩文件的相关信息。 -v或–verbose 显示指令执行过程。 1234#压缩hello.java文件gzip -vf hello.java#将hello.java.gz解压缩gunzip -vf hello.java.gz zip和unziplinux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。 zip命令的常用选项 -g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。 -q 不显示指令执行过程。 -r 递归处理，将指定目录下的所有文件和子目录一并处理。 -S 包含系统和隐藏文件。 -v 显示指令执行过程或显示版本信息。 unzip常用的选项 1234#将所有的jpg文件压缩成一个z.zip文件zip z.zip *.jpg#解压文件unzip all.zip JDK安装将jdk的linux安装文件放入到linux的某个目录下 解压 1tar -zxvf jdkxxx.tar.gz 设置环境变量 在&#x2F;etc&#x2F;profile的最后增加以下内容 12345JAVA_HOME=/usr/jdk1.8.0_261CLASSPATH=.:$JAVA_HOME/libPATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH 重新加载配置文件 1source /etc/profile 进行测试 javac或者java命令就可以测试","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Java面试题-四(多线程)","slug":"Java面试题-四-多线程","date":"2023-09-18T05:21:24.000Z","updated":"2023-09-18T05:27:43.105Z","comments":true,"path":"2023/09/18/Java面试题-四-多线程/","link":"","permalink":"http://example.com/2023/09/18/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9B%9B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1. 说说并发与并行的区别 并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)； 并行： 单位时间内，多个任务同时执行。 2. 进程 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。 3. 线程 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。 从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。 4. 线程和进程的区别 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。 线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 一个程序至少一个进程，一个进程至少一个线程。 为什么会有线程？ 每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。 线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。 进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。 线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有的资源的变化。 进程线程的区别： 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 资源拥有：同一进程内的线程共享本进程的资源如内存、I&#x2F;O、cpu等，但是进程之间的资源是独立的。 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程是处理器调度的基本单位，但是进程不是。 两者均可并发执行。 优缺点： 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。 进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。 何时使用多进程，何时使用多线程？ 对资源的管理和保护要求高，不限制开销和效率时，使用多进程。 要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。 5. 为什么要使用多线程 先从总体上来说： 从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 再深入到计算机底层来探讨： 单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。 举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。 多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。 6. 什么是上下文切换？ 多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。 概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。 7. 在java程序中如何保证多线程的运行安全？ 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized） 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）； 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取共享变量时，它会去内存中读取新值。普通的共享变量不能保证可见性，因为普通共享变量被修改后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。更新主存的步骤：当前线程将其他线程的工作内存中的缓存变量的缓存行设置为无效，然后当前线程将变量的值跟新到主存，更新成功后将其他线程的缓存行更新为新的主存地址其他线程读取变量时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。 有序性：即程序执行的顺序按照代码的先后顺序执行。在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。可以通过volatile关键字来保证一定的“有序性”。当在处理并发编程的时候，只要程序满足了原子性，可见性和有序性，那么程序就不会发生脏数据的问题。 8. 编写多线程程序有几种实现方式 Java 5以前实现多线程有两种实现方法： 继承Thread类； 实现Runnable接口。 两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。 Java5之后还可以通过 实现Callable接口，此种实现可以带返回值 使用 Executor 框架创建线程池 9. 启动一个线程事调用run()还是start()方法？ 启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。 10. 说一下runnable和callable有什么区别？ Callable规定的方法是call(),Runnable规定的方法是run(). Callable的任务执行后可返回值，而Runnable的任务是不能返回值得 call方法可以抛出异常，run方法不可以 运行Callable任务可以拿到一个Future对象，Future 表示异步计算的结果。 它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如果线程没有执行完，Future.get()方法可能会阻塞当前线程的执行；如果线程出现异常，Future.get()会throws InterruptedException或者ExecutionException；如果线程已经取消，会跑出CancellationException。取消由cancel 方法来执行。isDone确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。Future接口的定义如下：Future模式Future模式在请求发生时，会先产生一个Future凭证给发出请求的客户，它的作用就像是Proxy物件，同时，由一个新的执行线程持续进行目标物件的生成（Thread-Per-Message），真正的目标物件生成之后，将之设定至Future之中，而当客户端真正需要目标物件时，目标物件也已经准备好，可以让客户提取使用。结合JDK的Future来看，就是你run线程后，你可以把线程的返回值赋给Future并返回一个Future对象。这时你可以立即拿到这个对象，然后进行下面的逻辑。但是如果你要get这个Future中的线程结果，就会被阻塞直到线程结束。就相当于现在的期房，你把手续和钱都交上去了，就可以马上拿到合同，但只有合同没有房子。这个时候你已经是有房一族了，你可以先去买家电买装修（走下面的其他逻辑）。但是你要把家电和装修放进去，就必须等到房子完工（阻塞）。 11. 线程有哪些状态 在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态； 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep,suspend等方法都可以导致线程阻塞。 死亡状态。如果一个线程的run方法执行结束，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪状态。 12. 线程的sleep()方法和yield()方法有什么区别？ sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 13. 线程的run()和start()有什么区别？ 在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。 实现并启动线程有两种方法 写一个类继承自Thread类，重写run方法。用start方法启动线程 写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动多线程 原理： 相当于玩游戏机，只有一个游戏机（cpu），可是有很多人要玩，于是，start是排队！等CPU选中你就是轮到你，你就run（），当CPU的运行的时间片执行完，这个线程就继续排队，等待下一次的run（）。 调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。 然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。 先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。 start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。 14. wait和sleep的区别（线程） sleep()来自 Thread 类，wait()来自 Object 类； 调用 sleep()方法，线程不会释放对象锁。而调用 wait 方法线程会释放对象锁； sleep()睡眠后不出让系统资源，wait 让其他线程可以占用 CPU； sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。而 wait()需要配合 notify()或者 notifyAll()使用。 15. Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？ sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。 wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 16. wait()和sleep()的区别 sleep()来自 Thread 类，wait()来自 Object 类； 调用 sleep()方法，线程不会释放对象锁。而调用 wait 方法线程会释放对象锁； sleep()睡眠后不出让系统资源，wait 让其他线程可以占用 CPU； sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。而 wait()需要配合 notify()或者 notifyAll()使用 17. 请说出与线程同步以及线程调度相关的方法 wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 18. 守护线程是什么 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分两种. 守护线程，比如垃圾回收线程，就是最典型的守护线程。 用户线程，就是应用程序里的自定义线程。 19. 说说线程的生命周期和状态 Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）： 由上图可以看出：线程创建之后它将处于 NEW（新建）状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。 1操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。 当线程执行 wait()方法之后，线程进入 WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞）状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止）状态 20. 使用多线程可能带来什么问题？ 并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。 21. 什么是线程死锁？如何避免死锁 认识线程死锁两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。 下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过 Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。 学过操作系统的朋友都知道产生死锁必须具备以下四个条件： 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 如何避免线程死锁? 我们只要破坏产生死锁的四个条件中的其中一个就可以了。 破坏互斥条件 这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件 一次性申请所有的资源。 破坏不剥夺条件 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 我们对线程 2 的代码修改成下面这样就不会产生死锁了。 我们分析一下上面的代码为什么避免了死锁的发生? 线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。 然后线程 1 再去获取 resource2 的监视器锁，可以获取到。 然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。 这样就破坏了破坏循环等待条件，因此避免了死锁。 22. 怎么防止死锁1. 什么是死锁 死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 例如，在某一个计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。 2. 死锁产生的原因 系统资源的竞争 系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。 进程运行推进顺序不合适 进程在运行过程中，请求和释放资源的顺序不当，会导致死锁 3. 死锁的四个必要条件 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 4. 死锁的避免与预防1. 死锁避免 死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。,安全状态是指：如果系统存在 由所有的安全序列{P1，P2，…Pn},则系统处于安全状态。一个进程序列是安全的，如果对其中每一个进程Pi(i &gt;&#x3D;1 &amp;&amp; i &lt;&#x3D; n)他以后尚需要的资源不超过系统当前剩余资源量与所有进程Pj(j &lt; i)当前占有资源量之和，系统处于安全状态则不会发生死锁。 不安全状态：如果不存在任何一个安全序列，则系统处于不安全状态。他们之间的对对应关系如下图所示： 下面我们来通过一个例子对安全状态和不安全状态进行更深的了解 如上图所示系统处于安全状态，系统剩余3个资源，可以把其中的2个分配给P3，此时P3已经获得了所有的资源，执行完毕后还能还给系统4个资源，此时系统剩余5个资源所以满足（P2所需的资源不超过系统当前剩余量与P3当前占有资源量之和），同理P1也可以在P2执行完毕后获得自己需要的资源。 如果P1提出再申请一个资源的要求，系统从剩余的资源中分配一个给进程P1，此时系统剩余2个资源，新的状态图如下：那么是否仍是安全序列呢那我们来分析一下 系统当前剩余2个资源，分配给P3后P3执行完毕还给系统4个资源，但是P2需要5个资源，P1需要6个资源，他们都无法获得资源执行完成，因此找不到一个安全序列。此时系统转到了不安全状态。 2. 死锁预防 我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。 破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。 破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。 - 23. 什么是线程池（thread pool）? 在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 24. 创建线程池有哪几种方式 通常开发者都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的Executors目前提供了5种不同的线程池创建配置： newCachedThreadPool（），它是用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置时间超过60秒，则被终止并移除缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。 newFixedThreadPool（int nThreads），重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动线程数目，将在工作队列中等待空闲线程出现；如果工作线程退出，将会有新的工作线程被创建，以补足指定数目nThreads。 newSingleThreadExecutor()，它的特点在于工作线程数目限制为1，操作一个无界的工作队列，所以它保证了所有的任务都是被顺序执行，最多会有一个任务处于活动状态，并且不予许使用者改动线程池实例，因此可以避免改变线程数目。 newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。 newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。 25. 线程池都有哪些状态 线程池的5种状态： Running ShutDown Stop Tidying Terminated。 线程池各个状态切换框架图： 1. RUNNING 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！ 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 2. SHUTDOWN 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。 3. STOP 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。 4. TIDYING 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。 5. TERMINATED 状态说明：线程池彻底终止，就变成TERMINATED状态。 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。 26. 举例说明同步和异步 如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 27. 说一下synchronized底层实现原理（详细版） 数据同步需要依赖锁，那锁的同步又依赖谁？synchronized给出的答案是在软件层面依赖JVM，而Lock给出的方案是在硬件层面依赖特殊的CPU指令，大家可能会进一步追问：JVM底层又是如何实现synchronized的？ 下面首先介绍synchronized的实现： synrhronized关键字简洁、清晰、语义明确，因此即使有了Lock接口，使用的还是非常广泛。其应用层的语义是可以把任何一个非null 对象 作为’锁’，当synchronized作用在方法上时，锁住的便是对象实例（this）；当作用在静态方法时锁住的便是对象对应的Class实例，因为 Class数据存在于永久带，因此静态方法锁相当于该类的一个全局锁；当synchronized作用于某一个对象实例时，锁住的便是对应的代码块。在 HotSpot JVM实现中，锁有个专门的名字：对象监视器。 1. 线程状态及状态转换 当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程： Contention List：所有请求锁的线程将被首先放置到该竞争队列 Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck Owner：获得锁的线程称为Owner !Owner：释放锁的线程 下图反映了个状态转换关系： 新请求锁的线程将首先被加入到ConetentionList中，当某个拥有锁的线程（Owner状态）调用unlock之后，如果发现 EntryList为空则从ContentionList中移动线程到EntryList，下面说明下ContentionList和EntryList 的实现方式： 1.1 ContentionList 虚拟队列 ContentionList 并不是一个真正的Queue，而只是一个虚拟队列，原因在于ContentionList是由Node及其next指 针逻辑构成，并不存在一个Queue的数据结构。ContentionList是一个后进先出（LIFO）的队列，每次新加入Node时都会在队头进行， 通过CAS改变第一个节点的的指针为新增节点，同时设置新增节点的next指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个Lock- Free的队列。 因为只有Owner线程才能从队尾取元素，也即线程出列操作无争用，当然也就避免了CAS的ABA问题。 1.2. EntryList EntryList与ContentionList逻辑上同属等待队列，ContentionList会被线程并发访问，为了降低对 ContentionList队尾的争用，而建立EntryList。Owner线程在unlock时会从ContentionList中迁移线程到 EntryList，并会指定EntryList中的某个线程（一般为Head）为Ready（OnDeck）线程。Owner线程并不是把锁传递给 OnDeck线程，只是把竞争锁的权利交给OnDeck，OnDeck线程需要重新竞争锁。这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在 Hotspot中把OnDeck的选择行为称之为“竞争切换”。 OnDeck线程获得锁后即变为owner线程，无法获得锁则会依然留在EntryList中，考虑到公平性，在EntryList中的位置不 发生变化（依然在队头）。如果Owner线程被wait方法阻塞，则转移到WaitSet队列；如果在某个时刻被notify&#x2F;notifyAll唤醒， 则再次转移到EntryList。 2. 自旋锁 那些处于ContetionList、EntryList、WaitSet中的线程均处于阻塞状态，阻塞操作由操作系统完成（在Linxu下通 过pthread_mutex_lock函数）。线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响 锁的性能缓解上述问题的办法便是自旋，其原理是：当发生争用时，若Owner线程能在很短的时间内释放锁，则那些正在争用线程可以稍微等一等（自旋）， 在Owner线程释放锁后，争用线程可能会立即得到锁，从而避免了系统阻塞。但Owner运行的时间可能会超出了临界值，争用线程自旋一段时间后还是无法 获得锁，这时争用线程则会停止自旋进入阻塞状态（后退）。基本思路就是自旋，不成功再阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有非 常重要的性能提高。自旋锁有个更贴切的名字：自旋-指数后退锁，也即复合锁。很显然，自旋在多处理器上才有意义。 还有个问题是，线程自旋时做些啥？其实啥都不做，可以执行几次for循环，可以执行几条空的汇编指令，目的是占着CPU不放，等待获取锁的机 会。所以说，自旋是把双刃剑，如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。显然，自旋的周期选择显得非常重要，但这与操作系统、硬 件体系、系统的负载等诸多场景相关，很难选择，如果选择不当，不但性能得不到提高，可能还会下降，因此大家普遍认为自旋锁不具有扩展性。 自旋优化策略 对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下： 如果平均负载小于CPUs则一直自旋 如果有超过(CPUs&#x2F;2)个线程正在自旋，则后来线程直接阻塞 如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋 自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差） 自旋时会适当放弃线程优先级之间的差异那synchronized实现何时使用了自旋锁？答案是在线程进入ContentionList时，也即第一步操作前。线程在进入等待队列时 首先进行自旋尝试获得锁，如果不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平。还有一个不公平的地方是自旋线程可能会抢占了 Ready线程的锁。自旋锁由每个监视对象维护，每个监视对象一个。 3.JVM1.6偏向锁 在JVM1.6中引入了偏向锁，偏向锁主要解决无竞争下的锁性能问题，首先我们看下无竞争下锁存在什么问题： 现在几乎所有的锁都是可重入的，也即已经获得锁的线程可以多次锁住&#x2F;解锁监视对象，按照之前的HotSpot设计，每次加锁&#x2F;解锁都会涉及到一些 CAS操 作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个 线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁&#x2F;解锁流程。但还有很多概念需要解释、很多引入的 问题需要解决： 3.1 CAS及SMP架构 CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构： 其意思是所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。 而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，经过调查发现， 其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的 接口。 Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总 线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致 性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。 而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。 Cache一致性： 上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：http://en.wikipedia.org/wiki/MESI_protocol，以后会仔细讲解这部分。 Cache一致性流量的例外情况：其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：http://blogs.oracle.com/dave/entry/biased_locking_in_hotspotNUMA(NonUniform Memory Access Achitecture）架构： 与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。 3.2 偏向解除 偏向锁引入的一个重要问题是，在多争用的场景下，如果另外一个线程争用偏向对象，拥有者需要释放偏向锁，而释放的过程会带来一些性能开销，但总体说来偏向锁带来的好处还是大于CAS代价的。 4. 总结 关于锁，JVM中还引入了一些其他技术比如锁膨胀等，这些与自旋锁、偏向锁相比影响不是很大，这里就不做介绍。 通过上面的介绍可以看出，synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。 28. 说一下synchronized底层实现原理（简单版） synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 29. synchronized和Lock有什么区别？ 首先synchronized是java内置关键字，在jvm层面，Lock是个java类； synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 30. 说说自己是怎么使用synchronized关键字，在项目中用到了吗synchronized关键字最主要的三种使用方式： 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 修饰静态方法: :也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到静态方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！ 下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。 面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！” 双重校验锁实现对象单例（线程安全） 另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行： 1.为 uniqueInstance 分配内存空间 2.初始化 uniqueInstance 3.将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 31. synchronized和volatile的区别是什么？ volatile是变量修饰符，而synchronized则作用于一段代码或者方法。 volatile只是在线程内存和main memory(主内存)间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源。 32. 什么是ThreadLocal？ThreadLocal和Synchonized的区别 线程局部变量。是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。 Java提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。 synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而 ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。 33. ThreadLocal是什么？有哪些使用场景？ ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 从数据结构入手下图为ThreadLocal的内部结构图 ThreadLocal结构内部从上面的结构图，我们已经窥见ThreadLocal的核心机制： 每个Thread线程内部都有一个Map。 Map里面存储线程本地对象（key）和线程的变量副本（value）但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 应用场景Hibernate的session获取场景吗？ 为什么每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。使用ThreadLocal的典型场景正如上面的数据库连接管理，线程会话管理等场景，只适用于独立变量副本的情况，如果变量为全局共享的，则不适用在高并发下使用。 总结 每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。 ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。 适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。 34. 谈谈synchronized和ReentrantLock的区别 两者都是可重入锁两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。 synchronized 依赖于 JVM 而 ReentrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。 ReentrantLock 比 synchronized 增加了一些高级功能相比synchronized，ReentrantLock增加了一些高级功能。 主要来说主要有三点： ①等待可中断； ②可实现公平锁； ③可实现选择性通知（锁可以绑定多个条件） ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。 两者都是可重入锁两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。 35. 如何让list变成线程安全 使用synchronized关键字； 使用Collections.synchronizedList();使用方法如下：假如你创建的代码如下： 1List&lt;Map&lt;String, Object&gt;&gt; data = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); 那么为了解决这个线程安全问题你可以这么使用Collections.synchronizedList()，如： 1List&lt;Map&lt;String, Object&gt;&gt; data = Collections.synchronizedList(new ArrayList&lt;Map&lt;String, Object&gt;()) 其他的都没变，使用的方法也几乎与ArrayList一样，大家可以参考下api文档； 额外说下 ArrayList与LinkedList；这两个都是接口List下的一个实现，用法都一样，但用的场所的有点不同，ArrayList适合于进行大量的随机访问的情况下使用，LinkedList适合在表中进行插入、删除时使用，二者都是非线程安全，解决方法同上（为了避免线程安全，以上采取的方法，特别是第二种，其实是非常损耗性能的）。 36. 说一下atomic的原理 在多线程的场景中，我们需要保证数据安全，就会考虑同步的方案，通常会使用synchronized或者lock来处理，使用了synchronized意味着内核态的一次切换。这是一个很重的操作。 有没有一种方式，可以比较便利的实现一些简单的数据同步，比如计数器等等。concurrent包下的atomic提供我们这么一种轻量级的数据同步的选择。 在以上代码中，使用AtomicInteger声明了一个全局变量，并且在多线程中进行自增，代码中并没有进行显示的加锁。以上代码的输出结果，永远都是2000000。如果将AtomicInteger换成Integer，打印结果基本都是小于2000000。 也就说明AtomicInteger声明的变量，在多线程场景中的自增操作是可以保证线程安全的。接下来我们分析下其原理。 原理这里，我们来看看AtomicInteger是如何使用非阻塞算法来实现并发控制的。AtomicInteger的关键域只有以下3个： 这里， unsafe是java提供的获得对对象内存地址访问的类，注释已经清楚的写出了，它的作用就是在更新操作时提供“比较并替换”的作用。实际上就是AtomicInteger中的一个工具。 valueOffset是用来记录value本身在内存的编译地址的，这个记录，也主要是为了在更新操作在内存中找到value的位置，方便比较。 value是用来存储整数的时间变量，这里被声明为volatile。volatile只能保证这个变量的可见性。不能保证他 的原子性。可以看看getAndIncrement这个类似i++的函数，可以发现，是调用了UnSafe中的getAndAddInt。 如何保证原子性：自旋 + CAS（乐观锁）。在这个过程中，通过compareAndSwapInt比较更新value值，如果更新失败，重新获取旧值，然后更新。 优缺点 CAS相对于其他锁，不会进行内核态操作，有着一些性能的提升。但同时引入自旋，当锁竞争较大的时候，自旋次数会增多。cpu资源会消耗很高。换句话说，CAS+自旋适合使用在低并发有同步数据的应用场景。 Java 8做出的改进和努力在Java 8中引入了4个新的计数器类型，LongAdder、LongAccumulator、DoubleAdder、DoubleAccumulator。他们都是继承于Striped64。 在LongAdder 与AtomicLong有什么区别？Atomic遇到的问题是，只能运用于低并发场景。因此LongAddr在这基础上引入了分段锁的概念。可以参考《JDK8系列之LongAdder解析》一起看看做了什么。大概就是当竞争不激烈的时候，所有线程都是通过CAS对同一个变量（Base）进行修改，当竞争激烈的时候，会将根据当前线程哈希到对于Cell上进行修改（多段锁）。 可以看到大概实现原理是：通过CAS乐观锁保证原子性，通过自旋保证当次修改的最终修改成功，通过降低锁粒度（多段锁）增加并发性能。 37. 多线程锁的升级原理是什么？ 多线程优化锁升级monitorenter与monitorexit这两个控制多线程同步的bytecode原语，是JVM依赖操作系统互斥(mutex)来实现的（系统调用）。互斥是一种会导致线程挂起，并在较短的时间内又需要重新调度回原线程的，较为消耗资源的操作。 JDK1.6对线程进行了优化，目的就是减少多线程编程下对锁竞争产生的性能开销。 无锁状态：没有加任何锁 偏向锁：如果程序中只有一个线程在访问对象，那么这个对象的锁就会偏向于这一个线程，之后一系列的原子操作都不会产生同步开销，直到其他线程在竞争锁的时候，偏向锁才会解除掉 轻量级锁（Lightweight Locking）:多个线程会去竞争锁，但是尽可能地减少多线程进入互斥的几率。它并不是要替代互斥，因为随着竞争越来越激烈，它最后也会升级成重量级锁（inflated 膨胀）乐观锁：多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起（适应性自旋：不要旋转太久，否则会消耗过多的cpu），而是被告知这次竞争中失败，并可以再次尝试。乐观锁就是轻量级锁，悲观锁就是重量级锁。 轻量级锁是如何实现的呢？ 利用了CPU原语CompareAndSwap(汇编指令为CMPXCHG)，尝试在进入互斥前，进行补救。轻量级锁加锁（竞争的线程不会阻塞，提高了程序的响应速度） 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。 重量级锁：重量锁又叫对象监视器（Monitor），它实际上是利用操作系统中的Mutex，除了具备Mutex互斥的功能，它还负责实现Semaphore的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Java面试题-三(JavaWeb)","slug":"Java面试题-三-JavaWeb","date":"2023-09-18T05:17:52.000Z","updated":"2023-09-18T05:20:30.377Z","comments":true,"path":"2023/09/18/Java面试题-三-JavaWeb/","link":"","permalink":"http://example.com/2023/09/18/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%89-JavaWeb/","excerpt":"","text":"1. 如何解决POST请求中文乱码问题，GET的又是如何处理的 解决post请求乱码问题： 在web.xml中配置一个CharacterEncodingFilter过滤器，设置成UTF-8； 123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; get请求中文参数出现乱码的解决方法有两个： 修改tomcat配置文件添加编码与工程编码一致，如下： 1&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 另一种方法对参数进行重新编码 1String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;) ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 2. Servlet接口中有哪些方法?Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： void init(ServletConfig config) throws ServietException void service(ServletRequest req，ServietResponse resp) throws ServietException,java.io.IOException void destory() java.lang.String getServletlnfo() ServletConfig getServletConfig() Web容器加载Servlet并将其实例化后，Servlet生命周期开始容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service(）方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用 Servlet的destroy()方法。 3. 转发（forward）和重定向（redirect）的区别？ 相同点： 都能跳转到其它页面 不同点： 转发请求只发出一次请求，而重定向发出多次请求 转发request对象是同一个,而重定向request对象是多个 转发地址栏不变,而重定向地址栏改变 转发的”&#x2F;“是相对于项目,而重定向的”&#x2F;“相对于WEB容器 转发只能转发到项目资源,而重定向可以是项目资源也可以是外部资源 请求转发有两种写法 1234//forward 一去不回头，在转发之后向控制台(System.out.println)仍然会输出，但out.println(&quot;xxx&quot;)不会在页面上输出request.getRequestDispatcher(&quot;/xx&quot;).forward(request,response);//include 一去还回头，在转发之后向控制台(System.out.println)仍然会输出，但out.println(&quot;xxx&quot;)也会在页面上输出request.getRequestDispatcher(&quot;/xx&quot;).include(request,response); 4. web项目”&#x2F;“的相对路径 的理解 web.xml里”&#x2F;“相当于项目 index.html里”&#x2F;“相当于web容器 请求转发里”&#x2F;“相当于项目 请求重定向”&#x2F;“相当于web容器 自己处理的相当于项目 服务器处理相当于web容器 5. jsp有哪些内置对象？作用分别是什么？ Jsp有9个内置对象： request：封装客户端的请求，其中包合来自GET或Post请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config: Web应用的配置对象； page: JsP页面本身（相当于Java程序中的this ） exception：封装页面抛出异常的对象。 6. GET与POST请求比较 使用GET方式传递参数: 在浏览器地址栏中输入某个地址或单击网页上一个超链接 ，浏览器发出的HTTP请求方式为GET 如果form表单中method属性设置成了”GET，浏览器提交这个FORM表单的HTTP请求方式也为GET 使用GET请求给WEB服务器传递参数的格式 （Query String Paramaters） 1http://localhost:8080/02_JavaWeb_Servlet_HTTP/loginServlet2?uname=%E5%BC%A0%E4%B8%89 缺点: 地址栏大小有限制，最多255个字符 不安全，如果是密码则在地址栏中会以明码显示 优点: 书签 http://localhost:8080/books/java100day?page=10; 使用POST方式传递参数 【推荐】 如果form表单中method属性设置成了”POST”，浏览器提交这个FORM表单的HTTP请求方式就为POST 在址址栏中看不到传递的数据，因为它是使用表单数据传递的(Form Datas) 优点： 大小没有限制 安全 7. 常用的Web服务器有哪些？ Unix和Linux平台下使用最广泛的免费HTTP服务器，Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。 选择Web服务器应考虑的因素有：性能、安全性、日志统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。 下面是对常见服务器的简介： IIS : Microsoft的Web服务器产品全称是Internet Information Services。IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务软件，其中包括Web服务器、FTP服务器、NNTF服务器、 SMTP服务器分别用于网页浏览、文件传输、新闻服务和邮件发送等方面它使得在网络（包括互联网和局域网上发布信息成了一件很容易的事。它提供ISAPI(lntranet Server API）作为扩展Web服务器功能的编程接口；同时它还提供一个Internet数据库连接器可以实现对数据库的查询和更新。 Kangle:Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务 软件。此外Kangle也是一款专为做虚拟主机研发的WEB 服务器。实现虚拟主机独立进程、独立身份运行。用户 之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。 WebSphere:WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IMB电子商务计划的核心部分它是基于Java的应用环境用于建立、部署和 处理Internet和Intranet Web应用程序适应各种Web应用程序服务器的需要。 WebLogic : WebLogic Server是一款多功能、基于标准 的Web应用服务器，为企业构建企业应用提供了坚实的 基础。针对各种应用开发、关键性任务的部署，各种系统性数据库的集成、跨Internet协作等Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业的应用都选择它来作为开发和部署的环境。WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位为构建集成化的企业级应用提供了稳固的基础。 Apache：目前Apache仍然是世界上用得最多的Web服 器，其市场占有率很长时间都保持在60％以上（目前的 场份额约40％左右）。世界上很多著名的网站都是Apache 的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix, Windows, Linux系统平台上）以及它的可移动性等方面。 Tomcat:Tomcat是一个开放源代码、运行Servlet和JSP的WEB容器。Tomcat实现了Servlet和JSP规范。此外Tomc at还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。 Nginx：读作 ‘engine x’，是一个高性能的HTTP和反向代理服务器也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。Nginx是由Igor Sysoev 俄罗斯访问量第二的Rambler站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可的形式发布，因它的稳定性、丰富的功能集、示例配置组件和低系统资源的消耗而闻名。在2014年下半年Nginx: 市场份额达到了14%。 8 . 过滤器的理解 JavaWEB有三大组件 ： Servlet、Filter和Listener。Filter就是其中之一。 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。 可以将一个或多个过滤器附加到一个 Servlet 或一组 Servlet。过滤器也可以附加到 JavaServer Pages (JSP) 文 件和 HTML 页面。调用 Servlet 或页面前都会先执行过滤器。 Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的： 在客户端的请求访问后端资源之前，拦截这些请求。 在服务器的响应发送回客户端之前，处理这些响应。 10. Ajax简介 AJAX &#x3D; Asynchronous JavaScript and XML（异步 JavaScript 和 XML）。 Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 Javascript 来操作 DOM 而更新页面。这其中最关键的一步就是从服务器获得请求数据。 XmlHttpRequest 是 ajax 的核心机制，它是在 IE5 中首先引入的，是一种支持异步请求的技术。简单的说，也就是 Javascript 可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 11. http响应码301和302代表的是什么？有什么区别？ 官方的比较简洁的说明： 301 代表永久性转移(Permanently Moved) 302 代表暂时性转移(Temporarily Moved ) 共同点： 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B） 不同点 301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），**搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。** 12. web.xml文件中可以配置哪些内容？web.xml 用于配置 Web 应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等。 13. 怎么防止表单重复提交？ 禁掉提交按钮。表单提交后使用 Javascript 使提交按钮 disable。 Post&#x2F;Redirect&#x2F;Get 模式。在提交后执行页面重定向，这就是所谓的 Post-Redirect-Get (PRG) 模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。 在 session 中存放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。 14. cookie简述 在 web 程序中是使用 HTTP 协议来传输数据的，因为 http 是无状态协议，一旦数据交换完毕，客户端和服务器端的连接就会关闭，再次交换数据需要建立新的连接，所以无法实现会话跟踪，cookie 技术则弥补了这一缺陷。 cookie 实际上一段的文本信息，客户端请求服务器。如果服务器需要记录该用户的状态，就使用 response 向客户端浏览器颁发一个 cookie。客户端浏览器会把 cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 cookie 一同提交给服务器。服务器检查该 cookie，以此来辨认用户的状态。服务器还可以根据需要修改 cookie 的内容。 cookie 生命周期:cookie 的 maxAge 决定 cookie 的生命周期，单位为秒（second）。cookie 通过 getMaxAge() 方法和 setMaxAge()方法来获得 maxAge 属性，如果 maxAhe 属性为正，则表示 cookie 会在 maxAge 秒之后自动失效。如果 maxAge 属性为负，则说明 cookie 仅在本浏览器窗口和本窗口打开的子窗口下有效，关闭窗口 cookie 则失效。maxAge 的默认值是-1 当 maxAge 的值为 0 时，表示删除 cookie。 15. cookie和session的区别 session: session机制采用的是在服务器端保持状态的方案 session会在一定时间内保存在服务器上。当访问增多,会比较占用你服务器的性能 考虑到减轻服务器性能方面,应当使用COOKIE cookie: cookie机制采用的是在客户端保持状态的方案 cookie不是很安全,别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session 16. 监听器有哪些方法和作用 JavaWEB有三大组件 ： Servlet、Filter和Listener。Listener就是其中之一。 三个分类 监听对象自身创建和销毁的监听器 （不常用 ） ServletContextListener Initialized:容器开始创建， Destroyed： 容器关闭时消亡 HttpSessionListener Initialized:session创建时创建， Destroyed： session失效时消亡 ServletRequestListener Initialized:request创建时创建， Destroyed： 页面访问结束时消亡 监听对象中属性的增加和删除的监听器 ServletContextAttributeListener attributeReplaced attributeAdded attributeRemoved HttpSessionAttributeListener ServletRequestAttributeListener 监听Httpsession状态的事件监听器 ,不需要在xml中配置，要在JavaBean上实现此接口。（不常用 ） HttpSessionActivationListener sessionDidActivate，sessionWillPassivate ，需要在META-INF中配置 HttpSessionBindingListener valueBound valueUnbound 总8个监听接口 Listener接口 Event类 ServletContextListener ServletContextEvent ServletContextAttributeListener ServletContextAttributeEvent HttpSessionListener HttpSessionEvent HttpSessionActivationListener HttpSessionAttributeListener HttpSessionBindingEvent HttpSessionBindingListener ServletRequestListener ServletRequestEvent ServletRequestAttributeListener ServletRequestAttributeEvent 17. 什么是跨域，如何实现跨域 跨域说明：当浏览器执行脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。 这里的同源指访问的协议、域名、端口都相同。 同源策略是由 Netscape 提出的著名安全策略，是浏览器最核心、基本的安全功能，它限制了一个源中加载脚本与来自其他源中资源的交互方式。 Ajax 发起的跨域 HTTP 请求，结果被浏览器拦截，同时 Ajax 请求不能携带与本网站不同源的 Cookie。 &lt;script&gt; &lt;img&gt; &lt;iframe&gt; &lt;link&gt; &lt;video&gt; &lt;audio&gt; 等带有 src 属性的标签可以从不同的域加载和执行资源。 实现跨域方式如下 1、jsonp利用了 script 不受同源策略的限制缺点：只能 get 方式，易受到 XSS攻击 2、CORS（Cross-Origin Resource Sharing）,跨域资源共享当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；后端在接受到请求后确定响应后会在后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错缺点：忽略 cookie，浏览器版本有一定要求 3、代理跨域请求前端向发送请求，经过代理，请求需要的服务器资源缺点：需要额外的代理服务器 4、Html5 postMessage 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本、多窗口、跨域消息传递缺点：浏览器版本要求，部分浏览器要配置放开跨域限制 5、6、基于 Html5 websocket 协议websocket 是 Html5 一种新的协议，基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求缺点：浏览器一定版本要求，服务器需要支持 websocket 协议 18. Jquery简介 JQuery 是一个 JavaScript 库。功能包括 HTML 元素选取和操作、CSS 操作、HTML 事件函数、 JavaScript 特效和动画、HTML DOM 遍历和修改、AJAX 和 Utilities。除此之外，JQuery 还提供了大量插件。 重点三个方向 基础语法： $(selector).action()。 选择器：主要分四大选择器，分别是基本选择器、层次选择器、过滤选择器、属性过滤选择器。 事件：例如 click()、dblclick()、mouseenter()、mouseleave()、mousedown()等。 19. session简介 session 也是一种记录客户状态的机制，不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器是时候把客户端信息以某种形式记录在服务器上，这就是 session 中查找该客户的状态。 session 生命周期： session 保存在服务器端，为了获得更高的存取速度，服务器一般把 session 放在内存。每个用户都会有一个独立的 session,如果 session 内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。 session 在用户第一次访问服务器的时候自动创建，需要注意只有访问 JSP，Servlet 等程序时才会创建 session；只要访问 HTML、IMAGE 等静态资源不会创建 session。如果尚未生成session,可以使用 request.getSession(true)强制生成 session。 session 生成后，只要用户访问，服务器就会更新 session 的最后访问时间，并维护该 session。用户每访问服务器一次，无论是否续写 session 服务器都认为该用户的 session 活跃（active）了一次。 Session 对应的类是 javax.servlet.http.HttpSession，每一个访问者都对应一个 session 对象，并将其状态信息保存在这个 session 对象中，session 对象的创建是在用户第一次访问服务器时产生的。 20. JSP和Servlet是什么关系？ Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。 Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。 21. JSP和Servlet是什么关系？ Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。 Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。 给人感觉，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。 22. 过滤器的生命周期 创建，随着WEB容器的启动而启动，这一点与Servlet有区别 void init(FilterConfig) 过滤 ： 每次请求时都会执行 doFilter（ServletRequest request, ServletResponse response, FilterChain chain） 消亡：随着WEB容器的结束而结束 destroy( )","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Java面试题-二(JVM)","slug":"Java面试题-二-JVM","date":"2023-09-18T05:14:23.000Z","updated":"2023-09-18T05:16:43.564Z","comments":true,"path":"2023/09/18/Java面试题-二-JVM/","link":"","permalink":"http://example.com/2023/09/18/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%8C-JVM/","excerpt":"","text":"JVM 有哪些组成部分 JVM 是运行在操作系统之上的，它与硬件没有直接的交互 如下图所示： 整个JVM 分为四部分： Class Loader 类加载器 : 类加载器的作用是加载类文件到内存 Execution Engine 执行引擎: 执行引擎也叫做解释器(Interpreter) ，负责解释命令，提交操作系统执行。 Native Interface 本地接口 本地接口的作用是融合不同的编程语言为Java 所用，它的初衷是融合C&#x2F;C++ 程序，Java 诞生的时候是C&#x2F;C++ 横行的时候，要想立足，必须有一个聪明的、睿智的调用C&#x2F;C++ 程序，于是就在内存中专门开辟了一块区域处理标记为native 的代码，它的具体做法是Native Method Stack 中登记native 方法，在Execution Engine 执行时加载native libraies 。目前该方法使用的是越来越少了，除非是与硬件有关的应用，比如通过Java 程序驱动打印机，或者Java 系统管理生产设备，在企业级应用中已经比较少见，因为现在的异构领域间的通信很发达，比如可以使用Socket 通信，也可以使用Web Service 等等。 Runtime data area 运行数据区 运行数据区是整个JVM 的重点。我们所有写的程序都被加载到这里，之后才开始运行，Java 生态系统如此的繁荣，得益于该区域的优良自治。 JVM加载class文件的原理机制 Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。 类装载方式，有两种 1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中 2.显式装载， 通过class.forname()等方法，显式加载需要的类 Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。 Java的类加载器有三个，对应Java的三种类:（java中的类大致分为三种： 1.系统类 2.扩展类 3.由程序员自定义的类 ） – Bootstrap Loader &#x2F;&#x2F; 负责加载系统类 (指的是内置类，像是String，对应于C#中的System类和C&#x2F;C++标准库中的类) | - - ExtClassLoader &#x2F;&#x2F; 负责加载扩展类(就是继承类和实现类) | - - AppClassLoader &#x2F;&#x2F; 负责加载应用类(程序员自定义的类) 原理机制 装载:查找和导入class文件; 连接: (1)检查:检查载入的class文件数据的正确性; (2)准备:为类的静态变量分配存储空间; (3)解析:将符号引用转换成直接引用(这一步是可选的) 初始化:初始化静态变量，静态代码块。 常见的 jvm 调优的参数有哪些?（1）-Xms20M 表示设置JVM启动内存的最小值为20M，必须以M为单位 （2）-Xmx20M 表示设置JVM启动内存的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免JVM内存自动扩展。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高 （3）-verbose:gc 表示输出虚拟机中GC的详细情况 （4）-Xss128k 表示可以设置虚拟机栈的大小为128k （5）-Xoss128k 表示设置本地方法栈的大小为128k。不过HotSpot并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说这个参数是无效的 （6）-XX:PermSize&#x3D;10M 表示JVM初始分配的永久代（方法区）的容量，必须以M为单位 （7）-XX:MaxPermSize&#x3D;10M 表示JVM允许分配的永久代（方法区）的最大容量，必须以M为单位，大部分情况下这个参数默认为64M （8）-Xnoclassgc 表示关闭JVM对类的垃圾回收 （9）-XX:+TraceClassLoading 表示查看类的加载信息 （10）-XX:+TraceClassUnLoading 表示查看类的卸载信息 （11）-XX:NewRatio&#x3D;4 表示设置 年轻代（包括Eden和两个Survivor区）&#x2F;老年代 的大小比值为1：4，这意味着年轻代占整个堆的1&#x2F;5 （12）-XX:SurvivorRatio&#x3D;8 表示设置2个Survivor区：1个Eden区的大小比值为2:8，这意味着Survivor区占整个年轻代的1&#x2F;5，这个参数默认为8 （13）-Xmn20M 表示设置年轻代的大小为20M （14）-XX:+HeapDumpOnOutOfMemoryError 表示可以让虚拟机在出现内存溢出异常时Dump出当前的堆内存转储快照 （15）-XX:+UseG1GC 表示让JVM使用G1垃圾收集器 （16）-XX:+PrintGCDetails 表示在控制台上打印出GC具体细节 （17）-XX:+PrintGC 表示在控制台上打印出GC信息 （18）-XX:PretenureSizeThreshold&#x3D;3145728 表示对象大于3145728（3M）时直接进入老年代分配，这里只能以字节作为单位 （19）-XX:MaxTenuringThreshold&#x3D;1 表示对象年龄大于1，自动进入老年代,如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代被回收的概率。 （20）-XX:CompileThreshold&#x3D;1000 表示一个方法被调用1000次之后，会被认为是热点代码，并触发即时编译 （21）-XX:+PrintHeapAtGC 表示可以看到每次GC前后堆内存布局 （22）-XX:+PrintTLAB 表示可以看到TLAB的使用情况 （23）-XX:+UseSpining 开启自旋锁 （24）-XX:PreBlockSpin 更改自旋锁的自旋次数，使用这个参数必须先开启自旋锁 （25）-XX:+UseSerialGC 表示使用jvm的串行垃圾回收机制，该机制适用于丹cpu的环境下 （26）-XX:+UseParallelGC 表示使用jvm的并行垃圾回收机制，该机制适合用于多cpu机制，同时对响应时间无强硬要求的环境下，使用-XX:ParallelGCThreads&#x3D;设置并行垃圾回收的线程数，此值可以设置与机器处理器数量相等。 （27）-XX:+UseParallelOldGC 表示年老代使用并行的垃圾回收机制 （28）-XX:+UseConcMarkSweepGC 表示使用并发模式的垃圾回收机制，该模式适用于对响应时间要求高，具有多cpu的环境下 （29）-XX:MaxGCPauseMillis&#x3D;100 设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 （30）-XX:+UseAdaptiveSizePolicy 设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等，此值建议使用并行收集器时，一直打开 说一下jvm有哪些垃圾回收器 先图解虚拟机所包含的收集器： 图中展示了7种作用于不同分代的收集器，3个属于年轻代、3个属于年老代，G1属于横跨年轻代和年老代的算法。 新生代收集器：Serial、ParNew、Parallel Scavenge 老年代收集器：CMS、Serial Old、Parallel Old 整堆收集器： G1 几个相关概念： 并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。 并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。 吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )）。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99% Serial 收集器Serial收集器是最基本的、发展历史最悠久的收集器。 特点：单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。 应用场景：适用于Client模式下的虚拟机。 Serial &#x2F; Serial Old收集器运行示意图 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。 除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。 特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 和Serial收集器一样存在Stop The World问题 应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。 ParNew&#x2F;Serial Old组合收集器运行示意图如下： Parallel Scavenge 收集器与吞吐量关系密切，故也称为吞吐量优先收集器。 特点：属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。 该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别） GC自适应调节策略：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。 Parallel Scavenge收集器使用两个参数控制吞吐量： XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间 XX:GCRatio 直接设置吞吐量的大小。 Serial Old 收集器Serial Old是Serial收集器的老年代版本。 特点：同样是单线程收集器，采用标记-整理算法。 应用场景：主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。 Server模式下主要的两大用途（在后续中详细讲解···）： 在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。 作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。 Serial &#x2F; Serial Old收集器工作过程图（Serial收集器图示相同）： Parallel Old 收集器是Parallel Scavenge收集器的老年代版本。 特点：多线程，采用标记-整理算法。 应用场景：注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器。 Parallel Scavenge&#x2F;Parallel Old收集器工作过程图： CMS收集器一种以获取最短回收停顿时间为目标的收集器。 特点：基于标记-清除算法实现。并发收集、低停顿。 应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b&#x2F;s服务。 CMS收集器的运行过程分为下列4步： 初始标记：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。 并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。 并发清除：对标记的对象进行清除回收。 CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS收集器的工作过程图： CMS收集器的缺点： 对CPU资源非常敏感。 无法处理浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。 因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。 G1收集器一款面向服务端应用的垃圾收集器。 特点如下： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。 分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。 可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。 G1为什么能建立可预测的停顿时间模型？ 因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这样就保证了在有限的时间内可以获取尽可能高的收集效率。 G1与其他收集器的区别： 其他收集器的工作范围是整个新生代或者老年代、G1收集器的工作范围是整个Java堆。在使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region）。虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。 G1收集器存在的问题： Region不可能是孤立的，分配在Region中的对象可以与Java堆中的任意对象发生引用关系。在采用可达性分析算法来判断对象是否存活时，得扫描整个Java堆才能保证准确性。其他收集器也存在这种问题（G1更加突出而已）。会导致Minor GC效率下降。 G1收集器是如何解决上述问题的？ 采用Remembered Set来避免整堆扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否处于多个Region中（即检查老年代中是否引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆进行扫描也不会有遗漏。 如果不计算维护 Remembered Set 的操作，G1收集器大致可分为如下步骤： 初始标记：仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。） 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行） 最终标记：为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set Logs里面，把Remembered Set Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。） 筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行） G1收集器运行示意图： 什么是GC？为什么要有GC？GC（Garbage Collection）是垃圾收集的意思，负责清除对象并释放内存。Java 提供的 GC 功能可以自动检测对象是否超过作用域从而达到自动回收内存的目的，从而防止内存泄漏。 讲一下java内存模型 在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。 而在当前的 Java 内存模型下，线程可以把变量保存本地内存比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。 Java中有哪几种引用？它们的含义和区别是什么？从JDK1.2开始，Java中的引用类型分为四种，分别是： ①强引用（StrongReference）②软引用（SoftRefernce）③弱引用（WeakReference）④虚引用（PhantomReference） 强引用-StrongReference这种引用是平时开发中最常用的，例如String strong &#x3D; new String(‘Strong Reference’)，当一个实例对象具有强引用时，垃圾回收器不会回收该对象，当内存不足时，宁愿抛出OutOfMemeryError异常也不会通过回收强引用的对象，因为JVM认为强引用的对象是用户正在使用的对象，它无法分辨出到底该回收哪个，强行回收有可能导致系统严重错误。 软引用-SoftReference如果一个对象只有软引用，那么只有当内存不足时，JVM才会去回收该对象，其他情况不会回收。软引用可以结合ReferenceQueue来使用，当由于系统内存不足，导致软引用的对象被回收了，JVM会把这个软引用加入到与之相关联的ReferenceQueue中。 当系统内存不足时，触发gc，这个Book就会被回收，reference 将不为null。 弱引用-WeakReference只有弱引用的对象，当JVM触发gc时，就会回收该对象。与软引用不同的是，不管是否内存不足，弱引用都会被回收。弱引用可以结合ReferenceQueue来使用，当由于系统触发gc，导致软引用的对象被回收了，JVM会把这个弱引用加入到与之相关联的ReferenceQueue中，不过由于垃圾收集器线程的优先级很低，所以弱引用不一定会被很快回收。下面通过一个主动触发gc的例子来验证此结论。 当然这不是每次都能复现，因为我们调用System.gc()只是告诉JVM该回收垃圾了，但是它什么时候做还是不一定的，但就我测试来看，只要多写几次System.gc()，复现的概率还是很高的。 虚引用-PhantomReference如果一个对象只有虚引用在引用它，垃圾回收器是可以在任意时候对其进行回收的，虚引用主要用来跟踪对象被垃圾回收器回收的活动，当被回收时，JVM会把这个弱引用加入到与之相关联的ReferenceQueue中。与软引用和弱引用不同的是，虚引用必须有一个与之关联的ReferenceQueue，通过phantomReference.get()得到的值为null 什么是双亲委派模式 双亲委派模型要求除顶层启动类加载器外其余类加载器都应该有自己的父类加载器；类加载器之间通过复用关系来复用父加载器的代码。 双亲委派模型工作工程：1.当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。2.当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。3.如果Bootstrap ClassLoader加载失败(在、lib中未找到所需类)，就会让Extension ClassLoader尝试加载。4.如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。5.如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。6.如果均加载失败，就会抛出ClassNotFoundException异常。 双亲委派模型的实现过程： 实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass()方法中： 首先会检查请求加载的类是否已经被加载过； 若没有被加载过： 递归调用父类加载器的loadClass(); 父类加载器为空后就使用启动类加载器加载； 如果父类加载器和启动类加载器均无法加载请求，则调用自身的加载功能。 双亲委派模型的优点： Java类伴随其类加载器具备了带有优先级的层次关系，确保了在各种加载环境的加载顺序。保证了运行的安全性，防止不可信类扮演可信任的类","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"集合面试题","slug":"集合面试题","date":"2023-09-18T04:58:37.000Z","updated":"2023-09-18T05:12:27.180Z","comments":true,"path":"2023/09/18/集合面试题/","link":"","permalink":"http://example.com/2023/09/18/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"List、Set和Map之间的区别是什么？ List 是可重复有序集合，Set 是不可重复无序集合，这两个接口都实现了 Collection 父接口。 Map 未继承 Collection，而是独立的接口，Map 是一种把键对象和值对象进行映射的集合，它的每一个元素都包含了一对键对象和值对象，Map 中存储的数据是没有顺序的， 其 key 是不能重复的，它的值是可以有重复的。 List 的实现类有 ArrayList，Vector 和 LinkedList： ArrayList 和 Vector 内部是线性动态数组结构，在查询效率上会高很多，Vector 是线程安全的，相比 ArrayList 线程不安全的，性能会稍慢一些。 LinkedList：是双向链表的数据结构存储数据，在做查询时会按照序号索引数据进行前向或后向遍历，查询效率偏低，但插入数据时只需要记录本项的前后项即可，所以插入速度较快。 Set 的实现类有 HashSet 和 TreeSet； HashSet：内部是由哈希表（实际上是一个 HashMap 实例）支持的。它不保证 set 元素的迭代顺序。 TreeSet：TreeSet 使用元素的自然顺序对元素进行排序，或者根据创建 Set 时提供的 Comparator 进行排序。 Map 接口有三个实现类：Hashtable，HashMap，TreeMap，LinkedHashMap； Hashtable：内部存储的键值对是无序的是按照哈希算法进行排序，与 HashMap 最大的区别就是线程安全。键或者值不能为 null，为 null 就会抛出空指针异常。 TreeMap：基于红黑树 (red-black tree) 数据结构实现，按 key 排序，默认的排序方式是升序。 LinkedHashMap：有序的 Map 集合实现类，相当于一个栈，先 put 进去的最后出来，先进后出。 List 和 Map 区别？ 一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List 中存储的数据是有顺序，并且允许重复；Map 中存储的数据是没有顺序的，其 key 是不能重复的，它的值是可以有重复的。 ArrayList 和 LinkedList有何区别 ArrayList 是基于动态数组的数据结构，LinkedList 是基于链表的数据结构； 对于查询和修改操作，ArrayList 较优 ; 对于新增和删除操作 add 和 remove，LinedList 较优 数组和ArrayList有何区别？ 简单理解ArrayList是一种可以自动扩充的数组 数组类型的变量在声明的同时必须进行实例化(至少得初始化数组的大小)，而ArrayList可以只是先声明。 数组对象的初始化必须只定指定大小，且创建后的数组大小是固定的， 而ArrayList的大小可以动态指定，其大小可以在初始化时指定，也可以不指定，也就是说该对象的空间可以任意增加。 数组只能存储同构的对象，而ArrayList可以存储异构的对象。 数组不能够随意添加和删除其中的项，而ArrayList可以在任意位置插入和删除项。 阐述ArrayList、Vector、LinkedList的存储性能和特性。 ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以查询数据快而插入数据慢 Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的历史集合类。 LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 List和Set集合的区别 相同点: List接口和Set接口都是Collection接口的子接口 不同点: 内容是否有序 list是一个有序集合，保持了每个元素的插入顺序,即输出顺序就是输入顺序;而set方法是无序集合，无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序 内容是否重复 list方法可以允许重复的对象 ; 而set方法不允许重复对象 内容是否可null list可以插入多个null元素；而set只允许插入一个null元素 实现类不一样 list方法常用的实现类有ArrayList、LinkedList 和 Vector。其中ArrayList 最为流行，它提供了使用索引的随意访问，而LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适，Vector 表示底层数组，线程安全 Set方法中最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和compareTo() 的定义进行排序的有序容器 List、Set、Map是否继承自Collection接口 List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 List、Set、Map三个接口存取元素时，各有什么特点？ List以特定索引来存取元素，可以有重复元素。 Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。 Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。 Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 遍历Map的方式 keys values entryset ArrayList初始化大小 ，扩容https://www.cnblogs.com/zeroingToOne/p/9522814.html 在JDK1.8中，如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容。 执行add(E e)方法时，先判断ArrayList当前容量是否满足size+1的容量；在判断是否满足size+1的容量时，先判断ArrayList是否为空，若为空，则先初始化ArrayList初始容量为10，再判断初始容量是否满足最低容量要求；若不为空，则直接判断当前容量是否满足最低容量要求；若满足最低容量要求，则直接添加；若不满足，则先扩容，再添加。 ArrayList的最大容量为Integer.MAX_VALUE 说一下HashSet的实现原理？ HashSet中存储内容不可重复且无序，这是因为HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT &#x3D; new Object(); 相关HashSet的操作，基本上都是直接调用底层HashMap的键操作 说一下HashMap底层执行原理HashMap的数据结构首先有一个数组，如果hashMap不进行扩容的话默认是16个长度的数组，如果有hash冲突的话会使用单向链表来解决冲突。 HashMap的存储结构 数组、链表、红黑树（jdk1.8） HashMap中不单单只有数组结构，还有链表、红黑树 HashMap的特点 快速存储（put） 快速查找（时间复杂度O(1)）（get） 可伸缩（数组可以变长；单向链表长度超过8以后可以变成红黑树） Hash算法（HashMap的核心）要了解HashMap底层执行原理必须了解HashMap的核心–hash算法 Hash算法 所有的Java对象（Object.hashCode可以得到一个hash值）都有hashCode(hashMap中使用对象的hashCode 去计算hash值) 具体的hash值的计算方法：（hashCode）^(hashCode&gt;&gt;&gt;16) 这样算可以确保得出的数足够的随机、分散（算数组下标的时候要使用这个hash值，hash值足够的随机、分 散才能保证算出的数组下标的值足够的分散）。 数组下标计算 hashMap底层是数组组成的，数组的默认大小是16，数组的下标是如何计算的呢 使用2.1计算出来的hash值再进行运算计算出来的：hash%16 HashMap中算下标的方式：hash&amp;(16-1) 这样的效率会更高 Hash冲突 原因：不同的对象计算出来数组下标是相同的 单向链表：用于解决Hash冲突的方案，加入一个next记录下一个节点。如果链表非常长的话，效率是非常低的，所以在jdk1.8之后采用了红黑树。 HashMap扩容 HashMap底层是用数组存储数据的，数组存储的话不可能所有的数组存满16以后就变成链表，上面说了链表过长会影响效率，链表只是为了解决冲突准备的。 数组扩容的原理：存储量达到75% （一个数组有16个长度，75%大概就是12个长度）就对数组进行扩容，由于计算机里都是二进制的，所以扩容的标准是最好是变长2倍。75%是基于时间与空间的考虑，如果扩容比例设得很小，例如是50%,那么有一半的空间是浪费的，如果比例设置得很高，例如是90%，当发生hash冲突的时候很难去触发这个条件。 红黑树 红黑树是一种二叉树，有着高效的检索效率 触发条件：在链表的长度大于8的时候，将后面的数据存在红黑树中 。当链表的长度小于6的时候，又会把红黑树转化成链表 Hashtable和ConCurrenthashMap如何实现线程安全？ 在平时开发过程中为了提高性能或业务解耦，会引入多线程，同时在开发web应用的时候，每个web容器在处理用户请求的时候会把用户的请求放到线程里面去执行，这就意味着即使我们不主动的去使用多线程，在实际运行的过程中，我们的程序还是处在一个多线程的环境。如果不做任何的同步控制，我们的代码在多线程环境下是不安全的。 由此及彼，我们看看HashMap的源码，观察一下它是否是线程安全的。 观察我们最常用的get和put方法，它们并没有做同步的控制，所以HashMap在多线程环境中是线程不安全的。 在jdk里，java为我们提供了一个线程安全的Map，就是所谓的HashTable。我们可以观察一下HashTable的 源码，可以发现它的get和put方法都使用了内置锁进行同步控制，HashTable在所有真正和数据交互的方法 上面都加了Synchronized。 那么既然有了一个线程安全的Map，为什么Jdk的并发包中还会有一个ConcurrentHashMap呢？ 从HashTable的源码中我们了解到，不管是读（get）还是写（put）,所有的这些方法都使用了synchronized 关键字修饰，那么在多线程环境下，这样的效率是非常低下的，而ConcurrentHashMap针对这个问题而提 出的。 ConcurrentHashMap是如何在保证性能的情况下来实现线程的安全呢？这就要了解ConcurrentHashMap的 内部实现了 ConcurrentHashMap内部实现 HashMap中都有所谓Hash的说法，那么Hash到底是什么意思呢？ 假如现在有1000个元素，我们要把这1000个元素放到100个桶里面，这个过程就是所谓的Hash过程，我们可以通过取余来决定哪个元素放在哪个桶，如下图我们给100个桶标上下标，从1~100。元素1%100 &#x3D; 1，所以元素1就放在第1个桶。这就是Hash的基本思想。按照上面的取余过程，1和101都会放在第1个桶中，对于HashMap来说，会把1和101以链表的形式挂载第1个桶上，每个桶都有单独的一个锁（ConcurrentHashMap中分段锁的概念）。 分段锁在jdk1.7和jdk1.8的实现有所不同。 在jdk1.7及以前的实现里，把上面说的100个桶分为N个段，每个段里面有自己独立的一个锁。而jdk1.8及以后则是每个桶有自己独立的锁。总的来说就是jdk1.8之后的锁的粒度更细一些。 hashMap 和hashTable的区别相同点： ​ 两者都实现了 Map 接口 不同点: HashMap 允许空键值，Hashtable 键和值不允许空； HashMap 继承自 AbstractMap，Hashtable 继承自 Dictionary 类； HashMap 的方法不是同步的，Hashtable 的方法是同步的。 如何决定使用HashMap还是TreeMap？ HashMap：基于哈希表实现，使用HashMap要求添加的键明确定义了hasCode（）和equals（），为了优化hashMap空间的使用，可以调优初始容量和负载因子。hashmap适用于在map中插入，删除和定位元素。hashmap的结果是没有排序的的。 TreeMap：基于红黑树实现，TreeMap没有调优选项，该树总是处于平衡状态。treemap适用于按自然顺序或自定义顺序遍历键（key），TreeMap实现SortMap接口，能够把保存的额近路根据键排序，默认是按键值的升序排序，也可以指定排序的比较器。 TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。 TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。 Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持） 迭代器iterator是什么？ 为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator). 对 Collection 进行迭代的类，称其为迭代器。还是面向对象的思想，专业对象做专业的事情，迭代器就是专门取出集合元素的对象。但是该对象比较特殊，不能直接创建对象（通过new），该对象是以内部类的形式存在于每个集合类的内部。 如何获取迭代器？Collection接口中定义了获取集合类迭代器的方法（iterator（）），所以所有的Collection体系集合都可以获取自身的迭代器。 Iterable 正是由于每一个容器都有取出元素的功能。这些功能定义都一样，只不过实现的具体方式不同（因为每一个容器的数据结构不一样）所以对共性的取出功能进行了抽取，从而出现了Iterator接口。而每一个容器都在其内部对该接口进行了内部类的实现。也就是将取出方式的细节进行封装。 使用Iterator的简单例子 Iterator怎么使用？有什么特点？ Java中使用Iterator来遍历集合元素，Iterator遍历集合元素有以下几个特点: Iterator遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出ConcurrentModificationEception的异常。 Iterator遍历集合元素的过程中可以通过remove方法来移除集合中的元素。 Iterator必须依附某个Collection对象而存在，Iterator本身不具有装载数据对象的功能。 Iterator.remove方法删除的是上一次Iterator.next()方法返回的对象。 强调以下next（）方法，该方法通过游标指向的形式返回Iterator下一个元素。 Iterator的常用方法: boolean hasNext() ;判断迭代器中是否还有下一个元素，有则返回true Object next(); 返回迭代器中下一个元素 void remove() ; 删除集合里上一个next方法调用的时候返回的对象元素 void forEachRemaining(Consumer action) ;使用Lambdda表达式的形式输出Iterator中所以的元素。注意该方法其实是间接调用next()方法进行遍历，所以再次是next（）方法的时候Iterator中的对象已经被遍历完了。 Iterator和ListIterator之间有什么区别？ Iterator 用来遍历 Set 和 List 集合，而 ListIterator 只能遍历 List； Iterator 只可以向前遍历，而 LIstIterator 可以双向遍历； ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。 Collection和Collections有什么区别？ Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 sort( ) synchronizedCollection( ) synchronizedList( ) synchronizedSet( ) synchronizedMap( ) 53. 怎么确保一个集合不能被修改？我们很容易想到用final关键字进行修饰，我们都知道 final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的。 那么，我们怎么确保一个集合不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。 那我们应该怎么做才能确保集合不被修改呢？我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。 同理：Collections包也提供了对list和set集合的方法。Collections.unmodifiableList(List)Collections.unmodifiableSet(Set) 哪些集合类是线程安全的一、概念： 线程安全：就是当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染的情况。 线程不安全：就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染的情况。 对于线程不安全的问题，一般会使用synchronized关键字加锁同步控制。 线程安全工作原理： jvm中有一个main memory对象，每一个线程也有自己的working memory，一个线程对于一个变量variable进行操作的时候， 都需要在自己的working memory里创建一个copy,操作完之后再写入main memory。 当多个线程操作同一个变量variable，就可能出现不可预知的结果。 而用synchronized的关键是建立一个监控monitor，这个monitor可以是要修改的变量，也可以是其他自己认为合适的对象(方法)，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完加载load到working memory 到 use &amp;&amp; 指派assign 到 存储store 再到 main memory的过程。才会释放它得到的锁。这样就实现了所谓的线程安全。 二、线程安全(Thread-safe)的集合对象： Vector 线程安全： HashTable 线程安全： Concurrenthashmap线程安全(分段锁) 三、非线程安全的集合对象： ArrayList ： LinkedList： HashMap： HashSet： TreeMap： TreeSet：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"java基础","slug":"java基础","date":"2023-09-18T02:36:14.000Z","updated":"2023-09-18T02:38:07.719Z","comments":true,"path":"2023/09/18/java基础/","link":"","permalink":"http://example.com/2023/09/18/java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTML: 表单元素: input, textarea, select, checkbox, radio. 块状元素和行内元素的特点. 图片的属性：src, alt. 链接的属性：href, target. 路径问题：相对路径和绝对路径. 文件上传时form的注意事项：action, method=&quot;post&quot;, enctype=&quot;multipart/form-data&quot;. CSS: 选择器：id, 类, 标签（元素）, 属性, 子孙，子，兄弟，相邻兄弟，伪类，伪元素. display, float, 清除浮动（clear）. position：static, relative, absolute, fixed. 盒子模型（box model）. border-style, border-radius. JavaScript (JS): 弱类型，可以多次声明，赋不同类型的值. var, const, let. break, continue, return. 循环标签 tag: for() &#123; for () &#123; break tag; &#125; &#125;. 输出到控制台：console.log(&quot;aa&quot;);. DOM操作：创建元素，删除节点，事件处理，事件委托. BOM操作：alert(), prompt, confirm, 定时器（setInterval, setTimeout）. 对象创建：let a = &#123;&#125;. 原型链 (prototype). 闭包. ES6的语法，包括箭头函数，模板字符串，解构等. 异步操作：Promise对象，async和await. 模块化：export, import from. 改变上下文（this）：apply, bind, call. 函数中的arguments和callee（不常用）. Java: Java的发展史，JVM的特点，JDK, JRE, JVM之间的关系. 常见运算符：++, --, +=, &amp;, &amp;&amp;, |, ||, ^, instanceof. 基本数据类型和类型转换的示例. switch语句的使用. 数组的创建，扩容，排序和查找. 基本数据类型：byte, short, int, long, float, double, char, boolean. 面向对象编程的三个特点：封装，继承，多态. 访问修饰符：private, default, protected, public. static关键字，final关键字，abstract关键字. 抽象类，接口，内部类的概念. 常用的包装类：Integer, Character. 字符串 (String) 的常见方法和比较. Comparable和Comparator的使用. 替换文件名的示例.","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Java面试题(一)","slug":"Java面试题-一","date":"2023-09-14T11:05:39.000Z","updated":"2023-09-18T04:57:05.264Z","comments":true,"path":"2023/09/14/Java面试题-一/","link":"","permalink":"http://example.com/2023/09/14/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%80/","excerpt":"","text":"String s &#x3D; new String(“xyz”);创建了几个字符串对象？两个对象，一个是静态区的“xyz”，一个是用new创建的对象 String是最基本的数据类型吗？ 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean； 除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。 两个对象值相同（x.equals(y)&#x3D;&#x3D;true），但却可有不同的hashcode，这句话对不对？不对，如果两个对象x和y满足x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的： 如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同； 如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 java中如何实现序列化，有什么意义？ 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。 构造方法有哪些特性？ 特征 没有返回类型 方法名与类名一致 作用 创建对象 实例化一个类，首先调用类的对应的构造方法。当类中没有任意构造方法，JVM会自动创建空的构造方法(空参和空实现)。一但类的有了任意的构造方法，则JVM不会再自动的创建任意形式的构造方法。 初始成员变量 其它 构造方法调用时也要保证参数的类型、个数和顺序要一致 构行方法也可以有方法重载 Anonymous Inner Class(匿名内部类)是否可以继承其他类？是否可以实现接口？可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。 什么是方法的返回值？返回值在类的方法里的作用是什么？方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用：接收出接货，使得它可以作用于其他的操作！ 面向对象三大特征 封装 : 安全性 体现:把属性私有化，通过公共的get&#x2F;set或is&#x2F;set进行公开出去，以后通过方法对属性进行操作。这样做的好处，是在方法中可以对属性的安全性和有效性作出验证。 继承 : 重用性、扩展性 满足is a的关系 用到extends关键字 子类能继承父类中非私有的属性和方法 方法重写 @Override 使用super关键字 this: 代表当前类的对象 super: 代表当前类的父类对象 在java中的类是单继承 任何类的祖类都是Object，可以省略 extends Object 多态性：维护性、扩展性 口诀: 父类引用指向父类实例，只能调用父类的属性和方法 子类引用指向子类实例，可以调用父类中非私有的属性和方法 父类引用指向子类实例，只能调用父类的属性和方法，但是方法被子类重写，以子类的实现为准。 开闭原则 对扩展开放 对修改关闭 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？帮助子类做初始化工作 switch是否能作用在byte上，是否能作用在long上，是否能作用在String上 在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。 从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型 从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 用最有效率的方法算出2乘以8等于几？12 &lt;&lt; 3 因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是 2 &lt;&lt; 3。 访问修改符的理解 java中共有四个修饰符 private 同一个类 default 同一个包 protected 同一个包+不同包子类 public 所有包 注:访问修饰符最低原则，为了安全性 类有两个 public 所有类 default 同一个包 方法和属性有四个 private 同一个类 default 同一个包 protected 同一个包+不同包子类 public 所有包 Object类中常用的方法 Object clone() : 克隆。protected它r指的是在同一个包，或不同包子类中能访问 boolean equals(Object) : 地址相等 void finalize() : 垃圾回收器调用此方法来回收对象所占空间。protected Class getClass() ：得到Class对象 int hasCode() :对象的哈希码。同个对象的哈唏码一致。 String toString() ：把对象用字符串输。一般我们自定义的类都会重写此方法。 void wait() ：线程所用方法，后面讲 void notify() ：线程所用方法，后面讲 void notifyAll() ：线程所用方法，后面讲 方法重写的特性 父子类 方法名相同，参数列表相同 子类的访问修饰符&gt;&#x3D;父类 子类返回类型&lt;&#x3D;父类（&lt;&#x3D;指是父子类） 子类抛的异常&lt;&#x3D;父类（&lt;&#x3D;指是父子类） 方法重载的特性 在同一个类下 方法名一样 参数的类型、个数和‘顺序’至少有一个不一样 重载和重写的区别 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 值传递与引用区别 值传递: 参数的类型为值类型时，则为值传递。值传递，传递的是值复本。 引用传递: 参数的类型为引用类型时，则为引用传递。引用传递，传递的是引用的复本。 两者区别: 值传递，在方法里改变值，之前的值不会改变 引用传递，在方法里改变值，之前的值会发生改变。但String、StringBufferer、StringBuilder和枚举除外。 String、StringBuffer和StringBuilder区别String 是不能改变自身， StringBuffer和StringBuilder是改变自身 StringBuffer是线程安全的，相对而言性能较差，StringBuilder是线和不安全的，相对而言性能较好 成员变量与局部变量的区别有哪些？ 从语法形式上看: 成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数； 成员变量可以被 public,protected,default,private, static和final 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），而局部变量则不会自动赋值。 抽象类与接口有什么区别 相同点: 都可以有静态常量 都可以有抽象方法 都不能被实例化 区别点: 抽象类中有属性、实现的方法、抽象方法等，但接口中只公共静态常量、公共抽象方法 抽象类中的访问修饰符有四种，但接口中只有public访问修饰符 子类单继承抽象类，子类多实现接口，接口多继承接口 抽象类中包含构造方法，接口没有构造方法 使用时机 当所有方法都不知道如何实现时，用接口。一般用标准的制订（方法功能描述） 当有些方法知道如何实现，有些不知道时，使用抽象。 示例 数据访问实现 使用接口制订数据访问方法的标签 使用抽象类 实现接口，实现其中公共代码。（已知如何实现），未知实现（不清楚具体数据）写成抽象方法。 使用MySQL数据类 继承 抽象类，实现抽象方法。（已知用MySQL数据库实例 ） 使用Oralce数据类 继承 抽象类，实现抽象方法。（已知用Oralce数据库实例 ） 队列和栈是什么？有什么区别？ 队列（Queue）：是限定只能在表的一端进行插入和另一端删除操作的线性表 栈（Stack）：是限定之能在表的一端进行插入和删除操作的线性表 队列和栈的规则 ： 队列：先进先出 栈：先进后出 队列和栈的遍历数据速度 ： 队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快 栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，遍历数据时需要微数据开辟临时空间，保持数据在遍历前的一致性 Java有没有goto？goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 是否可以从一个static方法内部发出对非static方法的调用 ？不能直接调用 ，但可以通类的对象进行调用 类中的静态方法和静态变量，也称类方法和类变量 静态方法中只能直接调用静态方法和静态变量，如果要调用非静态的内容，必须通过实例.方法()或实例.变量的方式 去进行调用 java中的final关键字有哪些用法？修饰类：表示该类不能被继承； 修饰方法：表示方法不能被重写； 修饰变量：表示变量只能一次赋值以后值不能被修改（常量） final，finally和finalize的区别？ final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。 finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句： 1final StringBuffer a=new StringBuffer(&#x27;immutable&#x27;); 执行如下语句将报告编译期错误： 1a=new StringBuffer(&#x27;&#x27;); 但是，执行如下语句则可以通过编译： 1a.append(&#x27; broken!&#x27;); 抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 异常该如何处理 try : 存放可能出现异常的代码块，一但在此代码块中有了异常，则立即到跳转到catch中，并把对应异常对象传递给Catch中的形参，如果赋值不对应，则仍然处理不了 不能单独使用 catch ：捕获处理 不能单独使用 与try匹配catch可以有多个，分别捕获处理不同的异常，范围大异常一定要后面 当所有catch中的类型都不能匹配时，则相当于catch捕获处理不，仍然终止程序 finally ：最终地无论如何也要执行的代码，一般用于资源的释放。比如，文件的关闭，数据库连接关闭 不能单独使用 try-catch try-catch-catch try-finally 这种情况要注意，如果没catch，则在try中有了异常，相当于没有处理，程序程序会终止，只不过会执行finally中的语句，一般不省略catch throw : 抛的是一个对象 ，放置在方法里边 一般有了throw，要加上throws throw是抛给上一级处理，上一级指的是谁调用谁处理 上一级可以选择try-catch掉，也可以选择继续抛，如果到了main仍然继续抛出，则相当于抛了JVM，且等于没有处理异常，程序终止，所以一般到main必须处理掉。 throws : 抛的是异常类型，放置方法后面，可以有多个 异常分类和常见异常 运行时异常 ： 都是RuntimeException的子类 ArithmeticException ArrayIndexOutofBoundsException NullPointerException 非运行时异常（编译时异常）: 都是Exception的子类 ParseException IOException ClassNotFoundException 运行异常与非运行时异常有何异同？ 运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。 受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。 错误与异常的区别 Object Throwable Error Exception Error类: 一般指的是硬件问题，跟程序员无关，比如说硬盘空间不足，内容不够 Exception类: 一般指提程序员不小心造成的，有可能在某些时候出现（偶现），或都每次都出现（必须），这些异常本可以避免的。例如：算术异常、空指针异常和下标越界异常等 注: 我们只关心异常，所以以后我提到异常也好，错误也罢，全指异常。 Exception是所有异常类的祖类 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？创建类的对象+初始化成员变量 可以执行，因为一个类即使没有声明构造方法 JVM会自动创建的空参参数的构造方法。 静态方法和实例方法有何不同 在外部调用静态方法时，可以使用’类名.方法名’的方式，也可以使用’对象名.方法名’的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问直接实例成员变量和和实例方法；实例方法可以直接文章实例方法和实例变量，也可以访问静态方法 请手写一下冒泡排序【插入】，接着再用递归的方式写一遍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) &#123;// 12,45,9,67,455,用冒泡排序实现升序排列。 int[] arr = &#123; 12, 45, 9, 67, 455 &#125;; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println(&quot;排序后：&quot;); for (int i = 0; i &lt; arr.length; i++) System.out.print(arr[i] + &quot;\\t&quot;); //创建一个数组用于排序 int[]arr2=&#123;1,4,3,2,6,12,10&#125;; //调用递归的冒泡 arr2=recursiveBubble(arr2,arr2.length); for(int i=0;i&lt;arr2.length;i++)&#123; System.out.print(arr2[i]); &#125; &#125;//冒泡排序之递归方法public static int[] recursiveBubble(int[] arr2,int e)&#123; if(e==0)&#123; return arr2; &#125; else&#123; for(int i=0;i&lt;e-1;i++)&#123; int temp=0; if(arr2[i]&gt;arr2[i+1])&#123; temp=arr2[i]; arr2[i]=arr2[i+1]; arr2[i+1]=temp; &#125; &#125; e--; //System.out.println(e); recursiveBubble(arr2,e); &#125; return arr2;&#125; 静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同?Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。 Math.round(11.5)等于多少？Math.round(-11.5)等于多少？Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。 阐述静态变量和实例变量的区别。 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝； 实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 请讲讲冒泡排序、快速排序、插入排序 这两种排序的原理冒泡排序原理：1，比较相邻的元素。如果第一个比第二个大，就交换他们两个。2，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3，针对所有的元素重复以上的步骤，除了最后一个。4，持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 快速排序原理：1，先定义两个指针，一个在最前面，一个在最后面，第一次要对数组进行划分，先找出一个中间数，2，一般默认把第一个数作为中间数，然后从后往前找比中间数小的，把他放在前一个指针的位置，3，在从前往后找比中间数大的，找到后把它放在第二个指针的位置，直到前面和后面的指针指向同一个位置，4，我们就把中间值放在这里即可，这样根据中间数，把整个需要排序的数组分为两部分，5，前一部分都小于中间数，后一部分都大于中间数，此时这两部分的数还是无序的，最后递归调用排序方法，对两部分分别进行排序即可。 插入排序原理： 说说你对多态的理解 现象： 调用同一个类型对象的同一个方法，会出现不同的结果 实现多态的三个条件： 1）要有继承； 2）要有方法重写； 3）要有父类指针（引用）指向子类对象。 多态的原理： 动态连编，根据实际对象的类型来判断重写方法的调用。多态的原理：动态连编，根据实际对象的类型来判断重写方法的调用 写clone方法时，通常都有一行代码，是什么？clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。 Java中是如何支持正则表达式操作的？Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。 Java序列化中如果有写字段不想进行序列化，怎么办？对于不想进行序列化的变量，使用transient关键字修饰。transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。 构造器（constructor）是否可被重写（override）构造器不能被继承，因此不能被重写，但可以被重载。 65. int和Integer的区别？ java是一个的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 自动装箱与拆箱装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； &#x3D;&#x3D;与equals的区别？ &#x3D;&#x3D; 值类型：判断是值是否相等 引用类型：判断是引用地址是否相等 equals() 是Object中的方法，表示地址是否相等 但String 中的 equals 方法是被重写过的，它表示的是值相等 构造方法调用顺序实例化一个子类首先会调用父类中的空的构造方法，再调用子类中对应的构造方法 除非在子类构造方法的第一行有super(xxx)，则调用父类对应构造方法。 一般在子类构造方法的第一行即为super()，默认是可以省略的，所以推荐在父类一般保留一个空的构造方法 java和 javaX有什么区别刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。所以，实际上java和javax没有区别。这都是一个名字 &amp;和&amp;&amp;的区别 &amp;按位与；&amp;&amp;逻辑与。 &amp;非短信与; &amp;&amp;运算符是短路与运算 逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。 &amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;， 例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(‘’)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。 注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 说一下类加载的执行过程java程序在执行过程中，类，对象以及它们成员加载、初始化的顺序如下： 首先加载父类。 对静态成员进行加载，主要包括静态成员变量的初始化，静态语句块的执行，在加载时按代码的先后顺序进行。 加载非静态的成员，主要包括非静态成员变量的初始化，非静态语句块的执行，在加载时按代码的先后顺序进行。 最后执行构造器，构造器执行完毕，对象生成。 java中实现多态的机制是什么靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 是否可以继承string类String 类是final类，不可以被继承。 数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？ 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； 一种方法是将基本数据类型与空字符串（’’）连接（+）即可获得其所对应的字符串； 另一种方法是调用String 类中的valueOf()方法返回相应字符串 接口是否可以继承（extends）接口，抽象类是否可以实现(implements)接口,抽象类是否可以继承具体类(concrete class)? 接口可以继承接口，而且支持多重继承。 抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员 简述一下你了解的设计模式？ 所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式， 包括： Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式），Chain Of Responsibility（责任链模式）。面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I&#x2F;O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 什么是单例模式？实现步骤？单例模式分为： 懒汉式：用的时候，才去创建对象（不会出现线程问题的单例模式） 饿汉式：类一加载就创建对象（可能会线程问题的单例模式） 饿汉代码 外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。 123456789 public class SingletonClass &#123; private static SingletonClass instance = new SingletonClass(); public static SingletonClass getInstance() &#123; return instance; &#125; private SingletonClass() &#123; &#125; &#125; 懒汉代码 上面的代码虽然简单，但无论这个类是否被使用，都会创建一个instance对象 123456789101112public class SingletonClass &#123; private static SingletonClass instance = null; public static SingletonClass getInstance() &#123; if(instance == null) &#123; instance = new SingletonClass(); &#125; return instance; &#125; private SingletonClass() &#123; &#125; &#125; 上述代码会有线程安全的问题 12345678910111213141516public class SingletonClass &#123; private static SingletonClass instance = null; public synchronized static SingletonClass getInstance() &#123; if(instance == null) &#123; instance = new SingletonClass(); &#125; return instance; &#125; private SingletonClass() &#123; &#125; &#125; 性能调优一下,double-check 123456789101112131415public class SingletonClass &#123; private static SingletonClass instance = null; public static SingletonClass getInstance() &#123; if (instance == null) &#123; synchronized (SingletonClass.class) &#123; if (instance == null) &#123; instance = new SingletonClass(); &#125; &#125; &#125; return instance; &#125; private SingletonClass() &#123; &#125; &#125; 创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JMM规范并没有规定。 线程1开始创建SingletonClass的实例，此时线程B调用了getInstance()方法，首先判断instance是否为null。按照我们上面所说的内存模型，1已经把instance指向了那块内存，只是还没有调用构造方法，因此2检测到instance不为null，于是直接把instance返回了——问题出现了，尽管instance不为null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还是毛坯房 只要我们简单的把instance加上volatile关键字就可以了。volatile在Java并发编程中常用于保持内存可见性和防止指令重排序 123456789101112131415public class SingletonClass &#123; private volatile static SingletonClass instance = null; public static SingletonClass getInstance() &#123; if (instance == null) &#123; synchronized (SingletonClass.class) &#123; if(instance == null) &#123; instance = new SingletonClass(); &#125; &#125; &#125; return instance; &#125; private SingletonClass() &#123; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"区块链基础知识","slug":"区块链基础知识","date":"2023-09-14T03:38:17.000Z","updated":"2023-09-14T03:40:11.743Z","comments":true,"path":"2023/09/14/区块链基础知识/","link":"","permalink":"http://example.com/2023/09/14/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"区块链与隐私保护技术：构建安全可信的去中心化世界随着数字化时代的不断发展，个人数据的保护和隐私成为了一个极其重要的议题。同时，区块链技术的兴起也引发了人们对隐私保护的新思考。本文将探讨区块链与隐私保护的关系，以及当前正在发展的技术和方法，以确保在去中心化世界中维护个人数据的安全和隐私。 区块链基础知识在深入讨论区块链与隐私保护的关系之前，我们需要先了解一些区块链的基础知识。 区块链是什么？ 区块链是一种去中心化的分布式账本技术，最初用于支持加密货币比特币。它是一个由多个区块组成的链式结构，每个区块包含一组交易记录。这些区块按照时间顺序连接在一起，并且通过密码学技术保护其完整性和安全性。 区块链的关键特性 区块链的关键特性包括： 去中心化：没有中央权威机构控制区块链，而是由网络中的多个节点共同维护和验证交易。 不可篡改性：一旦数据被添加到区块链，几乎不可能修改或删除。 透明性：区块链上的所有交易都是公开可见的，任何人都可以查看。 安全性：区块链使用密码学技术来保护数据的机密性和完整性。 区块链与隐私保护的挑战 尽管区块链具有许多优点，但它也带来了一些隐私保护的挑战。其中一些挑战包括： 交易透明性：区块链上的所有交易都是公开的，这意味着交易的参与者和交易金额都可以被追踪。 无法删除数据：一旦数据上链，就很难删除或修改，这可能会导致个人敏感信息的永久性泄露。 链外数据：虽然区块链上的交易数据是公开的，但与之相关的链外数据（如身份信息）可能不受同样的保护，容易被恶意利用。 隐私保护技术为了解决区块链上的隐私保护问题，许多技术和方法已经被提出和发展。以下是一些常见的隐私保护技术： 零知识证明（Zero-Knowledge Proofs） 零知识证明是一种密码学技术，允许一个人向另一方证明他们知道某些信息，而不必透露这些信息的内容。这在区块链上的隐私保护中非常有用。通过零知识证明，用户可以验证自己的交易有效性，而无需公开其交易详细信息。zk-SNARKs（零知识可验证的非交互式参数）是一种常见的零知识证明机制，用于保护以太坊等区块链的隐私。 链上混币技术 链上混币技术允许用户将他们的加密货币与其他用户的加密货币混合在一起，以增加交易的隐私性。这使得很难追踪特定的加密货币流动路径。CoinJoin和Confidential Transactions是两个常见的链上混币技术。 侧链和二层解决方案 侧链和二层解决方案是构建在主区块链之上的附加层，它们可以提供更高级的隐私保护。例如，Lightning Network是比特币的二层解决方案，允许快速且低成本的交易，同时减少了主区块链上的交易记录。 匿名性币种 一些加密货币专注于提供更强的隐私保护。例如，Monero和Zcash都使用不同的隐私技术来确保交易的完全匿名性。这些币种的交易数据被设计成不可追踪和不可链接。 多方计算（Multi-Party Computation） 多方计算是一种协议，允许多个参与者在不透露私有数据的情况下进行计算。这可以用于在区块链上进行私有智能合约的执行，而不泄露相关数据。 去中心化身份验证 去中心化身份验证技术允许用户在区块链上验证其身份，同时控制其个人数据。用户可以选择性地透露身份信息，以确保他们的隐私得到保护。 这些技术共同构建了区块链生态系统，使其成为一个安全、可信、去中心化的基础设施，可用于各种应用程序，从加密货币到供应链管理和智能合约。区块链技术的不断发展和创新将继续推动数字经济的进步。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Excel导入导出","slug":"Excel导入导出","date":"2023-09-14T03:30:44.000Z","updated":"2023-09-14T03:33:10.361Z","comments":true,"path":"2023/09/14/Excel导入导出/","link":"","permalink":"http://example.com/2023/09/14/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"Excel导入导出1. 简介1.1 实现方式 Apache POI POI（Poor Obfuscation Implementation）是Apache提供的操作ms office文档的API，主要针对excel进行操作。 官网 https://poi.apache.org Apache维护 EasyPOI easypoi功能如同名字easy，主打的功能就是容易，让一个没见接触过poi的人员就可以方便的写出Excel导出、Excel导入。 通过简单的注解和模板语言(熟悉的表达式语法)，完成以前复杂的写法。 官网 http://doc.wupaas.com/docs/easypoi 个人维护 EasyExcel EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。 他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。 官网 https://easyexcel.opensource.alibaba.com 阿里维护 1.2 Excel简介excel的基础元素： 工作簿 workbook 就是一个文件 工作表 sheet 属于工作簿 行 row 属于工作表 单元格 cell 属于行，如C2，表示第二行第三列 2. 用法2.1 Apache POI步骤： 添加依赖 123456&lt;!--poi--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;5.2.3&lt;/version&gt;&lt;/dependency&gt; 基本用法 12345678910111213141516171819202122232425262728293031@Testpublic void write() throws Exception &#123; // 1、创建工作簿 Workbook workbook = new HSSFWorkbook(); // 2、创建工作表 Sheet sheet = workbook.createSheet(&quot;wanho&quot;);// 指定工作表名 // 3、创建行 Row row = sheet.createRow(2); // 创建第3行，索引从0开始 // 4、创建单元格 Cell cell = row.createCell(2); // 创建第3行第3列 cell.setCellValue(&quot;南京万和&quot;); // 设置单元格内容 // 5.输出到硬盘 workbook.write(new FileOutputStream(&quot;/Users/txy/Desktop/test.xls&quot;)); System.out.println(&quot;写入成功！&quot;); workbook.close();&#125;@Testpublic void read() throws Exception &#123; // 1、读取工作簿 Workbook workbook = new HSSFWorkbook(new FileInputStream(&quot;/Users/txy/Desktop/test.xls&quot;)); // 2、读取工作表 Sheet sheet = workbook.getSheet(&quot;wanho&quot;); // 根据名称读取工作表 // Sheet sheet = workbook.getSheetAt(0); //根据索引读取工作表，索引从0开始 // 3、读取行 Row row = sheet.getRow(2); // 读取第3行 // 4、读取单元格 Cell cell = row.getCell(2); // 读取第3行第3列 System.out.println(&quot;第3行第3列内容为：&quot; + cell.getStringCellValue()); workbook.close();&#125; 2.2 EasyPOI步骤： 添加依赖 123456&lt;!--easypoi--&gt;&lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt; 基本用法 @Excel 标注在属性上，对Excel列进行描述 工具类： ExcelExportUtil 导出Excel ExcelImportUtil 导入Excel 2.3 EasyExcel步骤： 添加依赖 123456&lt;!--easyexcel--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt; 基本用法 常用注解 @ExcelProperty 标注在属性上，对Excel列进行描述 @ColumnWidth 标注在类和属性上，设置列宽 @ContentStyle 标注在类上，设置内容样式 @HeadFontStyle 标注在类上，设置表头样式 @DateTimeFormat 标注在属性上，设置日期的格式 ….. 工具类： EasyExcel.write() 导出Excel EasyExcel.read() 导入Excel","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"SQL语句中不同类型的join的区别","slug":"SQL语句中不同类型的join的区别","date":"2023-09-03T15:34:05.000Z","updated":"2023-09-03T15:35:49.225Z","comments":true,"path":"2023/09/03/SQL语句中不同类型的join的区别/","link":"","permalink":"http://example.com/2023/09/03/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84join%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"sql之left join、right join、inner join的区别left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录inner join(等值连接) 只返回两个表中联结字段相等的行 举例如下：表A记录如下：aID aNum1 a200501112 a200501123 a200501134 a200501145 a20050115 表B记录如下:bID bName1 20060324012 20060324023 20060324034 20060324048 2006032408 1.left joinsql语句如下:select * from Aleft join Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 20060324045 a20050115 NULL NULL （所影响的行数为 5 行）结果说明:left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID &#x3D; B.bID).B表记录不足的地方均为NULL.2.right joinsql语句如下:select * from Aright join Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404NULL NULL 8 2006032408 （所影响的行数为 5 行）结果说明:仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.3.inner joinsql语句如下:select * from Ainnerjoin Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404 结果说明: 很明显,这里只显示出了 A.aID &#x3D; B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Spring常用注解","slug":"Spring常用注解","date":"2023-08-29T00:52:13.000Z","updated":"2023-09-25T11:36:32.428Z","comments":true,"path":"2023/08/29/Spring常用注解/","link":"","permalink":"http://example.com/2023/08/29/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"@Param@Param()注解，标注在参数前，为参数指定占位符名称 1public User selectByUsernameAndPassword(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); @Component 及@Repository、@Service、@Controller@Component 定义组件Bean，添加到IoC容器中，不区分组件类型区分组件类型的注解：@Repository 表示Dao组件@Service 表示Service组件@Controller 表示Controller组件 @RequestMapping：@RequestMapping： @ResponseBody@ResponseBody：将方法返回值写到响应体中，一般用来处理Ajax请求，返回JSON数据也可以使用@RestController，相当于@Controller+@ResponseBody注意：ResponseBody与RequestBody区别 @RequiredArgsConstructor：该注解作用于类上 标记为final的对象,会自动进行注入 使用lombok的 @NonNull 注解标记的对象,会自动进行注入 @Resource：@Resource和@Autowired注解都是用来实现依赖注入的。只是@AutoWried按by type自动注入，而@Resource默认按byName自动注入。 @Resource有两个重要属性，分别是name和type @Json衍生@JsonFormat指定序列化和反序列化时的格式，一般用于指定日期、时间和数字的格式@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”,timezone &#x3D; “GMT+8”)，设置响应时的日期格式 @JsonProperty指定序列化和反序列化时的名称 @JsonAlias指定反序列化时的备用别名 @JsonIgnore指定序列化和反序列化时忽略属性 参数来源注解@RequestParam表示参数来源于请求参数，默认为所有参数添加该注解，参数值来源于同名称的请求参数 @PathVariable表示参数来源于URL（URL就是请求路径） @PathVariable：spring3.0的一个新功能：接收请求路径中占位符的值 @PathVariable(“xxx”) 通过 @PathVariable 可以将URL中占位符参数{xxx}绑定到处理器类的方法形参中@PathVariable(“xxx“)@RequestMapping(value&#x3D;”user&#x2F;{id}&#x2F;{name}”)请求路径：http://localhost:8080/hello/show5/1/james @RequestHeader表示参数来源于请求头 @CookieValue表示参数来源于Cookie @RequestBody表示参数来源于请求体，用来接收前端传递给后端的 json 格式的数据 @RequestMapping及其衍生变体@RequestMapping表示共享映射,用于将任意HTTP 请求映射到控制器方法上。如果没有指定请求方式，将接收GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT所有的HTTP请求方式。@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping 都是HTTP方法特有的快捷方式@RequestMapping的变体，分别对应具体的HTTP请求方式的映射注解。 @Transactional@Transactional也可以配置在类上，如果方法上没有配置@Transactional，则使用类上的事务配置 使用@Transactional 注解管理事务的实现步骤分为两步。 第一步，在 xml 配置文件中添加如清单 1 的事务配置信息。除了用配置文件的方式，@EnableTransactionManagement 注解也可以启用事务管理功能。这里以简单的 DataSourceTransactionManager 为例。 第二步，将@Transactional 注解添加到合适的方法上，并设置合适的属性信息。 SpringBoot@SpringBootApplication标注在类上，表示这是一个SpringBoot应用，通过运行该类的main方法来启动SpringBoot应用 @SpringBootConfiguration标注在类上，表示这个类是SpringBoot的配置类 层级关系：@SpringBootConfiguration——&gt;@Configuration——&gt;@Component @Configuration标注在类上，表示这个类是Spring的配置类，相当于是一个xml配置文件 @EnableAutoConfiguration开启自动配置功能，SpringBoot会自动完成许多配置，简化了以前繁琐的配置 @ComponentScan标注在类上，指定要扫描的包，默认只扫描主程序类所在的包及其子包 可以使用@ComponentScan手动指定要扫描的包 @MapperScan：指定Dao接口所在的包API：@Api标注在类上，对类进行说明 @ApiOperation标注在方法上，对方法进行说明 @ApiParam标注在参数上，对方法的参数进行说明 @ApiModel标注在模型Model上，对模型进行说明 @ApiModelProperty标注在属性上，对模型的属性进行说明 @ApiIgnore标注在类或方法上，表示忽略这个类或方法 Mybatis注解：@Insert、@Update、@Delete、@Select这四个注解分别代表将会被执行的 SQL 语句。它们用字符串数组（或单个字符串）作为参数。如果传递的是字符串数组，字符串之间先会被填充一个空格再连接成单个完整的字符串。这有效避免了以 Java 代码构建 SQL 语句时的“丢失空格”的问题。然而，你也可以提前手动连接好字符串。属性有：value，填入的值是用来组成单个 SQL 语句的字符串数组。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Shiro学习","slug":"Shiro学习","date":"2023-08-24T03:15:48.000Z","updated":"2023-08-25T08:34:55.874Z","comments":true,"path":"2023/08/24/Shiro学习/","link":"","permalink":"http://example.com/2023/08/24/Shiro%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Shiro简介1. Shiro是什么？Apache Shiro是一个强大且易用的开源Java安全框架，执行身份认证、授权、密码学和会话管理等 Spring Security也是一个开源的权限管理框架，Spring Security 和 Shiro 的比较如下： Spring Security 是一个重量级的安全管理框架； Shiro 则是一个轻量级的安全管理框架 Spring Security 概念复杂，配置繁琐； Shiro 概念简单、配置简单 Spring Security 功能强大； Shiro 功能简单，但在一般的 SSM 项目中也够用了 Spring Security 依赖于Spring运行； Shiro则相对独立 Spring Security 一般与 Spring Boot&#x2F;Spring Cloud 项目组合使用； Shiro 一般与 SSM 项目结合使用 虽然在 Spring Boot 项目中一般使用 Spring Security ，但也可以使用 Shiro 2. 基本功能​ 身份认证、授权、加密、会话管理 ​ Web支持、缓存、多线程、测试、允许一个用户假装为另一个用户的身份进行访问、记住我 ​ ​ 3. 单词​ authentication [ɔ:ˌθentɪ’keɪʃn] 认证、身份验证 ​ authorization [ˌɔ:θəraɪˈzeɪʃn] 授权 ​ cryptography [krɪpˈtɒgrəfi] 密码学 ​ subject [ˈsʌbdʒɪkt] 主题、学科、主体 ​ token [ˈtəʊkən] 令牌 ​ strategy [ˈstrætədʒi] 策略 ​ realm 领域、范围 ​ principal [ˈprɪnsəpl] 当事人、用户 ​ credentials [krəˈdenʃlz] 凭证 二、身份认证1. 认证流程图​ 2. 执行过程分为五步： Subject 用户主体：请求的发起者，即访问应用的用户 Security Manager 安全管理器：Shiro的核心，用来分发请求，对Shiro中的其他对象进行管理 Authenticator 认证器：用来进行认证操作 Authentication Strategy 认证策略 ：对于多个realm，可以对认证realm的个数进行配置 三种认证策略：AtLeastOneSuccessfulStrategy、FirstSuccessfulStrategy、AllSuccessfulStrategy Realm 安全数据源：用来进行数据匹配的，可以通过多种数据源进行匹配认证，如文件、数据库、QQ、微信、手机号等 3. url过滤场景：有些url的访问需要登录才能访问，如后台管理界面，未登录时不允许访问，自动跳转到登录页面 解决：使用Shiro过滤器，配置url过滤规则 常用的过滤规则： anon 表示url不需要验证 authc 表示url需要登录验证，如果未登录，默认跳转到&#x2F;login.jsp，参考FormAuthenticationFilter类 roles 表示url需要角色验证 perms 表示url需要权限验证 ​ 注：默认所有url都不需要验证，相当于是anon 三、SpringBoot整合Shiro 1. 搭建项目环境步骤： 创建一个springboot工程，选择以下模块：Web、Lombok、DevTools 添加依赖 12345&lt;!--jsp--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml 12345678910server: port: 8080 servlet: context-path: /shirospring: mvc: view: prefix: / suffix: .jsp 创建前端页面 ​ 在webapp文件夹中创建index.jsp和login.jsp index.jsp 12345678910111213141516171819202122&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--受限资源--%&gt; &lt;h1&gt;系统主页&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;用户管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;订单管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;物流管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; login.jsp 12345678910111213141516171819&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;登录界面&lt;/h1&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 配置SpringBoot，兼容JSP 测试 访问 http://localhost:8080/shiro/login.jsp 、 http://localhost:8080/shiro/index.jsp 2. 整合Shiro步骤： 添加依赖 123456&lt;!--shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt; 自定义Realm 123456789101112131415161718192021/** * 自定义Realm，继承AuthorizingRealm */public class ShiroRealm extends AuthorizingRealm &#123; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; return null; &#125;&#125; 创建配置类ShiroConfig 123456789101112131415161718192021222324252627282930313233343536373839404142@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/index.jsp&quot;, &quot;authc&quot;);// 表示这个资源需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); return realm; &#125;&#125; 测试 ​ 访问 http://localhost:8080/shiro/index.jsp，发现会自动跳转到login.jsp，因为这个资源需要登录认证 3. 认证和退出步骤： 在index.jsp添加欢迎信息和退出 12欢迎您：&lt;shiro:principal/&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;退出登录&lt;/a&gt; 编写UserController 1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/login&quot;) public String login(String username, String password) &#123; // 获取主体对象 Subject subject = SecurityUtils.getSubject(); try &#123; subject.login(new UsernamePasswordToken(username,password)); return &quot;index&quot;; &#125; catch (UnknownAccountException e) &#123; e.printStackTrace(); System.out.println(&quot;用户不存在！&quot;); &#125; catch (IncorrectCredentialsException e) &#123; e.printStackTrace(); System.out.println(&quot;密码错误！&quot;); &#125; catch (AuthenticationException e)&#123; e.printStackTrace(); System.out.println(&quot;认证失败！&quot;); &#125; return &quot;redirect:/login.jsp&quot;; &#125; @RequestMapping(&quot;logout&quot;) public String logout() &#123; Subject subject = SecurityUtils.getSubject(); subject.logout(); return &quot;redirect:/login.jsp&quot;; &#125;&#125; 修改自定义的ShiroRealm 123456789101112131415161718192021222324public class ShiroRealm extends AuthorizingRealm &#123; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 if (!&quot;admin&quot;.equals(username)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，然后交由凭证匹配器（CredentialsMatcher）进行凭证的判断，默认是对密码进行判断 return new SimpleAuthenticationInfo(username,&quot;123&quot;,this.getName()); // 参数：用户信息、密码、realm名称 &#125;&#125; 修改配置类ShiroConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/user/login&quot;,&quot;anon&quot;);// 表示这个为公共资源，一定是在受限资源上面 map.put(&quot;/**&quot;,&quot;authc&quot;);//表示这个为受限资源，需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); return realm; &#125;&#125; 测试 登录和退出的功能正常 未登录时不能访问index.jsp 4. 加密的认证通常需要对密码进行加密，常用的散列算法有md5、sha等，都是非对称的算法 对于普通的散列加密，如果知道加密后的值，可以通过穷举算法，暴力破解出对应的明文 所以建议进行散列加密时可以添加salt（盐），相当于对原始密码+盐进行散列加密，盐值一般放在数据库中 同时可以配置散列次数，次数一般放在配置文件中 步骤： 创建数据库 12345678910drop database if exists shiro;create database shiro charset utf8;use shiro; create table t_user ( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(40) comment &#x27;用户名&#x27;, password varchar(40) comment &#x27;密码&#x27;, salt varchar(255) comment &#x27;盐值&#x27;) engine=innodb default charset=utf8 comment &#x27;用户表&#x27;; 添加依赖 1234567891011121314151617&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920server: port: 8080 servlet: context-path: /shirospring: mvc: view: prefix: / suffix: .jsp datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/shiro?useUnicode=true&amp;characterEncoding=utf8 username: root password: rootmybatis: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml 创建注册页面register.jsp 12345678910111213141516171819&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;注册界面&lt;/h1&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/register&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;立即注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建Entity、Mapper、Service、Controller 修改自定义的ShiroRealm 123456789101112131415161718192021222324252627282930313233public class ShiroRealm extends AuthorizingRealm &#123; @Autowired private UserService userService; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 User user = userService.findByUsername(username); if (ObjectUtils.isEmpty(user)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，交由AuthenticatingRealm进行密码匹配（使用密码匹配器CredentialsMatcher） return new SimpleAuthenticationInfo( user.getUsername(), // 用户信息 user.getPassword(), // 密码 ByteSource.Util.bytes(user.getSalt()), // salt盐值 this.getName()); //realm名称 &#125;&#125; 修改配置类ShiroConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/user/login&quot;,&quot;anon&quot;);// 表示这个为公共资源，一定是在受限资源上面 map.put(&quot;/user/register&quot;,&quot;anon&quot;); map.put(&quot;/register.jsp&quot;,&quot;anon&quot;); map.put(&quot;/**&quot;,&quot;authc&quot;);//表示这个为受限资源，需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); // 创建密码匹配器，支持散列算法 HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(); credentialsMatcher.setHashAlgorithmName(&quot;md5&quot;); // 设置加密算法 credentialsMatcher.setHashIterations(1024); // 设置散列次数 // 设置密码匹配器 realm.setCredentialsMatcher(credentialsMatcher); return realm; &#125;&#125; 测试 ​ 注册和登录的功能正常 五、授权1. 简介授权也称为访问控制，控制用户对资源的访问 权限：增删改查 CRUD 角色：权限的集合，如系统管理员、老师、学生 2. 授权流程图​ 执行过程，分为4步： Subject 发送请求，对角色和权限进行判断 hasRole()、isPermitted() SecurityManager 接收Subject的请求 Authorizer 授权器 Realm 查询角色和权限信息 3. 基本用法步骤： 创建数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455drop database if exists shiro;create database shiro charset utf8;use shiro; create table t_user ( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(40) comment &#x27;用户名&#x27;, password varchar(40) comment &#x27;密码&#x27;, salt varchar(255) comment &#x27;盐值&#x27;) engine=innodb default charset=utf8 comment &#x27;用户表&#x27;;create table t_role ( id int not null primary key auto_increment, name varchar(60) default null) engine=innodb default charset=utf8 comment &#x27;角色表&#x27;;create table t_perms ( id int not null primary key auto_increment, name varchar(80) default null, url varchar(255) default null) engine=innodb default charset=utf8 comment &#x27;权限表&#x27;;create table t_user_role ( id int not null primary key auto_increment, userid int default null, roleid int default null) engine=innodb default charset=utf8 comment &#x27;用户角色表&#x27;;create table t_role_perms ( id int not null primary key auto_increment, roleid int default null, permsid int default null) engine=innodb default charset=utf8 comment &#x27;角色权限表&#x27;;insert into t_user values (null, &#x27;aaa&#x27;, &#x27;37c80a50a975580fb2fb287bee20a04a&#x27;, &#x27;K2*LWFB#&#x27;); -- 密码为123insert into t_user values (null, &#x27;bbb&#x27;, &#x27;93a2dc457a2f9c50fa0a9f2b9de9f456&#x27;, &#x27;DwOkv&amp;WW&#x27;); -- 密码为123insert into t_user values (null, &#x27;ccc&#x27;, &#x27;37c80a50a975580fb2fb287bee20a04a&#x27;, &#x27;K2*LWFB#&#x27;); -- 密码为123insert into t_role values (null, &#x27;admin&#x27;);insert into t_role values (null, &#x27;user&#x27;);insert into t_role values (null, &#x27;stu&#x27;);insert into t_perms values (null, &#x27;admin:*:*&#x27;, null);insert into t_perms values (null, &#x27;user:*:*&#x27;, null);insert into t_perms values (null, &#x27;user:find:*&#x27;, null);insert into t_user_role values (null, 1, 1);insert into t_user_role values (null, 1, 2);insert into t_user_role values (null, 2, 2);insert into t_user_role values (null, 3, 3);insert into t_role_perms values (null, 1, 1);insert into t_role_perms values (null, 2, 2);insert into t_role_perms values (null, 2, 3);insert into t_role_perms values (null, 3, 3); 创建Entity、Mapper、Service 修改自定义的ShiroRealm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ShiroRealm extends AuthorizingRealm &#123; @Resource private UserService userService; @Resource private PermsService permsService; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = (String) principalCollection.getPrimaryPrincipal(); // 获取角色信息 User user = userService.findRolesByUsername(username); List&lt;String&gt; roles = user.getRoles().stream().map(Role::getName).collect(Collectors.toList()); // 获取权限信息 List&lt;String&gt; perms = user.getRoles().stream().flatMap(role -&gt; &#123; List&lt;Perms&gt; list = permsService.findPermsByRoleId(role.getId()); return list.stream().map(Perms::getName); &#125;).collect(Collectors.toList()); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addRoles(roles); info.addStringPermissions(perms); System.out.println(roles); System.out.println(perms); return info; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 User user = userService.findByUsername(username); if (ObjectUtils.isEmpty(user)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，然后交由凭证匹配器（CredentialsMatcher）进行凭证的判断，默认是对密码进行判断 return new SimpleAuthenticationInfo( user.getUsername(), // 用户信息 user.getPassword(), // 密码 ByteSource.Util.bytes(user.getSalt()), // salt盐值 this.getName()); //realm名称 &#125;&#125; 测试 ​ 不同用户由于角色和权限的不同，登录后看到的系统主页是不一样的！ 六、JWT1. 简介 JWT（JSON Web Token）是目前最流行的跨域认证解决方案。 传统的认证流程，使用session： 12345671、用户向服务器发送用户名和密码2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等3、服务器向用户返回一个 session_id，写入用户的 Cookie4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份存在的问题：扩展性差、服务器内存占用较高 JWT的认证流程，使用token： 123451、用户向服务器发送用户名和密码2、服务器验证通过后，会生成一个token（JWT），表示用户的身份3、服务器向用户返回该token，客户端存储token，可以存储在Cookie、localStorage或sessionStorage中4、用户随后的每一次请求，都要带上这个token，一般放请求头中携带5、服务器收到token并验证是否有效，由此得知用户的身份。 2. JWT原理JWT 原理：服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 12345&#123; &quot;姓名&quot;: &quot;张三&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2023年6月12日0点0分&quot;&#125; 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。 为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 优点： 服务器不再保存任何 session 数据，服务器变成无状态了 由客户端保存身份信息，即JWT令牌 token，一般存储在客户端的localStorage中 客户端每次请求时，JWT令牌随着请求头一起提交 3. JWT数据结构实际的 JWT 大概就像下面这样。 它是一个很长的字符串，中间用点.分隔成三个部分。 JWT的三个部分如下： Header（头部） Payload（载荷） Signature（签名） 3.1 头部（Header）Header 部分是一个 JSON 对象，用于描述该JWT的基本信息，例如签名所用的算法及令牌的类型等。 1234&#123; &quot;alg&quot;:&quot;HS256&quot;, &quot;typ&quot;:&quot;JWT&quot;&#125; 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；type属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 注： Base64URL 算法和 Base64 算法基本类似，但有一些小的不同，其会将个别特殊符合替换掉。 3.2 载荷（Playload）Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 除了官方字段，你还可以在这个部分自定义私有字段，下面就是一个例子。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 这个 JSON 对象也要使用 Base64URL 算法转成字符串。 1eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 注意：由于Base64URL是对称算法，可以被解密为明文信息，所以一般不建议存放敏感数据。 3.3 签名（Signature）Signature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。 4. 优缺点优点： 因为json的通用性，所以JWT是可以跨语言的 因为有了payload部分，所以JWT可以在自身存储一些其他业务所必要的非敏感信息 便于传输，JWT的构成非常简单，字节占用很小，所以它是非常便于传输的 它不需要在服务端保存会话信息，所以易于扩展，例如集群或微服务环境下。 JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 缺点： JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次 JWT 不加密的情况下，不能将敏感数据写入 JWT。 由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 5. 在Java中使用JWT步骤： 添加依赖 123456&lt;!--java-jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 基本用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class JwtTest &#123; /** * 生成令牌 */ @Test public void generate()&#123; Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;(); payload.put(&quot;id&quot;,1001); payload.put(&quot;name&quot;,&quot;tom&quot;); Calendar c = Calendar.getInstance(); c.add(Calendar.SECOND,30); // JWTCreator.Builder builder = JWT.create(); String token = JWT.create() .withPayload(payload) // 载荷 .withExpiresAt(c.getTime()) // 过期时间 .sign(Algorithm.HMAC256(&quot;secret&quot;)); // 签名：算法和密钥 System.out.println(token); &#125; /** * 校验令牌 * 如果令牌过期，会抛异常TokenExpiredException * 一般会返回boolean，表示校验是否通过 */ @Test public void valid()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; try &#123; JWT.require(Algorithm.HMAC256(&quot;secret&quot;)).build().verify(token); &#125; catch (Exception e) &#123; // 如果令牌过期，会抛异常TokenExpiredException e.printStackTrace(); &#125; &#125; /** * 解析令牌 * 如果令牌过期，会抛异常TokenExpiredException */ @Test public void parse()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; DecodedJWT decodedJWT = JWT.require(Algorithm.HMAC256(&quot;secret&quot;)).build().verify(token); // 获取载荷中的信息 Long id = decodedJWT.getClaim(&quot;id&quot;).asLong(); String name = decodedJWT.getClaim(&quot;name&quot;).asString(); System.out.println(id+&quot;-&quot;+name); &#125; /** * 反码令牌 * 直接获取载荷信息，不会校验是否过期 */ @Test public void decode()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; DecodedJWT decodedJWT = JWT.decode(token); Long id = decodedJWT.getClaim(&quot;id&quot;).asLong(); String name = decodedJWT.getClaim(&quot;name&quot;).asString(); System.out.println(id+&quot;-&quot;+name); &#125;&#125; 七、整合步骤： 创建一个springboot工程，选择以下模块：Web、Lombok、DevTools、Spring Data Redis 添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!--mysql、druid、mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--knife4j--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--java-jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- easy-captcha --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt; &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- hutool --&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.15&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920212223242526272829303132server: port: 8080spring: # DruidDataSource datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/project?useUnicode=true&amp;characterEncoding=utf8 username: root password: root # knife4j mvc: pathmatch: matching-strategy: ant_path_matcher # redis redis: host: localhost port: 6379 database: 0# MyBatismybatis: type-aliases-package: net.wanho.po mapper-locations: classpath:mapper/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl map-underscore-to-camel-case: true# PageHelperpagehelper: helper-dialect: mysql 数据库 123456789101112131415161718192021drop database if exists project;create database project charset utf8;use project;create table user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(50) unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, status tinyint comment &#x27;帐号状态（0正常 1停用）&#x27;) engine innodb default charset utf8 comment &#x27;用户表&#x27;;create table student( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(50) comment &#x27;姓名&#x27;, age int comment &#x27;年龄&#x27;, gender varchar(50) comment &#x27;性别&#x27;, address varchar(50) comment &#x27;地址&#x27;, birth date comment &#x27;生日&#x27;) engine innodb default charset utf8 comment &#x27;学生表&#x27;;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"}]},{"title":"Vue3学习","slug":"Vue3学习","date":"2023-08-22T08:31:19.000Z","updated":"2023-08-23T00:52:03.095Z","comments":true,"path":"2023/08/22/Vue3学习/","link":"","permalink":"http://example.com/2023/08/22/Vue3%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、简介1. 介绍​ Vue 2 将于 2023 年 12 月 31 日停止维护，详见 Vue 2 延长 LTS。 ​ Vue 3是Vue.js的下一个主要版本，最初于2020年9月发布，Vue 3支持Vue 2的大多数特性。 2. 优点 更快更省 Object.defineProperty ——&gt; Proxy 重构 Virtual DOM 运行速度更快，打包体积更小 更好的TypeScript集成 团队开发更轻松 架构更灵活，阅读源码更轻松 可以独立使用Vue内部模块 组合式API（Composition API） 一组低侵入式的、函数式的 API 更好的逻辑复用与代码组织 更好的类型推导 二、创建Vue3项目1. 简介Vue.js官方提供了两种创建Vue 3项目的方式：vue-cli 或 vite 区别如下: 运行方式不同 vue-cli使用Webpack进行项目打包，这意味着启动和打包速度相对较慢 vite使用ES模块系统，利用浏览器原生的模块解析器来运行，启动速度更快，打包速度也更快。 默认配置有区别 vue-cli提供了更多的默认配置和插件，可以帮助开发者更快地创建和部署Vue.js项目 vite则采用更加精简的配置和插件，让开发者自由地选择第三方插件和配置模块。 2. 使用 viteVite是一种新型前端构建工具，能够显著提升前端开发体验。 特点： 快速的冷启动，不需要等待打包操作 即时的热模块更新，替换性能和模块数量的解耦让更新飞起 真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变 操作步骤： 123456789# 创建项目npm init vue@latest # 基于Vite# 安装依赖cd vue3-projectnpm install# 运行项目npm run dev 三、API 风格Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API 1. 选项式 API (Options API)使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。 选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。 123456789101112131415161718192021222324&lt;script&gt;export default &#123; // data() 返回的属性将会成为响应式的状态，并且暴露在 this 上 data() &#123; return &#123; count: 0 &#125; &#125;, // methods 是一些用来更改状态与触发更新的函数，它们可以在模板中作为事件处理器绑定 methods: &#123; increment() &#123; this.count++ &#125; &#125;, // 生命周期钩子会在组件生命周期的各个不同阶段被调用，例如这个函数就会在组件挂载完成后被调用 mounted() &#123; console.log(`The initial count is $&#123;this.count&#125;.`) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 2. 组合式 API (Composition API)通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。 在单文件组件中，组合式 API 通常会与&lt;script setup&gt;搭配使用。这个 setup 属性是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，&lt;script setup&gt; 中的导入和顶层变量&#x2F;函数都能够在模板中直接使用。 下面是使用了组合式 API 与 &lt;script setup&gt; 改造后和上面的模板完全一样的组件： 1234567891011121314151617181920&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 响应式状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() =&gt; &#123; console.log(`The initial count is $&#123;count.value&#125;.`)&#125;)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 四、响应式APIVue 3 提供的一组具有响应式特性的函数式API，都是以函数形式提供的 1. reactivereactive()函数接收一个普通对象，返回该普通对象的响应式代理对象 简单来说，就是用来创建响应式的数据对象 12345678910&lt;script setup&gt; // 导入reactive函数 import &#123; reactive &#125; from &#x27;vue&#x27; // 创建响应式数据对象，是一个代理对象 const user = reactive(&#123; name:&#x27;tom&#x27;, age:18 &#125;)&lt;/script&gt; 2. refref()函数接收一个参数值，返回一个响应式的数据对象。该对象只包含一个指向内部值的 .value 属性 在模板中访问时，无需通过.value属性，它会自动展开 3. toReftoRef()函数用来将 reactive 对象的一个属性创建为一个 ref，并且这个 ref 具有响应性，可以被传递。 4. toRefstoRefs()函数用来将 reactive 对象创建为一个普通对象，但该普通对象的每个属性都是一个 ref，并且这个 ref 具有响应性，可以被传递。 5. computedcomputed() 函数用来创建计算属性，函数的返回值是一个 ref 的实例 6. watchwatch() 函数用来监视数据的变化，从而触发特定的操作 6. watchEffectwatchEffect()函数接收一个函数作为参数，并立即执行该函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。 五、组件间数据传递1. 父子组件父向子传递数据：属性绑定+数据拦截 使用defineProps接收父组件传递的数据 子向父传递数据：事件监听+事件触发 使用defineEmits自定义事件，然后触发事件 注：defineProps 和 defineEmits是自动导入的，不需要手动导入 2. 依赖注入依赖注入就是祖先组件向后代组件传递数据，使用provide() 和 inject() 函数来实现 在祖先组件中使用provide()函数向下传递数据 在后代组件中使用inject()函数获取上层传递过来的数据 六、生命周期钩子函数Vue 3 中的生命周期函数和 Vue 2.x 相比做了一些调整和变化，对应关系如下： beforeCreate -&gt; 使用 setup() created -&gt; 使用 setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured 七、模板 Refs通过 ref()函数还可以引用页面上的元素或组件，功能类似于 vue 2.x中的 vm.$refs 步骤： 创建一个空的 ref 对象并返回它 在页面上为元素添加 ref 属性，并设置属性值与创建的 ref 对象的名称相同 当页面渲染完成后，可以通过该 ref 对象获取到页面中对应的DOM元素 八、Pinia状态管理Pinia（小菠萝）是一个轻量级的、基于Vue 3的状态管理库，提供了更简单的 API，支持Typescript和组合式API风格。 与Vuex相比，Pinia抛弃了Mutation操作，保留state、getters、actions，且提供了更简便的用法。 官网 https://pinia.vuejs.org/zh/ 基本用法，步骤： 定义store 1234567891011121314import &#123; ref, computed &#125; from &#x27;vue&#x27;import &#123; defineStore &#125; from &#x27;pinia&#x27;export const useUser = defineStore(&#x27;user&#x27;, () =&gt; &#123; const msg = ref(&#x27;welcome to pinia&#x27;) const reverseMsg = computed(() =&gt; msg.value.toUpperCase().split(&#x27; &#x27;).reverse().join(&#x27; &#x27;)) function setMsg(newValue) &#123; msg.value = newValue &#125; return &#123; msg, reverseMsg, setMsg &#125;&#125;) 使用store 1234567891011&lt;script setup&gt; import &#123; useUser &#125; from &#x27;@/stores/user&#x27; const user = useUser()&lt;/script&gt;&lt;template&gt; &lt;p&gt;&#123;&#123; user.msg &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; user.reverseMsg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;user.setMsg(&#x27;hello world&#x27;)&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt; 附录：vite常用插件1. unplugin-auto-importunplugin-auto-import 自动导入插件，能够自动引入ref、reavtive等函数，不需要再自己引入 步骤： 安装插件 执行npm install -D unplugin-auto-import 配置插件，编辑vite.config.js 123456789101112131415import AutoImport from &#x27;unplugin-auto-import/vite&#x27;export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; imports:[&#x27;vue&#x27;,&#x27;vue-router&#x27;,&#x27;pinia&#x27;] // 自动导入相关函数 &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 2. vite-plugin-pagesvite-plugin-pages 自动读取指定目录下的文件，生成路由信息，不需要自己去逐个配置路由 步骤： 安装插件 执行npm install -D vite-plugin-pages 配置插件，编辑vite.config.js 123456789101112131415161718192021import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Pages from &#x27;vite-plugin-pages&#x27;export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; imports:[&#x27;vue&#x27;,&#x27;vue-router&#x27;,&#x27;pinia&#x27;] // 自动导入相关函数 &#125;), Pages(&#123; dirs:[ &#123; dir: &quot;src/views&quot;, baseRoute: &quot;&quot; &#125;], // 修改默认文件夹 importMode: &quot;async&quot; &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 自动生成路由，编辑router&#x2F;index.js 12345678import routes from &#x27;~pages&#x27;const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes&#125;)export default router 注意： vite-plugin-pages默认读取的页面文件夹是 pages，默认读取的页面是 index.vue 所以最好先在pages文件夹下面创建一个 index.vue文件","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"JDK8新特性","slug":"JDK8新特性","date":"2023-08-22T08:30:50.000Z","updated":"2023-08-22T08:32:35.087Z","comments":true,"path":"2023/08/22/JDK8新特性/","link":"","permalink":"http://example.com/2023/08/22/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"一、类型推断的改进类型推断(推导) 是 JDK7的特性，JDK8中做了改进。 二、默认方法JDK8 新增了接口的默认方法，默认方法就是一个在接口中有具体实现的方法，即非抽象方法。 定义默认方法时需要使用 default 关键字进行修饰。 也可以定义静态方法，且不需要使用 default 修饰。 三、Lambda表达式Lambda 表达式是一个匿名函数，允许把函数作为一个方法的参数。 Lambda 表达式可以认为是对匿名内部类的一种简化，使代码变的更简洁紧凑。 但并不是所有的匿名内部类都可以简化为Lambda表达式，只有函数式接口的匿名内部类才可以使用Lambda表达式来进行简化 函数式接口：就是接口中只有一个抽象方法，Lambda表达式正好是针对这个唯一的抽象方法使用的 Lambda表达式的语法： 123(parameters) -&gt; expression或(parameters) -&gt; &#123; statement; &#125; 注意: 参数类型是可选的 : 可以省略参数的类型声明，由编译器统一识别，进行类型推断 参数小括号是可选的 : 当方法只有一个参数时，可以省略参数小括号 方法体大括号是可选的: 当方法体只包含一条语句时，可以省略方法体大括号 return关键字是可选的 : 当方法体只包含一条语句，且需要返回该语句的执行结果时，可以省略return 四、方法引用方法引用是一种语法糖操作，作用是简化Lambda在调用已经存在的方法时的表达式。 方法引用可以直接引用已有Java类或对象的方法或构造方法，使用一对冒号 :: 方法引用的几种类型： 静态方法引用（类名::静态方法名） 实例方法引用（对象名::实例方法名） 类的实例方法引用（类名::实例方法名） 构造方法引用（类名::new） 五、函数式接口函数式接口 Functional Interface：就是有且只有一个抽象方法的接口，但可以有多个非抽象方法。 函数式接口（的实现类的对象）可以隐式转换为Lambda表达式，进行简化。 Java 8 提供了一个特殊的注解**@FunctionalInterface**，用于标注一个接口是函数式接口 1234567891011121314151617181920212223242526272829/** * JDK8之前的函数式接口 */java.lang.Runnablejava.lang.Comparable&lt;T&gt;java.util.Comparator&lt;T&gt;java.io.FileFilterjava.io.FilenameFilterjava.lang.reflect.InvocationHandler...... /** * JDK8新增的函数式接口，主要在java.util.function包中 */ // 消费型接口java.util.function.Consumer&lt;T&gt; void accept(T t); // 接收一个参数, 无返回// 供给型接口java.util.function.Supplier&lt;T&gt; T get(); // 无参数, 返回一个结果// 函数型接口java.util.function.Function&lt;T, R&gt; R apply(T t); // 接收一个参数, 返回一个结果// 断言型接口java.util.function.Predicate&lt;T&gt; boolean test(T t); // 接收一个参数, 返回一个布尔值的结果 六、Stream API1. 简介Java 8 API 添加了一个新的抽象称为Stream流，它可以让你以一种声明的方式来处理数据。 Stream主要用于集合操作，支持链式编程，极大的简化了代码。 Stream将要处理的元素集合看作为一种流，数据在流的管道中传输，可以在管道的节点上对元素进行处理，如：筛选、排序、聚合等。 元素流在管道中经过 中间操作 的处理，最后由 终止操作 得到前面处理的结果。 Stream流的操作步骤： 获取Stream对象 中间操作（实现要做的数据处理操作） 终止操作 2. 获取Stream对象三种方式： 通过Collection接口中的stream方法或parallelStream方法获取集合的流 通过Arrays类中的stream方法获取数组的流（串行流） 通过Stream接口中的of方法获取一个或多个元素的流（串行流） 3. 基本使用3.1 Stream特点Stream不会存储元素 Stream不会改变源对象，它会返回一个持有结果的新Stream对象。 Stream中间操作都会返回一个持有结果的新Stream对象，可以对新的Stream继续执行其他的中间操作，这样的多个连续操作，可以串联成一个管道。 Stream的中间操作是延迟执行的，需要执行终止操作，才会真正的执行中间操作。 3.2 惰性求值多个中间操作可以连起来，形成一个流水线。除非流水线上触发了终止操作，否则中间操作不会被执行。 只有当发生终止操作时，才会一次性处理全部的操作，这种情况称为 惰性求值 。 3.3 内部迭代以前对集合遍历都是通过 Iterator 或 For-Each 的方式，这种显式的在集合外部进行迭代的方式称为 外部迭代。 在集合内部进行迭代的方式称为 内部迭代。例如：集合的forEach方法、Stream的操作的forEach方法（是一个终止操作）。 4. 中间操作4.1 筛选与切片filter(Predicate predicate) 从流中获取符合条件的元素 limit(long maxSize) 截断流，使其元素不超过指定数量 skip(long n) 跳过多个元素，返回一个扔掉了 n 个元素的流，如果流中的元素不足 n，则返回一个空的流 distinct() 通过流中的元素的 hashCode和equals方法进行判断是否重复 4.2 映射map(Function&lt;T, R&gt; mapper) 将回调方法的操作应用到每一个元素上，将其映射成一个新的元素。 flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper) 将流中的每一个元素都转换成一个流，然后将所有的流连成一个新的流。 mapToInt(ToIntFunction&lt;T&gt; mapper) 将流中的每一个元素转换成int类型的元素，然后返回包含所有转换后值的流 mapToLong(ToLongFunction&lt;T&gt; mapper) 将流中的每一个元素转换成long类型的元素，然后返回包含所有转换后值的流 mapToDouble(ToDoubleFunction&lt;T&gt; mapper) 将流中的每一个元素转换成double类型的元素，然后返回包含所有转换后值的流 peek(Consumer&lt;? super T&gt; action) 作用与map()类似，但无需返回值，属于消费型接口 4.3 排序sorted() 返回一个新的流，其中元素按照自然顺序升序排序。 sorted(Comparator&lt;T&gt; comparator) 根据比较器指定的排序规则，对流中的元素进行排序。 5. 终止操作5.1 查找与匹配forEach(Consumer c)遍历流中的数据,该方法接收一个Consumer函数式接口，会将每一个流的元素交给函数 allMatch(Predicate&lt;T&gt; predicate) 元素全部满足要求时，才会返回 true，否则返回 false（短路操作） anyMatch(Predicate&lt;T&gt; predicate) 元素只要有一个满足要求，就会返回 true，否则返回 false（短路操作） noneMatch(Predicate&lt;? super T&gt; predicate) 元素全部不满足要求时，才会返回 true，否则返回 false（短路操作） findFirst() 取出流中第一个元素，会把结果封装成 Optional 类型的对象。 findAny() 取出符合要求的一个元素(任意的、只要满足要求即可)。 count() 统计流中的元素个数。 max(Comparator&lt;T&gt; comparator) 找最大的元素。 min(Comparator&lt;T&gt; comparator) 找最小的元素。 5.2 归约归约：将流中的元素反复结合起来，得到一个值。 reduce(BinaryOperator&lt;T&gt; accumulator) 对流中的元素进行累计操作。前一次的操作结果会作为下一次操作的参数，最终返回一个 使用 Optional 封装的累计结果。 reduce(T identity, BinaryOperator&lt;T&gt; accumulator) 对流中的元素进行累计操作。根据初始值 identity 进行累计操作，最终返回一个和流中元素类型一致的结果。 5.3 收集collect(Collector&lt;T, A, R&gt; collector) 收集处理的结果，将流转换成指定集合，一般通过Collectors工具类指定集合类型 七、Optional 类型Optional 是一个容器，可以保存 T 类型的值，或仅仅保存null。 Optional 主要的作用是用来解决空指针异常的。 Optional 提供了很多有用的方法，这样程序员就不用显式进行空值判断了。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Redis学习","slug":"Redis学习","date":"2023-08-21T13:30:53.000Z","updated":"2023-08-22T08:33:47.976Z","comments":true,"path":"2023/08/21/Redis学习/","link":"","permalink":"http://example.com/2023/08/21/Redis%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Redis简介1. 关于NoSQLNoSQL的全称是Not only SQL，意即”不仅仅是SQL”，是一项全新的数据库革命性运动 NoSQL，泛指非关系型的数据库，如Redis、MongoDB和memcached等内存数据库。 产生背景： 海量数据、数据多样化和实时性 高并发、高可扩和高性能 2. Redis是什么Redis是一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求。 Redis数据就是以key-value形式来存储数据： key只能是字符串类型 value可以是以下五种类型：String、List、Set、Sorted-Sets、Hash 3. Redis优势优点： 应用广泛，技术成熟，简单易用 基于内存，高性能（Redis读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s ） 丰富的数据类型 数据持久化 支持主从备份和读写分离 支持集群 4. Redis的应用场景 缓存（数据查询、短连接、菜单内容、新闻内容、商品内容等） 分布式集群架构中的session分离 聊天室的在线好友列表 任务队列（秒杀、抢购、12306等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） 二、安装Redis1. 安装1.1 WindowsRedis程序文件redis-win.zip 解压到无空格无中文目录下 redis-server.exe 启用服务的命令 redis-cli.exe 连接服务端的命令 端口号6379 12345678# 默认连接【本机+6379】redis-cli# 指定连接 -h ip -p 端口redis-cli -h 127.0.0.1 -p 6379# 连接好了，退出exit# 关闭redis服务器redis-cli shutdown 使用图形化客户端工具 Redis Desktop Manager.exe 1.2 Linux​ 步骤： 解压redis-3.2.8.tar.gz 12cd ~/softwaretar -zxf redis-3.2.8.tar.gz 编译 12cd redis-3.2.8make 安装 12mkdir ~/software/redis-binmake install PREFIX=~/software/redis-bin/ #PREFIX选项用来指定安装的位置 启动redis 12345cd ~/software/redis-bin/bin/./redis-server #使用默认配置文件启动，默认配置文件所在目录redis-3.2.8/redis.conf或cp ~/software/redis-3.2.8/redis.conf myredis.conf #复制默认配置文件到当前目录，并改名./redis-server myredis.conf #使用指定的配置文件启动 连接redis 123./redis-cli #默认连接本机的6379端口(redis默认使用的端口号)或./redis-cli -h IP地址 -p 端口号 #连接指定主机、指定端口的redis，如./redis-cli -h localhost -p 6379 测试 12127.0.0.1:6379&gt; set name tom127.0.0.1:6379&gt; get name 关闭 方式1：在服务器窗口中按 Ctrl+C 方式2：在客户端连接后输入 shutdown 或 直接输入 redis-cli shutdown ​ 查看进程 123ps -ef | grep redis #查看redis的进程信息或lsof -i:6379 #查看6379端口的进程信息 2. 配置编辑redis.conf配置文件： 123456789daemonize yes #配置为守护进程，后台启动port 6379 #修改监听端口#让redis支持远程访问，默认只允许本地访问#bind 127.0.0.1 #注释掉该行，允许所有主机访问redisprotected-mode no #关闭保护模式requirepass 123 #配置redis密码，使用时需要输入auth 123进行认证，认证后才能操作redis 三、Redis数据类型1. String类型1.1 简介​ 字符串类型是Redis中最为基础的数据存储类型，它是以二进制形式存储的，这便意味着该类型可以存储任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。 1.2 操作 set&#x2F;get&#x2F;append&#x2F;strlen 12345678910111213141516171819202122$ redis-cli 127.0.0.1:6379&gt; select 0 #切换到第1个数据库（默认共有16个数据库，通过数字来进行命名，索引从0开始）OK127.0.0.1:6379&gt; keys * #显示所有的键key(empty list or set)127.0.0.1:6379&gt; set name tom #设置键OK127.0.0.1:6379&gt; get name #获取键对应的值&quot;tom&quot;127.0.0.1:6379&gt; append mykey &quot;hello&quot; #如果该键不存在，则创建，返回当前value的长度(integer) 5127.0.0.1:6379&gt; append mykey &quot; world&quot; #如果该键已经存在，则追加，返回追加后value的长度(integer) 11127.0.0.1:6379&gt; get mykey #获取mykey的值&quot;hello world&quot;127.0.0.1:6379&gt; strlen mykey #获取mykey的长度(integer) 11#EX和PX表示失效时间，单位为秒和毫秒，两者不能同时使用；NX表示数据库中不存在时才能设置,XX表示存在时才能设置127.0.0.1:6379&gt; set mykey &quot;this is test&quot; EX 5 NX OK127.0.0.1:6379&gt; get mykey&quot;this is test&quot; ​ 注：命令不区分大小写，但key和value区分大小写 incr&#x2F;decr&#x2F;incrby&#x2F;decrby 1234567891011121314151617181920127.0.0.1:6379&gt; flushdb #清空数据库OK127.0.0.1:6379&gt; set mykey 20OK127.0.0.1:6379&gt; incr mykey #递增1(integer) 21127.0.0.1:6379&gt; decr mykey #递减1(integer) 20127.0.0.1:6379&gt; del mykey #删除该键(integer) 1127.0.0.1:6379&gt; decr mykey(integer) -1127.0.0.1:6379&gt; del mykey(integer) 1127.0.0.1:6379&gt; incr mykey(integer) 1127.0.0.1:6379&gt; incrby mykey 5 #递增5，即步长(integer) 15127.0.0.1:6379&gt; decrby mykey 10 #递减10(integer) 5 2. List类型2.1 概述​ 在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。​ 从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。 2.2 操作 lpush&#x2F;lpushx&#x2F;lrange 1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; flushdbOK#创建键mykey及与其关联的List，然后将参数中的values从左到右依次插入127.0.0.1:6379&gt; lpush mykey a b c d(integer) 4#获取从位置0开始到位置2结束的3个元素127.0.0.1:6379&gt; lrange mykey 0 21) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;#获取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;a&quot;#获取从倒数第3个到倒数第2个的元素127.0.0.1:6379&gt; lrange mykey -3 -21) &quot;c&quot;2) &quot;b&quot;#lpushx表示键存在时才能插入，mykey2键此时并不存在，因此该命令将不会进行任何操作，其返回值为0127.0.0.1:6379&gt; lpushx mykey2 e (integer) 0#可以看到mykey2没有关联任何List Value127.0.0.1:6379&gt; lrange mykey2 0 -1(empty list or set)#mykey键此时已经存在，所以该命令插入成功，并返回链表中当前元素的数量127.0.0.1:6379&gt; lpushx mykey e(integer) 5#获取该键的List中的第一个元素127.0.0.1:6379&gt; lrange mykey 0 01) &quot;e&quot; lpop&#x2F;llen 123456789101112127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; lpush mykey a b c d(integer) 4#取出链表头部的元素，该元素在链表中就已经不存在了127.0.0.1:6379&gt; lpop mykey&quot;d&quot;127.0.0.1:6379&gt; lpop mykey&quot;c&quot;#在执行lpop命令两次后，链表头部的两个元素已经被弹出，此时链表中元素的数量是2127.0.0.1:6379&gt; llen mykey(integer) 2 lrem&#x2F;lindex&#x2F;lset&#x2F;ltrim 12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; flushdbOK#准备测试数据127.0.0.1:6379&gt; lpush mykey a b c d a c(integer) 6#从头部(left)向尾部(right)操作链表，删除2个值等于a的元素，返回值为实际删除的数量127.0.0.1:6379&gt; lrem mykey 2 a(integer) 2#查看删除后链表中的全部元素127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;c&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;#获取索引为1(头部的第二个元素)的元素值127.0.0.1:6379&gt; lindex mykey 1&quot;d&quot;#将索引为1(头部的第二个元素)的元素值设置为新值e127.0.0.1:6379&gt; lset mykey 1 eOK#查看是否设置成功127.0.0.1:6379&gt; lindex mykey 1&quot;e&quot;#索引值6超过了链表中元素的数量，该命令返回nil127.0.0.1:6379&gt; lindex mykey 6(nil)#设置的索引值6超过了链表中元素的数量，设置失败，该命令返回错误信息。127.0.0.1:6379&gt; lset mykey 6 h(error) ERR index out of range#仅保留索引值0到2之间的3个元素，注意第0个和第2个元素均被保留。127.0.0.1:6379&gt; ltrim mykey 0 2OK#查看trim后的结果127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;c&quot;2) &quot;e&quot;3) &quot;c&quot; 3. Set类型3.1 概述​ 在Redis中，我们可以将Set类型看作为没有排序的字符集合，也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。Set可包含的最大元素数量是4294967295。​ 和List类型不同的是，Set集合中不允许出现重复的元素，这一点和Java中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions并、intersections交和differences差。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。 3.2 操作 sadd&#x2F;smembers&#x2F;sismember&#x2F;scard 123456789101112131415161718192021222324252627#由于该键myset之前并不存在，因此参数中的三个成员都被正常插入127.0.0.1:6379&gt; sadd myset a b c(integer) 3#查看集合中的元素，从结果可以，输出的顺序和插入顺序无关(无序的)127.0.0.1:6379&gt; smembers myset1) &quot;a&quot;2) &quot;c&quot;3) &quot;b&quot;#由于参数中的a在myset中已经存在，因此本次操作仅仅插入了d和e两个新成员（不允许重复）127.0.0.1:6379&gt; sadd myset a d e(integer) 2#查看插入的结果127.0.0.1:6379&gt; smembers myset1) &quot;a&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;b&quot;5) &quot;e&quot;#判断a是否已经存在，返回值为1表示存在127.0.0.1:6379&gt; sismember myset a(integer) 1#判断f是否已经存在，返回值为0表示不存在127.0.0.1:6379&gt; sismember myset f(integer) 0#获取集合中元素的数量127.0.0.1:6379&gt; scard myset(integer) 5 srandmember&#x2F;spop&#x2F;srem&#x2F;smove 123456789101112131415161718192021222324252627282930313233343536373839127.0.0.1:6379&gt; del myset(integer) 1#准备测试数据127.0.0.1:6379&gt; sadd myset a b c d(integer) 4#查看集合中的元素127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot;4) &quot;b&quot;#随机返回一个成员，成员还在集合中127.0.0.1:6379&gt; srandmember myset&quot;c&quot;#取出一个成员，成员会从集合中删除127.0.0.1:6379&gt; spop myset&quot;b&quot;#查看移出后Set的成员信息127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot;#从Set中移出a、d和f三个成员，其中f并不存在，因此只有a和d两个成员被移出，返回为2127.0.0.1:6379&gt; srem myset a d f(integer) 2#查看移出后的输出结果127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;127.0.0.1:6379&gt; del myset(integer) 1#为后面的smove命令准备数据127.0.0.1:6379&gt; sadd myset a b(integer) 2127.0.0.1:6379&gt; sadd myset2 c d(integer) 2#将a从myset移到myset2，从结果可以看出移动成功127.0.0.1:6379&gt; smove myset myset2 a(integer) 1 3.3 应用范围 可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。 充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。 4. Sorted-Sets类型4.1 概述​ Sorted-Sets和Sets类型极为相似，也称为Zset，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序（默认）。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。​ 在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。 4.2 操作 zadd&#x2F;zrange&#x2F;zcard&#x2F;zrank&#x2F;zcount&#x2F;zrem&#x2F;zscore&#x2F;zincrby 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#添加一个分数为1的成员127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot;(integer) 1#添加两个分数分别是2和3的两个成员127.0.0.1:6379&gt; zadd myzset 2 &quot;two&quot; 3 &quot;three&quot;(integer) 2#通过索引获取元素，0表示第一个成员，-1表示最后一个成员。WITHSCORES选项表示返回的结果中包含每个成员及其分数，否则只返回成员127.0.0.1:6379&gt; zrange myzset 0 -1 WITHSCORES1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;5) &quot;three&quot;6) &quot;3&quot;#获取myzset键中成员的数量 127.0.0.1:6379&gt; zcard myzset(integer) 3#获取成员one在集合中的索引，0表示第一个位置127.0.0.1:6379&gt; zrank myzset one(integer) 0#成员four并不存在，因此返回nil127.0.0.1:6379&gt; zrank myzset four(nil)#获取符合指定条件的成员数量，分数满足表达式1 &lt;= score &lt;= 2的成员的数量127.0.0.1:6379&gt; zcount myzset 1 2(integer) 2#删除成员one和two，返回实际删除成员的数量127.0.0.1:6379&gt; zrem myzset one two(integer) 2#查看是否删除成功127.0.0.1:6379&gt; zcard myzset(integer) 1#获取成员three的分数。返回值是字符串形式127.0.0.1:6379&gt; zscore myzset three&quot;3&quot;#由于成员two已经被删除，所以该命令返回nil127.0.0.1:6379&gt; zscore myzset two(nil)#将成员three的分数增加2，并返回该成员更新后的分数127.0.0.1:6379&gt; zincrby myzset 2 three&quot;5&quot;#将成员three的分数增加-1，并返回该成员更新后的分数127.0.0.1:6379&gt; zincrby myzset -1 three&quot;4&quot;#查看在更新了成员的分数后是否正确127.0.0.1:6379&gt; zrange myzset 0 -1 withscores1) &quot;three&quot;2) &quot;4&quot; zrangebyscore&#x2F;zremrangebyscore&#x2F;zremrangebyrank 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; del myzset(integer) 1127.0.0.1:6379&gt; zadd myzset 1 one 2 two 3 three 4 four(integer) 4#通过分数获取元素，获取分数满足表达式1 &lt;= score &lt;= 2的成员127.0.0.1:6379&gt; zrangebyscore myzset 1 21) &quot;one&quot;2) &quot;two&quot;#-inf表示第一个成员，+inf表示最后一个成员，limit后面的参数用于限制返回成员的数量，#2表示从位置索引(0-based)等于2的成员开始，取后面3个成员，类似于MySQL中的limit127.0.0.1:6379&gt; zrangebyscore myzset -inf +inf withscores limit 2 31) &quot;three&quot;2) &quot;3&quot;3) &quot;four&quot;4) &quot;4&quot;#根据分数删除成员，删除分数满足表达式1 &lt;= score &lt;= 2的成员，并返回实际删除的数量127.0.0.1:6379&gt; zremrangebyscore myzset 1 2(integer) 2#看一下上面的删除是否成功127.0.0.1:6379&gt; zrange myzset 0 -11) &quot;three&quot;2) &quot;four&quot;#根据索引删除成员，删除索引满足表达式0 &lt;= rank &lt;= 1的成员127.0.0.1:6379&gt; zremrangebyrank myzset 0 1(integer) 2#查看上一条命令是否删除成功127.0.0.1:6379&gt; zcard myzset(integer) 0 4.3 应用范围 可以用于大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOP 10的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。 Sorted-Sets类型还可用于构建索引数据。 5. Hash类型5.1 概述 可以将Redis中的Hash类型看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。 5.2 操作 hset&#x2F;hget&#x2F;hlen&#x2F;hexists&#x2F;hdel&#x2F;hsetnx 12345678910111213141516171819202122232425262728293031#给键值为myhash的键设置字段为field1，值为itany127.0.0.1:6379&gt; hset myhash field1 &quot;itany&quot;(integer) 1#获取键值为myhash，字段为field1的值127.0.0.1:6379&gt; hget myhash field1&quot;itany&quot;#myhash键中不存在field2字段，因此返回nil127.0.0.1:6379&gt; hget myhash field2(nil)#给myhash关联的Hashes值添加一个新的字段field2，其值为liu127.0.0.1:6379&gt; hset myhash field2 &quot;liu&quot;(integer) 1#获取myhash键的字段数量127.0.0.1:6379&gt; hlen myhash(integer) 2#判断myhash键中是否存在字段名为field1的字段，由于存在，返回值为1127.0.0.1:6379&gt; hexists myhash field1(integer) 1#删除myhash键中字段名为field1的字段，删除成功返回1127.0.0.1:6379&gt; hdel myhash field1(integer) 1#再次删除myhash键中字段名为field1的字段，由于上一条命令已经将其删除，因为没有删除，返回0127.0.0.1:6379&gt; hdel myhash field1(integer) 0#通过hsetnx命令给myhash添加新字段field1，其值为itany，因为该字段已经被删除，所以该命令添加成功并返回1127.0.0.1:6379&gt; hsetnx myhash field1 &quot;itany&quot;(integer) 1#由于myhash的field1字段已经通过上一条命令添加成功，因为本条命令不做任何操作后返回0127.0.0.1:6379&gt; hsetnx myhash field1 &quot;itany&quot;(integer) 0 hincrby 1234567891011121314127.0.0.1:6379&gt; del myhash(integer) 1#准备测试数据127.0.0.1:6379&gt; hset myhash field 5(integer) 1#给myhash的field字段的值加1，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field 1(integer) 6#给myhash的field字段的值加-1，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field -1(integer) 5#给myhash的field字段的值加-10，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field -10(integer) -5 hmset&#x2F;hmget&#x2F;hgetall&#x2F;hkeys&#x2F;hvals 123456789101112131415161718192021222324127.0.0.1:6379&gt; del myhash(integer) 1#为该键myhash，一次性设置多个字段，分别是field1 = &quot;hello&quot;, field2 = &quot;world&quot;127.0.0.1:6379&gt; hmset myhash field1 &quot;hello&quot; field2 &quot;world&quot;OK#获取myhash键的多个字段，其中field3并不存在，因为在返回结果中与该字段对应的值为nil127.0.0.1:6379&gt; hmget myhash field1 field2 field31) &quot;hello&quot;2) &quot;world&quot;3) (nil)#返回myhash键的所有字段及其值，从结果中可以看出，他们是逐对列出的127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;hello&quot;3) &quot;field2&quot;4) &quot;world&quot;#仅获取myhash键中所有字段的名字127.0.0.1:6379&gt; hkeys myhash1) &quot;field1&quot;2) &quot;field2&quot;#仅获取myhash键中所有字段的值127.0.0.1:6379&gt; hvals myhash1) &quot;hello&quot;2) &quot;world&quot; 四、Key操作命令1. 命令列表 命令用法 解释 keys pattern 获取所有匹配pattern参数的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。 del key [key…] 从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。 exists key 判断指定键是否存在。 persist key 如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。 expire key seconds 该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 ttl key 获取该键所剩的超时描述。 type key 获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。 2. 操作 keys&#x2F;del&#x2F;exists 123456789101112131415161718192021222324252627282930313233127.0.0.1:6379&gt; flushdbOK#添加String类型的数据127.0.0.1:6379&gt; set mykey 2OK#添加List类型的数据127.0.0.1:6379&gt; lpush mylist a b c(integer) 3#添加Set类型的数据127.0.0.1:6379&gt; sadd myset 1 2 3(integer) 3#添加Sorted-Set类型的数据127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot; 2 &quot;two&quot;(integer) 2#添加Hash类型的数据127.0.0.1:6379&gt; hset myhash username &quot;tom&quot;(integer) 1#根据参数中的模式，获取当前数据库中符合该模式的所有key，从输出可以看出，该命令在执行时并不区分与Key关联的Value类型127.0.0.1:6379&gt; keys my*1) &quot;myset&quot;2) &quot;mykey&quot;3) &quot;myzset&quot;4) &quot;myhash&quot;5) &quot;mylist&quot;#删除了两个Keys127.0.0.1:6379&gt; del mykey mylist(integer) 2#查看刚刚删除的Key是否还存在，从返回结果看，mykey确实已经删除了127.0.0.1:6379&gt; exists mykey(integer) 0#查看一下没有删除的Key，以和上面的命令结果进行比较127.0.0.1:6379&gt; exists myset(integer) 1 ttl&#x2F;persist&#x2F;expire 12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; flushdbOK#准备测试数据，将该键的超时设置为100秒127.0.0.1:6379&gt; set mykey &quot;hello&quot; ex 100OK#通过ttl命令查看还剩多少秒127.0.0.1:6379&gt; ttl mykey(integer) 97#立刻执行persist命令，该存在超时的键变成持久化的键，即将该Key的超时去掉127.0.0.1:6379&gt; persist mykey(integer) 1#ttl的返回值告诉我们，该键已经没有超时了127.0.0.1:6379&gt; ttl mykey(integer) -1#为后面的expire命令准备数据127.0.0.1:6379&gt; del mykey(integer) 1127.0.0.1:6379&gt; set mykey &quot;hello&quot;OK#设置该键的超时被100秒127.0.0.1:6379&gt; expire mykey 100(integer) 1#用ttl命令看当前还剩下多少秒，从结果中可以看出还剩下96秒127.0.0.1:6379&gt; ttl mykey(integer) 96#重新更新该键的超时时间为20秒，从返回值可以看出该命令执行成功127.0.0.1:6379&gt; expire mykey 20(integer) 1#再用ttl确认一下，从结果中可以看出被更新了127.0.0.1:6379&gt; ttl mykey(integer) 17#立刻更新该键的值，以使其超时无效。127.0.0.1:6379&gt; set mykey &quot;world&quot;OK#从ttl的结果可以看出，在上一条修改该键的命令执行后，该键的超时也无效了127.0.0.1:6379&gt; ttl mykey(integer) -1 type 123456789101112131415161718192021222324127.0.0.1:6379&gt; del mykey(integer) 1#添加不同类型的测试数据127.0.0.1:6379&gt; set mykey 2OK127.0.0.1:6379&gt; lpush mylist a b c(integer) 3127.0.0.1:6379&gt; sadd myset 1 2 3(integer) 3127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot; 2 &quot;two&quot;(integer) 2127.0.0.1:6379&gt; hset myhash username &quot;tom&quot;(integer) 1#分别查看数据的类型127.0.0.1:6379&gt; type mykeystring127.0.0.1:6379&gt; type mylistlist127.0.0.1:6379&gt; type mysetset127.0.0.1:6379&gt; type myzsetzset127.0.0.1:6379&gt; type myhashhash 五、持久化1. 概述Redis提供了两种数据持久化的方式： RDB 该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘。 AOF 该机制将以日志的形式记录服务器所处理的每一个写操作 在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。 2. RDBRedis Database：通过单文件的方式来持久化 RDB是默认的持久化方式，默认存储在启动redis服务器时所在当前目录下的dump.rdb文件中，一般都会修改存储在一个固定的目录中 编辑配置文件： 1234$ vi myredis.conf dbfilename dump.rdb #持久化文件的名称 #dir ./ #持久化文件的目录,默认为执行redis-server命令时所在的当前目录 dir /home/soft01/software/dump/ #修改存储位置为一个固定的目录 持久化的时机： 在数据库关闭时会持久化（需要注意的是在数据库宕机时不会生成，数据可能会丢失） 满足特定条件时会持久化，编辑配置文件： 1234$ vi myredis.conf save 900 1 #在900秒内，只要有1个key发生变化，就会dump持久化 save 300 10 save 60 10000 优缺点： 缺点：可能会丢失数据 优点：效率比较高 3. AOFAppend Only File：通过操作日志的方式来持久化 编辑配置文件： 12345$ vi myredis.conf appendonly yes #开启aof模式的持久化 appendfilename &quot;appendonly.aof&quot; #aof的持久化文件 appendfsync everysec #每一秒进行一次持久化操作，可取值：always、everysec、no dir /home/soft01/software/dump/ #持久化文件的目录，与RDB相同 优缺点： 缺点：效率比较差 优点：丢失数据量比较少 六、SpringBoot整合Redis1. 用法步骤： 创建一个SpringBoot工程，选择以下模块：Spring Data Redis、Web、Lombok、DevTools 配置redis 12345678910111213spring: redis: host: localhost port: 6379 password: database: 0 # lettuce连接池配置 lettuce: pool: max-wait: 10000 max-idle: 20 min-idle: 10 max-active: 8 注：Java中操作Redis主要有两种客户端：jedis和lettuce，SpringBoot中默认使用的是lettuce 基本操作 使用SpringDataRedis提供的工具类：RedisTemplate 2. RedisConfig配置类1234567891011121314151617181920212223242526/** * Redis配置类 */@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // 设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); // 设置key的序列化方式 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setHashKeySerializer(stringRedisSerializer); // 设置value的序列化方式 GenericJackson2JsonRedisSerializer jsonRedisSerializer =new GenericJackson2JsonRedisSerializer(); redisTemplate.setValueSerializer(jsonRedisSerializer); redisTemplate.setHashValueSerializer(jsonRedisSerializer); return redisTemplate; &#125;&#125; 七、Redis应用：验证码将验证码存储在Redis中 添加依赖，使用captcha生成验证码 123456&lt;!--easy-captcha--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt; &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"如何解决跨域问题","slug":"如何解决跨域问题","date":"2023-08-21T03:44:39.000Z","updated":"2023-09-07T02:40:21.490Z","comments":true,"path":"2023/08/21/如何解决跨域问题/","link":"","permalink":"http://example.com/2023/08/21/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"方法一定义一个配置类，实现WebMvcConfigurer接口，重写addCorsMappings方法 123456789101112@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOriginPatterns(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;*&quot;) .maxAge(3600); &#125;&#125; 方法二在xml中添加如下配置: 123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;/mvc:cors&gt; 方法三在vue项目中vue.config.js内配置代理： 1234567891011121314module.exports = defineConfig(&#123; transpileDependencies: true, devServer: &#123; // 配置代理 proxy:&#123; &#x27;/api&#x27;:&#123; // 所有以/api开头的请求都会被代理到target上 target: &#x27;http://localhost:8080&#x27;, // 代理的目标地址 changeOrigin: true, // 支持跨域 pathRewrite: &#123; // 重写路径 &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125; 在main.js中配置axios： 1234// axios配置import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;/api/&#x27;Vue.prototype.$http = axios 在组件中method中定义方法： 123async getCode()&#123; const &#123;data:res&#125; = await this.$http.get(&#x27;captchaImage&#x27;)&#125;,","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"SpringBoot学习","slug":"SpringBoot学习","date":"2023-08-17T08:36:01.000Z","updated":"2023-08-17T08:40:14.997Z","comments":true,"path":"2023/08/17/SpringBoot学习/","link":"","permalink":"http://example.com/2023/08/17/SpringBoot%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、SpringBoot简介1. SpringBoot是什么？产生背景：Spring开发变的越来越笨重，大量的XML文件、繁琐的配置、复杂的部署流程、整合第三方框架难度大等，导致开发效率低下 SpringBoot是一个用来简化Spring应用的初始创建和开发过程的框架，简化配置，实现快速开发 融合了整个Spring技术栈，JavaEE开发的一站式解决方案 参考：Spring官网 https://spring.io/projects 2. 为什么使用SpringBoot？优点： 快速创建独立运行的Spring项目并与主流框架集成 内置Servlet容器，应用无需打成WAR包 使用starter(启动器)管理依赖并进行版本控制 大量的自动配置，简化开发 提供准生产环境的运行时监控，如指标、健康检查、外部配置等 无需配置XML，没有冗余代码生成，开箱即用 二、第一个SpringBoot程序1. 环境要求 SpringBoot 2.x JDK 8及以上 Maven 3.5及以上 Tomcat 9及以上 2. 操作步骤步骤： 创建一个maven的java工程 传统web应用需要创建一个web工程，后期要打成war包，然后放到tomcat中，太麻烦 而SpringBoot应用只需要创建一个java工程，后期直接打成可执行的jar包，其内置tomcat 导入SpringBoot的相关依赖 12345678910111213&lt;!-- 继承SpringBoot的父工程 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- 添加web应用的starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写Controller 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; return &quot;Hello World&quot;; &#125;&#125; 编写主程序类，用来启动SpringBoot应用 12345678910/** * 使用@SpringBootApplication标注主程序类，表示这是一个SpringBoot应用 */@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 启动SpringBoot应用 SpringApplication.run(MainApplication.class, args); //传入主程序类的Class对象 &#125;&#125; 注：主程序类必须放到其他类的上层包中，因为默认只扫描主程序类所在的包及其子包 运行主程序并访问测试 http://localhost:8080/hello 部署打包 添加spring-boot-maven-plugin插件，将应用打成可执行的jar包，然后直接执行java -jar springboot01-helloworld-1.0-SNAPSHOT.jar 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 分析HelloWorldPOM文件： 父项目是spring-boot-starter-parent 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt; 父项目的父项目是spring-boot-dependencies，用来管理SpringBoot应用中依赖的版本，进行版本控制 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt; 通过启动器starter指定依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 主程序类： @SpringBootApplication 标注在类上，表示这是一个SpringBoot应用，通过运行该类的main方法来启动SpringBoot应用 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration 标注在类上，表示这个类是SpringBoot的配置类 层级关系：@SpringBootConfiguration——&gt;@Configuration——&gt;@Component @Configuration标注在类上，表示这个类是Spring的配置类，相当于是一个xml配置文件 @EnableAutoConfiguration 开启自动配置功能，SpringBoot会自动完成许多配置，简化了以前繁琐的配置 @ComponentScan 标注在类上，指定要扫描的包，默认只扫描主程序类所在的包及其子包 可以使用@ComponentScan手动指定要扫描的包 三、基本用法1. 快速创建项目步骤： 使用Spring Initializer快速创建SpringBoot项目 ​ 选择SpringBoot 2.x 版本 ​ 勾选Web、Lombok模块 基本操作 ​ 默认生成的.mvn、.gitignore、mvnw、mvnw.cmd，可以直接删除 ​ resources文件夹的目录结构 1234|-resources |-static // 存放静态资源，如css、js、imgs等 |-templates // 存放模板页面，可以使用模板引擎，如thymeleaf、freemarker等 |-application.properties // SpringBoot应用的配置文件，可以修改默认设置 ​ 注：SpringBoot生成的可执行jar包使用嵌入式的Tomcat，默认不支持JSP 修改banner图案 ​ 在resources&#x2F;目录下创建名为banner.txt的文件，内容如下生成 ​ 在线生成：https://patorjk.com/software/taag ​ 经典图案 ：https://blog.csdn.net/vbirdbest/article/details/78995793 1234567891011121314151617181920212223::Spring Boot Version:: $&#123;spring-boot.version&#125;////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88&quot; . &quot;88 //// (| ^_^ |) //// O\\ = /O //// ____/`---&#x27;\\____ //// .&#x27; \\\\| |// `. //// / \\\\||| : |||// \\ //// / _||||| -:- |||||- \\ //// | | \\\\\\ - /// | | //// | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | //// \\ .-\\__ `-` ___/-. / //// ___`. .&#x27; /--.--\\ `. . ___ //// .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. //// | | : `- \\`.;`\\ _ /`;.`/ - ` : | | //// \\ \\ `-. \\_ __\\ /__ _/ .-` / / //// ========`-.____`-.___\\_____/___.-`____.-&#x27;======== //// `=---=&#x27; //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG ////////////////////////////////////////////////////////////////////// 2. 配置文件2.1 简介SpringBoot的默认全局配置文件有两个： application.properties application.yml 注：文件名固定，存放在classpath:/ 或 classpath:/config/目录下 2.2 YAML文件YAML是专门用来写配置文件的语言，文件的后缀名为.yml，语法规则： 使用缩进表示层级关系，相同层级的元素左侧要对齐 键和值之间以冒号+空格隔开 key: value # 表示注释 1234server: port: 8081 servlet: context-path: /springboot02 2.3 多环境切换针对不同的环境，可以提供不同的配置，例如，不同环境下使用的数据库配置大多是不同的 常用的环境： 开发环境 dev 测试环境 test 生产环境 prod 可以通过命名约定来定义多个配置文件，格式：application-&#123;profile&#125;.yml 然后在application.yml文件中使用spring.profiles.active 来激活某一个环境配置 123spring: profiles: active: dev 3. 热部署​ 使用SpringBoot提供的devtools实现热部署 ​ 原理：实时监控classpath下文件的变化（即编译后的target目录），如果发生变化则自动重启 ​ 配置：添加devtools的依赖即可（需要开启IDEA的自动编译） 1234567&lt;!-- devtools热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 补充：开启IDEA的自动编译，IDEA默认是不自动编译的 Settings——&gt;搜索Compiler——&gt;勾选Build project automatically Help——&gt;Find Action——&gt;搜索Registry——&gt;勾选compiler.automake.allow.parallel 4. 定义配置类4.1 添加组件通过定义配置类 向容器中添加组件，使用注解：@Configuration和@Bean 123456789101112// 标注在类上，表示这是一个配置类，相当于以前编写的Spring配置文件@Configurationpublic class SpringConfig &#123; // 标注在方法上，向容器中添加一个组件，将方法的返回值添加到容器中，方法名作为组件id @Bean public Date date()&#123; Calendar c = Calendar.getInstance(); c.set(2008,5,10); return c.getTime(); &#125;&#125; 4.2 跨域访问定义一个配置类，实现WebMvcConfigurer接口，重写addCorsMappings方法 123456789101112@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOriginPatterns(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;*&quot;) .maxAge(3600); &#125;&#125; 5. 数据校验5.1 简介数据校验就是数据的合法性检查，在服务器端也可以对数据进行校验，一般使用 JSR303 校验 JSR303是Java为Bean数据合法性校验提供的标准框架，是一种声明式校验 JSR303通过在Bean属性上标注类似于@NotNull、@Max等注解来指定校验规则，并通过标准的验证接口对Bean进行验证 注解 功能 @Null 必须为null @NotNull 不能为null @NotBlank 字符串不能为null，且长度大于 0，会去掉前后空格 @Max(value) 数字必须小于等于指定值 @Min(value) 数字必须大于等于指定值 @Size(min,max) 长度必须在指定的范围内（可以是字符串、数组、集合等） @Past 时间必须是过去的时间 @Future 时间必须是将来的时间 @Pattern 必须符合指定的正则表达式 JSR303的扩展： Hibernate Validator扩展注解 Hibernate Validator是JSR303的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解 注解 功能 @Length(min,max) 字符串长度必须在指定范围之间 @NotEmpty 字符串不能为空 @Email 必须是合法的邮箱 @Range(min,max,message) 数值必须在指定的范围内 5.2 基本用法步骤： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在Bean上添加校验注解 12345678910111213141516171819202122@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable &#123; private Integer id; @NotBlank(message = &quot;用户名不能为空&quot;) private String username; @NotBlank(message = &quot;密码不能为空&quot;) @Length(min = 6,max = 12,message = &quot;密码长度必须在6~12之间&quot;) private String password; @Range(min = 18,max = 30,message = &quot;年龄只能在18~30之间&quot;) private int age; @NotNull(message = &quot;生日不能为空&quot;) @Past(message = &quot;生日必须是过去的时间&quot;) @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birthday;&#125; 在方法形参前添加@Valid注解 12345678910@RestControllerpublic class AjaxController &#123; @RequestMapping(&quot;/addUser&quot;) public String addUser(@Valid User user)&#123; // @Valid 开启对User对象的数据校验 System.out.println(user); return &quot;success&quot;; &#125;&#125; 6. 定时任务6.1 简介在项目开发中，经常需要编写定时任务来执行一些周期性的任务。 比如定时备份数据库、定时发送邮件、定时清理数据、定时提醒或通知等。 例如生活中网上购物时如果用户收到了商品，但一直没有确认收货，过了一个星期这个订单就需要自动转变为已收货状态，这种实时性不高的情景就可以用定时任务实现。 定时任务的实现： Quartz框架：是一个开源的任务调度框架 Spring Boot内置定时任务 Cron表达式是一个字符串，由6个字段组成，每个字段使用空格隔开 ，用于指定定时任务的执行时间。也称为七子表达式 字段 取值范围 说明 秒 0-59 分 0-59 时 0-23 日 1-31 月 1-12 星期 0-7 0和7都表示星期日 年 1970~2099 此项非必需，可以省略 使用以下特殊字符来指定执行时间： 星号（*）：表示匹配该字段的所有可能值 问号（?）：表示不关心该字段具体的值 斜线（&#x2F;）：表示指定一个间隔 逗号（,）：表示列举多个值 连字符（-）：表示指定一个范围 6.2 基本用法我们可以使用Spring Boot提供的定时任务，非常简单。 步骤： 定制任务，使用@Scheduled 1234567891011121314@Componentpublic class MyScheduledTasks &#123; @Scheduled(fixedRate = 3000) // 每隔3秒执行一次 public void task1() &#123; System.out.println(&quot;定时任务1执行了！&quot;); &#125; @Scheduled(cron = &quot;0 0 3 * * ?&quot;) // 每天凌晨3点执行 public void task2() &#123; System.out.println(&quot;定时任务2执行了！&quot;); &#125;&#125; 启用定时任务，使用@EnableScheduling 123456789@SpringBootApplication@EnableScheduling // 开启定时任务public class Springboot02QuickApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot02QuickApplication.class, args); &#125;&#125; 7. 日志SLF4j是一个日志标准，提供了日志接口，并不是日志系统的具体实现，其具体实现有：log4j、log4j2、slf4j-simple、logback等。 SpringBoot默认使用的日志是logback 常见的日志级别： debug、info、warn、error 使用步骤： 创建logback.xml日志配置文件，默认会自动加载该文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;!--日志存放目录--&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;./logs&quot; /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式：%d表示日期，%thread表示线程名，%-5level表示级别从左显示5个字符宽度，%logger&#123;50&#125;表示logger名字最长50个字符，%msg表示日志消息，%n表示换行符 --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 DEBUG --&gt; &lt;appender name=&quot;DEBUG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;!--日志文件名--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/debug/manage-remote-debug.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;16&lt;/MaxHistory&gt; &lt;!--日志文件切割大小--&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--过滤日志级别--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 INFO --&gt; &lt;appender name=&quot;INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/info/manage-remote-info.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;16&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 WARN --&gt; &lt;appender name=&quot;WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/warn/manage-remote-warn.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;24&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 ERROR --&gt; &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/error/manage-remote-error.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;32&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 设置logger --&gt; &lt;logger name=&quot;net.wanho&quot; level=&quot;debug&quot;/&gt; &lt;!-- 设置root --&gt; &lt;root level=&quot;warn&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;INFO&quot; /&gt; &lt;appender-ref ref=&quot;WARN&quot; /&gt; &lt;appender-ref ref=&quot;ERROR&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; 记录日志 123456789101112131415161718192021@Slf4j // lombok注解，自动创建log对象public class LogTest &#123; // private static final Logger log = LoggerFactory.getLogger(LogTest.class); @Test public void test() &#123; log.debug(&quot;debug消息&quot;); log.info(&quot;info消息&quot;); log.warn(&quot;warn消息&quot;); log.error(&quot;error消息&quot;); try &#123; System.out.println(5/0); &#125; catch (Exception e) &#123; log.error(e.getMessage()); throw new RuntimeException(e); &#125; &#125;&#125; 注：可以在IDEA中安装Grep Console插件，便于在控制台以不同颜色区别日志级别 四、整合MyBatis123456789drop database if exists springboot;create database springboot charset utf8;use springboot;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(100) not null unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 1. MyBatis步骤： 创建一个工程，选择以下模块：Web、MyBatis、Lombok 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt; 注：SpringBoot默认使用的连接池是HikariCP，是一款轻量、高性能的连接池。 配置application.yml 12345678910111213# 配置MyBatismybatis: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml configuration: # 打印sql log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 下划线映射为驼峰 map-underscore-to-camel-case: true# 配置PageHelperpagehelper: helper-dialect: mysql 使用@MapperScan指定Dao接口所在的包 12345678@SpringBootApplication//指定Dao接口所在的包，动态创建Dao实现类@MapperScan(&quot;net.wanho.mapper&quot;)public class Springboot04MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04MybatisApplication.class, args); &#125;&#125; 配置Dao、Service、Controller等 可以在Dao接口上添加@Repository 或 @Mapper，以解决在Service层注入时提示找不到bean的问题 2. MyBatis-Plus参考：http://mp.baomidou.com 2.1 基本用法步骤： 创建一个springboot工程，选择以下模块：Web、Lombok 添加依赖 1234567891011121314151617&lt;!--mbyatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920212223242526# 配置DataSourcespring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8 username: root password: root initialSize: 5 maxActive: 50 minIdle: 3 maxWait: 5000# 配置MyBatis-Plusmybatis-plus: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml configuration: # 打印sql log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 下划线映射为驼峰 map-underscore-to-camel-case: true global-config: db-config: # id-type: auto # 使用数据库的自动增长，不可作为分布式ID使用 id-type: assign_id # 使用雪花算法自动生成long类型的数字，分布式的情况下可使用 配置MybatisPlusConfig 1234567891011121314@Configuration@MapperScan(&quot;net.wanho.mapper&quot;)public class MyBatisPlusConfig &#123; /** * 配置MP的分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 定义Mapper，继承BaseMapper 12345/** * 继承BaseMapper接口，通用Mapper */public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 注：当数据库表名和字段名 与 类名和属性名不一致时，需要使用@TableName、@TableId、@TableField注解对实体类进行标注 定义Service，使用通用Service 12345678910111213/** * 继承IService接口，通用Service */public interface UserService extends IService&lt;User&gt; &#123;&#125;/** * 继承ServiceImpl类，通用Service实现类 */@Service@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125; 使用Mybatis-plus提供的接口 2.2 逻辑删除物理删除和逻辑删除： 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 步骤： 在表中添加逻辑删除标识列 1is_deleted tinyint default 0 comment &#x27;是否删除（0表示正常，1表示删除）&#x27; 在实体类中添加逻辑删除属性 123@TableLogic@TableField(value = &quot;is_deleted&quot;)private Integer isDeleted; ​ 也可以进行全局配置 123456mybatis-plus: global-config: db-config: logic-delete-field: isDeleted # 全局逻辑删除字段 logic-delete-value: 1 # 标识删除的值(默认为1) logic-not-delete-value: 0 # 逻辑未删除值(默认为0) 测试 测试删除：实际上执行的是更新操作 12-- 实际执行的SQLupdate t_user set is_deleted=1 where id = 1 and is_deleted=0 ​ 测试查询：不会查询被逻辑删除的数据 12-- 实际执行的SQLselect id,username,password,is_deleted t_from user where is_deleted=0 2.3 自动填充在对数据库表进行操作时经常会遇到一些字段，每次都使用相同的方式填充值，比如创建时间、更新时间等。 在阿里巴巴的开发手册中建议每个数据库表都必须要有create_time 和 update_time字段，以便记录每次操作的时间。 此时我们可以使用MyBatis Plus的自动填充功能，完成这些字段的自动填充赋值。 步骤： 在表中添加列 12create_time datetime comment &#x27;创建时间&#x27;,update_time datetime comment &#x27;更新时间&#x27; 在实体类中添加属性 12345@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 创建元对象处理器，实现MetaObjectHandler接口，用于对字段进行填充 1234567891011121314151617@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill ....&quot;); this.strictInsertFill(metaObject, &quot;createTime&quot;, () -&gt; new Date(), Date.class); this.strictInsertFill(metaObject, &quot;updateTime&quot;, () -&gt; new Date(), Date.class); &#125; @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;start update fill ....&quot;); this.strictUpdateFill(metaObject, &quot;updateTime&quot;, () -&gt; new Date(), Date.class); &#125;&#125; 测试 ​ 测试新增：会自动对create_time和update_time进行填充赋值 ​ 测试修改：会自动对update_time进行填充赋值 五、Restful API1.简介Representational State Transfer，简称为REST， 即表现层状态转化 Restful是一种网络应用程序的设计方式与开发方式，基于HTTP 表现层 Representational 资源的表现层，指的是资源的具体呈现形式，如HTML、JSON等 状态转化 State Transfer 指的是状态变化，通过HTTP方法来实现 通过不同的请求方式实现不同的功能，实现表现层状态转化 GET 获取资源，即查询操作 POST 新建资源，即添加操作 PUT 更新资源，即修改操作 DELETE 删除资源，即删除操作 2.设计原则Restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计 Restful API设计原则： 尽量将API 部署在一个专用的域名下，如 http://wanho.net/api 或 http://api.wanho.net API的版本应该在URL中体现，如 http://wanho.net/api/v2 URL中不要使用动词，应使用资源名词，且使用名词的复数形式，如： 功能说明 请求类型 URL 获取用户列表 GET http://wanho.net/api/v2/users 根据id获取用户 GET http://wanho.net/api/v2/users/id 添加用户 POST http://wanho.net/api/v2/users 根据id删除用户 DELETE http://wanho.net/api/v2/users/id 修改用户 PUT http://wanho.net/api/v2/users 注：简单来说，可以使用同一个 URL ，通过约定不同的 HTTP 方法来进行不同的业务操作 服务器响应时返回JSON对象，包含业务逻辑状态码、响应的消息、响应的查询结果 3. 基本用法​ @GetMapping ​ @PostMapping ​ @PutMapping ​ @DeleteMapping 4. 接口测试Postman​ Postman是一款非常优秀的调试工具，可以用来模拟发送各类HTTP请求，进行接口测试。 六、API接口文档1. 简介通常情况下，我们会创建一份API文档来记录所有的接口细节，供其他开发人员使用提供的接口服务，但会存在以下的问题： 接口众多，并且细节复杂 需要根据接口的变化，不断修改API文档，非常麻烦，费时费力 Swagger的出现就是为了解决上述的这些问题，减少创建API文档的工作量 后端人员在代码里添加接口的说明内容，就能够生成可预览的API文档，无须再维护Word文档 让维护文档和修改代码整合为一体，在修改代码逻辑的同时方便的修改文档说明 提供了页面测试功能，便于对接口进行测试 Knife4j是对Swagger的封装，对接口文档UI进行了优化，并做了增强，用起来更方便 2. 使用步骤使用步骤： 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt; 创建配置类 1234567891011121314151617181920212223242526272829303132@Configuration@EnableKnife4j // 启用Knife4jpublic class Knife4jConfig &#123; /** * 创建Restful API文档内容 */ @Bean public Docket Api() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .groupName(&quot;商城模块&quot;) .select() // 指定要暴露的接口所在包 .apis(RequestHandlerSelectors.basePackage(&quot;net.wanho.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; /** * API的基本信息 */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;商城项目后端API接口文档&quot;) .description(&quot;欢迎访问后端API接口文档&quot;) .contact(new Contact(&quot;tangxiaoyang&quot;,&quot;https://github.com/tangyang8942&quot;,&quot;tangxiaoyang@qq.com&quot;)) .version(&quot;1.0&quot;) .build(); &#125;&#125; 配置application.yml 1234spring: mvc: pathmatch: matching-strategy: ant_path_matcher # 用于解决SpringBoot2.6+版本与Swagger的兼容性问题 添加文档内容 使用Swagger提供的注解对接口进行说明，常用注解： @Api 标注在类上，对类进行说明 @ApiOperation 标注在方法上，对方法进行说明 @ApiParam 标注在参数上，对方法的参数进行说明 @ApiModel 标注在模型Model上，对模型进行说明 @ApiModelProperty 标注在属性上，对模型的属性进行说明 @ApiIgnore 标注在类或方法上，表示忽略这个类或方法 查看接口文档页面，并测试接口 启动SpringBoot程序，访问http://localhost:端口/doc.html，查看接口文档 可以在接口文档中对接口进行测试 七、代码生成器Generator1. 简介MyBatis-Plus代码生成器，快速生成 Entity、Mapper、Service、Controller 层代码，支持模板引擎自定义配置 12345678910111213141516171819202122232425drop database if exists springboot;create database springboot charset utf8;use springboot;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(100) not null unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, is_deleted tinyint default 0 comment &#x27;是否删除（0表示正常，1表示删除）&#x27;, create_time datetime comment &#x27;创建时间&#x27;, update_time datetime comment &#x27;更新时间&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;;create table t_dept( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;部门名称&#x27;)engine innodb default charset utf8 comment &#x27;部门表&#x27;;create table t_emp( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;姓名&#x27;, salary double comment &#x27;工资&#x27;, dept_id int comment &#x27;部门编号&#x27;, foreign key (dept_id) references t_dept(id))engine innodb default charset utf8 comment &#x27;员工表&#x27;; 2. 基本用法步骤： 创建一个SpringBoot工程，选择以下模块：Web、Lombok 添加依赖 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--mbyatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-plus-generator--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--beetl模板引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;com.ibeetl&lt;/groupId&gt; &lt;artifactId&gt;beetl&lt;/artifactId&gt; &lt;version&gt;3.15.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--guava--&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;32.0.0-jre&lt;/version&gt;&lt;/dependency&gt; 快速生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class CodeGenerator &#123; private static String projectPath = &quot;/Users/txy/code/IdeaProjects/framework/springboot05-generator&quot;; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator generator = new AutoGenerator(); // 1、全局配置 GlobalConfig gc = new GlobalConfig(); gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); gc.setAuthor(&quot;汤小洋&quot;); gc.setOpen(false); gc.setFileOverride(true); // 重新生成时文件是否覆盖 gc.setServiceName(&quot;%sService&quot;); // Service接口的命名方式 gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); gc.setBaseResultMap(true); gc.setBaseColumnList(true); generator.setGlobalConfig(gc); // 2、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;); dsc.setDriverName(&quot;com.mysql.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); generator.setDataSource(dsc); // 3、包配置 PackageConfig pc = new PackageConfig(); pc.setParent(&quot;net.wanho&quot;); pc.setEntity(&quot;po&quot;); // entity 层 pc.setMapper(&quot;mapper&quot;); // mapper 层 pc.setService(&quot;service&quot;); // service层 pc.setController(&quot;controller&quot;); // controller 层 generator.setPackageInfo(pc); // 4、自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setTablePrefix(&quot;t_&quot;); // 过滤表前辍 strategy.setNaming(NamingStrategy.underline_to_camel); //数据库表映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); //数据库列映射到实体属性的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 // 逻辑删除 strategy.setLogicDeleteFieldName(&quot;is_deleted&quot;); // 自动填充 List&lt;TableFill&gt; tableFillList = new ArrayList&lt;&gt;(); tableFillList.add(new TableFill(&quot;create_time&quot;, FieldFill.INSERT)); tableFillList.add(new TableFill(&quot;update_time&quot;, FieldFill.INSERT_UPDATE)); strategy.setTableFillList(tableFillList); generator.setStrategy(strategy); // 6、设置解析模板 generator.setTemplateEngine(new BeetlTemplateEngine() &#123; // 获取主键 String primaryKey = &quot;&quot;; String primaryKeyUnderline=&quot;&quot;; @Override public AbstractTemplateEngine init(ConfigBuilder configBuilder) &#123; AbstractTemplateEngine engine = super.init(configBuilder); // 映射文件放到resources目录下 configBuilder.getPathInfo().put(&quot;xml_path&quot;, projectPath + &quot;/src/main/resources/mapper/&quot; + pc.getModuleName()); return engine; &#125; @Override public Map&lt;String, Object&gt; getObjectMap(TableInfo tableInfo) &#123; for (TableField tableField : tableInfo.getFields()) &#123; if (tableField.isKeyFlag()) &#123; primaryKey = tableField.getPropertyName(); primaryKeyUnderline = tableField.getName(); break; &#125; &#125; // 获取源码中的map Map objectMap = super.getObjectMap(tableInfo); // 额外添加两个键值对 objectMap.put(&quot;entityCamel&quot;, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, tableInfo.getEntityName())); objectMap.put(&quot;primaryKey&quot;, primaryKey); objectMap.put(&quot;primaryKeyUnderline&quot;, primaryKeyUnderline); return objectMap; &#125; &#125;); // 7、执行生成 generator.execute(); &#125;&#125; 自定义模板 可以根据需求自定义模板 entity.java.btl mapper.java.btl mapper.xml.btl service.java.btl serviceImpl.java.btl controller.java.btl 测试 3. 多表查询MyBatis-Plus默认只能完成单表的操作，多表操作仍然需要自己写。 步骤： 在Emp实体类中添加属性 123@ApiModelProperty(value = &quot;部门&quot;)@TableField(exist = false) // 表示该属性不是数据库表中的字段private Dept dept; 编辑EmpMapper.java和EmpMapper.xml 123456public interface EmpMapper extends BaseMapper&lt;Emp&gt; &#123; List&lt;Emp&gt; selectAll(); IPage&lt;Emp&gt; selectByPage(IPage&lt;Emp&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;Emp&gt; queryWrapper);&#125; 1234567891011121314151617&lt;resultMap id=&quot;EmpMap&quot; type=&quot;Emp&quot; extends=&quot;BaseResultMap&quot;&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;dept_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;dept_name&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap&quot;&gt; select e.*, d.name as dept_name from t_emp e left join t_dept d on e.dept_id = d.id&lt;/select&gt;&lt;select id=&quot;selectByPage&quot; resultMap=&quot;EmpMap&quot;&gt; select e.*, d.name as dept_name from t_emp e left join t_dept d on e.dept_id = d.id $&#123;ew.customSqlSegment&#125;&lt;/select&gt; 编辑EmpService和EmpServiceImpl 123456public interface EmpService extends IService&lt;Emp&gt; &#123; List&lt;Emp&gt; findAll(); IPage&lt;Emp&gt; findByPage(IPage&lt;Emp&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;Emp&gt; queryWrapper);&#125; 12345678910111213@Servicepublic class EmpServiceImpl extends ServiceImpl&lt;EmpMapper, Emp&gt; implements EmpService &#123; @Override public List&lt;Emp&gt; findAll() &#123; return this.baseMapper.selectAll(); &#125; @Override public IPage&lt;Emp&gt; findByPage(IPage&lt;Emp&gt; page, Wrapper&lt;Emp&gt; queryWrapper) &#123; return this.baseMapper.selectByPage(page,queryWrapper); &#125;&#125; 测试 123456789101112131415161718192021@SpringBootTestclass EmpServiceImplTest &#123; @Resource private EmpService empService; @Test public void findAll() &#123; System.out.println(empService.findAll()); &#125; @Test public void findByPage() &#123; Page&lt;Emp&gt; page = new Page&lt;&gt;(1, 3); QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.likeRight(&quot;e.name&quot;, &quot;1&quot;); empService.findByPage(page, wrapper); System.out.println(page.getRecords()); &#125;&#125; 八、MyBatis-Plus-Join1. 简介官网 https://mybatisplusjoin.com/ 2. 基本用法步骤： 添加依赖 123456&lt;!--mybatis-plus-join--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-join-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.5&lt;/version&gt;&lt;/dependency&gt; 编辑EmpMapper.java，继承自MPJBaseMapper 12public interface EmpMapper extends MPJBaseMapper&lt;Emp&gt; &#123;&#125; 测试 12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass EmpMapperTest &#123; @Resource private EmpMapper empMapper; @Test public void selectAll()&#123; MPJLambdaWrapper&lt;Emp&gt; wrapper = new MPJLambdaWrapper&lt;Emp&gt;() .selectAll(Emp.class) // 查询Emp类的所有字段 .selectAs(Dept::getName, EmpDTO::getDeptName)// 查询Dept类的name字段 .leftJoin(Dept.class, Dept::getId, Emp::getDeptId) // 左连接 .orderByDesc(Emp::getId); List&lt;EmpDTO&gt; list = empMapper.selectJoinList(EmpDTO.class, wrapper); list.forEach(System.out::println); &#125; @Test public void selectByPage()&#123; Page&lt;EmpDTO&gt; page = new Page&lt;&gt;(1, 3); empMapper.selectJoinPage(page, EmpDTO.class, new MPJLambdaWrapper&lt;Emp&gt;() .selectAll(Emp.class) .selectAs(Dept::getName, EmpDTO::getDeptName) .leftJoin(Dept.class, Dept::getId, Emp::getDeptId) .eq(Dept::getId, 1)); page.getRecords().forEach(System.out::println); &#125;&#125; 九、综合案例基于SpringBoot的日记管理系统（diary） 后端 SpringBoot 前端 LayUI","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Vue基础学习(三)","slug":"Vue基础学习-三","date":"2023-08-15T04:58:17.000Z","updated":"2023-08-15T05:00:12.576Z","comments":true,"path":"2023/08/15/Vue基础学习-三/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%B8%89/","excerpt":"","text":"一、组件化与模块化1. 组件化​ 组件化，是从UI界面的角度进行划分的，将页面构成拆分为一个个组件，方便UI组件的重用 ​ 组件包含：页面构成（template）、样式（css）、功能（js） 2. 模块化​ 模块化，是从代码逻辑的角度进行划分的，将项目按照一定的规则拆分成一个个模块，进行组合使用 ​ 方便代码的分层开发，保证每个功能模块的职能单一 二、构建模块化环境1. 开发环境模块化开发一般需要独立的开发环境，一般都基于 Node.js 和 webpack 进行环境搭建 Node.js 独立JS运行环境和模块系统支持 webpack 自动化的前端构建工作流工具，类似于gulp，但功能更强大 Vue模块化项目环境搭建，可以通过官方提供的环境构建工具 Vue CLI ，称为Vue脚手架 2. Vue脚手架2.1 简介 @vue/cli是一个Vue脚手架，用来快速构建模块化项目结构 cli：command line interface 命令行接口 通过命令行的方式快速构建Vue模块化项目运行环境 2.2 安装脚手架系统环境： node环境：node -v npm环境：npm -v nrm环境： nrm ls 安装@vue&#x2F;cli： 全局安装：npm install @vue/cli -g （需要具有管理员权限） 验证安装：vue --version 查看帮助：vue --help 常用命令： 创建项目：vue create 项目名 或 vue ui 为项目增加扩展插件：vue add 插件 3. 使用脚手架创建项目切换到项目的存放目录，执行 vue create 项目名称，进入交互模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 1.选择构建模式Vue CLI v4.1.2? Please pick a preset: (Use arrow keys) default (babel, eslint) # 默认选项，只包含基础依赖 ——&gt; 直接执行第6步❯ Manually select features # 自定义环境，手动选择特性依赖 # 2.自定义环境的选择Vue CLI v4.1.2? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) # 选择需要的环境特性 ❯◉ Babel # ES6语法兼容转换器（Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，避免运行环境不支持） ◯ TypeScript # TS语法支持 ◯ Progressive Web App (PWA) Support # 构建渐进式Web应用，优化用的 ◯ Router # 集成路由功能 ◯ Vuex # 集成统一数据状态管理器 ◉ CSS Pre-processors # CSS预编译，支持使用LESS、SASS等动态样式语言 ◉ Linter / Formatter # 代码规范检查和格式化检测 ◯ Unit Testing # 单元测试 ◯ E2E Testing # 端到端测试 # 3.所选环境的进一步配置# 如果选择了CSS Pre-processors，则需要选择 动态样式语言? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys) Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) ❯ Less Stylus # 如果选择Linter / Formatter，则需要选择 代码规范检查的规则? Pick a linter / formatter config: (Use arrow keys)❯ ESLint with error prevention only # 使用ESLint，仅检测错误（ESLint是用来统一代码规范和风格的工具） ESLint + Airbnb config # 使用 eslint+airbnb 前端规范 ESLint + Standard config # 使用标准规范 ESLint + Prettier # 使用严格规范# 选择代码规范检查的时机? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◉ Lint on save # 文件保存时 ◯ Lint and fix on commit # 代码整理和提交时 # 4.选择工具配置文件的存放位置? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)❯ In dedicated config files # 存放在独立的配置文件中 In package.json # 集成在package.json文件中 # 5.是否将上述配置保存为一个预设选项，方便以后创建项目使用? Save this as a preset for future projects? Yes? Save preset as: mypreset# 6.创建项目，安装所需依赖Vue CLI v4.1.2✨ Creating project in /Users/appleuser/Desktop/aa-aa.🗃 Initializing git repository...⚙ Installing CLI plugins. This might take a while..........🎉 Successfully created project first-project.👉 Get started with the following commands: 4. 启动项目切换到项目的根目录，执行 npm run serve 启动开发服务器，然后根据提示url访问 npm run 命令名称 是npm内置的脚本执行命令，该命令会自动搜索执行目录下package.json文件中的scripts对应的命令并执行 三、项目结构1. 文件结构​ 通过多个关联文件构成模块化开发环境，最终由webpack工具进行打包合并 12345678910111213141516|-项目名称 |-node_modules # 项目运行所依赖的模块，内容较多，文件较大，拷贝项目时一般不拷贝此目录，可通过npm install自动下载安装 |-public # 项目的静态资源目录，如html、css、js、image等，服务器访问的根目录，对外公开的资源 |-index.html # 默认访问的页面文件 |-src # 源代码目录 |-assets # 静态资源目录 |-components # 自定义组件目录 |-App.vue # 项目的主组件 |-main.js # 项目的启动文件 |-.browserslistrc # 项目的浏览器适配版本 |-.eslintrc.js # eslint配置文件，定义语法校验规则 |-.gitignore # git配置文件，定义忽略文件列表 |-babel.config.js # babel配置文件，定义ES语法转换规则 |-package-lock.json # 对项目的安装模块信息进行本地记录 |-package.json # node项目的描述文件，定义项目的相关描述信息 |-README.md # 项目的说明文件，对项目进行说明介绍 2. 核心文件详解​ Vue模块化项目启动时会自动查找两个核心文件： index.html 和 main.js 2.1 index.html​ index.html是访问应用时默认显示的页面文件，也是Vue项目的容器定义文件 2.2 main.js​ main.js是项目的启动文件，也是Vue模块化项目的整合入口文件 123456/** * 使用ES6提供的模块导入导出功能 */import 模块名 from 文件路径 // 导入模块，模块名可自定义export default &#123;&#125; // 导出模块，默认导出 2.3 App.vue​ App.vue是Vue中提供的一种特殊的组件定义文件，这类文件用于描述模块化项目中的组件 ​ App.vue是项目的主组件，其他组件都是在该组件下加载的 3. 单文件组件​ 以.vue结尾的文件，是Vue.js自定义的一种文件格式，称为单文件组件 ​ 一个.vue文件就是一个单独的组件，在文件内封装了该组件相关的html、css和js，实现了对一个组件的封装 ​ .vue文件由三部分组成： 1234567891011&lt;template&gt; &lt;!-- html，组件的页面结构 --&gt;&lt;/template&gt;&lt;script&gt; // js，组件的功能配置&lt;/script&gt;&lt;style&gt; /* css，组件的样式 */&lt;/style&gt; 四、模块化开发1. 组件样式全局样式和局部样式： 在style标签中定义的样式，默认为全局样式，在所有组件中都有效 可以为style标签指定scoped属性，此时定义的样式为局部样式，只在当前组件中有效 用法：&lt;style scoped&gt; 动态样式支持： 可以为style标签指定lang属性，设置当前使用的样式语言，如：css、less、sass、stylus等 默认使用的是css语法，可以使用动态样式语言 用法：&lt;style lang=&quot;动态样式语言&quot;&gt; 2. 脚本架配置文件vue.config.js 是Vue脚手架@vue&#x2F;cli的全局配置文件，是一个可选的配置文件，如果不存在则使用默认配置，如果项目的根目录中存在这个文件，则项目运行时会自动加载 编辑vue.config.js文件 12345678module.exports = &#123; // 项目的基础url publicPath:&#x27;/film/&#x27;, // 开发服务器的配置 devServer: &#123; port: 8888 &#125;｝ 注：修改vue.config.js文件后，需要重启项目才生效 3. 项目打包当项目要部署上线时，需要先对开发环境的项目进行打包构建操作，生成一个由纯静态文件构成的项目 切换到项目的根目录，执行 npm run build 对项目进行打包构建操作 默认会在项目的根目录下生成一个dist目录，该目录中存放打包后的项目静态文件，可直接部署到生产环境中 打包后可将dist目录中的静态文件拷贝到任意Web服务器中部署运行 生产环境和开发环境： 由于生产环境和开发环境可能会有所不同，有时会导致资源无法访问，此时需要对环境进行配置 编辑vue.config.js文件 123456789101112module.exports = &#123; // 项目的基础url，所有静态资源在加载时的基础路径BASE_URL // publicPath:&#x27;/film/&#x27;, // 判断环境，分别指定生成环境production和开发环境development的地址 publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/film/&#x27; : &#x27;/&#x27;, // 开发服务器的配置 devServer: &#123; port: &#x27;8888&#x27; // 使用的端口 &#125;, // 打包时是否生成map文件，主要用于生成环境下调试js源代码，建议改为false productionSourceMap: false,&#125; 五、全局功能定义1. 简介用于统一定义全局的功能，如：全局组件、全局插件、全局过滤器、全局指令等 使用Vue提供的全局方法Vue.use()，一般在 main.js 文件中使用 Vue.use(Object) 参数Object是一个必须提供install方法的对象，Vue.use会自动调用执行install方法 2. 用法​ 全局组件、全局插件 六、数据交互1. 简介Vue模块化项目的数据交互，使用的就是AJAX技术，发送异步请求 实现异步请求的模块有很多，官方推荐使用 axios 模块 axios是一个基于Promise的HTTP请求客户端，用来发送AJAX请求 2. 安装axios切换到项目的根目录，执行 npm install axios --save 安装模块 在需要使用axios的文件中，通过import axios from &#39;axios&#39;导入模块 导入模块后，可以使用axios对象提供的方法： axios.get(url[, config]) axios.delete(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) 补充：Restful请求，根据HTTP请求方式来区分对资源的操作 GET 获取资源 POST 新建资源 PUT 更新资源 DELETE 删除资源 3. 用法3.1 基本用法使用axios.get(url[,config]) ，传参方式： 通过url传参，即查询字符串方式 通过params选项传参 使用axios.post(url[,data,[config]])，传参方式： 通过查询字符串方式 使用qs模块进行转换import qs from &#39;qs&#39; 注：对于post方式请求，axios发送数据时默认的数据格式为Request Payload，并非我们常用的Form Data格式，所以参数不能直接以json形式传递 3.2 全局引入全局引入axios并添加到Vue原型中，避免在组件中重复引用axios，简化使用 在main.js中导入axios模块 为Vue函数添加一个原型属性$http，指向axios对象 在组件中无需再引入axios模块，直接使用this.$http即可 4. 跨域访问发送请求时，如果协议、主机或端口，只要有任何一个不同，则为跨域访问 两种解决方式： 后端允许跨越访问，设置响应头为Access-Control-Allow-Origin 在前端构建代理服务器，进行请求的转发。配置代理服务器的步骤： 编辑vue.config.js文件 ，添加代理服务器配置 1234567// 配置代理服务器，解决开发阶段的跨域问题（只在开发阶段有效）proxy: &#123; &#x27;/data&#x27;: &#123; // 所有以/data开头的请求都需要被代理转发 target: &#x27;http://127.0.0.1:80&#x27;, // 转发到的目标服务器 logLevel: &#x27;debug&#x27; // 开启调试模式 &#125; &#125; 重启开发服务器，查看日志输出 七、路由1. 简介SPA应用：Single Page Application 单页应用程序 就是只有一个Web页面的应用，所有的操作都在这个页面上完成（容器页面） 浏览器一开始会加载相应的HTML、CSS和JavaScript，然后将所有的活动都局限在该Web页面中 当用户与应用程序交互时通过JavaScript动态更新页面中的内容 在开发SPA单页应用时，需要在不同的组件间切换，从而实现在一个容器页面中显示不同的内容 我们可以使用Vue Router来开发单页应用，根据不同的url地址，路由跳转到不同的组件 路由是一种组件动态分发机制，通过url路径进行组件的切换 根据url路径查找对应的组件，然后将组件显示到指定的页面位置 2. 基本用法创建项目时选择Router路由功能 123456789|-项目名称 |-node_modules |-vue-router # 路由模块 |-src |-router |-index.js # 路由配置文件 |-views # 视图组件目录 |-App.vue |-main.js 核心文件详解：main.js、index.js、App.vue 提供了两个路由组件 &lt;router-link&gt;组件：用来定义导航，默认会创建&lt;a&gt;标签，根据指定的url路径跳转到组件 &lt;router-view&gt;组件：用来渲染url路径对应的组件，将组件显示到当前定义的位置 3. 路由嵌套当应用由多层嵌套的组件构成时，需要使用嵌套路由 关于url路径的定义： 根路径 根路径就是/，默认访问项目时显示的就是根路径对应的组件，即默认显示的组件 嵌套路由的路径 子级路由可以使用相对路径或绝对路径 通配路径 可以使用通配符 *来设置当url路径不存在时显示的组件 4. 路由传参通过&lt;router-link&gt;的to属性传递参数 两种方式： 查询字符串传参 传递参数： 字符串形式 语法：to=&quot;路径?参数名=参数值&amp;参数名=参数值&quot; 对象形式 语法：:to=&quot;&#123;path:&#39;组件的url路径&#39;，query:&#123;key:value,key:value&#125;&#125;&quot; 或 ​ :to=&quot;&#123;name:&#39;组件的路由名称&#39;，query:&#123;key:value,key:value&#125;&#125;&quot; 获取参数： 使用路由对象vm.$route.query获取参数信息 Rest风格传参 传递参数： 字符串形式 语法：to=&quot;/路径/参数/参数&quot; 将参数伪装成请求地址的一部分 在定义路由时需要在url路径中通过:参数名指定参数 对象形式 语法：:to=&quot;&#123;name:&#39;组件的路由名称&#39;，params:&#123;key:value,key:value&#125;&#125;&quot; 对于Rest风格的对象形式传参，只能使用路由名称的形式 获取参数： 使用路由对象vm.$route.params获取参数信息 5. 路由对象路由对象$route，表示当前激活的路由的状态信息，称为激活路由信息对象 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$route访问，且访问的都是同一个对象 该对象中存储着当前激活路由的相关信息 123456$route.path // 当前激活路由的路径$route.fullPath // 当前激活路由的完整路径$route.name // 当前激活路由的名称，即命名路由的name$route.query // 当前激活路由的字符串查询传递的参数$route.params // 当前激活路由的rest方式传递的参数$route.meta // 当前激活路由的元信息 路由元信息： 在定义路由时，可以通过meta属性为当前路由指定一些自定义配置项，称为元信息 在组件中可以通过$route.meta获取到这些元信息 6. 路由守卫也称为路由导航守卫，用来对路由导航进行守卫，控制导航的跳转，可以进行权限的控制 全局前置守卫：使用 router.beforeEach 12345678const router = new VueRouter(&#123; ... &#125;)// 当一个导航触发时，全局前置守卫将被调用 router.beforeEach((to, from, next) =&gt; &#123; // to 即将要访问的目标路由对象 // from 来源于哪个路由对象 // next 是一个函数，表示下一步怎么做，如：next()表示放行，next(&#x27;/login&#x27;)表示跳转到/login路径 &#125;) 全局解析守卫：使用router.beforeResolve 全局后置钩子：使用router.afterEach 7. 路由模式通过mode选项可以修改路由的模式 两种模式： hash模式（默认值） 原理：使用HTML的锚点技术，实现路由匹配和跳转 ​ 通过location.hash获取url中的锚点值，完成 url 跳转，且不会重新加载页面，即不刷新页面 缺点：地址中会出现#号，比较丑陋 history模式 原理：使用HTML5的History技术 ​ 通过history.pushState 完成 url 跳转，且不会重新加载页面 缺点：在生产环境下，如果用户在浏览器中直接访问url路径，则会报错 Not Found ​ 所以在生产环境下，需要后台服务器的配置支持才行（在开发环境下是没问题的） 8. 编程式导航除了使用&lt;router-link&gt;组件来定义导航链接，还可以通过编写js代码，调用路由实例$router的方法来实现路由跳转，称为编程式导航 路由实例$router，表示构建路由时的实例对象，主要用来对路由进行控制，称为 路由控制对象 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$router访问，且访问的都是同一个对象 该对象中包含控制路由的相关方法 1234$router.push(location) // 跳转到指定页面，参数location可以为字符串或对象$router.forward() // 向前一步$router.back() // 后退一步$router.go(n) // 向前或后退多少步 八、Vuex1. 简介Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 采用集中式存储管理应用中所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 简单来说，就是用来集中管理数据的，统一维护项目中的数据状态，相当于是一个全局的数据存储对象store，在所有组件中都可以访问 应用场景：适合于大型的单页应用程序 2. 基本用法创建项目时选择Vuex功能 1234567|-项目名称 |-node_modules |-vuex # vuex模块 |-src |-store |-index.js # vuex配置文件 |-main.js Vuex的核心是store（存储），相当于是一个容器，核心概念： State 定义属性，用来存储状态数据 Getter 定义属性，用来获取从state派生出的状态数据，类似于计算属性 Mutation 定义变化，用来改变状态数据（突变），只能是同步操作，需要通过commit来提交变化mutations Action 定义方法，用来改变状态数据，可以包含异步操作，类似于mutations，但mutations只能是同步操作 Module 用来分模块组织Vuex 3. 使用Vuex3.1 在Vuex中定义状态配置store对象： 定义state 定义getters 定义mutations 定义actions 定义modules 3.2 在组件中访问状态在组件中访问store对象，两种方式： 方式1：通过存储对象$store访问 存储对象$store，表示Vuex中定义的数据存储对象store，包含Vuex中的所有数据信息 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$store访问，且访问的都是同一个对象 方式2：通过辅助函数访问 Vuex中提供了一些辅助函数，用于获取Vuex中的数据信息，如： mapState() 获取state mapGetters() 获取getters mapMutations() 获取mutations mapActions() 获取actions 注：需要先导入辅助函数import &#123;mapState,mapGetters,mapActions&#125; from &#39;vuex&#39; 4. 模块化当应用变得非常复杂时，store对象会变得相当臃肿，store&#x2F;index.js文件内容会非常多 此时可以将store分成多个模块，每个模块拥有自己的state、getters、mutations、actions 可以根据业务分模块，如：用户数据、产品数据、购物车数据、订单数据等 可以根据页面分模块，如：主页数据、搜索页数据、详情页数据等 Vuex模块化的项目结构： 12345678910111213|-src |-store |-index.js |-state.js // 根级别的state |-getters.js // 根级别的getters |-mutations.js // 根级别的mutations |-actions.js // 根级别的actions |-modules // 分为多个模块，每个模块都可以拥有自己的state、getters、actions、mutations |-user.js // 用户模块 |-product.js // 产品模块 |-cart.js // 购物车模块 |-order.js // 订单模块 |-.... 九、Element UI1. 简介​ Element是饿了么团队提供的一套基于Vue的桌面端组件库，可以快速的搭建网站，提高开发效率 ​ 官方文档 https://element.eleme.cn 2. 用法执行 vue add element为项目安装Element插件 123? How do you want to import Element? Fully import # 完整引入? Do you wish to overwrite Element&#x27;s SCSS variables? No ? Choose the locale you want to load zh-CN ​","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue基础学习(二)","slug":"Vue基础学习-二","date":"2023-08-15T04:44:48.000Z","updated":"2023-08-15T04:54:35.537Z","comments":true,"path":"2023/08/15/Vue基础学习-二/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/","excerpt":"","text":"一、组件1. 简介​ Component 组件是可复用的Vue实例，且带有一个名字，可以把组件作为自定义元素来使用 ​ 将项目中重复出现的页面结构定义为Vue的一个组件实例，或将特殊功能封装成组件 2. 构造器继承函数构造器继承函数，语法： Vue.extend(options) 以基础 Vue 构造器为蓝本，创建一个具有指定配置项的“子类”构造器，也称为组件构造器 可以使用该子类构造器来创建Vue实例（组件） data选项必须以函数形式声明，函数内返回一个包含初始数据的对象 二、定义组件组件分类： 全局组件，在所有Vue实例中都可以使用 局部组件，只能在构建组件的 Vue实例的容器范围内使用 1. 全局组件全局组件的定义，通过全局方法 Vue.component()来定义 两种写法 方式1：Vue.component(组件名, 组件构造器) 先创建组件构造器，然后由组件构造器创建组件 方式2：Vue.component(组件名, 选项对象) 直接创建组件，传入一个选项对象 本质上还是自动调用 Vue.extend 先创建组件构造器 注：组件必须在一个已存在的Vue实例中使用，不能在页面独立使用和存在 2. 局部组件​ 局部组件的定义，依赖于某个Vue实例，通过选项 components:&#123;&#125; 来定义 ​ 用法： 123456new Vue(&#123; components:&#123; &quot;component-a&quot;:Vue.extend(&#123; /* ... */ &#125;), &quot;component-b&quot;:&#123; /* ... */ &#125; &#125;&#125;) 三、组件间数据传递1. 组件间的关系​ 页面组件的关系结构，是一个由许多组件构成的树状结构，组件间存在着两种关系：父子关系、非父子关系 ​ 默认情况下，每个组件实例都是独立的，组件间无法直接访问数据，因此需要进行组件间的数据传递，也称为组件间的通信 2. 父子组件间的数据传递2.1 父向子传递数据技术：属性绑定+数据拦截 步骤： 父组件在调用子组件时，以属性绑定的方式将要传递的数据绑定在子组件标签上 在子组件对象中，使用props选项声明获取的数据，进行绑定属性的拦截，即接收来自父组件的数据 2.2 子向父传递数据技术：事件监听+事件触发 步骤： 父组件在调用子组件时，监听子组件触发的自定义事件，并在父组件中定义回调方法，用来接收数据 在子组件中使用vm.$emit(事件名,数据)触发自定义事件 补充： 子组件向父组件传递数据是不具有响应式的，即子组件数据发生变化时并不会主动触发$emit更新父组件中数据 可以监视子组件数据的变化，当数据发生变化时手动触发$emit更新父组件中数据 四、内置全局组件Vue提供了全局的内置组件，这些组件主要完成的都是功能封装 1. 动态组件多个组件使用同一个挂载点，然后动态地在它们之间切换，称为动态组件 用法：&lt;component :is=&quot;&quot;&gt;&lt;/component&gt; 2. 缓存组件缓存非活动的组件，可以保留组件状态，避免重新渲染，默认每次都会销毁非活动组件并重新创建 一般会结合动态组件使用，用于缓存非活动的组件实例，避免组件的重复创建和删除，提高性能 用法：&lt;keep-alive&gt;动态组件&lt;/keep-alive&gt; 注：&lt;keep-alive&gt;是一个抽象组件，它自身不会渲染为一个 DOM 元素，也不会出现在组件链中 3. 分发组件实现内容的分发，可以在定义组件时指定插槽位置，调用组件时提供要替换插槽位置的内容 在开发组件时，如果组件模板中部分内容暂时不确定，则可以通过&lt;slot&gt;插槽定义页面占位 当调用组件时，再定义对应的内容，会自动替换到插槽位置 用法：&lt;slot&gt;&lt;/slot&gt; 具名插槽：为插槽指定名称，根据插槽名称进行内容分发 在定义插槽时，在slot标签上通过name属性为插槽指定名称 在提供插槽内容时，通过为template标签指定v-slot指令，并以指令参数表示插槽名称 插槽数据作用域：让插槽内容能够访问子组件中的数据，通过作用域插槽控制内容分发时变量的取值范围 在定义插槽时，在slot标签上通过v-bind进行数据绑定 在提供插槽内容时，通过v-slot指令接收绑定的数据，获取的是一个自定义对象","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue基础学习","slug":"Vue基础学习","date":"2023-08-15T03:31:38.000Z","updated":"2023-08-15T03:49:00.320Z","comments":true,"path":"2023/08/15/Vue基础学习/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、MVVM1. 简介Model-View-ViewModel 模型-视图-视图模型 模型：构成页面内容的相关数据 视图：展示数据的页面 视图模型：介于模型和视图之间，它是连接view和model的桥梁，也是mvvm设计模式的核心思想 2. MVVM框架实现MVVM设计思想的框架： 基本上都高度封装了view-model的交互过程，完成对DOM功能的极限封装 开发者几乎不用操作DOM就可以完成页面和数据的关联交换 开发者只需关心页面的构成和数据的构成，无需关心页面和数据的状态关系 Vue、React、Angular等就是实现MVVM设计思想的前端框架 二、Vue1. 简介 Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架（入门简单、学习成本低，随着深入学习可以根据需求进行功能扩展） Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合 通过简洁的API实现响应的数据绑定和灵活的视图组件 由个人维护：尤雨溪，华人 2. 基本使用Vue的页面使用方式： 即在页面中直接引入Vue核心库的js文件 该方式只是为了让开发者在学习Vue语法时可以快速掌握 实际上Vue并不适合直接使用 页面方式进行语法定义，更推荐使用模块化方式 使用步骤： 获取Vue核心库的js文件 通过地址 https://cdn.jsdelivr.net/npm/vue/dist/vue.js 下载 使用 npm 下载： npm install vue 在页面中引入Vue 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; 创建Vue实例并应用 3. 调试工具安装vue-devtools插件，便于在Chrome浏览器中调试vue 步骤： 将vue-devtools.zip解压缩 打开Chrome浏览器的更多工具——&gt;扩展程序 将解压后的chrome目录拖放到扩展程序中即可 在VSCode中安装Vue相关插件：Vue 3 Snippets、Vetur、Vue Peek、vue-helper 三、基本交互1. 插值表达式语法： &#123;&#123; &#125;&#125; 由两对大括号组成，称为“Mustache”语法 作用：用于在页面标签中插入值，进行数据的绑定显示，且当值发生变化时标签会重新渲染加载，称为响应式特性，即数据状态同步操作 用法：&lt;标签&gt;&#123;&#123; Vue对象数据仓库变量|JS表达式|JS内置对象 &#125;&#125;&lt;/标签&gt; 只能用在标签中间的内容位置 可以绑定三种数据： 数据仓库中的变量 简单的JS表达式 JS内置对象 2. 指令2.1 简介指令 (Directives）是用来扩展html标签的功能，以v-作为前缀 语法： &lt;标签 v-指令名[:参数][.修饰符][=&quot;指令值&quot;]&gt;&lt;/标签&gt; 指令名：指令的名称 指令值：指令的取值，可选 参数：限制当前指令的操作范围，可选 修饰符：限制当前指令的触发条件，可选 特性：无痕迹特性 代码开发时的vue语法，在项目运行时会被删除，不会显示 Vue对象和容器在完成语法解析后，不会在浏览器上保留vue语法定义 2.2 常用指令 指令 取值 作用 v-text string 更新元素的textContent v-html string 更新元素的innerHTML v-pre 无 跳过当前元素和子元素的编译过程，不对vue语法进行编译执行 v-once 无 对当前元素和子元素的vue功能只执行一次 v-cloak 无 在vue实例构建完成前，隐藏未编译的vue语法，需要配合css样式一起使用 v-on Function | Object | Array | 行内表达式 绑定事件监听器，用于事件绑定 v-show any 根据表达式的boolean结果，切换元素的 display CSS 属性，控制元素的显示隐藏 v-if、v-else-if、v-else any 根据表达式的boolean结果，执行元素的创建和删除操作，控制元素的显示隐藏 v-for Array | Object | number | string 基于数据多次渲染元素或模板块，用于循环数据 v-bind any 动态的为标签绑定属性，用于属性绑定 2.3 指令详解v-on事件绑定指令 语法：&lt;标签 v-on[:参数][.修饰符]=&quot;取值&quot;&gt;&lt;/标签&gt; 缩写：可以使用@替代v-on: 参数：指定事件的名称，即事件类型 取值：Function | Object | Array | 行内表达式 修饰符： 按键修饰符——&gt;只有当点击对应的按键时才触发 功能修饰符——&gt;实现特定的功能 修饰符 含义 .capture 添加事件监听器时使用事件捕获模式 .stop 阻止事件传播，调用 event.stopPropagation() .self 只当事件是元素本身触发时才执行回调，即不是事件传播引起的 .prevent 阻止事件的默认行为，调用 event.preventDefault() .once 事件只触发一次 v-bind属性绑定指令 语法：&lt;标签 v-bind[:参数]=&quot;取值&quot;&gt;&lt;/标签&gt; 缩写：省略v-bind 参数：指定要绑定的属性 取值：any 注意：特殊属性的绑定，如boolean类型属性、class、style 3. 响应式原理响应式的概念：实际上就是所谓的数据状态同步操作，当内存中变量数据发生变化时，页面会及时做出响应，进行页面重构渲染 响应式的基础：：Object.defineProperty(obj, prop, descriptor) 用于定义一个对象上的属性以及这个属性的描述符 obj : 操作的目标对象 prop：操作的属性名称 descriptor：属性的详细定义 get（function）：拦截属性的取值操作，为取值操作提供扩展功能 set（function）：拦截属性的赋值操作，为赋值操作提供扩展功能 响应式的原理： 数据劫持 使用Object.defineProperty()实现，称为JS的数据劫持 ​ 注：Vue 不支持 IE8 以及更低版本浏览器 4. 双向数据绑定v-model双向数据绑定指令 语法：&lt;标签 v-model[.修饰符]=&quot;取值&quot;&gt;&lt;/标签&gt; 取值：随表单控件类型不同而不同 限制：仅限于表单中可输入或者可选择的元素，如&lt;input&gt;、&lt;select&gt; 、&lt;textarea&gt; 修饰符： 修饰符 含义 .lazy 使用 change 事件替代input事件 .number 将输入的值转换为数字 .trim 去除首尾的空格 双向数据绑定： 模型数据变化时重新渲染页面（基于Object.defineProperty） 页面数据变化时自动更新模型数据（基于元素事件监听） 四、数据控制​ 对数据进行包装处理和监控 1. 计算属性​ 计算属性（computed）也是用来存储属性数据的，但具有以下特点： 可以对数据进行逻辑处理操作，实现数据包装 计算属性通常依赖于当前Vue对象中的普通属性 当依赖的普通属性发生变化时计算属性也会变化，实现数据监控 ​ 计算属性由两部分组成： get 用来获取计算属性 set 用来设置计算属性 ​ 默认计算属性只有get，如果需要set，可以自己添加，此时需要以对象的形式配置 2. 监视器监视器（watch）是用来监视数据的变化，对数据进行监控 12345678910new Vue(&#123; watch: &#123; 变量:function(newValue, oldValue)&#123;&#125;, // 监控方法 变量:&#123; handler: function(newValue, oldValue)&#123;&#125;, // 监控方法 deep: true, // 开启深度监视 immediate: true // 开启初始化触发 &#125; &#125;,&#125;) 五、实例属性和方法1. 简介​ 通过Vue实例对象可以直接访问的属性和方法，称为实例属性和实例方法 ​ 实例属性和方法都以 $ 开头 2. 实例属性 vm.$el：当前Vue实例使用的根 DOM 元素 vm.$data：当前Vue实例观察的数据对象 vm.$options：当前Vue实例的初始化选项 vm.$refs：当前Vue实例容器中定义了ref属性的所有 DOM 元素 3. 实例方法 vm.$mount：手动挂载Vue实例 vm.$destroy：销毁Vue实例，只会销毁vue的实例对象，不会销毁与其关联的页面容器 vm.$nextTick：在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM并操作 vm.$set：为对象|数组添加一个属性|元素，并实现响应式，触发更新视图，实时监视，等同于全局方法 Vue.set vm.$delete：删除对象|数组的属性|元素，触发更新视图，等同于全局方法 Vue.delete 六、模板和渲染函数1. 模板​ 模板（template）就是定义Vue时指定的页面结构构成 默认使用el选项指定的挂载元素的内容来构成页面模板，同时指定挂载位置 可以使用 template 选项独立定义页面模板，此时el挂载元素的内容将被忽略 2. 渲染函数​ 渲染函数（render）用于通过JavaScript方式定义页面结构模板 默认通过el或template方式定义的页面模板也会被render渲染函数执行 可以使用 render 选项独立定义页面结构的渲染函数，此时template模板将被忽略 优先级：render &gt; template &gt; el 3. 虚拟DOM 模板转换为视图的过程： 将模板template编译成渲染函数render，执行渲染函数就可以得到一个虚拟节点树，即虚拟DOM 然后将虚拟节点树转换为真实DOM，映射到视图上 当Model数据更新时，Vue能够智能地计算出需要重新渲染的节点并对虚拟DOM进行修改（打补丁），然后再更新到视图上 虚拟DOM是什么？ 虚拟DOM（vdom）是一个用JavaScript对象方式描述的页面节点结构树，通过对象的属性来描述节点 实际上它只是对真实DOM的抽象，最终会通过一系列操作使这个虚拟DOM变为真实的DOM，显示在页面上 为什么使用虚拟DOM（优点）： 提高DOM更新效率，提升渲染性能 提供快速的DOM变化比较 减少页面中DOM重新渲染的次数（基于diff算法：找出本次DOM需要更新的节点来更新，其他的不更新） 注：JavaScript直接操作真实DOM时效率是比较低的，需要频繁的操作。 七、生命周期1. 简介Vue实例从创建到销毁的过程，称为生命周期，共有八个阶段： beforeCreate、created beforeMount 、mounted beforeUpdate、updated beforeDestroy、destroyed 在生命周期的每个阶段都提供了相应的钩子函数，可以在钩子函数中执行操作，控制生命周期的各个阶段 2. 生命周期流程 八、自定义指令分类：局部指令、全局指令 1. 局部指令在某个Vue实例中定义的指令，只在该Vue实例关联的容器中有效 123456789101112new Vue(&#123; directives:&#123; 指令名称:&#123; // 提供了5个钩子函数，在不同时机执行 bind: function (参数) &#123;&#125;, inserted: function (参数) &#123;&#125;, update: function (参数) &#123;&#125;, componentUpdated: function (参数) &#123;&#125;, unbind: function (参数) &#123;&#125; &#125; &#125;&#125;); 钩子函数的参数： 1234bind: function (el, binding, vnode, oldVnode) &#123; // el 指令所绑定的元素，DOM对象 // binding 一个对象，包含指令的相关信息&#125; 2. 全局指令使用全局方法 Vue.directive(指令ID,定义对象)定义的指令，在所有Vue实例中都有效 12345678Vue.directive(&#x27;指令名称&#x27;,&#123; // 提供了5个钩子函数，在不同时机执行 bind: function (参数) &#123;&#125;, inserted: function (参数) &#123;&#125;, update: function (参数) &#123;&#125;, componentUpdated: function (参数) &#123;&#125;, unbind: function (参数) &#123;&#125;&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"SpringMVC学习","slug":"SpringMVC学习","date":"2023-08-14T06:41:15.000Z","updated":"2023-08-15T02:49:51.535Z","comments":true,"path":"2023/08/14/SpringMVC学习/","link":"","permalink":"http://example.com/2023/08/14/SpringMVC%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、SpringMVC简介1. 什么是MVC​ M：model 数据模型，封装了业务逻辑，对业务数据进行处理 ​ V：view 视图，封装了显示逻辑，如HTML、JSP、Excel、PDF等 ​ C：controller 控制器，控制整个网站的处理流程，协调视图与模型 ​ MVC是一种Web应用架构，是一种代码设计思想 ​ 思想：将所有客户端请求全部交由控制器，由控制器将其分发，并将结果响应回客户端 ​ 注：区别MVC和三层架构 2. SpringMVC优点​ 简单，使用注解配置替代原生XML配置 ​ 效率高，单例的，将Controller层对象交给IoC容器管理 ​ 扩展性好，方便用户自定义 ​ SpringMVC和Spring无缝衔接 3. 实现原理3.1 流程图 3.2 执行过程分为六步： DispatcherServlet SpringMVC核心控制器：主要作用是用来分发，不进行任何处理 HandlerMapping 映射处理器：根据请求URL映射到具体的处理器Handler Handler就是Controller层实现类，也可称为Controller或Action HandlerAdapter 适配器：用来适配不同的处理器Handler 处理器有两种实现方式：实现接口、基于注解，所以执行之前需要先适配，这样才能知道如何执行 Handler 处理器：执行处理具体业务，并产生数据模型Model和视图名View Handler将数据模型和视图封装成ModelAndView对象并返回 ViewResolver 视图解析器：根据视图名解析为具体的视图，一般多为jsp页面，然后封装为View对象 View 视图：使用具体视图技术进行渲染，结合Model展示数据 视图有很多种形式，如jsp、freemarker、velocity、pdf、excel等 二、第一个SpringMVC程序1. 添加依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&lt;/dependency&gt; 2. 创建Controller12345678910@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public ModelAndView sayHello(String name)&#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;msg&quot;,&quot;Hello &quot;+name); mav.setViewName(&quot;hello&quot;); return mav; &#125;&#125; 3. 核心配置文件名称自定义，如springmvc.xml 1234567891011&lt;!-- 扫包 --&gt;&lt;context:component-scan base-package=&quot;controller&quot;/&gt;&lt;!-- mvc的注解驱动 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 配置ViewResolver --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/view/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 4. 配置核心控制器在web.xml中配置SpringMVC核心控制器，需要指定配置文件的路径 1234567891011121314&lt;!-- 配置DispatcherServlet，核心控制器，本质上就是一个Servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5. 静态资源处理当配置DispatcherServlet的url-pattern为/时，会拦截所有请求（包括静态资源），导致所有静态资源都无法访问 两种处理方式： 使用tomcat提供的默认Servlet 1&lt;mvc:default-servlet-handler/&gt; 使用SpringMVC提供的处理方式 1&lt;mvc:resources mapping=&quot;/imgs/**&quot; location=&quot;/WEB-INF/imgs/&quot; /&gt; 三、方法的返回值1. 返回值类型共有四种类型： ModelAndView 表示数据模型和视图 String 三种形式（写法）： 普通字符串 ——&gt; 表示视图名称，转发到指定视图 forward:url ——&gt; 转发到指定url redirect:url ——&gt; 重定向到指定url void 表示使用HttpServletResponse处理响应 Object 一般需要结合@ResponseBody使用 2. @ResponseBody将方法返回值写到响应体中，一般用来处理Ajax请求，返回JSON数据 SpringMVC默认使用jackson处理json数据的转换，所以需要引入jackson的依赖 可以使用@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;)，设置响应时的日期格式 123456&lt;!--jackson--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 注：也可以使用@RestController，相当于@Controller+@ResponseBody 常用注解： @JsonFormat 指定序列化和反序列化时的格式，一般用于指定日期、时间和数字的格式 @JsonProperty 指定序列化和反序列化时的名称 @JsonAlias 指定反序列化时的备用别名 @JsonIgnore 指定序列化和反序列化时忽略属性 注： json序列化：将Java对象转换为json字符串 json反序列化：将json字符串转换为Java对象 3. 跨域访问允许跨域访问 方式一：使用@CrossOrigin注解，可以在类或方法上添加该注解 方式二：在xml中添加如下配置 123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;/mvc:cors&gt; 四、方法的参数1. JavaEE组件HttpServletRequest HttpServletResponse HttpSession 2. String、基本类型及包装类@RequestParam 表示参数来源于请求参数，默认为所有参数添加该注解，参数值来源于同名称的请求参数 @PathVariable 表示参数来源于URL（URL就是请求路径） @RequestHeader 表示参数来源于请求头 @CookieValue 表示参数来源于Cookie @RequestBody 表示参数来源于请求体，用来接收前端传递给后端的 json 格式的数据 请求的方式必须为post，post请求才会有请求体 请求的内容类型必须为 json格式，需要设置contentType为application/json;charset=utf8 4. 自定义对象例如：User、UserDTO、UserVo等 @ModelAttribute 将请求数据转换为对象，默认为所有自定义类型添加该注解 要求对象的属性名必须与参数名相同 可以使用@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)，设置接收时的日期格式 注意： 可以使用SpringMVC提供的CharacterEncodingFilter解决POST请求中文乱码问题 控制台输出有乱码时，可以设置tomcat的VM options为-Dfile.encoding=utf8 五、请求路径1. @RequestMapping该注解可以定义在方法上，也可以定义在类上，表示层级关系 请求映射路径的写法： 固定写法 value和path属性互为别名，其值是一个数组，可以指定多个值，允许通过多个路径访问 Rest风格 {变量}表示URL中的占位符，URL中必须有对应的值，可以结合@PathVariable获取值 2. 限定请求方式method属性 限定请求方式：GET、POST、PUT、DELETE等 也可使用@GetMapping、@PostMapping、@PutMapping、@DeleteMapping等注解限定请求方式 六、全局异常处理步骤： 定义一个异常处理类，添加@ControllerAdvice或@RestControllerAdvice 定义异常处理方法，添加@ExceptionHandler 七、拦截器拦截器Interceptor对请求进行拦截处理，类似于过滤器Filter 步骤： 定义一个类，实现HandlerInterceptor接口 1234567891011121314151617181920212223public class HelloInterceptor implements HandlerInterceptor &#123; // 调用目标处理方法之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;HelloInterceptor.preHandle&quot;); return true; // true表示放行，继续调用目标处理方法，false表示不放行 &#125; // 调用目标处理方法之后执行，渲染视图之前 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;HelloInterceptor.postHandle&quot;); &#125; // 渲染视图之后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;HelloInterceptor.afterCompletion&quot;); &#125;&#125; 配置拦截器 12345678&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot; /&gt; &lt;mvc:mapping path=&quot;/path/**&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/path/path1&quot;/&gt; &lt;!-- 排除拦截该请求 --&gt; &lt;bean class=&quot;interceptor.HelloInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 八、文件上传SpringMVC为文件上传提供了支持，基于commons-fileupload 步骤： 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 配置文件解析器 12345&lt;!-- 配置文件解析器，id名称必须为multipartResolver --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot;/&gt;&lt;/bean&gt; 编写页面 12345&lt;form id=&quot;uploadForm&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt; &lt;br&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;doUpload()&quot;&gt;&lt;/form&gt; 编写FileController类 123456789101112131415161718192021/* * 通过参数CommonsMultipartFile接收文件 * 必须在参数前添加@RequestParam注解，否则无法接收文件 */@PostMapping(&quot;/upload&quot;)public AjaxResult upload2(String name, @RequestParam CommonsMultipartFile avatar, HttpServletRequest req) throws IOException &#123; System.out.println(name); System.out.println(avatar); System.out.println(avatar.getOriginalFilename()); // 文件名 System.out.println(avatar.getSize()); // 文件大小 System.out.println(avatar.getInputStream()); // 文件的输入流 String uploadPath = req.getServletContext().getRealPath(&quot;upload&quot;); String filename = UUID.randomUUID() + &quot;.&quot; + FileNameUtil.getSuffix(avatar.getOriginalFilename()); String filePath = uploadPath + File.separator + filename; System.out.println(filePath); avatar.transferTo(new File(filePath)); return AjaxResult.success(filename);&#125; ​ 注：maven打包时默认会忽略空目录，不对空目录进行打包，可以先手动创建一个文件 九、综合案例基于SSM的员工管理系统（ssm-ems） 后端 SSM 前端 LayUI","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Spring学习","slug":"Spring学习","date":"2023-08-10T02:57:52.000Z","updated":"2023-08-11T00:31:36.372Z","comments":true,"path":"2023/08/10/Spring学习/","link":"","permalink":"http://example.com/2023/08/10/Spring%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Spring简介1. Spring是什么？​ spring单词本义是“春天”，程序员的春天 ​ 是一个开源的控制反转(IoC)和面向切面(AOP)的容器框架，用来简化企业开发 ​ 官网：https://spring.io 2. 为什么使用Spring​ 降低组件之间的耦合度，实现软件各层之间的解耦 ​ 提供了众多的技术支持 ​ 对主流框架提供了集成 3. 核心概念IoC：Inversion Of Control 控制反转 控制反转(IoC)就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护由外部容器负责，这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。 外部容器&#x2F;IoC容器：存放对象（bean）的容器 12345678//Service依赖于DAOpublic class UserServiceImpl&#123; //UserDaoImpl由应用内部(Service)创建及维护 private UserDao userDao = new UserDaoImpl(); public void regist(User user)&#123; userDao.insert(user); &#125;&#125; DI：Dependency Injection 依赖注入 依赖注入(DI)就是指在运行期，由外部容器动态地将依赖对象注入到组件中。 1234567891011//依赖对象的创建及维护由外部容器负责public class UserServiceImpl&#123; private UserDao userDao; //通过setter方法，让容器把创建好的依赖对象注入到Service中 public void setUserDao(UserDao userDao)&#123; this.userDao=userDao &#125; public void regist(User user)&#123; userDao.insert(user); &#125;&#125; 二、第一个Spring程序1. 添加依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.27&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 核心配置文件​ 用来进行bean的配置，文件名可自定义，一般默认为applicationContext.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd &quot;&gt; &lt;!-- 定义一个bean id：指定bean的名称 class：指定bean的类型 --&gt; &lt;bean id=&quot;helloSpring&quot; class=&quot;ioc01.HelloSpring&quot;&gt; &lt;!-- 为bean中的属性注入值 --&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3. 操作1234567public static void main(String[] args) &#123; // 获取IoC容器，读取配置文件，初始化Spring上下文 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc01/applicationContext.xml&quot;); // 根据id名称获取bean的实例 HelloSpring helloSpring=(HelloSpring) ac.getBean(&quot;helloSpring&quot;); helloSpring.show();&#125; 4. 案例用户登陆 12345678910&lt;bean id=&quot;userDao&quot; class=&quot;ioc02.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;ioc02.service.impl.UserServiceImpl&quot;&gt; &lt;!-- 通过ref属性注入bean --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userController&quot; class=&quot;ioc02.controller.UserController&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;&lt;/bean&gt; 三、数据装配1. 简介为bean中的属性注入值，称为数据的装配，可装配不同类型的数据： 简单类型 ——&gt; 使用value ​ 基本类型及包装类型、String 其他bean的引用 ——&gt; 使用ref 集合类型 ——&gt;使用相对应的子元素 数组 List Set Map Properties 注：数据装配是通过setter方法进行的，所以必须有setter方法 2. 基本用法123456789101112131415161718192021222324252627282930313233&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;property name=&quot;otherBean&quot; ref=&quot;otherBean&quot;/&gt; &lt;property name=&quot;arrays&quot;&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;lists&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;otherBean&quot;/&gt; &lt;bean class=&quot;ioc03.OtherBean&quot;&gt; &lt;property name=&quot;sex&quot; value=&quot;male&quot;/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aaa&quot; value-ref=&quot;otherBean&quot;/&gt; &lt;entry key=&quot;bbb&quot; value-ref=&quot;otherBean&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/test&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3. 自动装配对于其他bean的引用的装配，IoC容器可以根据bean的名称、类型或构造方法进行自动的注入，称为自动装配 通过bean元素的autowire来配置 1234567891011&lt;!-- 自动装配 autowire 可取值如下： no：不进行自动装配，默认值，同default byName：根据属性名自动装配，自动查找与属性名相同的bean byType：根据属性类型自动装配，自动查找与属性类型相同的bean constructor：根据构造方法自动装配 根据构造方法参数的名称或类型进行自动装配，只要有一个可以装配就行 此时与setter方法无关，可以没有setter方法 --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; autowire=&quot;constructor&quot;/&gt; 四、bean管理1. bean生命周期​ 生命周期：实例化–&gt;数据装配–&gt;初始化方法–&gt;使用–&gt;销毁方法–&gt;从容器中销毁 1234&lt;!-- 生命周期的扩展 init destory --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ​ 在bean实例化并进行数据装配后，会调用初始化方法，执行初始化操作 ​ 在bean销毁之前会调用销毁方法，执行销毁前的操作 2. bean实例化时机​ 默认预先实例化，即在容器启动时实例化，可以设置懒实例化，在第一次使用bean时实例化 123&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; lazy-init=&quot;true&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3. bean作用域​ 在IoC容器中bean默认是单例的 ​ 通过bean元素的scope属性来设置bean的作用域，即是否为单例模式 123456&lt;!-- scope属性 可取值如下： singleton：单例，在容器启动时初始化，默认值 prototype：多例，在每次获取bean时初始化 --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; scope=&quot;prototype&quot;/&gt; 4. 在普通类中获取bean实际开发中，并不是所有类都需要交由IoC容器管理，某些类并不需要交由容器管理，如各种工具类，本身都提供了静态方法 问题：没有交由容器管理的类，容器是无法进行数据装配的，如何在这些类中获取容器中的bean呢？ 解决：使用ApplicationContextAware获取容器，然后从容器中获取bean 定义IoC容器工具类，步骤： 定义一个类，实现ApplicationContextAware接口 将该类添加到IoC容器中，当实例化时会自动注入当前的ApplicationContext 调用IoC容器工具类，从容器中获取bean 1234567891011121314151617181920212223242526272829303132public class ApplicationContextHolder implements ApplicationContextAware&#123; private static ApplicationContext ac; /** * 会自动注入当前的IoC容器 */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.ac = applicationContext; &#125; /** * 根据名称获取bean * @param beanName * @return */ public static Object getBean(String beanName)&#123; return ac.getBean(beanName); &#125; /** * 根据类型获取bean * @param clazz * @return * @param &lt;T&gt; */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123; return ac.getBean(clazz); &#125;&#125; 五、注解配置1. 简介​ Spring提供了一系列注解来替代配置文件，简化配置 ​ 使用注解时，需要扫描注解所在的包 123&lt;context:component-scan base-package=&quot;net.wanho.dao.impl&quot;/&gt;&lt;context:component-scan base-package=&quot;net.wanho.service.impl&quot;/&gt;&lt;context:component-scan base-package=&quot;net.wanho.controller&quot;/&gt; 2. 常用注解2.1 定义组件@Component 定义组件Bean，添加到IoC容器中，不区分组件类型 区分组件类型的注解： @Repository 表示Dao组件 @Service 表示Service组件 @Controller 表示Controller组件 注：以上三个注解和@Component的作用相同，只是用来表示不同的组件类型 2.2 数据装配注解方式的数据装配是直接使用属性进行注入，不是使用setter方法，所以可以没有setter方法 简单类型 123456789@Value(&quot;666&quot;)private int num;@Value(&quot;true&quot;)private Boolean flag;// @Value(&quot;tom&quot;)@Value(&quot;$&#123;username&#125;&quot;)private String username; 12&lt;!-- 引用属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:ioc/info.properties&quot;/&gt; 其他bean的引用，使用@Autowired 或 @Resource 12345678910111213141516171819202122232425262728// @Autowired // Spring提供的注解，默认按类型注入，如果有多个同类型的，则按名称注入@Resource // Java提供的注解，默认按名称注入，如果没找到，则按类型注入private OtherBean otherBean;/* * 方式1：基于field注入，即在属性上面添加@Autowired或@Resource */@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao;&#125;/* * 方式2：基于constructor注入，即在构造方法上面添加@Autowired或@Resource * 优点：可以为final属性注入、质量高（Spring官方推荐） */@Controller@RequiredArgsConstructor // 可以使用lombok的@RequiredArgsConstructor注解来生成带参构造方法（属性要使用final修饰）public class UserController &#123; private final UserService userService; // @Autowired // 如果类中只有一个构造方法，可以省略该注解 // public UserController(UserService userService) &#123; // this.userService = userService; // &#125;&#125; 2.3 bean生命周期1234567891011// 相当于init-method@PostConstructpublic void init() &#123; System.out.println(&quot;SpringBean.init()&quot;);&#125;// 相当于destroy-method@PreDestroypublic void destroy() &#123; System.out.println(&quot;SpringBean.destroy()&quot;);&#125; 2.4 bean实例化时机123// 默认是预实例化，配置为懒初始化@Lazypublic class SpringBean &#123;&#125; 2.5 scope作用域123//默认是单例，配置为非单例@Scope(&quot;prototype&quot;)public class SpringBean &#123;&#125; 六、AOP1. 简介​ AOP：Aspect Oriented Programming 面向切面编程，是OOP面向对象编程的一种补充 ​ 将程序中的交叉业务逻辑（事务、日志、异常等）代码提取出来，封装成切面，由AOP容器在适当的时机（位置）将封装的切面动态的织入到具体业务逻辑中。 2. 作用 在不改变原有代码的基础上动态添加新的功能 模块化，将分散在各层中的相同代码，通过横向切割的方式抽取到单独的模块中 方便维护 可扩展性强 3. 原理AOP的原理是使用动态代理技术 动态代理的含义： 代理类是在程序运行期间由JVM根据反射等机制动态生成的，自动生成代理类和代理对象 所谓动态是指在程序运行前不存在代理类的字节码文件，代理类和委托类的关系是在程序运行时确定 动态代理的两种技术： jdk技术：适用于有接口时使用，目标对象必须实现一个或多个接口，否则无法使用jdk动态代理 cglib技术：适用于无接口时使用（有接口时也可以使用） 注：Spring默认使用的是jdk动态代理，SpringBoot默认使用的是cglib动态代理 4. 用法步骤： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;&lt;/dependency&gt; 配置Advice 定义增强类并添加@Component和@Aspect注解，表示其为一个切面 配置Pointcut 定义切点表达式 在一个空方法上添加@Pointcut注解，配置切点表达式 为方法添加通知类型注解并指定切点 @Before 前置通知，在方法执行前添加功能 @AfterReturning 后置通知，在方法执行后添加功能 @AfterThrowing 异常通知，在方法抛出异常后添加功能 @Around 环绕通知 在方法执行前后添加功能 配置自动创建代理并织入 1&lt;aop:aspectj-autoproxy /&gt; 七、Spring整合JDBC12345678910drop database if exists spring;create database spring charset utf8;use spring;create table t_user( id int primary key auto_increment, username varchar(50) not null unique, password varchar(50) not null) charset utf8; 1. 基本用法步骤： 添加依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 配置 DataSource–&gt;JdbcTemplate–&gt;Dao–&gt;Service–&gt;Controller 123456@Repositorypublic class UserDaoJdbcImpl implements UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate; // ...&#125; 1234567891011121314&lt;context:property-placeholder location=&quot;classpath:datasource.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2. 事务操作​ JDBC默认是自动提交事务的，每执行完一条SQL语句就提交事务 ​ 问题：如果Service层出现异常，并不会回滚，怎么办？ ​ 解决：配置事务操作（使用的是环绕通知） 1234567&lt;!-- 定义事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务的注解驱动 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 12345678910111213141516// @Transactional也可以配置在类上，如果方法上没有配置@Transactional，则使用类上的事务配置@Transactional(propagation = Propagation.REQUIRED,rollbackFor = Exception.class)public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override @Transactional(propagation = Propagation.SUPPORTS, readOnly = true) public User login(String username, String password) &#123; &#125; @Override //@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, noRollbackFor = ArithmeticException.class, timeout = 3000) public void regist(UserVo userVo) &#123; &#125;&#125; 3. 事务属性和事务特性3.1 事务属性​ 五个事务属性：传播属性、隔离级别、回滚条件、只读优化、超时处理 传播属性 propagation：定义事务的边界，用来配置当前方法是否需要有事务，常用取值： REQUIRED 必须添加事务，如果当前没有事务则创建一个新的事务，一般用于增删改 SUPPORTS 可以没有事务，如果当前有事务则运行，如果没有事务也可以运行，一般用于查询 隔离级别 isolation：用来解决事务并发时会出现的一些问题，四种隔离级别，由低到高依次为： READ_UNCOMMITTED 读未提交——&gt;可能出现脏读、不可重复读、幻读 READ_COMMITTED 读已提交——&gt;避免脏读，但可能出现不可重复读、幻读 REPEATABLE_READ 可重复读——&gt;避免脏读、不可重复读，但可能出现幻读（MySQL默认隔离级别） SERIALIZABLE 可序列化（串行）——&gt;避免脏读、不可重复读、幻读，相当于是单并发，没意义 事务并发时会出现的三个问题（脏读、不可重复读、幻读或虚读）： 脏读: 一个事务读取到另一个事务中没有提交的数据，一般不会发生，如MySQL、Oracle底层默认都是只读取提交的数据 12345-- 打开两个session，即同时登陆两个账户mysql -uroot -pset autocommit=off; insert into t_user values(null,&#x27;alice&#x27;,&#x27;123&#x27;);select * from t_user; 不可重复读 : 一个事务已经读取数据，另一个事务在修改数据，可能导致使用的数据与数据库不同步 幻读或虚读 : 一个事务已经读取数据量，另一个事务在添加或删除数据，可能导致使用的数据量与数据库不一致 注：不可重复读和虚读都是小概率事件，实际开发中一般不需要配置隔离级别，大多是通过定时任务来检查+人工审核 回滚条件 rollback：默认抛出RuntimeException时才进行回滚 ​ rollbackFor&#x3D;”” 表示发生该异常时回滚 ​ noRollbackFor&#x3D;”” 表示发生该异常时不回滚 只读优化 readOnly：在该事务中只能读取，一般用于查询 超时处理 timeout：配置事务超时的时间，一般不配置 3.2 事务特性​ 四个事务特性：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、永久性(Durability) ​ 简称为ACID 八、Spring整合MyBatis​ 步骤： 添加依赖 12345678910111213141516&lt;!-- Spring整合MyBatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.13&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 创建Mapper映射文件 映射文件存放位置，两种形式： 将映射文件放在resources目录下 映射文件会进行打包部署 将映射文件放在java目录下 默认只会对该目录下的java代码进行打包部署，如果希望对该目录下的配置文件也进行打包，需要添加额外的配置 编辑pom.xml文件： 123456789101112131415161718192021&lt;build&gt; &lt;resources&gt; &lt;!-- 将java目录下的配置文件也进行打包 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 配置 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 可以引用独立的mybatis配置文件，也可以不用 --&gt; &lt;!-- &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 指定映射文件所在路径 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:org/wanho/mapper/*Mapper.xml&quot;&gt;&lt;/property&gt; &lt;!-- 为映射的类指定别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;net.wanho.entity&quot;&gt;&lt;/property&gt; &lt;!-- 自定义配置 --&gt; &lt;property name=&quot;configuration&quot;&gt; &lt;bean class=&quot;org.apache.ibatis.session.Configuration&quot;&gt; &lt;!-- 打印sql --&gt; &lt;property name=&quot;logImpl&quot; value=&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;/&gt; &lt;!-- 下划线映射为驼峰 --&gt; &lt;property name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 分页插件 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;helperDialect&quot;&gt;mysql&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 通过反射创建Dao实现类，然后放到IoC容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 指定Dao接口所在的包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;net.wanho.dao&quot;/&gt; &lt;!--注入sqlSessionFactory，通过value注入String类型的名称--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"MyBatis学习","slug":"MyBatis学习","date":"2023-08-08T05:28:46.000Z","updated":"2023-08-09T02:44:35.508Z","comments":true,"path":"2023/08/08/MyBatis学习/","link":"","permalink":"http://example.com/2023/08/08/MyBatis%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、简介1. MyBatis是什么MyBatis的前身叫iBatis 是一个持久层框架，或称为 ORM框架 用来访问数据库，做数据持久化操作 本质上只是对JDBC进行封装，简化JDBC繁琐的操作 ​ 注：框架就是别人写好的，对某些技术进行的封装，封装成对应的jar、js、css等，我们可以直接拿过来使用，简化开发 2. 持久层​ DAO：Data Access Object 数据访问对象 ​ 用来对数据进行持久化操作，如将数据存入数据库、硬盘等，可以永久保存 3. ORMObject Relational Mapping 对象关系映射 Java程序和数据库之间的映射关系： 类 ——&gt; 表 对象 ——&gt; 一条数据 属性 ——&gt; 列 4. 回顾JDBC​ JDBC访问数据库的步骤 1234567891011Class.forName(driverClassName);Connection conn = DriverManager.getConnection(url,user,password);PrepareStatement ps = conn.preparedStatement(sql);//ps.executeUpdate()ResultSet rs = ps.executeQuery();while(rs.next)&#123; //RM(RowMapper)行映射&#125;rs.close();ps.close();conn.close(); 数据库操作中的可变部分： 连接信息 dirverClassName、 url、user、password（也称为数据源datasource） SQL语句 RM行映射 二、第一个MyBatis程序1. 创建项目并添加依赖1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 数据库设计1234567891011drop database if exists mybatis;create database mybatis charset utf8;use mybatis;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(20) unique not null comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, phone varchar(20) comment &#x27;电话&#x27;, address varchar(100) comment &#x27;地址&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 3. 创建主配置文件config主配置文件，在一个mybatis工程中有且只有一个 用来配置与整个工程相关的信息，如环境配置、别名配置、插件配置、注册mapper文件等 文件名可自定义，一般命名为mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments：配置当前工程中可能使用的所有数据库环境 default属性：指定默认使用的环境，取值为某一个environment的id --&gt; &lt;environments default=&quot;hello&quot;&gt; &lt;!-- envirinment：配置某一个数据库环境，可以有多个 id属性：指定该环境的唯一标识符 --&gt; &lt;environment id=&quot;hello&quot;&gt; &lt;!-- transactionManager：配置事务管理器 type属性：指定事务管理器的类型，取值有两种： jdbc：使用简单的jdbc事务操作，如开启、提交、回滚 在mybatis中，默认是关闭自动提交事务的，即conn.setAutoCommit(false) managed：将事务交给其他框架/容器来处理，如spring mybatis不负责事务，什么都不会做 --&gt; &lt;transactionManager type=&quot;jdbc&quot;&gt;&lt;/transactionManager&gt; &lt;!-- dataSource：配置数据源 type属性：配置数据源的类型，取值有三种： UNPOOLED：简单的JDBC配置，未使用连接池，相当于DriverManager.getConnection(url,username,password) POOLED：使用连接池技术 JNDI：通过外部容器获取连接 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--&lt;environment id=&quot;world&quot;&gt;--&gt; &lt;!--&lt;transactionManager type=&quot;&quot;&gt;&lt;/transactionManager&gt;--&gt; &lt;!--&lt;dataSource type=&quot;&quot;&gt;&lt;/dataSource&gt;--&gt; &lt;!--&lt;/environment&gt;--&gt; &lt;/environments&gt; &lt;!-- 注册当前工程中使用的所有映射文件 --&gt; &lt;mappers&gt; &lt;!-- mapper：注册某一个mapper文件，可以有多个 resource属性：指定映射文件的路径，写的是相对于src的路径，使用正斜杠分隔 --&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 小技巧： 创建配置文件的模板：Settings——&gt;搜索template——&gt;File and Code Templates——&gt;Files——&gt;Create Template 4. 创建映射文件mapper映射配置文件，在一个mybatis工程中可以有多个mapper文件 用来配置dao功能相关的sql操作，如sql语句、CURD操作、字段映射等 每个实体类对应一个映射文件，每一个mapper文件相当于原来三层架构中dao实现类 文件名可自定义，一般命名为XxxMapper.xml，放到mapper文件夹中 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace属性：指定当前mapper配置文件的唯一标识符，取值为对应接口的全名--&gt;&lt;mapper namespace=&quot;dao.UserDao&quot;&gt; &lt;!-- insert：用来执行添加操作 id属性：表示当前的方法名，取值必须与接口中的方法名相同 parameterType属性：表示方法的参数类型 如果参数是对象，可以使用类的全名 如果参数是普通数据，可以使用mybatis中的别名，见参考文档12页 标签体：编写sql语句 使用#&#123;xxx&#125;表示占位符 如果参数是对象，则xxx为对象的属性 如果参数是普通数据，则xxx为参数名 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;entity.User&quot;&gt; insert into t_user (username, password, phone, address) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt; 小技巧： 去除背景：Settings——&gt;Editor——&gt;Color Scheme——&gt;General——&gt;Code——&gt;Injected language fragment，取消勾选右边的Background XML注释风格：Settings——&gt;Editor——&gt;Code Style——&gt;XML——&gt;Code Generation，取消勾选下面的两个 编写SQL时提示表和列： 在右侧的工具栏，添加数据库连接 Settings——&gt;搜索SQL Dialects——&gt;将右边的都选择为MySQL 5. 测试类1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; /** * 创建SqlSession，称为持久化管理器，是MyBatis操作的核心 */ // 1.创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); // 2.创建SqlSessionFactory，读取核心配置文件 SqlSessionFactory factory = builder.build(Test01.class.getClassLoader().getResourceAsStream(&quot;mybatis-config.xml&quot;)); // 3.创建SqlSession SqlSession session = factory.openSession(); // Connection connection = session.getConnection(); // System.out.println(connection); User user = new User(); user.setUsername(&quot;alice&quot;); user.setPassword(&quot;123&quot;); user.setPhone(&quot;110&quot;); user.setAddress(&quot;南京&quot;); /** * 获取DAO实现类的实例，并执行数据库操作 */ UserDao userDao = session.getMapper(UserDao.class); // 参数为接口的Class对象 // System.out.println(userDao); // 代理对象，通过代理自动生成DAO的实现类 userDao.insertUser(user); session.commit(); // 提交事务&#125; 6. MyBatisUtil工具类MyBatisUtil工具类： （1）MyBatisUtils主要职责是：● 帮助我们初始化SqlSessionFactory这个对象；同时让SqlSessionFactory全局唯一；● 获得SqlSession对象的方法；● 关闭SqlSession对象的方法； （2）在实际开发中，会经常使用MyBatisUtils工具类； 添加模板，实现快捷操作：Settings——&gt;搜索template——&gt;Live Templates 12345678910111213SqlSession session = null;try &#123; session = MyBatisUtil.getSession(); $END$ session.commit();&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();&#125; finally &#123; MyBatisUtil.close();&#125; 三、config文件1. settings123456&lt;!-- 自定义配置 --&gt;&lt;settings&gt; &lt;!-- 打印sql --&gt; &lt;!--&lt;setting name=&quot;logImpl&quot; value=&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;/&gt;--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; logImpl可以输出日志注：setting一定要在environment的上面，否则会报错。 2. typeAliases12345678910111213141516&lt;!-- 配置别名，为当前工程中的某些类指定别名--&gt;&lt;typeAliases&gt; &lt;!-- typeAlias：为某个类配置别名 type属性：指定类名 alias属性：指定类的别名 --&gt; &lt;!--&lt;typeAlias type=&quot;entity.User&quot; alias=&quot;User&quot;/&gt;--&gt; &lt;!-- package：为某个包下的所有类配置别名 name属性：指定包名，该包下所有类的别名就是其类名（别名不区分大小写，但建议与类名完全一致） --&gt; &lt;package name=&quot;entity&quot;/&gt;&lt;/typeAliases&gt; 3. properties1234&lt;!-- 引用外部的properties文件--&gt;&lt;properties resource=&quot;datasource.properties&quot;&gt;&lt;/properties&gt; 1234567&lt;!-- 通过$&#123;key&#125;访问properties文件中的值--&gt;&lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; 四、mapper文件1. insert​ 保存返回主键 123456789101112&lt;!-- useGeneratedKeys属性：设置保存时是否返回主键，取值有两个： false：表示不返回主键，默认值 true：表示返回主键，会自动将返回的主键绑定到参数对象的主键属性中 keyProperty属性：指定对象的哪个属性为主键属性，即主键所映射的属性，必须指定--&gt;&lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user (username, password, phone, address) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;address&#125;)&lt;/insert&gt; 2. update1234567891011&lt;!-- update：执行修改操作--&gt;&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update t_user set username=#&#123;username&#125;, password=#&#123;password&#125;, phone=#&#123;phone&#125;, address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; 3. delete1234567&lt;!-- delete：执行删除操作--&gt;&lt;delete id=&quot;deleteById&quot; parameterType=&quot;int&quot;&gt; delete from t_user where id=#&#123;id&#125;&lt;/delete&gt; 4. select123456789101112131415161718192021222324252627282930313233343536&lt;!-- select：执行查询操作 resultType属性：表示返回的结果类型 如果返回的是一个对象，会自动进行映射 前提条件：查询结果的字段名必须与对象的属性名完全相同--&gt;&lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select id,username,password,phone,address from t_user where id=#&#123;id&#125;&lt;/select&gt;&lt;!-- 当方法返回值为对象集合时，resultType指定的是集合中对象的类型，而非集合本身--&gt;&lt;select id=&quot;selectAll&quot; resultType=&quot;User&quot;&gt; &lt;!-- include：用于引用sql代码段 refid属性：指定要引用的sql代码段的id值 --&gt; select &lt;include refid=&quot;userColumn&quot;/&gt; from t_user&lt;/select&gt;&lt;!-- 模糊查询--&gt;&lt;select id=&quot;selectByUsername&quot; resultType=&quot;User&quot;&gt; select &lt;include refid=&quot;userColumn&quot;/&gt; from t_user &lt;!-- 方式1：使用concat()函数拼接 --&gt; &lt;!-- where username like concat(&#x27;%&#x27;,#&#123;username&#125;,&#x27;%&#x27;) --&gt; &lt;!-- 方式2：传参时直接拼接上% --&gt; where username like #&#123;username&#125;&lt;/select&gt; 5. sql片段123456789101112&lt;!-- sql：定义sql代码段，便于复用 id属性：指定该sql代码段的唯一标识符--&gt;&lt;sql id=&quot;UserColumn&quot;&gt; id,username,password,phone,address&lt;/sql&gt;&lt;sql id=&quot;BaseQuery&quot;&gt; select id,username,password,phone,address from t_user&lt;/sql&gt; 五、手动映射​ 当数据库查询结果的字段名与Java对象的属性名不同时，如何映射？ 1234567create table t_user2( user_id int primary key auto_increment comment &#x27;编号&#x27;, user_username varchar(20) unique not null comment &#x27;用户名&#x27;, user_password varchar(50) comment &#x27;密码&#x27;, user_phone varchar(20) comment &#x27;电话&#x27;, user_address varchar(100) comment &#x27;地址&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 1. 使用别名123456789101112131415&lt;!-- 使用别名：为查询结果的每个字段指定别名，与对象的属性名相同，此时相当于自动映射--&gt;&lt;select id=&quot;selectById2&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select user_id id, user_username username, user_password password , user_phone phone , user_address address from t_user2 where user_id=#&#123;id&#125;&lt;/select&gt; 2. 使用resultMap123456789101112131415161718&lt;!-- resultMap：定义结果映射，将数据库的字段与对象的属性进行映射 id属性：指定该resultMap的唯一标识符 type属性：映射的对象类型--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id：配置主键映射 result：配置其他映射 property属性：映射的属性名 column属性：映射的字段名 --&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;user_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;user_password&quot;/&gt; &lt;result property=&quot;phone&quot; column=&quot;user_phone&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;user_address&quot;/&gt;&lt;/resultMap&gt; 1234567891011121314&lt;!-- resultMap属性：引用一个resultMap，使用该resultMap进行手动映射 其值为已存在的某一个resultMap标签的id值--&gt;&lt;select id=&quot;selectById3&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt; select user_id, user_username, user_password , user_phone, user_address from t_user2 where user_id=#&#123;id&#125;&lt;/select&gt; 六、多个参数1. 使用@Param()注解12// 使用@Param()注解，标注在参数前，为参数指定占位符名称public User selectByUsernameAndPassword(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); 1234567&lt;!-- 使用@Param()定义的名称引用指定的参数--&gt;&lt;select id=&quot;selectByUsernameAndPassword&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;pwd&#125;&lt;/select&gt; ​ 注：如果方法只有一个参数，不需要加@Param注解，可以在占位符#{ }中使用任意名称 2. 将参数封装为对象12345&lt;!-- 将多个参数封装成一个对象，然后传递该对象 --&gt;&lt;select id=&quot;selectByUsernameAndPassword2&quot; parameterType=&quot;UserDTO&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; ​ 注：可以自定义一个参数对象，如UserDTO、UserParam等 3. 将参数封装为Map1234567&lt;!-- 将多个参数封装成一个Map集合，在#&#123;&#125;占位符中根据key获取value--&gt;&lt;select id=&quot;selectByUsernameAndPassword3&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; ​ 注：parameterType属性可以省略 4. #{}与${}的区别#{ }的含义 #{ }表示一个占位符 即JDBC中的？ 占位不会出现SQL注入的问题 ${ }的含义 ${}表示一个拼接符 拼接会导致SQL注入，如查询条件输入&#39;&#39; or 1=1就会有注入情况 如果排序时要指定排序列名和排序方式，此时就必须使用字符的拼接，即使用${ } 七、动态SQL​ 根据条件的不同，动态的拼接SQL语句，称为动态SQL ​ 传统JDBC拼接： 12345678StringBuffer sql=new StringBuffer();sql.append(&quot;select * from t_user where 1=1&quot;);if(username!=null &amp;&amp; !&quot;&quot;.equals(username))&#123; sql.append(&quot; and username=? &quot;);&#125;if(password!=null &amp;&amp; !&quot;&quot;.equals(password))&#123; sql.append(&quot; and password=? &quot;);&#125; 1. if1234567891011121314151617181920&lt;!-- if标签：用来进行条件的判断 test属性：判断表达式的值，如果为true，则拼接该sql片段，否则不拼接--&gt;&lt;select id=&quot;selectByParams&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where 1=1 &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; and password = #&#123;password&#125; &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; and phone = #&#123;phone&#125; &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; and address = #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 2. choose123456789101112131415161718192021222324252627&lt;!-- choose标签：用来进行条件的选择，只会拼接一个SQL when标签： test属性：判断表达式的值，如果为true，则拼接该sql片段，此时不再判断其它when otherwise标签：当所有when都不成立时，则拼接该sql片段--&gt;&lt;select id=&quot;selectByParams2&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where &lt;choose&gt; &lt;when test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; username = #&#123;username&#125; &lt;/when&gt; &lt;when test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password = #&#123;password&#125; &lt;/when&gt; &lt;when test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; phone = #&#123;phone&#125; &lt;/when&gt; &lt;when test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; address = #&#123;address&#125; &lt;/when&gt; &lt;otherwise&gt; 1=1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 3. where1234567891011121314151617181920212223&lt;!-- where标签：一般结合if或choose一起使用 作用：1.添加where关键字 2.删除sql片段的第一个连接关键字，如and、or等 3.如果没有拼接任何sql片段，则不会添加where关键字--&gt;&lt;select id=&quot;selectByParams3&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; &lt;where&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; or password = #&#123;password&#125; &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; and phone = #&#123;phone&#125; &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 4. set1234567891011121314151617181920212223&lt;!-- set标签：一般结合if或choose一起使用 作用：1.添加set关键字 2.删除sql片段的末尾逗号--&gt;&lt;update id=&quot;updateUser2&quot; parameterType=&quot;User&quot;&gt; update t_user &lt;set&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password = #&#123;password&#125;, &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; phone = #&#123;phone&#125;, &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; address = #&#123;address&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; 5. trim123456789101112131415161718192021222324&lt;!-- trim标签： 作用：1.在开头或末尾添加特定的前缀prefix或后缀suffix 2.删除开头prefixOverrides或末尾suffixOverrides的特定内容 注：当属性值可能有多个时，可以使用竖杠|来表示或者的意思，且竖杠的后面不能有空格--&gt;&lt;insert id=&quot;insertUser2&quot; parameterType=&quot;User&quot;&gt; insert into t_user &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;id,&lt;/if&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;username,&lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;password,&lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt;phone,&lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt;address,&lt;/if&gt; &lt;/trim&gt; values &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;#&#123;id&#125;,&lt;/if&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt;#&#123;phone&#125;,&lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt;#&#123;address&#125;,&lt;/if&gt; &lt;/trim&gt;&lt;/insert&gt; 6. foreach12345678910111213141516&lt;!-- foreach标签：当参数是集合时，用来对集合进行遍历，一般用在in条件中 collection属性：要遍历的集合，默认List集合指定为list，Map集合指定为map，数组指定为array item属性：迭代变量 open属性：遍历前添加的字符串 close属性：遍历后添加的字符串 separator属性：元素分隔符 index属性：当前迭代元素的索引--&gt;&lt;select id=&quot;selectByIds&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where id in &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; 八、多表关系映射1. 简介关联关系： 多对一，多个员工都在同一个部门中 一对多，一个部门中有多个员工 一对一，一个员工只能有一个身份证 多对多，一个员工可以同时开发多个项目，一个项目也可以同时有多个员工开发 数据库设计： 123456789101112create table t_dept( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;部门名称&#x27;)engine innodb default charset utf8 comment &#x27;部门表&#x27;;create table t_emp( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;姓名&#x27;, salary double comment &#x27;工资&#x27;, dept_id int comment &#x27;部门编号&#x27;, foreign key (dept_id) references t_dept(id))engine innodb default charset utf8 comment &#x27;员工表&#x27;; 2. 保存操作12345678&lt;mapper namespace=&quot;dao.DeptDao&quot;&gt; &lt;insert id=&quot;insertDept&quot; parameterType=&quot;Dept&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_dept (name) values (#&#123;name&#125;) &lt;/insert&gt;&lt;/mapper&gt; 12345678&lt;mapper namespace=&quot;dao.EmpDao&quot;&gt; &lt;insert id=&quot;insertEmp&quot; parameterType=&quot;Emp&quot;&gt; insert into t_emp (name, salary, dept_id) values (#&#123;name&#125;,#&#123;salary&#125;,#&#123;dept.id&#125;) &lt;/insert&gt;&lt;/mapper&gt; 3. 多对一在一个对象中定义另一个对象的属性 两种实现方式： 使用关联属性，即直接使用association标签 使用嵌套查询，即使用association的select属性，引用其他select，通过多个单表查询来实现 12345678910111213141516171819202122232425262728293031323334353637383940&lt;resultMap id=&quot;BaseMap&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;EmpMap&quot; type=&quot;Emp&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- association：用于配置关联属性，多对一的关系 property属性：当前需要映射的是对象中的哪个属性 javaType属性：当前映射的属性的Java类型 标签体：对当前映射的属性所在的表进行映射 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;deptId&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;deptName&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;EmpMap2&quot; type=&quot;Emp&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- select属性：引用其他的select查询配置 值为：select所在Mapper文件的namespace.select的id值 column属性：当前查询的某列，作为查询条件，传递给引用的select查询配置的参数 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot; select=&quot;dao.DeptDao.selectById&quot; column=&quot;dept_id&quot;&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap&quot;&gt; select &lt;include refid=&quot;EmpColumn&quot;/&gt; from t_emp e left join t_dept d on e.dept_id=d.id&lt;/select&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap2&quot;&gt; select id,name,salary,dept_id from t_emp&lt;/select&gt; 嵌套查询的缺点：效率低，会进行多次查询，存在N+1问题 首先查询了1次emp表，获取到N条dept_id的记录 对于每一个不同的dep_id，都会去dept表中进行一次查询，可能会查询N次 所以，总查询次数可能为：1次emp表+N次dept表 4. 一对多在一个对象中定义另一个对象的集合 两种实现方式： 使用集合属性，即直接使用collection标签 使用嵌套查询，即使用collection的select属性，引用其他select，通过多个单表查询来实现 12345678910111213141516171819202122232425262728293031323334353637&lt;resultMap id=&quot;BaseMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;DeptMap&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- collection：用于配置集合属性，一对多的关系 property属性：当前需要映射的集合属性 ofType属性：集合属性中对象的类型 标签体：对集合属性中对象所在的表进行映射 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;empId&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;empName&quot;/&gt; &lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;DeptMap2&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- select属性 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot; select=&quot;dao.EmpDao.selectByDeptId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;DeptMap&quot;&gt; select &lt;include refid=&quot;DeptColumn&quot;/&gt; from t_dept d left join t_emp e on d.id=e.dept_id&lt;/select&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;DeptMap2&quot;&gt; select id,name from t_dept&lt;/select&gt; 5. 懒加载1234567891011121314&lt;resultMap id=&quot;DeptMap2&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- fetchType属性：指定集合属性的加载时机 lazy：延迟加载，当使用到集合属性时，才会加载 eager：立即加载，查询主表时，就会查询集合属性 也可以在主配置文件中，通过setting标签，配置全局的fetchType属性 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot; select=&quot;dao.EmpDao.selectByDeptId&quot; column=&quot;id&quot; fetchType=&quot;lazy&quot;/&gt;&lt;/resultMap&gt;&lt;settings&gt; &lt;!-- 懒加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 九、缓存1. 简介将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据库的压力，同时提高系统性能。 合理使用缓存是优化中最常见的操作。 2. 一级缓存一级缓存是SqlSession级别的，存储在SqlSession中，默认是开启的 一般来说，一个请求中的所有增删改查操作都是在 同一个sqlSession里面的，可以认为每个请求都有自己的一级缓存 如果同一个SqlSession会话中 2个查询中间有一个 insert 、update或delete 语句，那么之前查询的所有缓存都会清空 流程： 用户发起查询请求，查找某条数据，SqlSession 先去缓存中查找，是否有该数据，如果有，读取； 如果没有，从数据库中查询，并将查询到的数据放入一级缓存区域，供下次查找使用。 当SqlSession 执行commit，即增删改操作时会清空缓存。这么做的目的是避免脏读。 生效的条件： 必须使用同一SqlSession，执行同一个查询方法才会有效 同一个SqlSession，如果查询条件不同，则无效 同一个SqlSession，如果两次查询期间执行了任何一次的增删改操作，则无效 3. 二级缓存二级缓存是 mapper 级别的缓存，多个SqlSession去操作同一个Mapper的sql语句时，多个SqlSession可以共用二级缓存 二级缓存是跨SqlSession的，因此二级缓存的作用范围更大 二级缓存默认是关闭的，需要手动开启 流程： 开启二级缓存后，用户查询时，会先去二级缓存中找，找不到了再去一级缓存中找 一级缓存也没有查询到，则查询数据库 当SqlSession会话提交或者关闭时，一级缓存的数据会刷新到二级缓存中 启用二级缓存：在 XxxMapper.xml 映射文件中，添加：&lt;cache/&gt; 十、分页插件1. 简介​ PageHelper是一款基于mybatis的分页插件 2. 用法2.1 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 2.2 插件的配置​ 在mybatis核心配置文件中配置插件 123456&lt;plugins&gt; &lt;!-- 配置mybatis分页插件 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 2.3 使用​ 分为三步： 123456789101112131415161718192021// 1.配置分页信息，指定页码、页大小int pageNum = 3;int pageSize = 4;PageHelper.startPage(pageNum, pageSize);// 2.获取原始数据UserDao userDao = session.getMapper(UserDao.class);List&lt;User&gt; users = userDao.selectAll();for (User user:users)&#123; System.out.println(user);&#125; // 3.将原始数据封装成分页数据PageInfo&lt;User&gt; pageInfo=new PageInfo&lt;&gt;(users);System.out.println(pageInfo);System.out.println(&quot;页码：&quot;+pageInfo.getPageNum());System.out.println(&quot;页大小：&quot;+pageInfo.getPageSize());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;分页数据：&quot;+pageInfo.getList()); 十一、其他1. MyBatisX​ 一款全免费且强大的 IDEA 插件，支持跳转，自动补全生成 SQL，代码生成。 1234567891011create table t_product( pro_id int primary key auto_increment comment &#x27;编号&#x27;, pro_name varchar(100) comment &#x27;产品名称&#x27;, pro_price decimal(10,2) comment &#x27;产品价格&#x27;, pro_number int comment &#x27;产品数量&#x27;, pro_introduce text comment &#x27;产品介绍&#x27;, pro_state tinyint comment &#x27;产品状态(0未通过,1审核中,2已审核)&#x27;, add_time datetime comment &#x27;添加时间&#x27;, is_del tinyint comment &#x27;是否删除(0正常,1删除)&#x27;) engine innodb default charset utf8 comment &#x27;产品表&#x27;; 1234&lt;settings&gt; &lt;!-- 下划线映射为驼峰 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 2. MyBatisCodeHelperPro​ 功能更强大，收费！","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"}]},{"title":"Maven学习","slug":"Maven学习","date":"2023-08-07T01:16:39.000Z","updated":"2023-08-08T05:29:16.903Z","comments":true,"path":"2023/08/07/Maven学习/","link":"","permalink":"http://example.com/2023/08/07/Maven%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Maven简介1. 什么是Maven​ maven [ˈmeɪvn] 专家、内行 ​ Apache Maven 是一个软件项目管理和构建工具，可以帮助创建和管理项目 ​ 基于项目对象模型（POM：Project Object Model）的概念，帮助开发者构建一个项目的完整生命周期 ​ 官网：http://maven.apache.org/ 2. 为什么使用Maven 项目的管理工具 项目规模很大时一定会将项目进行拆分，拆分成多个工程，使用Maven在多个工程之间建立依赖关系 jar包的管理工具 通过仓库管理jar包、解决jar包的依赖、自动下载jar包 自动化的构建工具 编译代码、执行测试、打包、部署等 3. 术语 中央仓库 是一个网络仓库，用于存放jar包和maven插件 https://repo1.maven.org/maven2 https://mvnrepository.com 本地仓库 从中央仓库下载的jar包的存放位置，也是一个仓库，只不过是存放在本地电脑上 镜像仓库 对中央仓库做的镜像（mirror） 阿里云提供的镜像仓库 https://maven.aliyun.com/repository/public 私服 局域网内部搭建的maven服务器 二、安装Maven1. 下载安装包​ 从maven官网下载安装包，这里使用apache-maven-3.6.0-bin.tar.gz 2. 解压安装包​ 将安装包解压到无中文、无空格的路径下，如：D:\\software\\apache-maven-3.6.0 ​ 配置环境变量，将bin目录添加到Path变量中，如：D:\\software\\apache-maven-3.6.0\\bin ​ 测试，在DOS窗口中执行以下命令： 1mvn -version 3. 配置本地仓库本地仓库的默认位置： ~&#x2F;.m2&#x2F;repository（如 C:&#x2F;Users&#x2F;登录用户&#x2F;.m2&#x2F;repository） 修改本地仓库的位置：编辑conf&#x2F;setting.xml文件 1234&lt;settings&gt; &lt;!--指定本地仓库的位置--&gt; &lt;localRepository&gt;D:\\maven-repos&lt;/localRepository&gt;&lt;/settings&gt; 4. 配置镜像仓库​ 使用maven时默认从中央仓库下载所需的包(插件)，比较慢，可以配置使用阿里云提供的镜像仓库 ​ 编辑maven主目录下的&#x2F;conf&#x2F;setting.xml文件，在&lt;mirrors&gt;&lt;/mirrors&gt;标签中添加如下内容： 123456&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;!-- 名称自定义，必须唯一 --&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;!-- 所有访问都使用该镜像仓库 --&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 5. 配置Maven的JDK版本​ 修改maven默认使用的jdk版本，编辑conf&#x2F;setting.xml文件，在profiles标签里面添加如下内容 123456789101112&lt;profile&gt; &lt;id&gt;jdk‐1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 三、使用Maven1. 在IDEA中集成maven指定Maven主目录和配置文件：Settings——&gt;搜索Maven——&gt;Maven Home directory和User settings file 注：切换Porject后要重新配置maven 2. 创建maven项目File——&gt;New——&gt;Module——&gt;Maven Archetype Archetype：maven-archetype-quickstart（Java项目） &#x2F; maven-archetype-webapp（Java Web项目） GroupId : net.wanho.shop（组织域名反向+项目名称） ArtifactId : shop-product（模块名称） Version : 1.0.1（版本） 3. 目录结构Maven项目的目录结构如下： 1234567891011121314|-项目名称 |-src //程序代码 |-main //主代码 |-java //源代码 |-用于存放源代码，相当于传统项目中的src，传统项目的包名.类名，如net.wanho.shop.dao |-resources //配置文件 |-用于存放配置文件 |-webapp //网站根目录 |-WEB-INF |-web.xml |-test //测试代码，目录结构和main中完全一致 |-java |-resources |-pom.xml //maven核心配置文件 如果没有对应的目录，可以自己创建，但必须符合该目录结构 在IDEA中目录是分类型的，常用的有四种： Sources Root：主代码的目录——&gt;src&#x2F;main&#x2F;java Test Sources Root：测试代码的目录——&gt;src&#x2F;test&#x2F;java Resources Root：主代码所需资源的目录——&gt;src&#x2F;main&#x2F;resources Test Resources Root：测试代码所需资源的目录——&gt;src&#x2F;test&#x2F;resources 默认情况下新建的目录是普通的Directory，创建后可以设置目录的类型： 右击目录——&gt;Mark Directory As 每种目录的图标有所不同 4. 执行maven操作在IDEA中管理所有Maven项目：View——&gt;Tool Windows——&gt;Maven Maven项目的生命周期： 命令 作用 描述 clean 清理 删除target目录 compile 编译 将main&#x2F;中的源代码编译成字节码文件，放在target&#x2F;classes目录下 test 测试 执行测试类（使用JUnit），并生成测试报告，放在target&#x2F;surefire-reports目录下 package 打包 将java项目打包成jar，将web项目打包成war，放在target目录下 install 安装 将项目的jar包安装到本地仓库，供其他项目使用 注意： 问题：在Maven Projects中项目显示为灰色，表示该maven项目未被管理，不可用 解决：在Maven Projects里点击”+”，选择项目对应的pom.xml文件 四、pom.xml文件1. 简介​ pom:project object model 项目对象模型 ​ pom.xml是Maven的核心配置文件，与项目构建相关的所有配置都在该文件中 2. 坐标​ 用来唯一的标识每个项目，必须为项目定义坐标，且坐标必须唯一 ​ Maven坐标是通过一些元素定义的：groupId、artifactId、version 123456789&lt;!-- 坐标： groupId：定义组织id，表示当前模块隶属的项目，采用&quot;组织域名反向+项目名称&quot; artifactId：定义模块id version：定义当前的版本--&gt;&lt;groupId&gt;net.wanho.shop&lt;/groupId&gt;&lt;artifactId&gt;shop-product&lt;/artifactId&gt;&lt;version&gt;1.0.1&lt;/version&gt; 3. dependency​ 如何查找一个jar包的坐标? https://mvnrepository.com 12345678910111213141516171819202122232425262728293031&lt;!-- dependency基本配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; ​ scope表示依赖的作用域，用来配置依赖的jar包的可作用范围，即在什么地方可以使用 取值 含义 举例 compile 表示该依赖可以在整个项目中使用，参与打包部署，默认值 fastjson test 表示该依赖只能在测试程序中使用，不参与打包和部署 junit provided 表示编写源代码的时候需要，不参与打包部署 lombok、servlet-api（因为tomcat中已有） runtime 表示运行时需要，编译代码时不需要 mysql-connector（通过接口反射加载） 4. properties​ 全局属性，一般情况下用于定义全局的jar的版本 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 可以自定义标签名，然后使用 $&#123;标签名&#125; 获取标签中的值 一般情况下用于定义全局的jar的版本，相当于定义全局变量 --&gt; &lt;spring.version&gt;5.3.27&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 注：快速将jar包的版本添加到properties中：右击版本号——&gt;Refactor——&gt;Property 5. repositories​ 用于配置当前工程使用的远程仓库 ​ 查找顺序：本地仓库、pom.xml中配置的远程仓库、maven主录下的conf&#x2F;setting.xml中配置的远程仓库 1234567&lt;repositories&gt; &lt;!-- 有些最新版本的jar包，在中央仓库中可能并没有，此时可以指定其他可用的远程仓库 --&gt; &lt;repository&gt; &lt;id&gt;springio&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 6. plugins插件是一种工具，如 maven-clean-plugin插件是用来清理项目的工具 maven-compile-plugin插件是用来编译代码的工具 tomcat7-maven-plugin插件是用来将web项目自动打包并部署到tomcat的工具 1234567891011121314&lt;build&gt; &lt;plugins&gt; &lt;!-- tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8888&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 7. 案例Web应用的开发，模块名称：shop-user 步骤： 添加依赖 12345678910111213&lt;!-- servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 创建HelloServlet类 1234567891011121314151617@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setAttribute(&quot;name&quot;,&quot;tom&quot;); List&lt;Integer&gt; nums = Arrays.asList(13, 25, 38); req.setAttribute(&quot;nums&quot;,nums); Properties p=new Properties(); p.load(HelloServlet.class.getClassLoader().getResourceAsStream(&quot;stu.properties&quot;)); System.out.println(p); req.setAttribute(&quot;age&quot;,p.getProperty(&quot;age&quot;)); req.setAttribute(&quot;sex&quot;,p.getProperty(&quot;sex&quot;)); req.getRequestDispatcher(&quot;/index.jsp&quot;).forward(req,resp); &#125;&#125; 创建index.jsp 1234567891011121314151617&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--默认生成的web.xml文件使用的是web-app_2_3.dtd，会忽略EL表达式，需要启用EL表达式--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;name&#125; &lt;br&gt; &lt;ul&gt; &lt;c:forEach items=&quot;$&#123;hobbies&#125;&quot; var=&quot;hobby&quot;&gt; &lt;li&gt;$&#123;hobby&#125;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; stu.properties 123name=aliceage=21sex=male 五、Maven中的关系1. 继承含义：一个Maven工程继承自另一个Maven工程，分别称为子工程、父工程 场景：实际开发中一个大项目会拆分为多个子项目（子模块&#x2F;子工程），多个子工程使用的技术基本都相同，即多个子工程中使用的是相同的依赖或插件等配置，此时可以把相同配置抽取到一个父工程中，进行统一管理，保持一致性，简化pom.xml配置 步骤： 创建三个工程：子工程child01和child02、父工程parent 将父项目的打包方式设置为pom 12345678&lt;!-- 打包方式 jar：java项目的打包方式，默认值 war：web项目的打包方式 pom：父项目的打包方式 注：将父工程打包方式设置为pom后，父工程将不会被打包，因此不要在父工程中写java代码，父工程只是用来简化POM配置 --&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 在子项目中引用父项目，指定父项目的坐标，并指定父项目pom.xml文件的路径 12345678&lt;!-- 引用父项目，指定父项目的坐标 --&gt;&lt;parent&gt; &lt;groupId&gt;net.wanho.study&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 指定父项目pom.xml文件的相对物理路径 --&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; 注：如果子项目的位置是在父项目所在的目录中，则可以省略不配置relativePath项 问题：有时并不是父项目的所有ja包都需要被子项目继承，但又希望能够对依赖进行统一管理，如：jar包版本的控制，怎么办？ 解决：配置dependencyManagement 步骤： 在父项目中配置dependencyManagement此时父项目只进行jar包的管理，父项目的jar包默认并不会被子项目继承 12345678910111213141516171819202122&lt;!-- dependencyManagement表示父项目只进行依赖的管理，依赖默认不会被子项目继承 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在子项目中引用父项目中的依赖 如果子项目想继承父项目的jar包，需要在子项目中手动引用，且引用时只需要配置groupId和artifactId，无需指定版本version 123456789101112131415&lt;dependencies&gt; &lt;!-- 父项目配置dependencyManagement后默认并不会继承过来，需要手动在子项目中引用 只需要指定groupId和artifactId，无需指定版本version 可以指定要引用的依赖，并不一定要使用父项目中所有的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 聚合将多个子项目聚合到一个父项目中，然后通过对该父项目进行操作，从而实现对所有的聚合项目的操作 在父项目中聚合子项目： 12345&lt;!-- 聚合子项目，指定子项目的根目录--&gt;&lt;modules&gt; &lt;module&gt;../child01&lt;/module&gt; &lt;module&gt;../child02&lt;/module&gt;&lt;/modules&gt; 3. 依赖项目C —&gt; 项目B —&gt; 项目A 概念：如果项目C依赖于项目B，项目B依赖于项目A，则项目C也依赖于项目A，这叫依赖的传递 步骤： 配置依赖关系 child03——&gt;child02——&gt;child01 在child01中添加依赖时，child02和child03会传递该依赖，也会出现该依赖 3.1 控制依赖的传递并不是所有的依赖都会被传递： scope为compile的依赖会被传递 scope为test和provided的依赖不会被传递 配置optional为true的依赖不会被传递 123456&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 表示该jar包不传递 --&gt;&lt;/dependency&gt; 3.2 继承和依赖的区别继承： 使用&lt;parent&gt; 继承是指子项目可以继承父项目的数据和配置，从而简化配置 继承时父项目一般都是自己创建的项目，也可以是第三方的 依赖： 使用&lt;dependencies&gt; 依赖是指jar包可以通过依赖的方式引入 依赖时所依赖的jar包一般多是第三方的，也可以是自己创建的依赖项目 六、Maven综合应用1. 分析将项目分为多个工程，可以按层次分，也可以按模块分，或者同时按层次和模块分 以ums为例，使用Maven创建和管理项目： 父工程：ums-parent dao工程：ums-dao service工程：ums-service web工程：ums-web 2. 步骤2.1 创建工程 创建父工程：ums-parent File——&gt;New——&gt;Module——&gt;Maven Archetype——&gt;maven-archetype-quickstart GroupId：net.wanho.ums ArtifactId：ums-parent Context root：~&#x2F;IdeaProjects&#x2F;framework&#x2F;ums-parent 创建子工程：ums-dao 右键ums-parent父工程——&gt;New——&gt;Module——&gt;Maven Archetype——&gt;maven-archetype-quickstart ArtifactId：ums-dao Content root：~&#x2F;IdeaProjects&#x2F;framework&#x2F;ums-parent&#x2F;ums-dao 创建子工程：ums-service 创建子工程：ums-web，web工程 2.2 配置依赖 在父工程中配置依赖管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;javax.servlet-api.version&gt;4.0.1&lt;/javax.servlet-api.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;mysql-connector-java.version&gt;5.1.38&lt;/mysql-connector-java.version&gt; &lt;fastjson.version&gt;1.2.31&lt;/fastjson.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;hutool-all.version&gt;5.8.15&lt;/hutool-all.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hutool --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;$&#123;hutool-all.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在各个子工程中引用依赖 ums-dao 123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; ums-service 123456&lt;!-- 依赖于dao --&gt;&lt;dependency&gt; &lt;groupId&gt;net.wanho.ums&lt;/groupId&gt; &lt;artifactId&gt;ums-dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; ums-web 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 依赖于service --&gt; &lt;dependency&gt; &lt;groupId&gt;net.wanho.ums&lt;/groupId&gt; &lt;artifactId&gt;ums-service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 部署访问 先对其他模块进行install操作，然后再对ums-web进行部署访问 2.3 配置dao子工程​ create.sql 123456789drop database if exists ums;create database ums charset utf8;use ums;create table t_user( id int primary key auto_increment, username varchar(100), password varchar(100), age int) engine=Innodb charset utf8; ​ datasource.properties 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ums?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=root 2.3 配置service子工程2.4 配置web子工程2.5 测试​ 只要修改了其他模块，都需要先对这些模块进行install操作，然后再对ums-web进行部署访问","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"}]},{"title":"Java-后端多表增删改查","slug":"Java-后端多表增删改查","date":"2023-07-30T11:27:36.000Z","updated":"2023-08-03T02:36:11.461Z","comments":true,"path":"2023/07/30/Java-后端多表增删改查/","link":"","permalink":"http://example.com/2023/07/30/Java-%E5%90%8E%E7%AB%AF%E5%A4%9A%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","excerpt":"","text":"1. Many2One1.1 数据建模关系图 表结构123456789101112131415161718192021222324252627282930313233drop table if exists t_clazz;/*==============================================================*//* Table: t_clazz 父 *//*==============================================================*/create table t_clazz( bno varchar(20) not null, name varchar(20), primary key (bno));alter table t_clazz comment &#x27;班级表&#x27;;drop table if exists t_student;/*==============================================================*//* Table: t_student 子 *//*==============================================================*/create table t_student( sid varchar(20) not null comment &#x27;学号 主键&#x27;, name varchar(20) comment &#x27;姓名&#x27;, age int(3) comment &#x27;年龄&#x27;, sex int(1) comment &#x27;性别 0 男 1 女&#x27;, bno varchar(20), primary key (sid));alter table t_student comment &#x27;学生信息表&#x27;;alter table t_student add constraint FK_stu_clazz_bno foreign key (bno) references t_clazz (bno) on delete restrict on update restrict; 表数据12345678910111213141516171819public abstract class BaseTest &#123; protected JDBCTemplate jdbcTemplate = new JDBCTemplate() ; // 初始化 测试环境 @Before public void before()&#123; //清空表数据 truncate table 截断表 无法使用 关联关系 先删除儿子 在删除爹 jdbcTemplate.update(&quot;delete from t_student &quot;) ; jdbcTemplate.update(&quot;delete from t_clazz &quot;) ; //插入班级数据 jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B001&#x27;,&#x27;Java177&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B002&#x27;,&#x27;Java178&#x27;)&quot;) ; //插入 68 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student(sid,name,age,sex,bno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;张三&quot;+(i+1)+&quot;&#x27;,18,0,&#x27;B001&#x27;)&quot;) ; &#125; &#125;&#125; 1.2 领域建模1234public class Clazz &#123; private String bno ; private String name ;&#125; 1234567public class Student &#123; private String sid ; private String name ; private Integer age ; private Integer sex ; private Clazz clazz = new Clazz() ;&#125; 1.3 列表DAO12-- 分页查询的SQL： select sid,s.name,age,sex,c.bno &quot;clazz.bno&quot;,c.name &quot;clazz.name&quot; from t_student s left join t_clazz c on s.bno = c.bno where 1=1 12345// t_student表 t_clazz表 同名列 二义性 条件查询需指定 哪个表的nameif (query!=null &amp;&amp; StringUtils.isNotEmpty(query.getName())) &#123; sb.append(&quot; and s.name like ?&quot;) ; paramList.add(&quot;%&quot;+query.getName()+&quot;%&quot;); &#125; jsplist-stu.jsp 12345678910111213141516171819202122232425262728293031&lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;班号&lt;/th&gt; &lt;th&gt;班名&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;studentPage.list&#125;&quot; var=&quot;student&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;sid&quot; value=&quot;$&#123;student.sid&#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.clazz.bno&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.clazz.name&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-stu.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-stu.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt;&lt;/table&gt; 1.4 新增beforeDAO123public interface ClazzDAO &#123; List&lt;Clazz&gt; selectAll() ;&#125; 1234567891011public class ClazzDAOImpl implements ClazzDAO &#123; private JDBCTemplate jdbcTemplate = new JDBCTemplate() ; @Override public List&lt;Clazz&gt; selectAll() &#123; String DQL = &quot;select bno,name from t_clazz&quot; ; Object[] paramAy = &#123;&#125; ; return jdbcTemplate.queryList(DQL,Clazz.class,paramAy); &#125;&#125; Service123456789101112public class ClazzService &#123; private ClazzDAO clazzDAO = new ClazzDAOImpl() ; /** * 查询所有班级 * @return */ public Collection&lt;Clazz&gt; list()&#123; return clazzDAO.selectAll(); &#125;&#125; Controller1234567891011121314151617@WebServlet(...&quot;/toAddView-stu.do&quot;&#125;)public class StudentServlet extends HttpServlet &#123; private ClazzService clazzService = new ClazzService() ; ... service(..)&#123; else if (&quot;/toAddView-stu.do&quot;.equals(requestURI))&#123; this.toAddView(request,response) ; &#125; &#125; //跳转到新增学生界面 protected void toAddView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Collection&lt;Clazz&gt; clazzList = clazzService.list(); request.setAttribute(&quot;clazzList&quot;,clazzList); request.getRequestDispatcher(&quot;/add-stu.jsp&quot;).forward(request,response); &#125;&#125; Jsplist-stu.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toAddView-stu.do&quot; class=&quot;btn btn-primary&quot;&gt;添加学生&lt;/a&gt; add-stu.jsp 1234567891011&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;班级&lt;/label&gt; &lt;select name=&quot;clazz.bno&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择班级--&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;option value=&quot;$&#123;clazz.bno&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/div&gt; 1.5 新增DAO123456@Overridepublic boolean insert(Student student) &#123; String DQL = &quot;insert into t_student(sid,name,age,sex,bno) values (?,?,?,?,?)&quot; ; Object[] paramAy = &#123;student.getSid(),student.getName(),student.getAge(),student.getSex(),student.getClazz().getBno()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; Controller12//重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/page-stu.do&quot;); 1.6 查看jspmodify-stu.jsp 123456789101112131415&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;班级&lt;/label&gt; &lt;select name=&quot;clazz.bno&quot; class=&quot;form-control&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择班级--&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;option value=&quot;$&#123;clazz.bno&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/div&gt;//设置下拉框被选中$(&quot;select&quot;).val(&quot;$&#123;student.clazz.bno&#125;&quot;) Controller123456789101112protected void view(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得查看的学生编号 String sid = request.getParameter(&quot;sid&quot;); //2.调用业务方法 Student student = studentService.get(sid); //3.request作用域中设置 学生信息 request.setAttribute(&quot;student&quot;,student); Collection&lt;Clazz&gt; clazzList = clazzService.list(); request.setAttribute(&quot;clazzList&quot;,clazzList); //4.跳转页面 服务器内部跳转 request.getRequestDispatcher(&quot;/modify-stu.jsp&quot;).forward(request,response); &#125; DAO1String DQL = &quot;select sid,s.name,age,sex,c.bno \\&quot;clazz.bno\\&quot;,c.name \\&quot;clazz.name\\&quot; from t_student s left join t_clazz c on s.bno = c.bno where s.sid=?&quot; ; 1.7 修改DAO123456@Overridepublic boolean update(Student student) &#123; String DQL = &quot;update t_student set name=?,age=?,sex=?,bno=? where sid=?&quot; ; Object[] paramAy = &#123;student.getName(),student.getAge(),student.getSex(),student.getClazz().getBno(),student.getSid()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; 2. One2Many2.1 列表[单表]controller1234567891011121314151617181920212223242526272829303132@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;&#125;)public class ClazzServlet extends HttpServlet &#123; /** 班级业务实例 */ private ClazzService clazzService = new ClazzService() ; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得请求的url 包含项目名 String requestURI = request.getRequestURI(); //2. 去掉项目名 /list-stu.do /add-stu.do requestURI = requestURI.replace(request.getContextPath(),&quot;&quot;); //3.判断 url 与方法 调用 if (&quot;/list-clazz.do&quot;.equals(requestURI))&#123; this.list(request,response) ; &#125; &#125; /** * * @param request * @param response * @throws ServletException * @throws IOException */ protected void list(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 调用业务方法 Collection&lt;Clazz&gt; clazzCollection = clazzService.list(); //2. 把查询数据保存 四种(pageContext,request,session,application)属性作用域中 set ==&gt; list-stu.jsp get request.setAttribute(&quot;clazzList&quot;,clazzCollection); //3. 跳转到 list-stu.jsp request.getRequestDispatcher(&quot;/list-clazz.jsp&quot;).forward(request,response); &#125;&#125; jspindex.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/list-clazz.do&quot;&gt;班级列表&lt;/a&gt; &lt;br&gt; list-clazz.jsp 1234567891011 &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;bno&quot; value=&quot;$&#123;clazz.sid&#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;clazz.bno&#125;&lt;/td&gt; &lt;td&gt;$&#123;clazz.name&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-clazz.do?sid=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-clazz.do?sid=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 2.2 新增准备【裸跳页面】逻辑上： 直接怼到页面 比如 add-clazz.jsp OCP A. 代码复用 B.新增班级 【权限访问控制？当前登录用户是否有权限？】 jsplist-clazz.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toAddView-clazz.do&quot; class=&quot;btn btn-primary&quot;&gt;添加班级&lt;/a&gt; add-clazz.jsp 1234567891011121314151617181920212223242526272829&lt;h1&gt;新增班级&lt;/h1&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/add-clazz.do&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sid&quot;&gt;班号&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sid&quot; name=&quot;bno&quot; value=&quot;$&#123;param.bno&#125;&quot; placeholder=&quot;请输入班号&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sname&quot;&gt;班名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sname&quot; name=&quot;name&quot; value=&quot;$&#123;param.name&#125;&quot; placeholder=&quot;请输入班名&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;新增&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;重置&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; Controller1234567891011// ClazzServlet@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;&#125;).... else if(&quot;/toAddView-clazz.do&quot;.equals(requestURI))&#123; this.toAddView(request,response) ; &#125;//跳转到新增班级界面protected void toAddView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher(&quot;/add-clazz.jsp&quot;).forward(request,response);&#125; 2.3 新增【单表】controller12345678910111213141516171819202122232425262728//添加新的请求 url@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;&#125;)//添加判断 调用自定义的方法else if(&quot;/add-clazz.do&quot;.equals(requestURI))&#123; this.add(request,response) ;&#125;protected void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置请求中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); //调用 自定义 工具类 实现：解析请求自动封装 pojo中 Clazz clazz = RequestUtil.parseParameter(request, Clazz.class); //4. 调用业务方法 boolean saveRs = clazzService.save(clazz); //5. 根据业务方法的返回值 if (saveRs)&#123; //6.响应 //重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do&quot;); return; &#125; //新增失败 view实现显示效果 request.setAttribute(&quot;errorMsg&quot;,&quot;班号已经存在！！！&quot;); //使用服务器内部跳转 request.getRequestDispatcher(&quot;/toAddView-clazz.do&quot;).forward(request,response);&#125; Service12345678910111213... ClazzService &#123; public boolean save(Clazz clazz) &#123; //获得新增的班号 String bno = clazz.getBno() ; //1.判断是否 新增的班号 db 中已经存在 Clazz dbClazz = clazzDAO.selectById(bno); if (dbClazz!=null)&#123; return false ; &#125; //班号不存在 向数据库插入数据 return clazzDAO.insert(clazz) ; &#125;&#125; DAO12345... ClazzDAO&#123; Clazz selectById(String bno); boolean insert(Clazz clazz);&#125; 123456789101112131415... ClazzDAOImpl ... &#123; @Override public Clazz selectById(String bno) &#123; String DQL = &quot;select bno,name from t_clazz where bno=?&quot; ; Object[] paramAy = &#123;bno&#125; ; return jdbcTemplate.queryObject(DQL,Clazz.class,paramAy); &#125; @Override public boolean insert(Clazz clazz) &#123; String DQL = &quot;insert into t_clazz(bno,name) values (?,?)&quot; ; Object[] paramAy = &#123;clazz.getBno(),clazz.getName()&#125; ; return jdbcTemplate.update(DQL,paramAy); &#125;&#125; 2.4 删除【单表&#x2F;子记录依赖】jsplist-clazz.jsp 123 &lt;form action=&#x27;$&#123;pageContext.request.contextPath&#125;/del-clazz.do&#x27;&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;bno&quot; value=&quot;$&#123;clazz.bno&#125;&quot; /&gt;&lt;/td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-clazz.do?bno=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; controller1234567891011121314151617181920@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;&#125;)else if(&quot;/del-clazz.do&quot;.equals(requestURI))&#123; this.del(request,response) ;&#125;protected void del(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得 删除的班号 String[] idAy = request.getParameterValues(&quot;bno&quot;); //把数组 拼接成一个 字符串 String id =&quot;&quot;; for (String s : idAy) &#123; id +=s+&quot;,&quot; ; &#125; id = id.substring(0,id.length()-1) ; //2. 调用业务方法 boolean removeRs = clazzService.remove(id); String msg = removeRs?&quot;&quot;:&quot;del-fail&quot; ; response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do?msg=&quot;+msg);&#125; Service123456789101112131415161718public class ClazzService &#123; private StudentDAO studentDAO = new StudentDAOImpl() ; public boolean remove(String id) &#123; //字符串 转成数组 String[] sidAy = id.split(&quot;,&quot;); for (String bno : sidAy) &#123; //根据FK 查询学生列表 List&lt;Student&gt; studentList = studentDAO.selectByFk(bno); //删除班级编号 在学生表中出现了 不能删除 if (!studentList.isEmpty())&#123; return false ; &#125; &#125; //调用批处理删除 return clazzDAO.delete(sidAy) ; &#125;&#125; DAOStudentDAO1List&lt;Student&gt; selectByFk(String bno) ; 123456@Overridepublic List&lt;Student&gt; selectByFk(String bno) &#123; String DQL = &quot;select sid,name,age,sex from t_student where bno=?&quot; ; Object[] paramAy = &#123;bno&#125; ; return jdbcTemplate.queryList(DQL,Student.class,paramAy);&#125; ClazzDAO1boolean delete(String ... idAy) ; 123456789101112public class ClazzDAOImpl implements ClazzDAO &#123; @Override public boolean delete(String... sidAy) &#123; String DML = &quot;delete from t_clazz where bno=?&quot; ; Object[][] paramAy = new Object[sidAy.length][1] ; for (int i = 0; i &lt; sidAy.length; i++) &#123; paramAy[i][0] = sidAy[i] ; &#125; return jdbcTemplate.updateBatch(DML,paramAy); &#125;&#125; 2.5 查看【N+1】jsplist-clazz.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-clazz.do?bno=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; modify-clazz.jsp 1234567891011121314151617&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sname&quot; name=&quot;name&quot; value=&quot;$&#123;clazz.name&#125;&quot; placeholder=&quot;请输入班名&quot;/&gt;&lt;c:forEach items=&quot;$&#123;clazz.studentList&#125;&quot; var=&quot;student&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; Controller1234567891011121314151617@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;,&quot;/view-clazz.do&quot;&#125;)else if(&quot;/view-clazz.do&quot;.equals(requestURI))&#123; this.view(request,response) ;&#125;protected void view(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得查看的学生编号 String bno = request.getParameter(&quot;bno&quot;); //2.调用业务方法 Clazz clazz = clazzService.get(bno) ; //3.request作用域中设置 学生信息 request.setAttribute(&quot;clazz&quot;,clazz); //4.跳转页面 服务器内部跳转 request.getRequestDispatcher(&quot;/modify-clazz.jsp&quot;).forward(request,response);&#125; Service12345678910 public Clazz get(String bno) &#123; //N+1查询 //1. 根据班级id 查询 班级对象 单表查询 Clazz clazz = clazzDAO.selectById(bno); //2. 根据班级id 查询当前班级的学生列表 单表查询 List&lt;Student&gt; studentList = studentDAO.selectByFk(bno); //3.当前班级对象的 stuList属性进行赋值 clazz.setStudentList(studentList); return clazz ;&#125; 2.6 修改【单表】jspmodify-clazz.jsp 12&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/modify-clazz.do&quot; method=&quot;post&quot;&gt; .... controller123456789101112131415161718192021222324@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;,&quot;/view-clazz.do&quot;,&quot;/modify-clazz.do&quot;&#125;)else if(&quot;/modify-clazz.do&quot;.equals(requestURI))&#123; this.modify(request,response) ;&#125;protected void modify(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置请求中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); //调用 自定义 工具类 实现：解析请求自动封装 pojo中 Clazz clazz = RequestUtil.parseParameter(request, Clazz.class); //4. 调用业务方法 boolean modifyRs = clazzService.modify(clazz); //5. 根据业务方法的返回值 if (modifyRs)&#123; //6.响应 //重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do&quot;); return; &#125; request.setAttribute(&quot;errorMsg&quot;,&quot;修改班级失败！！！&quot;); request.getRequestDispatcher(&quot;/view-clazz.do&quot;).forward(request,response);&#125; Service123public boolean modify(Clazz clazz) &#123; return clazzDAO.update(clazz) ;&#125; DAO1boolean update(Clazz clazz); 123456@Overridepublic boolean update(Clazz clazz) &#123; String DQL = &quot;update t_clazz set name=? where bno=?&quot; ; Object[] paramAy = &#123;clazz.getName(),clazz.getBno()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; 3. Many2Many3.1 数据建模表关系 表结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869drop table if exists t_clazz;/*==============================================================*//* Table: t_clazz 父 *//*==============================================================*/create table t_clazz( bno varchar(20) not null, name varchar(20), primary key (bno));alter table t_clazz comment &#x27;班级表&#x27;;drop table if exists t_student;/*==============================================================*//* Table: t_student 子 *//*==============================================================*/create table t_student( sid varchar(20) not null comment &#x27;学号 主键&#x27;, name varchar(20) comment &#x27;姓名&#x27;, age int(3) comment &#x27;年龄&#x27;, sex int(1) comment &#x27;性别 0 男 1 女&#x27;, bno varchar(20), primary key (sid));alter table t_student comment &#x27;学生信息表&#x27;;drop table if exists t_teacher;/*==============================================================*//* Table: t_teacher *//*==============================================================*/create table t_teacher( tno varchar(20) not null, tname varchar(20), primary key (tno));alter table t_teacher comment &#x27;教师表&#x27;;drop table if exists t_student_teacher;/*==============================================================*//* Table: t_student_teacher *//*==============================================================*/create table t_student_teacher( tno varchar(20) not null, sid varchar(20) not null comment &#x27;学号 主键&#x27;, primary key (tno, sid));alter table t_student_teacher comment &#x27;教师学生关系表&#x27;;alter table t_student_teacher add constraint FK_stu_teacher_teacher_tno foreign key (tno) references t_teacher (tno) on delete restrict on update restrict;alter table t_student_teacher add constraint FK_stu_teacher_stu_sid foreign key (sid) references t_student (sid) on delete restrict on update restrict;alter table t_student add constraint FK_stu_clazz_bno foreign key (bno) references t_clazz (bno) on delete restrict on update restrict; 表数据12345678910111213141516171819202122232425@Beforepublic void before()&#123; //清空表数据 truncate table 截断表 无法使用 关联关系 先删除儿子 在删除爹 jdbcTemplate.update(&quot;delete from t_student_teacher &quot;) ; jdbcTemplate.update(&quot;delete from t_teacher &quot;) ; jdbcTemplate.update(&quot;delete from t_student &quot;) ; jdbcTemplate.update(&quot;delete from t_clazz &quot;) ; //插入班级数据 jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B001&#x27;,&#x27;Java177&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B002&#x27;,&#x27;Java178&#x27;)&quot;) ; //插入学生 68 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student(sid,name,age,sex,bno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;张三&quot;+(i+1)+&quot;&#x27;,18,0,&#x27;B001&#x27;)&quot;) ; &#125; //插入教师数据 jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T001&#x27;,&#x27;赵贺贺&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T002&#x27;,&#x27;赵健&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T003&#x27;,&#x27;马美平&#x27;)&quot;) ; //插入学生与教师关系表 68*2 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student_teacher(sid,tno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;T001&#x27;),(&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;T002&#x27;)&quot;) ; &#125;&#125; 3.2 列表pojo1234public class Teacher &#123; private String tno ; private String tname ;&#125; 12345public class Student &#123; ... /**Many2Many 一个学生拥有多个老师 */ private List&lt;Teacher&gt; teacherList ;&#125; DAO123public interface TeacherDAO &#123; List&lt;Teacher&gt; selectBySid(String sid) ;&#125; 123456789public class TeacherDAOImpl implements TeacherDAO &#123; private JDBCTemplate jdbcTemplate = new JDBCTemplate() ; @Override public List&lt;Teacher&gt; selectBySid(String sid) &#123; String DQL = &quot;select tno,tname from t_teacher where tno in (select tno from t_student_teacher where sid = ?)&quot; ; Object[] paramAy = &#123;sid&#125; ; return jdbcTemplate.queryList(DQL, Teacher.class,paramAy); &#125;&#125; service123456789101112131415161718192021public class StudentService &#123; private TeacherDAO teacherDAO = new TeacherDAOImpl() ; public void selectPage(Page&lt;Student, StudentQuery&gt; page)&#123; //1.统计总记录数 long count = studentDAO.count(page.getCond()); //2.查询当前页面的数据 List&lt;Student&gt; studentList = studentDAO.selectPage(page); //循环所有的学生列表 for (Student student : studentList) &#123; //根据学号查询老师信息 List&lt;Teacher&gt; teacherList = teacherDAO.selectBySid(student.getSid()); //设置到 当前学生的 关联老师集合属性 student.setTeacherList(teacherList); &#125; //3. 设置总记录数 page.setTotalRecord(count); //4. 设置当前页的数据 page.setList(studentList); &#125;&#125; jsplist-stu.jsp 123456&lt;td&gt; &lt;c:forEach items=&quot;$&#123;student.teacherList&#125;&quot; var=&quot;teacher&quot; varStatus=&quot;vs&quot;&gt; $&#123;teacher.tname&#125; &lt;c:if test=&quot;$&#123;not vs.last&#125;&quot;&gt;,&lt;/c:if&gt; &lt;/c:forEach&gt;&lt;/td&gt; 3.3 显示关联教师DAO123public interface TeacherDAO &#123; List&lt;Teacher&gt; selectAll();&#125; 12345678public class TeacherDAOImpl implements TeacherDAO &#123; @Override public List&lt;Teacher&gt; selectAll() &#123; String DQL = &quot;select tno,tname from t_teacher&quot; ; Object[] paramAy = &#123;&#125; ; return jdbcTemplate.queryList(DQL, Teacher.class,paramAy); &#125;&#125; Service123456789101112131415161718public class StudentService &#123; private TeacherDAO teacherDAO = new TeacherDAOImpl() ; /** * 根据id 查询学生信息 * @param sid * @return */ public Student get(String sid)&#123; //学生信息 班级信息 Student student = studentDAO.selectById(sid) ; // N+1 根据学生id 查询关联的教师 List&lt;Teacher&gt; teacherList = teacherDAO.selectBySid(sid); // 设置当前学生关联的教师信息 student.setTeacherList(teacherList); return student ; &#125;&#125; Controller1234567891011121314151617181920@WebServlet(.... &quot;/toSelectView-teacher.do&quot;&#125;)else if (&quot;/toSelectView-teacher.do&quot;.equals(requestURI))&#123; this.toSelectTeacherView(request,response) ;&#125;protected void toSelectTeacherView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得学生的id String sid = request.getParameter(&quot;sid&quot;); //2.查询当前学生信息 Student student = studentService.get(sid); //3.查询所有的老师信息 List&lt;Teacher&gt; teacherList = teacherService.list() ; //4. 数据存放在作用域中 request.setAttribute(&quot;student&quot;,student); request.setAttribute(&quot;teacherList&quot;,teacherList); request.getRequestDispatcher(&quot;/select-teacher.jsp&quot;).forward(request,response);&#125; Jsplist-stu.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toSelectView-teacher.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;关联教师&lt;/a&gt; select-teacher.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div class=&quot;container&quot;&gt; &lt;h1&gt;学生选择教师&lt;/h1&gt; &lt;div class=&quot;widget-content padded clearfix&quot;&gt; &lt;!-- 学生基本信息 --&gt; &lt;table class=&quot;table detail-view&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性别&lt;/th&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;td&gt;$&#123;student.clazz.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;!-- 教师信息 --&gt; &lt;form action=&quot;&quot;&gt; &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/th&gt; &lt;th&gt;工号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;teacherList&#125;&quot; var=&quot;teacher&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;tno&quot; value=&quot;$&#123;teacher.tno&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;$&#123;teacher.tno&#125;&lt;/td&gt; &lt;td&gt;$&#123;teacher.tname&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;关联教师&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 循环当前学生的关联老师信息 &lt;c:forEach items=&quot;$&#123;student.teacherList&#125;&quot; var=&quot;teacher&quot;&gt; $(&quot;:checkbox[value=&#x27;$&#123;teacher.tno&#125;&#x27;]&quot;).prop(&#x27;checked&#x27;,true) &lt;/c:forEach&gt;&lt;/script&gt; 3.4 设置关联教师jspselect-teacher.jsp 123456 &lt;!-- 教师信息 --&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/set-teacher.do&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sid&quot; value=&quot;$&#123;student.sid&#125;&quot;&gt;.... &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;tno&quot; value=&quot;$&#123;teacher.tno&#125;&quot;/&gt;&lt;/td&gt; DAO12345public interface StudentDAO &#123; boolean deleteRefBySid(String sid) ; boolean insertRef(Student student) ;&#125; 12345678910111213141516171819202122232425public class StudentDAOImpl implements StudentDAO &#123; @Override public boolean deleteRefBySid(String sid) &#123; String DQL = &quot;delete from t_student_teacher where sid = ?&quot; ; Object[] paramAy = &#123;sid&#125; ; return jdbcTemplate.update(DQL,paramAy); &#125; @Override public boolean insertRef(Student student) &#123; //获得当前学生的学号 String sid = student.getSid(); //获得当前学生关联的教师信息 List&lt;Teacher&gt; teacherList = student.getTeacherList(); String DML = &quot;insert into t_student_teacher(sid,tno) values(?,?)&quot; ; Object[][] paramAy = new Object[teacherList.size()][2] ; for (int i = 0; i &lt; teacherList.size(); i++) &#123; //教师信息 Teacher teacher = teacherList.get(i); paramAy[i][0] = sid ; paramAy[i][1] = teacher.getTno() ; &#125; return jdbcTemplate.updateBatch(DML,paramAy); &#125;&#125; Service12345678910public class StudentService &#123; public boolean setTeacher(Student student)&#123; //1.中间表删除 当前学号 关联所有信息 boolean delRs = studentDAO.deleteRefBySid(student.getSid()) ; //2.批量新增 中间表 关联信息 boolean insertRs = studentDAO.insertRef(student) ; return delRs &amp;&amp; insertRs ; &#125;&#125; controller123456789101112131415161718192021222324252627@WebServlet(...&quot;/set-teacher.do&quot;&#125;)else if (&quot;/set-teacher.do&quot;.equals(requestURI))&#123; this.setTeacher(request,response) ;&#125;protected void setTeacher(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获得学生的id String sid = request.getParameter(&quot;sid&quot;); // 关联的教师工号 String[] tnoAy = request.getParameterValues(&quot;tno&quot;); //封装学生对象 Student student = new Student(); student.setSid(sid); List&lt;Teacher&gt; teacherList = new ArrayList&lt;&gt;() ; for (String tno : tnoAy) &#123; Teacher teacher = new Teacher(); teacher.setTno(tno); teacherList.add(teacher); &#125; //设置关联关系 student.setTeacherList(teacherList); boolean rs = studentService.setTeacher(student) ; //重新查询 response.sendRedirect(request.getContextPath()+&quot;/page-stu.do&quot;);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Vue指令学习","slug":"Vue指令学习","date":"2023-07-24T06:34:03.000Z","updated":"2023-07-25T11:25:24.993Z","comments":true,"path":"2023/07/24/Vue指令学习/","link":"","permalink":"http://example.com/2023/07/24/Vue%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Vue构成vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。之前接触到的 App.vue 文件本质上就是一个 vue 的组件。每个 .vue 组件都由 3 部分构成，分别是： 模板结构 功能 template 组件的模板结构 script 组件的 JavaScript 行为 style 组件的样式 其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。vue 规定：每个组件对应的模板结构，需要定义到 template 节点中。 在 template 中使用指令在组件的 template 节点中，支持使用前面所学的指令语法，来辅助开发者渲染当前组件的 DOM 结构。代码示例如下： 123456789&lt;template&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;!-- 使用&#123;&#123; &#125;&#125;插值表达式 --&gt;&lt;p&gt;生成一个随机数字: &#123;&#123; (Math. random() * 10). toFixed(2) &#125;&#125;&lt;/p&gt;&lt;!-- 使用v-bind属性绑定 --&gt;&lt;p :title=&quot;new Date().tolocaleTimeString()&quot;&gt;我在学习vue.js&lt;/p&gt;&lt;!-- 属性v-on事件绑定 --&gt;&lt;button @click=”showInfo&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt; 在 template 中定义根节点在 vue 2.x 的版本中，template 节点内的 DOM 结构仅支持单个根节点： 1234567&lt;template&gt; &lt;!-- vue 2.x中，template节点内的所有元素，最外层“必须有”唯一的根节点进行包裹，否则报错 --&gt;&lt;div&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;h2&gt;这是副标题&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt; 但是，在 vue 3.x 的版本中，&lt; template&gt; 中支持定义多个根节点： 12345&lt;template&gt;&lt;!-- 这是包含多个根节点的template结构，因为h1标签和h2标签外层没有包裹性质的根元素 --&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;h2&gt;这是副标题&lt;/h2&gt;&lt;/template&gt; 组件的 script 节点vue 规定：组件内的 &lt; script&gt; 节点是可选的，开发者可以在 &lt; script&gt; 节点中封装组件的 JavaScript 业务逻辑。&lt; script &gt; 节点的基本结构如下： 1234&lt;script&gt;//今后，组件相关的data数据、methods方法等，都需要定义到export default所导出的对象中。export default &#123;&#125;&lt;/script&gt; script 中的 name 节点可以通过 name 节点为当前组件定义一个名称，代码如下： 123456&lt;script&gt;export default &#123;// name属性指向的是当前组件的名称（建议：每个单词的首字母大写）name: &#x27;MyApp&#x27;&#125;&lt;/script&gt; 在使用 vue-devtools 进行项目调试的时候，自定义的组件名称可以清晰的区分每个组件。 script 中的 data 节点vue 组件渲染期间需要用到的数据，可以定义在 data 节点中： 123456789101112&lt;script&gt;export default &#123;// 组件的名称 name: &#x27;MyApp&#x27;,// 组件的数据（data方法中return出去的对象，就是当前组件渲染期间需要用到的数据对象） data() &#123; return &#123; username: &#x27;哇哈哈&#x27;, &#125; &#125;,&#125;&lt;/script&gt; 其中组件中的 data 必须是函数，vue 规定：组件中的 data 必须是一个函数，不能直接指向一个数据对象。因此在组件中定义 data 数据节点时，下面的方式是错误的： 123data: &#123; // 组件中，不能直接让 data 指向一个数据对象（会报错） count: 0&#125; script 中的 methods 节点组件中的事件处理函数，必须定义到 methods 节点中，示例代码如下： 12345678910111213export default &#123; name: &#x27;MyApp&#x27;, // 组件的名称 data() &#123; // 组件的数据 return &#123; count: 0, &#125; &#125;, methods: &#123; //处理函数 addCount() &#123; this.count++ &#125;, &#125;,&#125; 组件的 style 节点vue 规定：组件内的 &lt; style &gt; 节点是可选的，开发者可以在 &lt; style &gt; 节点中编写样式美化当前组件的 UI 结构。&lt; script &gt; 节点的基本结构如下： 12345&lt;style&gt;h1 &#123;font-weight: normal;&#125;&lt;/style&gt; 其中 &lt; style &gt; &lt;&#x3D;”” font&#x3D;””&gt; 标签上的 lang&#x3D;”css” 属性是可选的，它表示所使用的样式语言。默认只支持普通的 css 语法，可选值还有 less、scss 等。多学一招：让 style 中支持 less 语法：如果希望使用 less 语法编写组件的 style 样式，可以按照如下两个步骤进行配置：① 运行 npm install less -D 命令安装依赖包，从而提供 less 语法的编译支持；② 在 &lt; style &gt; &lt;&#x3D;”” font&#x3D;””&gt; 标签上添加 lang&#x3D;”less” 属性，即可使用 less 语法编写组件的样式。 123456789&lt;style&gt;h1 &#123;font-weight: normal;&#125;i &#123;color: red;font-style: normal;&#125;&lt;/style&gt; Vue指令插值表达式 目的: 在dom标签中, 直接插入内容 又叫: 声明式渲染&#x2F;文本插值 语法: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; person.age &gt; 100 ? `老头` : `小伙` &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // data 格式固定, 定义vue数据之处 data() &#123; // key相当于变量名 return &#123; msg: `hello vue!!!`, person: &#123; name: `张三丰`, age: 108, &#125;, &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 总结: dom中插值表达式赋值, vue的变量必须在data里声明注意点：1.在插值表达式中使用的数据 必须在data中进行了提供2.支持的是表达式，而非语句，比如：if for …3.不能在标签属性中使用插值（插值表达式只能在标签中间使用），比如：&lt;p title=&quot;&#123;&#123;username&#125;&#125;&quot;&gt;我是P标签&lt;/p&gt; v-bind 目标: 给标签属性设置vue变量的值 vue指令, 实质上就是特殊的 html 标签属性, 特点: v- 开头 每个指令, 都有独立的作用 语法：v-bind:属性名=&quot;vue变量&quot; 简写：:属性名=&quot;vue变量&quot; 123456789&lt;!-- vue指令-v-bind属性动态赋值 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;我是a标签&lt;/a&gt;&lt;img :src=&quot;imgSrc&quot;&gt;图片服务器:https://demo-video-oss.oss-cn-hangzhou.aliyuncs.com/images/mm.jpg或 指定尺寸 https://demo-video-oss.oss-cn-hangzhou.aliyuncs.com/images/mm.jpg?x-oss-process=image/resize,w_60,h_60 总结: 把vue变量的值, 赋予给dom属性上, 影响标签显示效果 v-on 目标: 给标签绑定事件 语法 v-on:事件名&#x3D;”要执行的 少量代码 “ v-on:事件名&#x3D;”methods中的函数” v-on:事件名&#x3D;”methods中的函数(实参)” 简写: @事件名&#x3D;”methods中的函数” 123456789101112131415161718192021222324&lt;!-- vue指令: v-on事件绑定--&gt;&lt;p&gt;你要买商品的数量: &#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count = count + 1&quot;&gt;增加1&lt;/button&gt;&lt;button v-on:click=&quot;addFn&quot;&gt;增加1个&lt;/button&gt;&lt;button v-on:click=&quot;addCountFn(5)&quot;&gt;一次加5件&lt;/button&gt;&lt;button @click=&quot;subFn&quot;&gt;减少&lt;/button&gt;&lt;script&gt; export default &#123; // ...其他省略 methods: &#123; addFn()&#123; // this代表export default后面的组件对象(下属有data里return出来的属性) this.count++ &#125;, addCountFn(num)&#123; this.count += num &#125;, subFn()&#123; this.count-- &#125; &#125; &#125;&lt;/script&gt; 总结: 常用@事件名, 给dom标签绑定事件, 以及&#x3D;右侧事件处理函数 v-on事件对象 目标: vue事件处理函数中, 拿到事件对象 语法: 无传参, 通过形参直接接收 传参, 通过$event指代事件对象传给事件处理函数 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止百度&lt;/a&gt; &lt;hr&gt; &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止去百度&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; one(e)&#123; e.preventDefault() &#125;, two(num, e)&#123; e.preventDefault() &#125; &#125;&#125;&lt;/script&gt; v-on修饰符 目的: 在事件后面.修饰符名 - 给事件带来更强大的功能 语法: @事件名.修饰符&#x3D;”methods里函数” .stop - 阻止事件冒泡 .prevent - 阻止默认行为 .once - 程序运行期间, 只触发一次事件处理函数 123456789101112131415161718192021&lt;template&gt; &lt;div @click=&quot;fatherFn&quot;&gt; &lt;!-- vue对事件进行了修饰符设置, 在事件后面.修饰符名即可使用更多的功能 --&gt; &lt;button @click.stop=&quot;btn&quot;&gt;.stop阻止事件冒泡&lt;/button&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;.prevent阻止默认行为&lt;/a&gt; &lt;button @click.once=&quot;btn&quot;&gt;.once程序运行期间, 只触发一次事件处理函数&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fatherFn()&#123; console.log(&quot;father被触发&quot;); &#125;, btn()&#123; console.log(1); &#125; &#125;&#125;&lt;/script&gt; 总结: 修饰符给事件扩展额外功能 v-on按键修饰符 目标: 给键盘事件, 添加修饰符, 增强能力 语法: @keyup.enter - 监测回车按键 @keyup.esc - 监测返回按键 更多修饰符 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; enterFn()&#123; console.log(&quot;enter回车按键了&quot;); &#125;, escFn()&#123; console.log(&quot;esc按键了&quot;); &#125; &#125;&#125;&lt;/script&gt; 总结: 多使用事件修饰符, 可以提高开发效率, 少去自己判断过程 例1：翻转字符串 目标: 点击按钮 - 把文字取反显示 - 再点击取反显示(回来了) 提示: 把字符串取反赋予回去 正确代码: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;反转字符串&lt;/h1&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;reverseStr&quot;&gt;反转字符串&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: `我是我爹的儿`, &#125; &#125;, methods: &#123; reverseStr() &#123; this.msg = this.msg.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 总结: 记住方法特点, 多做需求, vue是数据变化视图自动更新, 减少操作DOM时间, 提高开发效率 v-model 目标: 把value属性和vue数据变量, 双向绑定到一起 语法: v-model&#x3D;”vue数据变量” 双向数据绑定 数据变化 -&gt; 视图自动同步 视图变化 -&gt; 数据自动同步 演示: 用户名绑定 - vue内部是MVVM设计模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;!-- v-model:是实现vuejs变量和表单标签value属性, 双向绑定的指令 --&gt; &lt;div&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; v-model=&quot;pass&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;来自于: &lt;/span&gt; &lt;!-- 下拉菜单要绑定在select上 --&gt; &lt;select v-model=&quot;from&quot;&gt; &lt;option value=&quot;北京市&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;南京市&quot;&gt;南京&lt;/option&gt; &lt;option value=&quot;天津市&quot;&gt;天津&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- (重要) 遇到复选框, v-model的变量值 非数组 - 关联的是复选框的checked属性 数组 - 关联的是复选框的value属性 --&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;抽烟&quot;&gt;抽烟 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;喝酒&quot;&gt;喝酒 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;写代码&quot;&gt;写代码 &lt;/div&gt; &lt;div&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;男 &lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;女 &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍&lt;/span&gt; &lt;textarea v-model=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; username: &quot;&quot;, pass: &quot;&quot;, from: &quot;&quot;, hobby: [], sex: &quot;&quot;, intro: &quot;&quot;, &#125;; // 总结: // 特别注意: v-model, 在input[checkbox]的多选框状态 // 变量为非数组, 则绑定的是checked的属性(true/false) - 常用于: 单个绑定使用 // 变量为数组, 则绑定的是他们的value属性里的值 - 常用于: 收集勾选了哪些值 &#125;&#125;;&lt;/script&gt; 总结: 本阶段v-model只能用在表单元素上, 以后学组件后讲v-model高级用法 v-model修饰符 目标: 让v-model拥有更强大的功能 语法: v-model.修饰符&#x3D;”vue数据变量” .number 以parseFloat转成数字类型 .trim 去除首尾空白字符 （记下：去除字符串中间 空格 不是vue ） .lazy 在change事件时触发而非inupt触发 时 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;span&gt;年龄:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;人生格言:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;motto&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍:&lt;/span&gt; &lt;textarea v-model.lazy=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: &quot;&quot;, motto: &quot;&quot;, intro: &quot;&quot; &#125; &#125;&#125;&lt;/script&gt; 总结: v-model修饰符, 可以对值进行预处理, 非常高效好用 v-text和v-html 目的: 更新DOM对象的innerText&#x2F;innerHTML 语法: v-text&#x3D;”vue数据变量” v-html&#x3D;”vue数据变量” 注意: 会覆盖插值表达式 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; str: &quot;&lt;span&gt;我是一个span标签&lt;/span&gt;&quot; &#125; &#125;&#125;&lt;/script&gt; 总结: v-text把值当成普通字符串显示, v-html把值当做html解析 v-show和v-if 目标: 控制标签的隐藏或出现 语法: v-show&#x3D;”vue变量” v-if&#x3D;”vue变量” 原理 v-show 用的display:none隐藏 (频繁切换使用) v-if 直接从DOM树上移除 高级 v-else使用 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 v-show=&quot;isOk&quot;&gt;v-show的盒子&lt;/h1&gt; &lt;h1 v-if=&quot;isOk&quot;&gt;v-if的盒子&lt;/h1&gt; &lt;div&gt; &lt;p v-if=&quot;age &gt; 18&quot;&gt;我成年了&lt;/p&gt; &lt;p v-else&gt;还得多吃饭&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isOk: true, age: 15 &#125; &#125;&#125;&lt;/script&gt; 总结: 使用v-show和v-if以及v-else指令, 方便通过变量控制一套标签出现&#x2F;隐藏 例2：折叠面板 目标: 点击展开或收起时，把内容区域显示或者隐藏 此案例使用了less语法, 项目中下载模块 1yarn add less@3.0.4 less-loader@5.0.0 -D 只有标签和样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; &gt; 收起 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;body &#123; background-color: #ccc; #app &#123; width: 400px; margin: 20px auto; background-color: #fff; border: 4px solid blueviolet; border-radius: 1em; box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.5); padding: 1em 2em 2em; h3 &#123; text-align: center; &#125; .title &#123; display: flex; justify-content: space-between; align-items: center; border: 1px solid #ccc; padding: 0 1em; &#125; .title h4 &#123; line-height: 2; margin: 0; &#125; .container &#123; border: 1px solid #ccc; padding: 0 1em; &#125; .btn &#123; /* 鼠标改成手的形状 */ cursor: pointer; &#125; &#125;&#125;&lt;/style&gt; 参考答案: 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt; &#123;&#123; isShow ? &#x27;收起&#x27; : &#x27;展开&#x27; &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt; &lt;p&gt;寒雨连江夜入吴, &lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isShow: false &#125; &#125;&#125;&lt;/script&gt; v-for 目标: 列表渲染, 所在标签结构, 按照数据数量, 循环生成 语法 v-for&#x3D;”(值, 索引) in 目标结构” v-for&#x3D;”值 in 目标结构” 目标结构: 可以遍历数组 &#x2F; 对象 &#x2F; 数字 &#x2F; 字符串 (可遍历结构) 注意: v-for的临时变量名不能用到v-for范围外 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- v-for 把一组数据, 渲染成一组DOM --&gt; &lt;!-- 口诀: 让谁循环生成, v-for就写谁身上 --&gt; &lt;p&gt;学生姓名&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;item&quot;&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;学生详细信息&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;obj in stuArr&quot; :key=&quot;obj.id&quot;&gt; &lt;span&gt;&#123;&#123; obj.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.sex &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.hobby &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- v-for遍历对象(了解) --&gt; &lt;p&gt;老师信息&lt;/p&gt; &lt;div v-for=&quot;(value, key) in tObj&quot; :key=&quot;value&quot;&gt; &#123;&#123; key &#125;&#125; -- &#123;&#123; value &#125;&#125; &lt;/div&gt; &lt;!-- v-for遍历整数(了解) - 从1开始 --&gt; &lt;p&gt;序号&lt;/p&gt; &lt;div v-for=&quot;i in count&quot; :key=&quot;i&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; arr: [&quot;小明&quot;, &quot;小欢欢&quot;, &quot;大黄&quot;], stuArr: [ &#123; id: 1001, name: &quot;孙悟空&quot;, sex: &quot;男&quot;, hobby: &quot;吃桃子&quot;, &#125;, &#123; id: 1002, name: &quot;猪八戒&quot;, sex: &quot;男&quot;, hobby: &quot;背媳妇&quot;, &#125;, ], tObj: &#123; name: &quot;蜘蛛精&quot;, age: 18, class: &quot;昆虫&quot;, &#125;, count: 10, &#125;; &#125;,&#125;;&lt;/script&gt; 总结: vue最常用指令, 铺设页面利器, 快速把数据赋予到相同的dom结构上循环生成","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Java-常见异常","slug":"Java-常见异常","date":"2023-07-20T10:54:44.000Z","updated":"2023-08-03T01:27:16.127Z","comments":true,"path":"2023/07/20/Java-常见异常/","link":"","permalink":"http://example.com/2023/07/20/Java-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/","excerpt":"","text":"1.ClassCastException(类转换异常)数据类型转换错误，比如有个String temp&#x3D;”abc”; 如果设为(int)temp就会报错了，因为它们类型不一样，但是设为(object)temp就可以，因为object是它们的父类 2.IndexOutOfBoundsException(数组越界)这个异常我们在操作数组的时候会经常遇到，异常的解释是“数组下标越界”，现在程序中大多都有对数组的操作，因此在调用数组的时候一定要认真检查，看自己调用的下标是不是超出了数组的范围，一般来说，显示(即直接用常数当下标)调用不太容易出这样的错，但隐式(即用变量表示下标)调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。 3.NullPointerException(空指针)这个异常在编程时也经常遇到，异常的解释是 “程序遇上了空指针”，简单地说就是调用了未经初始化的对象或者是不存在的对象，这个错误经常出现在调用数组这些操作中，对数组操作中出现空指针，很多情况下是一些刚开始学习编程的人常犯的错误，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化(如果要调用的话)。 4.IllegalAccessException(安全权限异常)这个异常的解释是“没有访问权限“，当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常。 5. IOException(输入输出异常)一般读写文件会出现这个异常,比如你想从磁盘上读一个文件到你写的程序,如果硬盘上没有这文件,java虚拟机就会报这个异常","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-多表查询","slug":"Mysql-多表查询","date":"2023-07-18T16:27:20.000Z","updated":"2023-07-18T16:30:57.140Z","comments":true,"path":"2023/07/19/Mysql-多表查询/","link":"","permalink":"http://example.com/2023/07/19/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"1.DDLcreate 创建 alter 修改 drop 删除 truncate清空&#x2F;截断 【事务自动提交】 1.1 创建表常用创建 1234567表名 练习： t_emp tb_emp tbl_emp 项目： sys_ oa_ order_ product_create table 表名( 字段名 数据类型 [列级约束], 字段名 数据类型 [列级约束], [表级约束]) ; 1234CREATE TABLE t_emp01( id INT, NAME VARCHAR(20)) ; 查看表结构 1DESC t_emp01; 查看表创建语句 1SHOW CREATE TABLE t_emp01 ; CTAS语法创建表【没约束】 123CREATE TABLE emp10 AS SELECT * FROM emp WHERE deptno = 10;CREATE TABLE emp20 AS SELECT empno id,ename NAME,sal sal FROM emp WHERE deptno = 20;CREATE TABLE myemp AS SELECT * FROM emp WHERE 1=2 ; 1.2 约束主键 PK 非空+唯一 123456789101112131415CREATE TABLE t_emp02( id INT PRIMARY KEY, NAME VARCHAR(20)) ;或CREATE TABLE t_emp03( id INT , NAME VARCHAR(20), PRIMARY KEY (id)) ;INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;a&#x27;) ;INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) ;查询：INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) 错误代码： 1062Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27; 123456789CREATE TABLE t_emp04( id INT , NAME VARCHAR(20), PRIMARY KEY (id,NAME) -- 联合主键) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;a&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;2&#x27;,&#x27;b&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;2&#x27;,&#x27;a&#x27;) ; 查看表约束 123-- 查询数据字典：SELECT * FROM `information_schema`.`TABLE_CONSTRAINTS` WHERE TABLE_SCHEMA=&#x27;scott&#x27; AND table_name=&#x27;t_emp04&#x27;; 外键 FK 参考完整性 可以为 NULL 给值 只能关联 另一个主键 123456789101112131415161718192021222324CREATE TABLE mydept AS SELECT * FROM dept ;CREATE TABLE myemp02 ( id INT PRIMARY KEY, NAME VARCHAR(20), deptno INT REFERENCES mydept(deptno)) ;或CREATE TABLE myemp03 ( id INT PRIMARY KEY, NAME VARCHAR(20), deptno INT , CONSTRAINT fk_myemp03 FOREIGN KEY (deptno) REFERENCES mydept(deptno) -- 注意：PK) ;INSERT INTO myemp03(id,NAME,deptno) VALUES (3,&#x27;aaa&#x27;,NULL) ;INSERT INTO myemp03(id,NAME,deptno) VALUES (4,&#x27;aaa&#x27;,88) ; -- 88 部门表中没有该数据查询：INSERT INTO myemp03(id,NAME,deptno) VALUES (4,&#x27;aaa&#x27;,88) 错误代码： 1452Cannot add or update a child row: a foreign key constraint fails (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `mydept` (`DEPTNO`))DELETE FROM `mydept` WHERE deptno = 10 ; -- 10部门下 有关联的员工查询：delete from `mydept` where deptno = 10 错误代码： 1451Cannot delete or update a parent row: a foreign key constraint fails (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `mydept` (`DEPTNO`)) 非空 1234CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) NOT NULL -- 该列不能为空) ; 唯一 1234CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) UNIQUE -- 该列唯一 可以为 null 【只能一个null】) ; 默认值 12345CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) , age INT DEFAULT 18 ) ; 自增长 123456789-- 历史遗留问题：ID 使用雪花算法 【通过程序控制】CREATE TABLE t_emp08( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ) ;INSERT INTO t_emp08 (id,NAME) VALUES (NULL,&#x27;a&#x27;) ;INSERT INTO t_emp08 (id,NAME) VALUES (200,&#x27;b&#x27;) ;INSERT INTO t_emp08 (id,NAME) VALUES (NULL,&#x27;c&#x27;) ; 1.3 修改表注意： 权限问题 ？ 修改表名 1ALTER TABLE t_emp08 RENAME TO tbl_emp08 ; 修改字段名 1ALTER TABLE tbl_emp08 CHANGE NAME e_name VARCHAR(20); 修改字段类型 1ALTER TABLE tbl_emp08 MODIFY e_name VARCHAR(80); 添加字段 12ALTER TABLE tbl_emp08 ADD age INT ;ALTER TABLE tbl_emp08 ADD sex INT AFTER id ; 删除字段 1ALTER TABLE tbl_emp08 DROP COLUMN sex ; 1.4 删除表12-- 最新的备份 最新的简历DROP TABLE tbl_emp08 ; 1.5 清空表1234567891011-- 1. 清空表中数据 表结构保留 DDL事务自动提交 不可回滚 速度快 自增长从1开始-- 降低高水位TRUNCATE TABLE myemp03 ;TRUNCATE TABLE mydept; -- FK 外键引用查询：truncate table mydept错误代码： 1701Cannot truncate a table referenced in a foreign key constraint (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `scott`.`mydept` (`DEPTNO`))-- 2. delete where过滤条件 DML语句 事务不提交 可以回滚 速度慢delete from myemp03 where .... DDL练习12345678910111213141516171819202122232425262728293031323334351.创建一张表 student id int name varchar(10) age int(10) tel varchar（10） 给 id 字段添加主键约束 自增长 给 name 字段添加非空约束 给 age 字段 默认值 0 给 tel 添加唯一 非空 约束 2.创建一张学员兴趣爱好表 hobby id int(10) hobby_name varchar(10) sid int --学生 id 给 sid 字段添加外键约束 3.创建一个表emp1empno int(10)ename varchar(50)4.emp1 添加一个字段 sal int(4)5.emp1 修改字段 ename varchar(100) 6.emp1 删除字段 sal7.把表 emp1 改成 emp2 SQL面试题面试题一（厦门）12345678910111213141516Table: （员工emp1） id name 1 a 2 b 3 c 4 dTable:( 性别sext) id sex 1 男 4 女 5 男找出忘记填写性别的员工? create table emp1(id int,name varchar(20)) ; insert into emp1(id,name) values (1,&#x27;a&#x27;),(2,&#x27;b&#x27;),(3,&#x27;c&#x27;),(4,&#x27;d&#x27;) ; create table sext(id int,sex varchar(20)) ; insert into sext(id,sex) values (1,&#x27;男&#x27;),(4,&#x27;女&#x27;),(5,&#x27;男&#x27;) ; 12345-- 员工id 没有在 sext表出现过? -- inselect * from emp1 where id not in (select id from sext) ;-- existsselect * from emp1 e where not exists (select null from sext where id=e.id) ; 面试题二（上海）12345678910111213141516表一(AAA) 商品名称 mc 商品总量 sl A 100 B 120表二(BBB) 商品名称 mc 出库数量 sl A 10 A 20 B 10 B 20 B 30用一条 SQL 语句算出商品 A,B 目前还剩多少？ create table AAA(mc varchar(20),sl int) ; insert into AAA (mc,sl) values (&#x27;A&#x27;,100),(&#x27;B&#x27;,120) ; create table BBB(mc varchar(20),sl int) ; insert into BBB (mc,sl) values (&#x27;A&#x27;,10),(&#x27;A&#x27;,20),(&#x27;B&#x27;,10),(&#x27;B&#x27;,20),(&#x27;B&#x27;,30) ; 12345678910111213-- 期望结果： -- mc sl-- A 70 -- B 60 -- 方法1: 子查询 select mc, sl-(select sum(sl) from BBB where mc=a.mc) sy from AAA a ;-- 方法2: 多表-- 先分组select mc,sum(sl) from BBB group by mc ;-- 看做一张表select a.mc, a.sl-t.sum_sl from AAA a join (select mc,sum(sl) sum_sl from BBB group by mc) t on a.mc = t.mc ; 面试题三（上海）1234567891011121314151617181920212223242526272829人员情况表（employee）中字段包括，员工号（ID），姓名（name），年龄（age），文化程度（wh）：包括四种情况（本科以上，大专，高中，初中以下）,现在我要根据年龄字段查询统计出：表中文化程度为本科以上，大专，高中，初中以下，各有多少人，占总人数多少。结果如下A：学历 年龄 人数 百分比本科以上 20 34 14大专 20 33 13高中 20 33 13初中以下 20 100 40本科以上 21 50 20。。。。。。SQL 查询语句如何写？create table employee(id int primary key auto_increment, name varchar(20), age int(2), wh varchar(20) ) ;insert into employee(id,name,age,wh) values (null,&#x27;a&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;b&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;c&#x27;,21,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;d&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;大专&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,21,&#x27;大专&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,21,&#x27;高中&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;高中&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;初中以下&#x27;) ; 123456查询结果集B：-- [行列转换]学历 20岁 21岁本科以上 3 1大专 2 2高中 4 1SQL 查询语句如何写？ 面试题四（福州）1234567891011121314151617181920212223242526272829303132333435363738四张表-- 学生表 create table student(sid varchar(20),sname varchar(20));insert into student values(1,&#x27;小明&#x27;);insert into student values(2,&#x27;小花&#x27;);-- 教师表 create table teacher(tid varchar(20),tname varchar(20)) ;insert into teacher values(1,&#x27;陈红&#x27;);insert into teacher values(2,&#x27;陈白&#x27;);-- 课程表 create table course(cid varchar(20),cname varchar(20)，ctype varchar(20)) ;insert into course values(1,&#x27;语文&#x27;,&#x27;文科&#x27;);insert into course values(2,&#x27;数学&#x27;,&#x27;理科&#x27;);-- 选课表 create table choose_course(ccid varchar(20),sid varchar(20),tid varchar(20), cid varchar(20));-- 小明选了陈红老师的语文insert into choose_course values(1,1,1,1);-- 小明选了陈红老师的数学insert into choose_course values(2,1,1,2);-- 小花选了陈红老师的数学insert into choose_course values(3,2,1,2);-- 小明选了陈白老师的语文insert into choose_course values(1,1,2,1);-- 小花选了陈红老师的语文insert into choose_course values(4,2,1,1);-- 1. 查找陈红老师教的学生是那些？-- 2.找学生小明所有的文科老师？-- 3.找出没有选修陈红老师的学生？-- 4.教的学生最少的老师？ 面试题五（厦门）12345678910111213141516171819202122232425262728293031323334-- 8:00--12:00 为迟到, 12:00--18:00 为早退-- 打卡表 card create table card( cid int(10), ctime timestamp , cuser int(10) ); -- 人员表 personcreate table person( pid int(10), name varchar(10)) ;-- 插入人员表的数据insert into person values(1,&#x27;a&#x27;);insert into person values(2,&#x27;b&#x27;);-- 插入打卡的数据insert into card values(1,&#x27;2009-07-19 08:02:00&#x27;,1);insert into card values(2,&#x27;2009-07-19 18:02:00&#x27;,1);insert into card values(3,&#x27;2009-07-19 09:02:00&#x27;,2);insert into card values(4,&#x27;2009-07-19 17:02:00&#x27;,2);insert into card values(5,&#x27;2009-07-20 08:02:00&#x27;,1);insert into card values(6,&#x27;2009-07-20 16:02:00&#x27;,1);insert into card values(7,&#x27;2009-07-20 07:02:00&#x27;,2);insert into card values(8,&#x27;2009-07-20 20:02:00&#x27;,2);-- 查询 迟到 早退的员工姓名？查询结果如下:工号 姓名 打卡日期 上班打卡 下班打卡 迟到 早退1 a 2009-07-19 08:02:00 18:02:00 是 否1 a 2009-07-20 08:02:00 16:02:00 是 是2 b 2009-07-19 09:02:00 17:02:00 是 是 2. DML事务不自动提交 2.1 插入数据所有字段插入 123INSERT INTO dept(deptno,dname,loc) VALUES (11,&#x27;dev&#x27;,&#x27;NJ&#x27;) ;-- 所有列插入 可以省略列名 【不建议】 考虑兼容问题？INSERT INTO dept VALUES (12,&#x27;dev&#x27;,&#x27;NJ&#x27;) ; 插入多条 1INSERT INTO dept(deptno,dname,loc) VALUES (13,&#x27;dev&#x27;,&#x27;NJ&#x27;),(14,&#x27;test&#x27;,&#x27;BJ&#x27;) ; 查询结果集插入 1234-- CTAS 语法创建表 【同时拷贝数据 没有约束】CREATE TABLE myemp AS SELECT * FROM emp ;-- 查询结果集 插入 myemp表中INSERT INTO myemp SELECT * FROM emp ; 2.2 更新数据1UPDATE myemp SET sal=sal*1.5 ,comm=500 WHERE empno =7788 ; 2.3 删除数据1DELETE FROM myemp WHERE empno = 7788 ; DML练习：123456789-- 1.往 emp 表中插入 empno,ename,sal 数据（111,&#x27;1&#x27;,1000)(222,&#x27;2&#x27;,2000) insert into emp(empno,ename,sal) values (111,&#x27;1&#x27;,1000),(222,&#x27;2&#x27;,2000) ;-- 2.把 empno=111 的员工 comm 改成 100 update emp set comm = 100 where empno = 111 ;-- 3.往 dept 表中插入编号50 ，dname，loc 与10部门相同 的数据 insert into dept(deptno,dname,loc) select 55,dname,loc from dept where deptno=10 ;-- 4.删除 empno=111 的数据 delete from emp where empno=111 ; 3. 视图view &#x3D; 虚表 table &#x3D; 基表 【1.数据安全性 2.简化查询】 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 3.1 简单视图增删改查 &#x3D;&#x3D;&gt; 基表 增删改查 123456789-- 创建或替换视图CREATE OR REPLACE VIEW v_emp10ASSELECT empno,ename,sal FROM emp WHERE deptno = 10 ;-- 查询 基表SELECT * FROM v_emp10 ;-- 插入视图数据 基表数据插入INSERT INTO v_emp10 (empno,ename,sal) VALUES (333,&#x27;xxx&#x27;,800) ; 3.2 高级视图只能查询 无法新增 删除 修改 【统计函数 ，多表数据】 1234567CREATE OR REPLACE VIEW v_emp10ASSELECT deptno,COUNT(0) cut FROM emp GROUP BY deptno ;SELECT * FROM v_emp10 ;-- 无法插入数据 基表没有该列【cut 统计出来的】INSERT INTO v_emp10 (deptno,cut) VALUES (80,6) ; 视图练习1234-- 1.创建一个包含所有雇员的雇员编号、雇员名称、部门名称和薪金的视图 -- 2.创建一个包含各种工作的薪金总和的视图 4.索引 4.1 优缺点&#x2F;分类123456789101112优势1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。劣势1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。索引分类1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引2） 唯一索引 ：索引列的值必须唯一，但允许有空值3） 复合索引 ：即一个索引包含多个列 4.2 创建索引1234-- 创建索引CREATE INDEX idx_dept_dname ON dept(dname) ;-- 查看SQL执行计划EXPLAIN SELECT * FROM dept WHERE dname=&#x27;SALES&#x27;; 4.3 删除索引12-- 删除索引DROP INDEX idx_dept_dname ON dept ; 4.4 查看索引1SHOW INDEX FROM dept ; 4.5 索引设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I&#x2F;O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 12345678创建复合索引: CREATE INDEX idx_name_email_status ON tb_xx(NAME,email,STATUS);就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 索引练习:1-- 1. 在 emp 表的 ename 上创建一个索引 并查看执行计划？ 5. 存储过程 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 5.1 创建存储过程1234CREATE PROCEDURE procedure_name ([proc_parameter[,...]])begin -- SQL语句end ; 示例 ： 12345678delimiter $create procedure pro_test1()begin select &#x27;Hello Mysql&#x27; ;end$delimiter ; DELIMITER 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 5.2 调用存储过程1call procedure_name() ; 5.3 查看存储过程12345678910-- 查询db_name数据库中的所有的存储过程select name from mysql.proc where db=&#x27;db_name&#x27;;-- 查询存储过程的状态信息show procedure status;-- 查询某个存储过程的定义show create procedure test.pro_test1 \\G; 5.4 删除存储过程1DROP PROCEDURE [IF EXISTS] sp_name ； 5.5 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 1DECLARE var_name[,...] type [DEFAULT value] 示例 : 123456789delimiter $create procedure pro_test2() begin declare num int default 5; select num+ 10; end$delimiter ; SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： 1SET var_name = expr [, var_name = expr] ... 示例 : 12345678910DELIMITER $CREATE PROCEDURE pro_test3()BEGIN DECLARE NAME VARCHAR(20); SET NAME = &#x27;MYSQL&#x27;; SELECT NAME ;END$DELIMITER ; 也可以通过select … into 方式进行赋值操作 : 12345678910DELIMITER $CREATE PROCEDURE pro_test5()BEGIN declare countnum int; select count(*) into countnum from city; select countnum;END$DELIMITER ; if条件判断语法结构 : 1234567if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 需求： 1234567根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ----------&gt; 身材高挑 170 - 180 ---------&gt; 标准身材 170 以下 ----------&gt; 一般身材 示例 : 12345678910111213141516171819delimiter $create procedure pro_test6()begin declare height int default 175; declare description varchar(50); if height &gt;= 180 then set description = &#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description = &#x27;标准身材&#x27;; else set description = &#x27;一般身材&#x27;; end if; select description ;end$delimiter ; 调用结果为 : 传递参数语法格式 : 1234567create procedure procedure_name([in/out/inout] 参数名 参数类型)...IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认OUT: 该参数作为输出，也就是该参数可以作为返回值INOUT: 既可以作为输入参数，也可以作为输出参数 IN - 输入 需求 : 1根据定义的身高变量，判定当前身高的所属的身材类型 示例 : 12345678910111213141516delimiter $create procedure pro_test5(in height int)begin declare description varchar(50) default &#x27;&#x27;; if height &gt;= 180 then set description=&#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description=&#x27;标准身材&#x27;; else set description=&#x27;一般身材&#x27;; end if; select concat(&#x27;身高 &#x27;, height , &#x27;对应的身材类型为:&#x27;,description);end$delimiter ; OUT-输出 需求 : 1根据传入的身高变量，获取当前身高的所属的身材类型 示例: 12345678910create procedure pro_test5(in height int , out description varchar(100))begin if height &gt;= 180 then set description=&#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description=&#x27;标准身材&#x27;; else set description=&#x27;一般身材&#x27;; end if;end$ 调用: 123call pro_test5(168, @description)$select @description$ @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 case结构语法结构 : 12345678910111213141516171819202122232425方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE;方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 需求: 1给定一个月份, 然后计算出所在的季度 示例 : 1234567891011121314151617181920212223delimiter $create procedure pro_test9(month int)begin declare result varchar(20); case when month &gt;= 1 and month &lt;=3 then set result = &#x27;第一季度&#x27;; when month &gt;= 4 and month &lt;=6 then set result = &#x27;第二季度&#x27;; when month &gt;= 7 and month &lt;=9 then set result = &#x27;第三季度&#x27;; when month &gt;= 10 and month &lt;=12 then set result = &#x27;第四季度&#x27;; end case; select concat(&#x27;您输入的月份为 :&#x27;, month , &#x27; , 该月份为 : &#x27; , result) as content ; end$delimiter ; while循环语法结构: 12345while search_condition do statement_list end while; 需求: 1计算从1加到n的值 示例 : 1234567891011121314delimiter $create procedure pro_test8(n int)begin declare total int default 0; declare num int default 1; while num&lt;=n do set total = total + num; set num = num + 1; end while; select total;end$delimiter ; repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : 1234567REPEAT statement_list UNTIL search_conditionEND REPEAT; 需求: 1计算从1加到n的值 示例 : 123456789101112131415161718delimiter $create procedure pro_test10(n int)begin declare total int default 0; repeat set total = total + n; set n = n - 1; until n=0 end repeat; select total ; end$delimiter ; loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： 12345[begin_label:] LOOP statement_listEND LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 eave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： 123456789101112131415161718192021delimiter $CREATE PROCEDURE pro_test11(n int)BEGIN declare total int default 0; ins: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP ins; select total;END$delimiter ; 游标&#x2F;光标游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。 声明光标： 1DECLARE cursor_name CURSOR FOR select_statement ; OPEN 光标： 1OPEN cursor_name ; FETCH 光标： 1FETCH cursor_name INTO var_name [, var_name] ... CLOSE 光标： 1CLOSE cursor_name ; 示例 : 初始化脚本: 12345678910create table emp( id int(11) not null auto_increment , name varchar(50) not null comment &#x27;姓名&#x27;, age int(11) comment &#x27;年龄&#x27;, salary int(11) comment &#x27;薪水&#x27;, primary key(`id`))engine=innodb default charset=utf8 ;insert into emp(id,name,age,salary) values(null,&#x27;金毛狮王&#x27;,55,3800),(null,&#x27;白眉鹰王&#x27;,60,4000),(null,&#x27;青翼蝠王&#x27;,38,2800),(null,&#x27;紫衫龙王&#x27;,42,1800); 12345678910111213141516171819202122232425262728-- 查询emp表中数据, 并逐行获取进行展示create procedure pro_test11()begin declare e_id int(11); declare e_name varchar(50); declare e_age int(11); declare e_salary int(11); declare emp_result cursor for select * from emp; open emp_result; fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); close emp_result;end$ 通过循环结构 , 获取游标中的数据 : 12345678910111213141516171819202122232425DELIMITER $create procedure pro_test12()begin DECLARE id int(11); DECLARE name varchar(50); DECLARE age int(11); DECLARE salary int(11); DECLARE has_data int default 1; DECLARE emp_result CURSOR FOR select * from emp; DECLARE EXIT HANDLER FOR NOT FOUND set has_data = 0; open emp_result; repeat fetch emp_result into id , name , age , salary; select concat(&#x27;id为&#x27;,id, &#x27;, name 为&#x27; ,name , &#x27;, age为 &#x27; ,age , &#x27;, 薪水为: &#x27;, salary); until has_data = 0 end repeat; close emp_result;end$DELIMITER ; 6.函数语法结构: 12345CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ...END; 案例 : 定义一个存储过程, 请求满足条件的总记录数 ; 1234567891011121314delimiter $create function count_city(countryId int)returns intbegin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum;end$delimiter ; 调用: 12select count_city(1);select count_city(2); 7.触发器介绍触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 创建触发器语法结构 : 12345678910111213create trigger trigger_name before/after insert/update/deleteon tbl_name [ for each row ] -- 行级触发器begin trigger_stmt ;end; 示例 需求 1通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ; 首先创建一张日志表 : 12345678create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment &#x27;操作类型, insert/update/delete&#x27;, operate_time datetime not null comment &#x27;操作时间&#x27;, operate_id int(11) not null comment &#x27;操作表的ID&#x27;, operate_params varchar(500) comment &#x27;操作参数&#x27;, primary key(`id`))engine=innodb default charset=utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_insert_triggerafter insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;insert&#x27;,now(),new.id,concat(&#x27;插入后(id:&#x27;,new.id,&#x27;, name:&#x27;,new.name,&#x27;, age:&#x27;,new.age,&#x27;, salary:&#x27;,new.salary,&#x27;)&#x27;)); end $DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_update_triggerafter update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;update&#x27;,now(),new.id,concat(&#x27;修改前(id:&#x27;,old.id,&#x27;, name:&#x27;,old.name,&#x27;, age:&#x27;,old.age,&#x27;, salary:&#x27;,old.salary,&#x27;) , 修改后(id&#x27;,new.id, &#x27;name:&#x27;,new.name,&#x27;, age:&#x27;,new.age,&#x27;, salary:&#x27;,new.salary,&#x27;)&#x27;)); end $DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_delete_triggerafter delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;delete&#x27;,now(),old.id,concat(&#x27;删除前(id:&#x27;,old.id,&#x27;, name:&#x27;,old.name,&#x27;, age:&#x27;,old.age,&#x27;, salary:&#x27;,old.salary,&#x27;)&#x27;)); end $DELIMITER ; 测试： 123456insert into emp(id,name,age,salary) values(null, &#x27;光明左使&#x27;,30,3500);insert into emp(id,name,age,salary) values(null, &#x27;光明右使&#x27;,33,3200);update emp set age = 39 where id = 3;delete from emp where id = 5; 删除触发器语法结构 : 1drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 语法结构 ： 1show triggers ；","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Ajax学习","slug":"Ajax","date":"2023-07-13T10:33:25.000Z","updated":"2023-08-03T05:43:27.837Z","comments":true,"path":"2023/07/13/Ajax/","link":"","permalink":"http://example.com/2023/07/13/Ajax/","excerpt":"","text":"1.接口文档概念及说明 我们使用的 url，数据接口，或者简称为接口。 接口是服务器提供的一个url地址，通过这个url地址，我们可以操作服务器上的资源。 通过Ajax技术向一个接口发送请求，也叫做调用接口。 接口是谁设计的呢 后端设计的（学java的、学php的同学、…..） 后端设计完接口之后，会提供一个接口文档给前端开发工程师 一个好的接口文档，至少需要包含下面几项内容 接口说明（通过接口说明，大致了解到接口是干什么用的） 接口的url（发送ajax请求，必要的条件） 接口请求方式（发送ajax请求，必要的条件） 请求参数（参数名称、数据类型、是否必填、参数说明等） 响应格式 响应示例 请求的根路径 http://localhost:8080/day19-02-ajax 图书管理 1.1 图书列表 接口URL： &#x2F;api&#x2F;getbooks 调用方式： GET 参数格式： 参数名称 参数类型 是否必选 参数说明 id String 否 图书Id bookname String 否 图书名称 author String 否 作者 publisher String 否 出版社 响应格式： 数据名称 数据类型 说明 status Number 200 成功；500 失败； msg String 对 status 字段的详细说明 data Array 图书列表 +id String 图书Id +bookname String 图书名称 +author String 作者 +publisher String 出版社 返回示例： 123456789&#123; &quot;status&quot;: 200, &quot;msg&quot;: &quot;获取图书列表成功&quot;, &quot;data&quot;: [ &#123; &quot;id&quot;: &quot;B001&quot;, &quot;bookname&quot;: &quot;西游记&quot;, &quot;author&quot;: &quot;吴承恩&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125;, &#123; &quot;id&quot;: &quot;B002&quot;, &quot;bookname&quot;: &quot;红楼梦&quot;, &quot;author&quot;: &quot;曹雪芹&quot;, &quot;publisher&quot;: &quot;上海图书出版社&quot; &#125;, &#123; &quot;id&quot;: &quot;B003&quot;, &quot;bookname&quot;: &quot;三国演义&quot;, &quot;author&quot;: &quot;罗贯中&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125; ]&#125; 1.2 添加图书 接口URL： &#x2F;api&#x2F;addbook 调用方式： POST 参数格式： 参数名称 参数类型 是否必选 参数说明 bookname String 是 图书名称 author String 是 作者 publisher String 是 出版社 响应格式： 数据名称 数据类型 说明 status Number 201 添加成功；500 添加失败； msg String 对 status 字段的详细说明 返回示例： 1234&#123; &quot;status&quot;: 201, &quot;msg&quot;: &quot;添加图书成功&quot;&#125; 1.3 删除图书 接口URL： &#x2F;api&#x2F;delbook 调用方式： GET 参数格式： 参数名称 参数类型 是否必选 参数说明 id String 是 图书Id 响应格式： 数据名称 数据类型 说明 status Number 200 删除成功；500 未指定要删除的图书Id；502 要删除的图书不存在； msg String 对 status 字段的详细说明 返回示例： 1234&#123; &quot;status&quot;: 200, &quot;msg&quot;: &quot;删除图书成功！&quot;&#125; 2.服务器端开发2.1 vo封装返回结果123456789101112131415161718192021222324/** * 封装 ajax 响应结果 */public class AjaxResult &#123; /**响应状态码 */ private Integer status ; /**响应消息*/ private String msg ; /**响应数据 主要是查询接口返回的数据*/ private Object data ; public AjaxResult(Integer status, String msg) &#123; super(); this.status = status; this.msg = msg; &#125; public AjaxResult(Integer status, String msg, Object data) &#123; super(); this.status = status; this.msg = msg; this.data = data; &#125;&#125; 2.2 pojo1234567891011121314151617public class Book &#123; private String id ; private String bookname ; private String author ; private String publisher ; public Book() &#123; super(); // TODO Auto-generated constructor stub &#125; public Book(String id, String bookname, String author, String publisher) &#123; super(); this.id = id; this.bookname = bookname; this.author = author; this.publisher = publisher; &#125;&#125; 2.3 Service1234567891011121314151617181920212223242526272829public class BookService &#123; private static Map&lt;String,Book&gt; bookMap = Collections.synchronizedMap(new LinkedHashMap&lt;&gt;()) ; static &#123; bookMap.put(&quot;B001&quot;, new Book(&quot;B001&quot;,&quot;西游记&quot;,&quot;吴承恩&quot;,&quot;北京图书出版社&quot;)) ; bookMap.put(&quot;B002&quot;, new Book(&quot;B002&quot;,&quot;西红楼梦&quot;,&quot;曹雪芹&quot;,&quot;上海图书出版社&quot;)) ; bookMap.put(&quot;B003&quot;, new Book(&quot;B003&quot;,&quot;三国演义&quot;,&quot;罗贯中&quot;,&quot;北京图书出版社&quot;)) ; &#125; public AjaxResult save(Book book) &#123; //获得随机id String id = UUID.randomUUID().toString() ; //设置书籍id book.setId(id); bookMap.put(id, book); return new AjaxResult(201, &quot;添加图书成功&quot;) ; &#125; public AjaxResult remove(String id) &#123; if(!bookMap.containsKey(id)) &#123; return new AjaxResult(500, &quot;502 要删除的图书不存在&quot;) ; &#125; bookMap.remove(id) ; return new AjaxResult(200, &quot;删除图书成功！&quot;) ; &#125; public AjaxResult find(Book book) &#123; //此次忽略 条件 查询 return new AjaxResult(200, &quot;获取图书列表成功&quot;,bookMap.values()) ; &#125;&#125; 2.4 Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@WebServlet(&#123; &quot;/api/getbooks&quot;, &quot;/api/addbook&quot;, &quot;/api/delbook&quot; &#125;)public class BookController extends HttpServlet &#123; private static final long serialVersionUID = 1L; private BookService bookService = new BookService() ; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json;charset=UTF-8&quot;); String requestURI = request.getRequestURI() ; requestURI = requestURI.substring((request.getContextPath()+&quot;/api/&quot;).length()) ; try &#123; Method m = this.getClass().getDeclaredMethod(requestURI, HttpServletRequest.class,HttpServletResponse.class) ; AjaxResult ajaxResult = (AjaxResult)m.invoke(this, request,response) ; String json = JSON.toJSONString(ajaxResult) ; PrintWriter out = response.getWriter(); out.print(json); out.flush(); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; protected AjaxResult getbooks(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;POST&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; return bookService.find(null) ; &#125; protected AjaxResult addbook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;GET&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; String bookname = request.getParameter(&quot;bookname&quot;) ; String author = request.getParameter(&quot;author&quot;) ; String publisher = request.getParameter(&quot;publisher&quot;) ; Book book = new Book() ; book.setBookname(bookname); book.setAuthor(author); book.setPublisher(publisher); return bookService.save(book) ; &#125; protected AjaxResult delbook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;POST&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; String id = request.getParameter(&quot;id&quot;) ; if(id==null || id.equals(&quot;&quot;)) &#123; return new AjaxResult(500, &quot;未指定要删除的图书Id&quot;) ; &#125; return bookService.remove(id) ; &#125;&#125; 3. 接口测试准备工作： 121. tomcat先启动2. 安装 postman【默认安装】 3.1 图书列表 3.2 添加图书 3.3 删除图书 4. Ajax4.1 浏览器&#x2F;服务器交互模型 4.2 Ajax基本概念1234HTML是骨架CSS是颜值JS是行为数据是灵魂 AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用浏览器内置对象 XMLHttpRequest 与服务器通信。 Ajax是一种技术，通过浏览器内置对象和服务器进行数据交互的技术。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。 AJAX最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 你可以使用AJAX最主要的两个特性做下列事： 在不重新加载页面的情况下发送请求给服务器。 接受并使用从服务器发来的数据。 4.3 Ajax请求和浏览器请求1234567891011浏览器请求 是浏览器本能的请求 不需要执行任何JS代码 地址栏输入地址后，按下回车即可发送请求 接收到服务器的响应后，浏览器自动渲染响应结果到页面中Ajax请求 是通过浏览器内置对象（XHR）完成的 通过执行一段JS代码，才能实现的请求 响应结果由程序员自行处理，浏览器只负责接收响应结果。无论是浏览器请求，还是Ajax请求，道理都一样，都符合浏览器 – 服务器交互模型 123456789101112131415Ajax 优点： 可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 只更新页面的部分数据，节省带宽 用户体验好 异步，不阻塞 不阻塞，Ajax 代码之后的 其他 JS 代码无需等待 Ajax 代码执行完毕，即可执行。 多个Ajax请求可以同时进行。 Ajax 缺点: 1、增加了设计和开发时间 2、比构建经典Web应用程序更复杂 3、AJAX应用程序中的安全性较低，因为所有文件都是在客户端下载的。 4、可能出现网络延迟问题 5、禁用JavaScript的浏览器无法使用该应用程序。 6、由于安全限制，只能使用它来访问服务于初始页面的主机的信息。如果需要显示来自其他服务器的信息，则无法在AJAX中显示 4.4 JQuery封装的ajax方法$.get() 123jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求，从而将服务器上的资源请求到客户端来进行使用。 $.get() 函数的语法如下： $.get(url,[data],[success],[dataType]) 参数 是否必填 类型 说明 url 是 string 请求资源的接口地址，一般由后端开发工程师提供 data 否 string|array|object 请求参数，由后端提供 success 否 function 请求成功后触发的回调函数，函数的形参为响应结果 dataType 否 string 预期服务器端响应的数据的类型，一般不用设置 1234567891011121314//定义 请求接口地址 及 请求参数let url = &#x27;http://localhost:8080/day19-02-Ajax/api/getbooks&#x27;let obj = &#123; id: 1, bookname: &#x27;西游记&#x27;,&#125; ;//发送ajax get 请求$.get( url, obj, function (res) &#123; console.log(res) &#125;) $.post() 123jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，用于向服务器提交资源。 $.post() 函数的语法如下： $.post(url,[data],[success],[dataType]) 参数 是否必填 类型 说明 url 是 string 请求资源的接口地址，一般由后端开发工程师提供 data 否 string|array|object 请求参数，由后端提供 success 否 function 请求成功后触发的回调函数，函数的形参为响应结果 dataType 否 string 预期服务器端响应的数据的类型，一般不用设置 1234567891011// 定义路径和参数let url = &#x27;http://localhost:8080/day19-02-Ajax/api/addbook&#x27;;let obj = &#123; bookname: &#x27;三体之地球往&#x27;, author: &#x27;刘慈欣&#x27;, publisher: &#x27;中央人民出版社&#x27;&#125;;// 发送post类型的ajax$.post(url, obj, function (res) &#123; console.log(res);&#125;); $.ajax() 123456789$.ajax() - 一个综合的发送Ajax请求的方法，即可以发送GET方式的请求，也可以发送POST方式的请求，还可以根据需求配置更加复杂的Ajax请求，使用频率最高。$.ajax(&#123; method:&#x27;GET|POST&#x27;, // 请求方式 必填 url:&#x27;url接口地址&#x27;, //请求的接口地址 必填 data:&#x27;object|array|string&#x27;, // 请求参数 ，可选 success:function(res)&#123; //请求成功后的回调函数 res 表示响应结果 &#125;&#125;) 123456789101112// $.ajax(); 传递的参数是对象;// 四个关键参数都是一个属性形式存在！$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080/day19-02-Ajax/api/getbooks&#x27;, data: &#123; id: 1 &#125;, success: function (res) &#123; console.log(res); &#125;&#125;) 4.5 network工具使用 network工具使用 All – 查看所有请求 XHR – 查看Ajax请求 JS – 查看请求了哪些JS文件 CSS – 查看请求了哪些CSS文件 Img – 查看请求了哪些图片 Media – 查看请求了哪些音频、视频等 Font – 查看请求了哪些字体文件 Doc – document，查看请求了哪些html文件 4.6 综合案例效果图 素材12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!-- 套一个 .container 内容就有版心了 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;!-- bootstrap3 =&gt; 组件 =&gt; 面板 =&gt; 带标题的面版 =&gt; 情境效果 --&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;添加图书&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;!-- bootstrap3 =&gt; 全局CSS样式 =&gt; 表单 =&gt; 内联表单 --&gt; &lt;div class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;书名&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;书名&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpBookname&quot; placeholder=&quot;请输入书名&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;作者&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;作者&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpAuthor&quot; placeholder=&quot;请输入作者&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;出版社&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;出版社&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpPublisher&quot; placeholder=&quot;请输入出版社&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;btnAdd&quot; type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt; 添加 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注意: 第二部分是table标签，要写道 container 里面，panel下面 --&gt; &lt;!-- bootstrap3 =&gt; 全局CSS样式 =&gt; 表格 =&gt; 带边框的表格 --&gt; &lt;table class=&quot;table table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;西游记&lt;/td&gt; &lt;td&gt;吴承恩&lt;/td&gt; &lt;td&gt;北京图书出版社&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 5. CORS 错误跨源资源分享（CORS）是一种允许服务器放宽同源策略的标准。这用于明确允许一些跨源请求，同时拒绝其他请求。例如，如果站点提供外界嵌入的服务，则可能需要放宽同源策略。设置这样的 CORS 配置并不一定容易，并且可能存在一些挑战。在这些页面中，我们将研究一些常见的 CORS 错误消息以及如何解决它们。 如果未正确设置 CORS 配置，浏览器控制台将显示错误，例如 “Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite” 表示请求因违反 CORS 安全规则而被阻止。但这可能不一定是设置错误。因为用户的 Web 应用程序和远程外部服务可能故意禁止该请求。如果要使端点可用，则需要进行一些调试才能成功。 什么是跨域问题前端调用的后端接口不属于同一个域（域名或端口不同），就会产生跨域问题，也就是说你的应用访问了该应用域名或端口之外的域名或端口。 服务器端 开启跨域 12345678910111213141516171819202122232425262728/** * 功能描述：解决跨域过滤器 */@WebFilter(&quot;/api/*&quot;)public class CORSFilter implements Filter &#123; private final int time = 20*24*60*60; public void init(FilterConfig fConfig) throws ServletException &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse resp = (HttpServletResponse) response; // 添加参数，允许任意domain访问 resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 这个allow-headers要配为*，这样才能允许所有的请求头 resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;); resp.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); resp.setHeader(&quot;Access-Control-Max-Age&quot;, time+&quot;&quot;); chain.doFilter(request, resp); &#125; public void destroy() &#123; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"}]},{"title":"jQuery","slug":"jQuery","date":"2023-07-13T02:52:36.000Z","updated":"2023-07-13T02:58:04.316Z","comments":true,"path":"2023/07/13/jQuery/","link":"","permalink":"http://example.com/2023/07/13/jQuery/","excerpt":"","text":"1. JQ1.1 jQ概述jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。JavaScript库：是一个封装好的特定的集合包大量的方法。从封装函数的角度理解库，就是在JavaScrip库中，封装了很多预先定义好的函数在里面JQuery就是这样的一个js文件: 本质上就是对我们之前原生js代码封装后的一个js文件j 代表js Query 代表查询 优点： 轻量级。核心文件才几十kb，不会影响页面加载速度 跨浏览器兼容。基本兼容了现在主流的浏览器 链式编程、隐式迭代 对事件、样式、动画支持，大大简化了DOM操作 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等 免费、开源 初体验1234567891011121314151617181920212223242526272829303132&lt;!-- 使用 原生js 与 JQ PK 点击事件 --&gt; &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 隐式循环 2. 链式操作 3. $(dom对象) 转成 jq对象 调用 jq 的方法 $(&quot;li&quot;).mouseover(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;)).mouseout(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;&#x27;)) &lt;/script&gt; &lt;script&gt; //原生 let liCompAy = document.querySelectorAll(&#x27;li&#x27;) liCompAy.forEach((liComp) =&gt; &#123; liComp.addEventListener(&#x27;mouseover&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `pink` console.log(`鼠标覆盖`) &#125;) liComp.addEventListener(&#x27;mouseout&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `` console.log(`鼠标离开`) &#125;) &#125;) &lt;/script&gt; 入口函数12无需关心JS代码书写顺序 DOM中如果在HTML结构之前写JS代码,需要设置加载事件,获取HTML元素 【加载事件 window.onload】 123456789101112131415&lt;script&gt; //原生 window.addEventListener(&quot;load&quot;,()=&gt;&#123; let inputComp = document.querySelector(&quot;#name&quot;) console.log(`姓名 原生 :$&#123;inputComp.value&#125;`); &#125;) &lt;/script&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //JQ $(()=&gt;console.log(`姓名JQ: $&#123;$(&quot;#name&quot;).val()&#125;`)) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; DOM JQ转换12345678910DOM对象: 通过 document 方式获取到的元素都叫DOM对象jQuery对象 通过 $ 方式获取到的元素都叫 JQ对象将JQ对象转为DOM对象方式: JQ对象[索引] JQ对象.get(索引)将DOM对象转化为JQ对象: $(dom对象)注意： 只能由DOM对象 调用DOM的属性及方法，只能使用JQ对象调用 JQ的属性及方法 12345678910111213141516171819202122&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //dom对象 // let inputComp = document.querySelector(&quot;#name&quot;) // .val() jq的方法 必须 jq对象调用 .value dom的属性 必须 dom对象调用 // console.log(`姓名:$&#123;inputComp.value&#125;`); // jq对象 使用$开头 dom对象 // let $input = $(&quot;#name&quot;) // console.log(`姓名: $&#123;$input.val()&#125;`); //dom 转 jq let jq = $(dom) // let $input = $(inputComp) // console.log(`姓名: $&#123;$input.val()&#125;`); // jq 转 dom [0] .get(0) let $input = $(&quot;#name&quot;) // let input = $input[0] let input = $input.get(0) console.log(`姓名:$&#123;input.value&#125;`); &lt;/script&gt; 1.2 JQ 选择器基本选择器1234561. id选择器 #id值 $(&quot;#name&quot;)2. class选择器 .class值 $(&quot;.a&quot;)3. 标签选择器 标签名 $(&quot;li&quot;)4. 并集 OR , $(&quot;h1,#name,.a&quot;) 5. 交集 AND 直接写 $(&quot;li.c1&quot;)6. 适配 * $(&quot;*&quot;) 123456789101112131415161718192021&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li class=&quot;red&quot;&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data7&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`id选择器:$&#123;$(&#x27;#d5&#x27;).html()&#125;`) console.log(`class选择器:$&#123;$(&#x27;.red&#x27;).html()&#125;`) console.log(`标签选择器:$&#123;$(&#x27;ul&#x27;).html()&#125;`) console.log(`并集选择器===========`) $(&#x27;.red,#d5&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) $(&#x27;li.blue&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;) $(&#x27;*&#x27;).css(&#x27;fontSize&#x27;, &#x27;80px&#x27;)&lt;/script&gt; 层次选择器12345678910111. 儿子 &gt; $(&quot;tr&gt;td&quot;) $(&#x27;元素&#x27;).children([选择器]); 2. 后代 空格 $(&quot;table td&quot;) $(&#x27;元素&#x27;).find(选择器); 3. 下一个弟弟 + $(&quot;#data2+li&quot;) next() $(&quot;#data2&quot;).next(&quot;li&quot;)4. 所有的弟弟 ~ $(&quot;#data2~li&quot;) nextAll() $(&quot;#data2&quot;).nextAll(&quot;li&quot;)5. 上一个哥哥 prev() $(&quot;#data2&quot;).prev(&quot;li&quot;)6. 所有的哥哥 prevAll() $(&quot;#data2&quot;).prevAll(&quot;li&quot;)7. 同胞【哥哥弟弟们】 siblings() $(&quot;#data2&quot;).siblings(&quot;li&quot;) 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;ul&gt;li&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&quot;html li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5+li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).next(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5~li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).nextAll(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prev(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prevAll(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).siblings(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;)&lt;/script&gt; 属性选择器123451.拥有该属性 [attr] $(&quot;[name]&quot;)2.等于属性值 [attr=value] $(&quot;[name=&#x27;sid&#x27;]&quot;)3.使用属性值开头 [attr^=value] $(&quot;[name^=&#x27;s&#x27;]&quot;)4.使用属性值结尾 [attr$=value] $(&quot;[name$=&#x27;s&#x27;]&quot;)5.包含该属性值 [attr*=value] $(&quot;[name*=&#x27;s&#x27;]&quot;) 123456789101112131415&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;abc.html&quot;&gt;data1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;aaa.html&quot;&gt;data2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;ccc.html&quot;&gt;data3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;abcd.html&quot;&gt;data4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a&gt;data5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;[href]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href=&#x27;aaa.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href^=&#x27;a&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href$=&#x27;c.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href*=&#x27;c&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;)&lt;/script&gt; 过滤选择器基本过滤选择器12345671. 第一个 :first $(&quot;li:first&quot;)2. 最后一个 :last $(&quot;li:last&quot;)3. 偶数 :even $(&quot;li:even&quot;)4. 奇数 :odd $(&quot;li:odd&quot;)5. 等于索引 :eq(idx) 或 .eq(idx) $(&quot;li:eq(1)&quot;) 或 $(&quot;li&quot;).eq(1) 从0开始6. 小于索引 :lt(idx) $(&quot;li:lt(3)&quot;)7. 大于索引 :gt(idx) $(&quot;li:gt(3)&quot;) 123456789101112131415161718 &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li:first&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:last&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:even&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:odd&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:eq(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li&#x27;).eq(2).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:lt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:gt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;)&lt;/script&gt; 可见性过滤选择器121. 隐藏 :hidden2. 可见 :visible 1234567891011121314151617&lt;!-- 1. 隐藏 :hidden2. 可见 :visible--&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;显示&lt;/button&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).click(() =&gt; &#123; $(&#x27;img:visible&#x27;).hide(1000) &#125;) $(&#x27;button:eq(1)&#x27;).click(() =&gt; &#123; $(&#x27;img:hidden&#x27;).show(1000) &#125;)&lt;/script&gt; 表单过滤选择器12345678910111213141. input标签 :input $(&quot;input&quot;) &lt;input /&gt;2. type=&#x27;text&#x27; :text $(&quot;input[type=&#x27;text&#x27;]&quot;) &lt;input type=&#x27;text&#x27;/&gt;3. type=&#x27;password&#x27;:password $(&quot;input[type=&#x27;password&#x27;]&quot;) &lt;input type=&#x27;password&#x27;/&gt;4. type=&#x27;radio&#x27; :radio $(&quot;input[type=&#x27;radio&#x27;]&quot;) &lt;input type=&#x27;radio&#x27;/&gt;5. type=&#x27;checkbox&#x27;:checkbox $(&quot;input[type=&#x27;checkbox&#x27;]&quot;) &lt;input type=&#x27;checkbox&#x27;/&gt;6. type=&#x27;submit&#x27; :submit $(&quot;input[type=&#x27;submit&#x27;]&quot;) &lt;input type=&#x27;submit&#x27;/&gt;7. type=&#x27;image&#x27; :image $(&quot;input[type=&#x27;image&#x27;]&quot;) &lt;input type=&#x27;image&#x27;/&gt;8. type=&#x27;reset&#x27; :reset $(&quot;input[type=&#x27;reset&#x27;]&quot;) &lt;input type=&#x27;reset&#x27;/&gt;9. type=&#x27;button&#x27; :button $(&quot;input[type=&#x27;button&#x27;]&quot;) &lt;input type=&#x27;button&#x27;/&gt;10.type=&#x27;file&#x27; :file $(&quot;input[type=&#x27;file&#x27;]&quot;) &lt;input type=&#x27;file&#x27;/&gt;===========================布尔值属性==================11.被选中的单选/复选按钮 :checked $(&quot;:radio:checked&quot;)12.下拉框被选中 :selected $(&quot;:selected&quot;)13.被禁用 :disabled $(&quot;:disabled&quot;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;form action=&quot;xxController&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;admin1&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; value=&quot;admin2&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;hidden&quot; value=&quot;S1001&quot; /&gt; &lt;input type=&quot;text&quot; value=&quot;S1001&quot; disabled /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; value=&quot;123&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;CS&quot; /&gt;CS &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;LOL&quot; checked /&gt;LOL &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;DOTA&quot; checked /&gt;DOTA &lt;br /&gt; &lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt; &lt;br /&gt; &lt;select name=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;data1&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;data2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;data3&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;image&quot; src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`第一文本输入框:$&#123;$(&quot;input&quot;).val()&#125;`); console.log(`第一文本输入框:$&#123;$(&quot;:input&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;input[type=&#x27;text&#x27;]:eq(1)&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;:input:text:eq(1)&quot;).val()&#125;`); console.log(`密码输入框:$&#123;$(&quot;:password&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio:checked&quot;).val()&#125;`); $(&quot;:radio[value=&#x27;1&#x27;]&quot;)[0].checked = true $(&quot;:checkbox:checked&quot;).each((idx,e)=&gt;&#123; // console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); console.log(`索引:$&#123;idx&#125;========value:$&#123;$(e).val()&#125;`); &#125;) $.each($(&quot;:checkbox:checked&quot;),(idx,e)=&gt;&#123; console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); &#125;) $(&#x27;:submit&#x27;).val(&#x27;我是提交按钮&#x27;) $(&quot;:image&quot;).attr(&quot;src&quot;,&#x27;./images/html-css-js.png&#x27;) $(&quot;:reset&quot;).val(`回到解放前`) console.log(`file的name属性值:$&#123;$(&#x27;:file&#x27;).attr(&#x27;name&#x27;)&#125;`) console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).val()&#125;`); console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).text()&#125;`); console.log(`获得禁用的值:$&#123;$(&#x27;:disabled&#x27;).val()&#125;`) console.log(`获得隐藏的值:$&#123;$(&#x27;input:hidden&#x27;).val()&#125;`)&lt;/script&gt; 1.3 JQ注册事件鼠标事件121. 鼠标进入 mouseover = mouseenter2. 鼠标离开 mouseout = mouseleave 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* $(&#x27;li&#x27;) .mouseover(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) &#125;) .mouseout((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;)) */ $(&#x27;li&#x27;) .mouseenter((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;)) .mouseleave((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;))&lt;/script&gt; 123456789101112131415161718192021&lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;ul class=&quot;ul1&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;联系我们&lt;/a&gt; &lt;ul class=&quot;u2&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;邮件联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;电话联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;微信联系&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;.nav .ul1&gt;li:last&quot;).mouseenter(()=&gt;$(&quot;.u2&quot;).show()).mouseleave(()=&gt;$(&quot;.u2&quot;).hide()) &lt;/script&gt; 键盘事件121. 键盘按下 keydown2. 键盘释放 keyup 1234567&lt;input type=&quot;text&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;input&#x27;) .keydown((e) =&gt; console.log(e.keyCode)) .keyup(() =&gt; console.log(`释放`))&lt;/script&gt; 表单事件1234561.单击 click2.双击 dblclick3.值改变 change4.失去焦点 blur5.获得焦点 focus6.表单提交 submit 1234567891011121314151617181920212223242526272829&lt;form action=&quot;logcontroller&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;span id=&quot;accountError&quot;&gt;&lt;/span&gt;&lt;br /&gt; &lt;input type=&quot;password&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;:text&#x27;).focus((e) =&gt; $(e.target).css(&#x27;borderColor&#x27;, &#x27;red&#x27;)) $(&#x27;:text&#x27;).blur(() =&gt; &#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return &#125; console.log(`======用户名=====`) $(&#x27;#accountError&#x27;).html(``) &#125;) $(&quot;form&quot;).submit((e)=&gt;&#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return e.preventDefault() &#125; &#125;)&lt;/script&gt; 事件绑定1234561.绑定 bind(&quot;事件名&quot;,事件处理函数) = on (&quot;事件名&quot;,事件处理函数) 【结构固定,内容多变】 $(&quot;button:eq(0)&quot;).click(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;click&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).dblclick(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;dblclick&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).blur(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;blur&quot;,()=&gt;&#123;...&#125;)2.解绑 unbind(&quot;事件名&quot;) = off(&quot;事件名&quot;)3.只执行一次 one(&quot;事件名&quot;,事件处理函数) 1234567891011&lt;button&gt;绑定 click 按钮1&lt;/button&gt;&lt;button&gt;解除 click 按钮2&lt;/button&gt;&lt;button&gt;只绑定一次 click 按钮3&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).on(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).on(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).off(&#x27;click&#x27;)) $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).unbind(&#x27;click&#x27;)) $(&#x27;button:eq(2)&#x27;).one(&#x27;click&#x27;, () =&gt; console.log(`按钮3 被点击了..11.`))&lt;/script&gt; 复合事件12该事件由2个或2个以上的函数hover(fnOver,fnOut) 1234567891011121314151617&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li&#x27;).hover( (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;), (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) )&lt;/script&gt; 123456789101112131415161718 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;价格与包装&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;售后保障&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品评价&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;.box li&#x27;).hover( (e) =&gt; (e.target.className = &#x27;active&#x27;), (e) =&gt; (e.target.className = &#x27;&#x27;) )&lt;/script&gt; 事件冒泡1234触发子元素事件 级联 触发 父元素的事件【阻止事件冒泡:】1. event.stopPropagation()2. event.cancelBubble = true 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; #d1 &#123; width: 200px; height: 200px; background-color: pink; &#125; #d2 &#123; width: 100px; height: 100px; background-color: yellowgreen; &#125; #d3 &#123; width: 40px; height: 40px; background-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;d1&quot;&gt; &lt;div id=&quot;d2&quot;&gt; &lt;div id=&quot;d3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;#d1&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`爷爷被点击了`)) $(&#x27;#d2&#x27;).bind(&#x27;click&#x27;, function () &#123; console.log(`爸爸被点击了`) // event 内置对象 浏览器中 内置 对象 event.cancelBubble = true &#125;) $(&#x27;#d3&#x27;).bind(&#x27;click&#x27;, (e) =&gt; &#123; console.log(`你小子被点击了`) //e.stopPropagation() event.stopPropagation() &#125;)&lt;/script&gt; 事件默认行为1234默认事件行为： 比如 &lt;a href=&quot;addStu()&quot;&gt;...&lt;/a&gt; 默认链接到目标地址【阻止事件默认行为】1. javaScript:2. event.preventDefault() 12345678&lt;a href=&quot;http://www.baidu.com&quot;&gt;去百度 1 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:&quot;&gt;去百度 2 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:void(0)&quot;&gt;去百度 3 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;&quot;&gt;去百度 4 &lt;/a&gt; &lt;br /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;a&#x27;).bind(&#x27;click&#x27;, () =&gt; event.preventDefault())&lt;/script&gt; 表单序列化1234567序列化: 一次获取到表单中所有元素内容$(&#x27;form&#x27;).on(&#x27;submit&#x27;, function () &#123; // 通过 jQuery 对象的 serialize 方法，获取所有表单元素的数据 $(this).serialize(); // 阻止表单默认提交 return false;&#125;) 12345678910111213141516171819202122 &lt;form action=&quot;02-login-rs.html&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;account&quot; placeholder=&quot;请输入账号&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;pswd&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; placeholder=&quot;请输入年龄&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; location.href = `xxController?$&#123;$(&#x27;form&#x27;).serialize()&#125;` //阻止默认行为 event.preventDefault() &#125;) /* $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; let account = $(&quot;input[name=&#x27;account&#x27;]&quot;).val() let pswd = $(&quot;input[name=&#x27;pswd&#x27;]&quot;).val() location.href = `xxController?account=$&#123;account&#125;&amp;pswd=$&#123;pswd&#125;` //阻止默认行为 event.preventDefault() &#125;) */&lt;/script&gt; 1.4 JQ操作样式1234561.$(&#x27;元素&#x27;).css(&#x27;属性&#x27;, 值); 设置单个属性样式 $(&#x27;元素&#x27;).css(&#123;&#x27;属性&#x27;: &#x27;值&#x27;,&#x27;属性&#x27;: &#x27;值&#x27;&#125;) 设置多个属性样式2.$(&#x27;元素&#x27;).addClass(&#x27;类名 类名&#x27;); 3.$(&#x27;元素&#x27;).hasClass(&#x27;类名&#x27;);4.$(&#x27;元素&#x27;).removeClass(&#x27;类名&#x27;);5.$(&#x27;元素&#x27;).toggleClass(&#x27;类名&#x27;); 123456789101112131415161718192021222324&lt;style&gt; .pic &#123; width: 400px; height: 400px; border: 10px solid #000; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;/&gt;&lt;button&gt;添加样式1&lt;/button&gt;&lt;button&gt;添加样式2&lt;/button&gt;&lt;button&gt;添加样式3&lt;/button&gt;&lt;button&gt;删除样式4&lt;/button&gt;&lt;button&gt;切换样式5&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#x27;width&#x27;, &#x27;80px&#x27;)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#123; width: &#x27;80px&#x27; &#125;)) $(&#x27;button:eq(2)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).addClass(&#x27;pic&#x27;)) $(&#x27;button:eq(3)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).removeClass(&#x27;pic&#x27;)) $(&#x27;button:eq(4)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).toggleClass(&#x27;pic&#x27;)) console.log(`是否拥有pic样式: $&#123;$(&#x27;img&#x27;).hasClass(&#x27;pic&#x27;)&#125;`)&lt;/script&gt; 1.5 jQ操作属性12345678910111. 操作内置属性 获取: $(对象).prop(&#x27;属性名&#x27;); 设置: $(对象).prop(&#x27;属性名&#x27;, 值);2.操作自定义属性 获取: $(对象).attr(自定义属性名); 设置: $(对象).attr(自定义属性名, 值);3. 获取表单控件中的值 $(对象).val() $(对象).val(值);4. 操作普通标签中的值 $(对象).text(值); $(对象).html(值); 12345678910111213141516171819202122232425&lt;input type=&quot;text&quot; value=&quot;admin&quot; name=&quot;username&quot; data-user-id=&quot;S1001&quot; /&gt;&lt;span&gt;111111&lt;/span&gt;&lt;div&gt;&lt;h1&gt;2222&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`获得内置属性: $&#123;$(&#x27;input&#x27;).prop(&#x27;name&#x27;)&#125;`) $(&#x27;input&#x27;).prop(&#x27;name&#x27;, &#x27;uname&#x27;) console.log(`获得自定义属性: $&#123;$(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;)&#125;`) $(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;, &#x27;S6666&#x27;) console.log(`获得value属性: $&#123;$(&#x27;input&#x27;).val()&#125;`) $(&#x27;input&#x27;).val(&#x27;zhang3&#x27;) console.log(`获得innerText: $&#123;$(&#x27;span&#x27;).text()&#125;`) $(&#x27;span&#x27;).text(&#x27;span&#x27;) console.log(`获得innerHTML: $&#123;$(&#x27;div&#x27;).html()&#125;`) $(&#x27;div&#x27;).html(`&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt;&lt;/ul&gt;`)&lt;/script&gt; 1.6 jQ操作元素删除元素1231. $对象.remove(); 从页面中将当前标签删除2. $对象.empty(); 将标签中的所有内容清空3. $对象.html(&#x27;&#x27;); 将标签中的所有内容清空 创建元素121. $对象.html(&#x27;html标签名&#x27;); 直接在标签中添加新标签2. let res = $(&#x27;html标签&#x27;); 创建标签, 返回: JQ标签对象 添加元素1234567891. $父元素.append(元素); 将创建元素添加到父元素末尾2. $父元素.prepend(元素); 将创建元素添加到父元素开始1.尾部添加 父.append(子) 子.appendTo(父) 2.开始添加 父.prepend(子) 子.prependTo(父) 12345678910111213141516171819202122232425262728293031&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;p&gt;我的div中p&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.删除元素 $(&#x27;ul li:first&#x27;).remove() $(&#x27;ul li:last&#x27;).empty() $(&#x27;ul li:last&#x27;).html(``) //2.创建元素 $(&quot;ul li:first&quot;).html(`&lt;p&gt;aaaa&lt;/p&gt;`) let btn = $(`&lt;button&gt;按钮&lt;/button&gt;`) //3.添加元素 $(&#x27;div&#x27;).append(btn) btn.appendTo($(&#x27;div&#x27;)) $(&#x27;div&#x27;).prepend(btn) btn.prependTo($(&#x27;div&#x27;))&lt;/script&gt; 例：根据素材： 03-信息发布.html 实现元素添加&#x2F;删除功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; .msg &#123; width: 980px; padding-bottom: 10px; border: 1px solid #ccc; margin: 50px auto; &#125; textarea &#123; width: 880px; height: 100px; border: 0 none; border: 1px solid orange; resize: none; outline-style: none; border-radius: 10px; display: block; margin: 50px auto 0 auto; padding-left: 20px; padding-top: 20px; box-sizing: border-box; &#125; .btn &#123; width: 80px; height: 40px; display: block; float: right; margin-right: 50px; margin-top: 20px; background-color: blue; color: #fff; text-align: center; text-decoration: none; line-height: 40px; border-radius: 10px; clear: both; &#125; .content &#123; width: 880px; margin: 80px auto 0 auto; &#125; .item &#123; height: 50px; line-height: 50px; border-bottom: 1px dashed #ccc; padding-left: 20px; &#125; .item p &#123; float: left; &#125; .del &#123; float: right; text-decoration: none; color: #999; &#125; .del:hover &#123; color: orange; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;msg&quot;&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;btn&quot;&gt;发布&lt;/a&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;三天没吃肉啦&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //发布 $(`a.btn`).bind(`click`, () =&gt; &#123; //创建 元素 let divItemElt = $(`&lt;div class=&quot;item&quot;&gt; &lt;p&gt;$&#123;$(&#x27;textarea&#x27;).val()&#125;&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt;`) //添加元素 $(`div.content`).prepend(divItemElt) //清空输入框 $(&#x27;textarea&#x27;).val(``) console.log(`===发布=======`) &#125;) //删除 使用 事件委托 代理 $(`div.content`).on(`click`, `.del`, () =&gt; &#123; if (confirm(`确认删除吗?`)) &#123; $(event.target).parent().remove() &#125; console.log(`===删除=========`) &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"JDBC","slug":"JDBC","date":"2023-07-11T10:37:55.000Z","updated":"2023-07-11T16:45:26.895Z","comments":true,"path":"2023/07/11/JDBC/","link":"","permalink":"http://example.com/2023/07/11/JDBC/","excerpt":"","text":"JDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。 1. JDBC1.1 简介 1.2 工作原理 1.3 JDBC API 1.4 JDBC 驱动 1.5 Connection[会话] 1.6 Statement【执行SQL】Statement用于执行静态 SQL 语句 PreparedStatement表示预编译的 SQL 语句的对象。 CallableStatement用于执行 SQL 存储过程的接口。 存储过程定义1234567891011121314151617DELIMITER $$CREATE PROCEDURE p_save_dept(v_deptno INT,v_dname VARCHAR(20),v_loc VARCHAR(20) ,OUT v_rs INT ) BEGIN DECLARE cut INT(1) ; SELECT COUNT(0) INTO cut FROM dept WHERE deptno = v_deptno ; IF cut = 1 THEN SET v_rs = -1 ; END IF ; IF cut = 0 THEN SET v_rs = 1 ; INSERT INTO dept (deptno,dname,loc) VALUES (v_deptno,v_dname,v_loc) ; COMMIT ; END IF ;END $$DELIMITER ; 数据库直接调用12CALL p_save_dept(11,&#x27;aa&#x27;,&#x27;NJ&#x27;,@rs) ;SELECT @rs ; JDBC调用1234567891011Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;root&quot;);CallableStatement cs = conn.prepareCall(&quot;&#123;call p_save_dept(?,?,?,?)&#125;&quot;);cs.setInt(1,12);cs.setString(2,&quot;dev&quot;);cs.setString(3,&quot;NJ&quot;);cs.registerOutParameter(4, JDBCType.INTEGER);cs.execute() ;int out = cs.getInt(4);System.out.println(out);cs.close();conn.close(); 1.7 ResultSet 【查询结果集】 2. DAO2.1 什么是DAO 2.2 DAO作用 2.3 组成部分 2.4 示例 3.DbutilsDbutils：主要是封装了JDBC的代码，简化dao层的操作。作用：帮助java程序员，开发Dao层代码的简单框架。框架的作用：帮助程序员，提高程序的开发效率。 3.1 环境搭建jar包下载 https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils/1.7 3.2 官网地址https://commons.apache.org/proper/commons-dbutils/examples.html 3.3 Dbutils三个核心类介绍1：DbUtils：连接数据库对象—-jdbc辅助方法的集合类，线程安全构造方法：DbUtils()作用：控制连接，控制事务，控制驱动加载额一个类。 2：QueryRunner：SQL语句的操作对象，可以设置查询结果集的封装策略，线程安全。构造方法：（1）QueryRunner()：创建一个与数据库无关的QueryRunner对象，后期再操作数据库的会后，需要手动给一个Connection对象，它可以手动控制事务。Connection.setAutoCommit(false); 设置手动管理事务Connection.commit(); 提交事务 （2）QueryRunner(DataSource ds)：创建一个与数据库关联的queryRunner对象，后期再操作数据库的时候，不需要Connection对象，自动管理事务。DataSource：数据库连接池对象。 12345678 //构造函数与增删改查方法的组合：QueryRunner() update(Connection conn, String sql, Object... params) query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) QueryRunner(DataSource ds) update(String sql, Object... params) query(String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) 3：ResultSetHandle：封装数据的策略对象——将封装结果集中的数据，转换到另一个对象策略：封装数据到对象的方式（示例：将数据库保存在User、保存到数组、保存到集合）方法介绍：handle（ResultSet rs） 3.4 创建DBCP连接池1、创建DBCP链接池配置文件：名称为 dbcp.properties 内容如下： 12345driverClassName=com.mysql.jdbc.Driverusername=rootpassword=123456url=jdbc:mysql://127.0.0.1:3306/long1?characterEncoding=UTF8maxActive=2 2、读取配置文件，创建 DataSource 连接池实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.test.dbcp;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;public class DbcpDataSource &#123;/* * 重点：创建一个DataSource * 步骤为：1、用Properties类读取配置文件。 * 2、通过工厂类，读取这个Properties类获取的配置文件，创建出DataSource * DataSource作用： * 创建DataSource可以返回多个连接。可以实现dbutil简化操作数据库的流程。 *///1、创建一个静态的datasourceprivate static DataSource ds;//2、在静态代码块中，给ds赋值static&#123; //读取资源文件 try&#123; Properties p = new Properties(); p.load(DbcpDataSource.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;)); //在dbcp中有一个工厂类，读取一个资源文件,创建一个datasource ds = BasicDataSourceFactory.createDataSource(p); System.out.println(&quot;创建DataSource为&quot;+ds); &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125; &#125;//提供一个方法用于获取整个datasource对象public static DataSource getDataSource()&#123; return ds; &#125;//提供一个方法，获取connection连接public static Connection getConnection()&#123; Connection con = null; try&#123; con = ds.getConnection(); System.out.println(&quot;通过DataSource获取connection连接&quot;+con); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return con; &#125;&#125; 另外也可以不配置文件直接使用 1234567891011121314static &#123; //模拟初始化数据 Properties prop = new Properties(); prop.setProperty(&quot;driverClassName&quot;,&quot;com.mysql.jdbc.Driver&quot;); prop.setProperty(&quot;url&quot;,&quot;jdbc:mysql://localhost:3306/customer?useSSL=false&amp;characterEncoding=utf8&quot;); prop.setProperty(&quot;password&quot;,&quot;root&quot;); prop.setProperty(&quot;username&quot;,&quot;root&quot;); try&#123; dataSource = DruidDataSourceFactory.createDataSource(prop); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; //初始化 连接池&#125; 3.5 DBUtil 增删改查12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.test.ts;import java.sql.SQLException;import java.util.List;import javax.persistence.Version;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayHandler;import org.apache.commons.dbutils.handlers.ArrayListHandler;import org.junit.Test;import com.test.dbcp.DbcpDataSource;public class DbutilTests &#123;/* * dbutil向数据库新增数据 */@Testpublic void add() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run1 = new QueryRunner(DbcpDataSource.getDataSource()); //申明对象，获取DataSource链接池 //2、书写SQL字符串语句 String sq1 = &quot;INSERT INTO student(id,namee,sex,birth,department,address)&quot; + &quot;VALUES(3,&#x27;王思&#x27;,&#x27;男&#x27;,1995,&#x27;英文系&#x27;,&#x27;山东沧州&#x27;)&quot;; //3、执行sql语句 int result1 = run1.update(sq1); System.out.println(&quot;新增数据库结果，更新了数据有：&quot;+result1+&quot;条&quot;); &#125;/* * dbutil 修改数据库数据 * */@Testpublic void update() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run2 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句 String sq2 = &quot;UPDATE student SET sex=? WHERE id=?&quot;; //3、执行SQL语句 int result2 = run2.update(sq2, &quot;男&quot;,16); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result2+&quot;条&quot;); &#125;/* * dbutil 删除数据库数据 */@Testpublic void delete() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run3 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句（这个sql语句的作用是每次删除ID号最大的数据） String sq3 = &quot;DELETE FROM student WHERE id IN &quot; + &quot;(SELECT a.id FROM &quot; + &quot;(SELECT MAX(id) id FROM student a WHERE id IN&quot; + &quot;(SELECT id FROM student b WHERE a.id=b.id ORDER BY id DESC)) a)&quot;; //3、执行SQL语句 int result3 = run3.update(sq3); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result3+&quot;条&quot;); &#125;/* * dbutil 查询，将结果封装成Object对象，返回第一行数据 */@Testpublic void query() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource链接池 //2、查询 String sq4 = &quot;Select * from student&quot;; Object[] var = run.query(sq4, new ArrayHandler()); if(var !=null)&#123; System.out.print(&quot;输出学生表查询的信息&quot;+&quot;\\n&quot;); for(Object o :var)&#123; System.out.print(o+&quot;\\n&quot;); &#125; &#125; &#125;/* * dbutil 查询 ，将结果封装成Object对象，返回所有的数据 * */@Testpublic void query2() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run5 = new QueryRunner(DbcpDataSource.getDataSource()); //2、书写sql语句 String sq5 = &quot;select * from student&quot;; //3、查询sql List&lt;Object[]&gt; list = run5.query(sq5, new ArrayListHandler()); //4、遍历结果 if(list!=null)&#123; for(Object[] os:list)&#123; for(Object o :os)&#123; System.out.println(&quot;ArrayListHandler()显示查询到的所有数据：&quot;+o+&quot;\\t&quot;); &#125; System.out.println(&quot;\\n--------------------------------------------&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Tomcat-servlet","slug":"Tomcat-servlet","date":"2023-07-11T01:34:13.000Z","updated":"2023-07-11T02:13:21.920Z","comments":true,"path":"2023/07/11/Tomcat-servlet/","link":"","permalink":"http://example.com/2023/07/11/Tomcat-servlet/","excerpt":"","text":"Tomcat是web容器。在进行web项目开发的时候，经常需要http协议，也就是基于请求和响应，比如你在百度输入一行内容搜索，那么百度服务器如何处理这个请求呢？它需要创建servlet来处理，servlet其实就是java程序，只是在服务器端的java程序，servlet通过配置文件拦截你的请求，并进行相应处理，然后展示给你相应界面。那么servlet如何创建？这时候就要用到tomcat了。 1.网络编程1.1 图解 1.2 Server123456789101112131415161718192021222324252627282930313233343536public class ServerApp &#123; public static void main(String[] args) throws IOException &#123; //忠告 数组 final String[] ADVICE_AY = &#123;&quot;每天吃钙，到老我也健康膝盖!&quot;,&quot;听人劝，吃饱饭！&quot;,&quot;代码写的好，要饭要到老！&quot;&#125;; //随机数 final Random RAND = new Random(); //创建服务器端 套接字 ServerSocket serverSocket = new ServerSocket(8080); //服务器端 一直接受 客户端的请求 死循环 while (true)&#123; //获得 客户端套接字 Socket socket = serverSocket.accept(); new Thread(()-&gt;&#123; try &#123; // 获得输出流 OutputStream os = socket.getOutputStream(); //输出 随机字符串 字节流数组 os.write(ADVICE_AY[RAND.nextInt(ADVICE_AY.length)].getBytes(&quot;UTF-8&quot;)); //清空 缓存 os.flush(); InputStream is = socket.getInputStream(); byte[] ay = new byte[1024] ; is.read(ay) ; System.out.println(&quot;来着客户端的消息:&quot;+new String(ay)); //释放流 os.close(); is.close(); //关闭套接字 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 1.3 Client1234567891011121314151617181920public class ClientApp &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080); //获得输入流 InputStream is = socket.getInputStream(); byte[] ay = new byte[1024]; is.read(ay) ; //打印 服务器端消息 System.out.println(&quot;来着服务器端消息:&quot;+new String(ay)); //获得输出流 OutputStream os = socket.getOutputStream(); os.write((&quot;hello Server !!!&quot;+Math.random()).getBytes()); os.flush(); is.close(); os.close(); socket.close(); &#125;&#125; 2. CS&#x2F;BS架构2.1 图解 2.2 C&#x2F;S与B&#x2F;S区别123456789101112131415161718191．硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的，不必是专门的网络硬件环境，例如电话上网，租用设备. 信息自己管理. 有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。2．对安全要求不同：C/S 一般面向相对固定的用户群，对信息安全的控制能力很强。 一般高度机密的信息系统采用C/S 结构适宜。可以通过B/S发布部分可公开信息。B/S 建立在广域网之上， 对安全的控制能力相对弱， 可能面向不可知的用户。3．对程序架构不同：C/S 程序可以更加注重流程， 可以对权限多层次校验， 对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑，建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统。SUN 和IBM推JavaBean 构件技术等，使 B/S更加成熟.。4．软件重用不同：C/S 程序可以不可避免的整体性考虑， 构件的重用性不如在B/S要求下的构件的重用性好。B/S 的多重结构，要求构件相对独立的功能， 能够相对较好的重用，就如买来的餐桌可以再利用，而不是做在墙上的石头桌子。5．系统维护不同：C/S 程序由于整体性，必须整体考察，处理出现的问题以及系统升级、升级难、 可能是再做一个全新的系统。B/S 构件组成，方便构件个别的更换，实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级。 3. 手动部署3.0 创建web应用 3.1 静态html http://localhost/web01/hello.html 3.2 动态jsp http://localhost/web01/hello.jsp 3.3 Servlet1234567891011121314151617Servlet = Server applet 运行在服务器 tomcat上的小程序1.必须 规范：必须实现 Servlet 接口 //直接实现 Servlet 接口 A implements Servlet&#123; &#125; HttpServlet implments Servlet&#123; &#125; //间接实现 Servlet 接口 A extends HttpServlet&#123; ... &#125; 源码参考： 123456789101112131415161718192021import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class HelloWorld extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;Hello World!&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;Hello World Servlet ... !&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125;&#125; 编译 javac -cp D:\\java168_2\\server\\apache-tomcat-8.5.73\\lib\\servlet-api.jar .\\HelloWorld.java 部署 121. 桌面： aa文件下/HelloWorld.class 放在 classess文件夹下2. tomcat/lib/servlet-api.jar lib 空着 配置12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 访问http://localhost/web01/hello.do 4. IDE web开发4.1 创建项目 4.2 创建Servlet123456789public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //控制台输出 IDE console System.out.println(&quot;=====HelloServlet===doGet 该方法被执行啦=======&quot;); //通过 流 浏览器 输出 hello ... resp.getWriter().println(&quot;&lt;h1&gt; hello ...&lt;/h1&gt;&quot;); &#125;&#125; 4.3 配置Servlet123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;!-- 注册 servlet 类 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wanho.java171.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 映射 servlet 类访问路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.4 访问Servlethttp://localhost/day10-01-servlet/hello.do 基于请求驱动 地址栏直接怼 超链接 location.href form action&#x3D;“” 基于事件驱动 5.Servlet API5.1 HttpServletRequest12345678//获得请求参数的值方法1： String name = request.getParameter(&quot;name&quot;);&quot;name&quot; 参数名： 注意：如果参数名 不存在 String name 的值？ null 如果参数名 存在 没有值 String name 的值？ &quot;&quot; //1.针对 post 请求有效 中文乱码 req.setCharacterEncoding(&quot;UTF-8&quot;); 12345678910111213141516//兼容： get/postpublic class TestRequestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException &#123; //获得用户请求参数 使用 HttpServletRequest req 对象 String name = request.getParameter(&quot;name&quot;); String age = request.getParameter(&quot;age&quot;); System.out.println(&quot;姓名:&quot;+name+&quot;,年龄:&quot;+age); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 注意：doPost与doGet的区别GET调用用于获取服务器信息，并将其做为响应返回给客户端。当经由Web浏览器或通过HTML、JSP直接访问Servlet的URL时，一般用GET调用。 POST用于客户端把数据传送到服务器端，是可以隐藏传送给服务器的任何数据。Post适合发送大量的数据。 区别： 1、生成方式 get生成方式有四种：1）直接在URL地址栏中输入URL。2）网页中的超链接。3）form中method为get。4）form中method为空时，默认是get提交。 post生成方式：form中method属性为post。 2、数据传送方式 get方式：表单数据存放在URL地址后面。所有get方式提交时HTTP中没有消息体。 post方式：表单数据存放在HTTP协议的消息体中以实体的方式传送到服务器。 3、服务器获取数据方式 GET方式：服务器采用request.QueryString来获取变量的值。 POST方式：服务器采用request.Form来获取数据。 4、传送的数据量 GET方式：数据量长度有限制，一般不超过2kb。因为是参数传递，且在地址栏中，故数据量有限制。 POST方式：适合大规模的数据传送。因为是以实体的方式传送的。 5、安全性 GET方式：安全性差。因为是直接将数据显示在地址栏中，浏览器有缓冲，可记录用户信息。所以安全性低。 POST方式：安全性高。因为post方式提交数据时是采用的HTTP post机制，是将表单中的字段与值放置在HTTP HEADER内一起传送到ACTION所指的URL中，用户是看不见的。 6、在用户刷新时 GET方式：不会有任何提示、 POST方式：会弹出提示框，问用户是否重新提交 5.2 HttpServletResponse响应字符流12345// 1.响应 [html内容] 字符输出流resp.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter out = resp.getWriter();//通过 流 浏览器 输出 hello ... 类似： js ： document.write(&quot;html代码&quot;)out.println(&quot;&lt;h1&gt; hello . 该方法被执行啦..&lt;/h1&gt;&quot;); 响应URL12//2. 响应URL 浏览器 根据响应URL 再次发送新的请求resp.sendRedirect(&quot;./request.do&quot;) ;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"}]},{"title":"Java-捕获异常","slug":"Java-捕获异常","date":"2023-07-03T11:09:06.000Z","updated":"2023-07-03T11:35:12.222Z","comments":true,"path":"2023/07/03/Java-捕获异常/","link":"","permalink":"http://example.com/2023/07/03/Java-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/","excerpt":"","text":"捕获异常使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方。try&#x2F;catch代码块中的代码称为保护代码，使用 try&#x2F;catch 的语法如下： 1234567try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 实例:下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第四个元素的时候就会抛出一个异常。 1234567891011121314// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest&#123; public static void main(String args[])&#123; try&#123; int a[] = new int[2]; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; System.out.println(&quot;Out of the block&quot;); &#125;&#125; 以上代码编译运行输出结果如下 12Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block 多重捕获块一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。多重捕获块的语法如下所示： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;catch(异常类型3 异常的变量名3)&#123; // 程序代码&#125; 上面的代码段包含了 3 个 catch块。可以在 try 语句后面添加任意数量的 catch 块。如果保护代码中发生异常，异常被抛给第一个 catch 块。如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。如果不匹配，它会被传递给第二个 catch 块。如此，直到异常被捕获或者通过所有的 catch 块。 实例:该实例展示了怎么使用多重 try&#x2F;catch。 12345678910try &#123; file = new FileInputStream(fileName); x = (byte) file.read();&#125; catch(FileNotFoundException f) &#123; // Not valid! f.printStackTrace(); return -1;&#125; catch(IOException i) &#123; i.printStackTrace(); return -1;&#125; throws&#x2F;throw 关键字在Java中， throw 和 throws 关键字是用于处理异常的。throw 关键字用于在代码中抛出异常，而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。 throw 关键字throw 关键字用于在当前方法中抛出一个异常。通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 throw 关键字抛出异常，以告知调用者当前代码的执行状态。例如，下面的代码中，在方法中判断 num 是否小于 0，如果是，则抛出一个 IllegalArgumentException 异常。 12345public void checkNumber(int num) &#123; if (num &lt; 0) &#123; throw new IllegalArgumentException(&quot;Number must be positive&quot;); &#125;&#125; throws 关键字throws 关键字用于在方法声明中指定该方法可能抛出的异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常。例如，下面的代码中，当 readFile 方法内部发生 IOException 异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理 IOException 异常。 123456789public void readFile(String filePath) throws IOException &#123; BufferedReader reader = new BufferedReader(new FileReader(filePath)); String line = reader.readLine(); while (line != null) &#123; System.out.println(line); line = reader.readLine(); &#125; reader.close();&#125; 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException： 12345678910import java.io.*;public class className&#123; public void withdraw(double amount) throws RemoteException, InsufficientFundsException &#123; // Method implementation &#125; //Remainder of class definition&#125; finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; 实例:123456789101112131415public class ExcepTest&#123; public static void main(String args[])&#123; int a[] = new int[2]; try&#123; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; finally&#123; a[0] = 6; System.out.println(&quot;First element value: &quot; +a[0]); System.out.println(&quot;The finally statement is executed&quot;); &#125; &#125;&#125; 以上实例编译运行结果如下： 123Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed 注意下面事项： 1.catch 不能独立于 try 存在。2.在 try&#x2F;catch 后面添加 finally 块并非强制性要求的。3.try 代码后不能既没 catch 块也没 finally 块。4.try, catch, finally 块之间不能添加任何代码。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-查询基础","slug":"Mysql-查询基础","date":"2023-07-03T10:27:29.000Z","updated":"2023-07-11T01:36:23.486Z","comments":true,"path":"2023/07/03/Mysql-查询基础/","link":"","permalink":"http://example.com/2023/07/03/Mysql-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 查询基础1.0 基本概念12345678DDL:[数据定义语言] create , alter , drop , truncate 语句 【事务自动提交】DML:[数据操作语言] insert ,update, delete 语句DQL:[数据查询语言] selectDCL:[数据控制语言] grant[授权] ，revoke[撤销] ,commit , rollback , savepoint 表结构 初始化脚本scott.sql 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394drop database if exists scott;create database scott;use scott;DROP TABLE IF EXISTS BONUS;CREATE TABLE BONUS (ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,SAL DOUBLE NULL ,COMM DOUBLE NULL ) ;-- ------------------------------ Records for BONUS-- ------------------------------ ------------------------------ Table structure for DEPT-- ----------------------------DROP TABLE IF EXISTS DEPT;CREATE TABLE DEPT (DEPTNO INT(2) PRIMARY KEY,DNAME VARCHAR(14) NULL ,LOC VARCHAR(13) NULL );-- ------------------------------ Records for DEPT-- ----------------------------INSERT INTO DEPT VALUES (&#x27;10&#x27;, &#x27;ACCOUNTING&#x27;, &#x27;NEW YORK&#x27;);INSERT INTO DEPT VALUES (&#x27;20&#x27;, &#x27;RESEARCH&#x27;, &#x27;DALLAS&#x27;);INSERT INTO DEPT VALUES (&#x27;30&#x27;, &#x27;SALES&#x27;, &#x27;CHICAGO&#x27;);INSERT INTO DEPT VALUES (&#x27;40&#x27;, &#x27;OPERATIONS&#x27;, &#x27;BOSTON&#x27;);-- ------------------------------ Table structure for EMP-- ----------------------------DROP TABLE IF EXISTS EMP;CREATE TABLE EMP (EMPNO INT(4) PRIMARY KEY ,ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,MGR INT(4) NULL ,HIREDATE DATETIME NULL ,SAL DOUBLE(7,2) NULL ,COMM DOUBLE(7,2) NULL ,DEPTNO INT(2) NULL );-- ------------------------------ Records for EMP-- ----------------------------INSERT INTO EMP VALUES (&#x27;7369&#x27;, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, &#x27;7902&#x27;, &#x27;1980-12-17 00:00:00&#x27;, &#x27;800&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7499&#x27;, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-20 00:00:00&#x27;, &#x27;1600&#x27;, &#x27;300&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7521&#x27;, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-22 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;500&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7566&#x27;, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-04-02 00:00:00&#x27;, &#x27;2975&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7654&#x27;, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-28 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;1400&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7698&#x27;, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-05-01 00:00:00&#x27;, &#x27;2850&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7782&#x27;, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-06-09 00:00:00&#x27;, &#x27;2450&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7788&#x27;, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1987-04-19 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7839&#x27;, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, null, &#x27;1981-11-17 00:00:00&#x27;, &#x27;5000&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7844&#x27;, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-08 00:00:00&#x27;, &#x27;1500&#x27;, &#x27;0&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7876&#x27;, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, &#x27;7788&#x27;, &#x27;1987-05-23 00:00:00&#x27;, &#x27;1100&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7900&#x27;, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, &#x27;7698&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;950&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7902&#x27;, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7934&#x27;, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, &#x27;7782&#x27;, &#x27;1982-01-23 00:00:00&#x27;, &#x27;1300&#x27;, null, &#x27;10&#x27;);-- ------------------------------ Table structure for &quot;SALGRADE&quot;-- ----------------------------DROP TABLE IF EXISTS SALGRADE;CREATE TABLE SALGRADE (GRADE INT(2) NULL ,LOSAL DOUBLE NULL ,HISAL DOUBLE NULL ) ;-- ------------------------------ Records for SALGRADE-- ----------------------------INSERT INTO SALGRADE VALUES (&#x27;1&#x27;, &#x27;700&#x27;, &#x27;1200&#x27;);INSERT INTO SALGRADE VALUES (&#x27;2&#x27;, &#x27;1201&#x27;, &#x27;1400&#x27;);INSERT INTO SALGRADE VALUES (&#x27;3&#x27;, &#x27;1401&#x27;, &#x27;2000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;4&#x27;, &#x27;2001&#x27;, &#x27;3000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;5&#x27;, &#x27;3001&#x27;, &#x27;9999&#x27;);-- ------------------------------ Foreign Key structure for table EMP-- ----------------------------ALTER TABLE EMP ADD FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO); 1.1 简单select所有行所有列1SELECT * FROM emp ; 限制列1SELECT empno,ename,sal FROM emp ; 限制行1SELECT * FROM emp WHERE deptno = 10 ; 1.2 算术运算符 + - * &#x2F;注意： null 值不参与计算 【null 未知值 不确定值 x？】 1SELECT sal+comm FROM emp ; -- comm null 值 + 【运算】1234SELECT 3+4 ;SELECT &#x27;3&#x27;+4 ;SELECT &#x27;3&#x27;+&#x27;4&#x27; ;SELECT &#x27;3&#x27;+&#x27;ABC&#x27; ; -- 3 [不报错] &#x2F; 【除法】1SELECT 5/2 ; -- 2.5000 1.3 别名 AS标准： AS “dept.dname” 1SELECT ename AS &quot;from&quot; ,sal AS &quot;员工 工资&quot; FROM emp AS e 1.4 null 空值安全 等于&#x2F;全等于 ：&lt;&#x3D;&gt; 与 &#x3D; 区别：可以判断null值 is null123SELECT * FROM emp WHERE comm IS NULL ;SELECT * FROM emp WHERE comm &lt;=&gt; NULL ; is not null123SELECT * FROM emp WHERE comm IS NOT NULL ;SELECT * FROM emp WHERE NOT comm IS NULL ; 1.5 去重复行 distinct1SELECT DISTINCT deptno ,job FROM emp ; 1.6 排序 order by堆表：快速插入数据 【搬家公司 –&gt; 家具】 默认： 升序 ASC 降序 DESC 基本排序12SELECT * FROM emp ORDER BY sal ASC;SELECT * FROM emp ORDER BY sal DESC; 结果集列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC; 排序多列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC ,1 ASC ; nullOracle 数据库有专用关键字，mysql没有 12345-- null firstSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),99999,comm) DESC ;-- null lastSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),-1,comm) DESC ; 1.7 比较运算符 &lt;&#x3D;&gt; 安全等于【比较null值】 &#x3D; 等于【不能比较null值】 !&#x3D; &lt;&gt; &lt; &lt;&#x3D; &gt; &gt;&#x3D; between and 1234SELECT * FROM emp WHERE deptno != 10 ;SELECT * FROM emp WHERE deptno &lt;&gt; 10 ;SELECT * FROM emp WHERE sal BETWEEN 800 AND 3000 ;SELECT * FROM emp WHERE sal&gt;=800 AND sal&lt;=3000 ; 1.8 in not inin12SELECT * FROM emp WHERE deptno IN (10,20) ;SELECT * FROM emp WHERE deptno =10 OR deptno =20 ; not in12-- 注意： not in (去null值)SELECT * FROM emp WHERE deptno NOT IN (10,20,NULL) ; 1.9 模糊查询_ 一个字符 % N个字符 1SELECT * FROM emp WHERE ename LIKE &#x27;__A%&#x27;; 1234-- zhang_san _进行转义 _不是 like 匹配字符 而是数据SELECT * FROM emp WHERE ename LIKE &#x27;%\\_%&#x27;;SELECT * FROM emp WHERE ename LIKE &#x27;%\\%%&#x27;; 1.10 正则 REGEXP12345^ 匹配开头$ 匹配结尾. 任何一个字符[abc] 范围匹配一个 [a-z] [0-9]* 匹配任意次 12345678-- s开头的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;^S&#x27; ;-- T结尾的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;T$&#x27; ;-- 第二个字母 CSELECT * FROM emp WHERE ename REGEXP &#x27;.C&#x27; ;-- 包含字母 OSELECT * FROM emp WHERE ename REGEXP &#x27;.*O.*&#x27; ; 1.11 逻辑运算符not ! and &amp;&amp; or || 1SELECT NOT 1=1 , ! (1=1) ; 1.12 limitTOPN 1234567-- limit 位置偏移量, 行数 -- 第一页SELECT * FROM emp LIMIT 0,5 ;SELECT * FROM emp LIMIT 5 ;-- 第二页SELECT * FROM emp LIMIT 5,5 ; 例1：123456789101112131415161718-- 1.选择在部门 30 中员工的所有信息 select * from emp where deptno = &#x27;30&#x27; ;-- 2 列出职位为（MANAGER）的员工的编号，姓名 select empno,ename from emp where job = &#x27;MANAGER&#x27; ;-- 3 找出奖金高于工资的员工 select * from emp where comm&gt;sal ;-- 4 找出每个员工奖金和工资的总和 select sal+if(isnull(comm),0,comm) month_sal ,ename from emp order by month_sal desc ;-- 5 找出部门 10 中的经理(MANAGER)和部门 20 中的普通员工(CLERK)select * from emp where (deptno,job) in ((10,&#x27;MANAGER&#x27;),(20,&#x27;CLERK&#x27;)) ;-- 6 找出部门 10 中既不是经理MANAGER也不是普通员工CLERK，而且工资大于等于 2000 的员工select * from emp where deptno = 10 and job not in (&#x27;MANAGER&#x27;,&#x27;CLERK&#x27;) and sal&gt;=2000 ;-- 7 找出有奖金的员工的不同工作select distinct job from emp where comm is not null ;-- 8 找出没有奖金或者奖金低于 500 的员工select * from emp where comm is null or comm&lt;500 ;-- 9 显示雇员姓名，根据其服务年限，将最老的雇员排在最前面select ename from emp order by hiredate asc ; 2. 单行函数2.1 数值函数绝对值 1SELECT ABS(-11.5) ; 平方根 1SELECT SQRT(100) ; 求余 1SELECT MOD(5,2) ; 向上取整 1SELECT CEIL(3.001) ,CEIL(3.000) ; 向下取整 1SELECT FLOOR(3.999) ,CEIL(3.000) ; 随机数 1SELECT RAND() ; 四舍五入 1SELECT ROUND(11.5),ROUND(-11.5) ; 2.2 字符函数字符个数 123SELECT * FROM emp WHERE CHAR_LENGTH(ename) = 5 ;SELECT * FROM emp WHERE ename LIKE &#x27;_____&#x27; ; 字符串连接 12345-- concat() null 值 返回 nullSELECT CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;,NULL) ;-- concat_ws() null值不参与 【第一个参数 连接符 】SELECT CONCAT_WS(&#x27;,&#x27;,&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT_WS(&#x27;*&#x27;,&#x27;hello&#x27;,NULL,&#x27;word&#x27;,&#x27;java167&#x27;) 字符串替换 12-- db 索引从 1 开始SELECT INSERT(&#x27;hellojava167&#x27;,3,2,&#x27;**&#x27;) ; 大小写转换 1SELECT UPPER(&#x27;hello java&#x27;),LOWER(&#x27;JAVA hello&#x27;) ; 左右截取字符串 1SELECT LEFT(&#x27;helloworld&#x27;,5),RIGHT(&#x27;helloworld&#x27;,5) ; 左右填充字符串 1SELECT LPAD(&#x27;helloworld&#x27;,15,&#x27;-&#x27;),RPAD(&#x27;helloworld&#x27;,15,&#x27;*&#x27;) ; 首尾去空格 12SELECT TRIM(&#x27; abc ddd &#x27;) ;SELECT TRIM(&#x27;abc&#x27; FROM &#x27;abcxxxyyyabc&#x27;) ; 重复生成字符串 1SELECT REPEAT(&#x27;hello&#x27;,5) ; 字符串比较 12-- 1 0 -1SELECT STRCMP(&#x27;abc&#x27;,&#x27;def&#x27;) ,STRCMP(&#x27;abc&#x27;,&#x27;abc&#x27;),STRCMP(&#x27;zzz&#x27;,&#x27;abc&#x27;); 字符串截取 1234SELECT SUBSTRING(&#x27;helloworld&#x27;,1,5) ,SUBSTRING(&#x27;helloworld&#x27;,5),SUBSTRING(&#x27;helloworld&#x27;,-5);SELECT MID(&#x27;helloworld&#x27;,1,5) ,MID(&#x27;helloworld&#x27;,5),MID(&#x27;helloworld&#x27;,-5); 查找索引 1SELECT LOCATE(&#x27;o&#x27;,&#x27;helloworld&#x27;) ,POSITION(&#x27;o&#x27; IN &#x27;helloworld&#x27;),INSTR(&#x27;helloworld&#x27;,&#x27;o&#x27;) ; 2.3 日期函数当前日期 123456-- 年月日SELECT CURRENT_DATE , CURRENT_DATE() , CURDATE();-- 时分秒SELECT CURRENT_TIME ,CURRENT_TIME(), CURTIME();-- 年月日 时分秒SELECT CURRENT_TIMESTAMP,CURRENT_TIMESTAMP(),LOCALTIME(),NOW(),SYSDATE() ; 日期之间相差天数 1SELECT DATEDIFF(NOW(),hiredate) FROM emp ; 当前日期该月最后一天 1SELECT LAST_DAY(NOW()) ; 日期加减 123SELECT DATE_ADD(NOW(),INTERVAL 1 DAY) ;SELECT DATE_SUB(NOW(),INTERVAL 1 DAY) ; 周 年 月 小时 分 12345SELECT WEEK(NOW()),YEAR(NOW()),MONTH(NOW()),HOUR(NOW()),MINUTE(NOW()) ;SELECT DAYOFMONTH(NOW()),DAY(NOW()),DAYOFYEAR(NOW()) ;-- 提取日期中 部分字段SELECT EXTRACT(YEAR FROM NOW()),EXTRACT(MONTH FROM NOW()) ; 日期格式化 12SELECT DATE_FORMAT(NOW(),&#x27;%Y/%m/%d %h:%i&#x27;);SELECT * FROM emp WHERE DATE_FORMAT(hiredate,&#x27;%m&#x27;) = &#x27;02&#x27; ; 2.4 条件判断函数if 12SELECT IF(3&lt;2,&#x27;aaa&#x27;,&#x27;bbb&#x27;);SELECT IF(STRCMP(&#x27;xyz&#x27;,&#x27;abc&#x27;),&#x27;yes&#x27;,&#x27;no&#x27;); ifnull 1SELECT sal+IFNULL(comm,0) FROM emp ; case 12345678910111213-- 根据部门 10 dev 20 test 30 public others SELECT empno, ename, CASE deptno WHEN 10 THEN &#x27;dev&#x27; WHEN 20 THEN &#x27;test&#x27; WHEN 30 THEN &#x27;public&#x27; ELSE &#x27;others&#x27; END dnameFROM emp ; 例2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546-- 1 找出每个月倒数第三天受雇的员工（如：2009-5-29） -- date_add last_dayselect * from emp where date_add(hiredate,INTERVAL 2 day) = last_day(hiredate);-- 2 找出 25 年前雇的员工 -- datediffselect * from emp where datediff(now(),hiredate)/365&gt;25 ;-- 3 所有员工名字前加上 Dear ,并且名字首字母大写 -- concat concat_ws upper substring midselect concat(&#x27;Dear&#x27;,upper(mid(ename,1,1)),mid(ename,2)) from emp ;-- 4 找出姓名为 5 个字母的员工 -- char_length like _select * from emp where char_length(ename) = 5 ;-- 5 找出姓名中不带 R 这个字母的员工 -- not likeselect * from emp where ename not like &#x27;%R%&#x27; ;-- 6 显示所有员工的姓名的第一个字 -- substringselect substring(ename,1,1) from emp ;-- 7 显示所有员工，按名字降序排列，若相同，则按工资升序排序 select ename,sal from emp order by ename desc , sal asc ;-- 8 假设一个月为 30 天，找出所有员工的日薪，不计小数 -- floor isnull if ifnullselect floor((sal+ifnull(comm,0))/30) from emp ;-- 9 找到 2 月份受雇的员工 -- month date_formatselect * from emp where month(hiredate) = 2 ;-- 10 列出员工加入公司的天数(四舍五入） select datediff(now(),hiredate) from emp ;-- 11 分别用 case 列出员工所在的部门，-- deptno=10 显示&#x27;部门 10&#x27;, -- deptno=20 显示&#x27;部门 20&#x27; -- deptno=30 显示&#x27;部门 30&#x27; -- deptno=40 显示&#x27;部门 40&#x27; -- 否则为&#x27;其他部门&#x27; select empno,ename ,case when deptno between 10 and 30 then &#x27;重要部门&#x27; when deptno&gt;40 then &#x27;辅助部门&#x27; else &#x27;其他部门&#x27; end dname from emp ; 3. 分组函数统计函数 组函数 聚合函数 count sum min max avg 3.1 注意：null值不参与统计 123SELECT COUNT(comm) FROM emp ; -- 4 表中数据 16行SELECT COUNT(0) FROM emp ; 分组函数不能出现where子句 12-- 查询工资大于平均工资的员工SELECT * FROM emp WHERE sal &gt; AVG(sal) ; 3.2 group by注意： 只要有group by 子句： ​ select 子句要求：只能写 group by 出现的列名 + 5 个分组函数 12345678910SELECT deptno, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno ; 多个分组条件： 12345678910SELECT deptno,job, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno,job ; 3.3 having123456789-- 根据部门分组 查询部门人数大于 2人的部门编号 人数-- 根据部门分组 查询部门人数大于 2人的部门编号 人数SELECT deptno, COUNT(0) dept_countFROM empGROUP BY deptnoHAVING COUNT(0)&gt;2 ; 3.4 完整的SQL1234567891011121314select 列名1 ,列名2...列名Nfrom 表1,表2 .... 表Nwhere 限制行【分组前过滤】group by 分组列having 分组后过滤order by 排序limit 偏移量,行数 12345678910111213-- 查询工资大于500 按照部门分组 如果部门相同按照工种分组 人数大于等于1 按照人数排降序 第2~5条SELECT deptno, job, COUNT(0) dept_count FROM emp WHERE sal &gt; 500 GROUP BY deptno, job HAVING COUNT(0) &gt;= 1 ORDER BY 3 DESC LIMIT 2, 3 ; 3.5 行列转换12345678910CREATE TABLE stu( sname VARCHAR(20), sub VARCHAR(20), score VARCHAR(20));INSERT INTO stu (sname,sub,score) VALUES (&#x27;zs&#x27;,&#x27;chinese&#x27;,&#x27;100&#x27;),(&#x27;zs&#x27;,&#x27;math&#x27;,&#x27;99&#x27;),(&#x27;zs&#x27;,&#x27;english&#x27;,&#x27;98&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;li&#x27;,&#x27;chinese&#x27;,&#x27;80&#x27;),(&#x27;li&#x27;,&#x27;math&#x27;,&#x27;89&#x27;),(&#x27;li&#x27;,&#x27;english&#x27;,&#x27;88&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;ww&#x27;,&#x27;chinese&#x27;,&#x27;70&#x27;),(&#x27;ww&#x27;,&#x27;math&#x27;,&#x27;79&#x27;),(&#x27;ww&#x27;,&#x27;english&#x27;,&#x27;78&#x27;);COMMIT ; 1234567SELECT sname, CASE sub WHEN &#x27;chinese&#x27; THEN score END chinese , CASE sub WHEN &#x27;math&#x27; THEN score END math , CASE sub WHEN &#x27;english&#x27; THEN score END english FROM stu 12345678SELECT sname, SUM(CASE sub WHEN &#x27;chinese&#x27; THEN score END) chinese , SUM(CASE sub WHEN &#x27;math&#x27; THEN score END) math , SUM(CASE sub WHEN &#x27;english&#x27; THEN score END) english FROM stu GROUP BY sname 例3:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-- 1 分组统计各部门下工资&gt;500 的员工的平均工资-- group by deptno 分组统计各部门-- where sal &gt; 500 工资&gt;500 的员工-- select avg(sal) 平均工资-- from emp 员工select deptno,avg(sal) avg_sal from emp where sal&gt;500 group by deptno ;-- 2 统计各部门下平均工资大于 500 的部门 -- group by deptno 统计各部门-- select avg(sal)-- having avg(sal)&gt;500 工资大于 500 select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;500 ;-- 3 算出部门 30 中得到最多奖金的员工奖金 -- where deptno = 30 部门 30-- select max(comm) 最多奖金select max(comm) from emp where deptno = 30 ;-- 4 算出部门 30 中得到最多奖金的员工姓名 -- where deptno = 30 部门 30 得到最多奖金-- select ename 员工姓名-- select ename,comm from emp where deptno=30 order by comm desc limit 0,1;-- select ename,comm from emp where deptno=30 and comm=(select max(comm) from emp where deptno = 30 ) ;select ename,comm from emp where (deptno,comm)=(select deptno,max(comm) from emp where deptno = 30 ) ;-- 5 算出每个职位的员工数和最低工资 -- group by job 每个职位-- select count(0) , min(sal) 员工数和最低工资select job,count(0) , min(sal) from emp group by job ;-- 6 算出每个部门,每个职位的平均工资和平均奖金(平均值包括没有奖金)，-- 如果平均奖金大于 300，显示“奖金不错”，-- 如果平均奖金 100 到 300，显示“奖金一般”，-- 如果平均奖金小于 100，显示“基本没有奖金”，-- 按部门编号降序，平均工资降序排列-- group by deptno,job 每个部门,每个职位-- select avg(sal) ,avg(ifnull(comm,0)) 平均工资和平均奖金-- case when then end .. 显示转换-- order by deptno desc ,avg(sal) desc 按部门编号降序，平均工资降序排列select deptno,job,avg(sal) ,case when avg(ifnull(comm,0))&gt;300 then &#x27;奖金不错&#x27; when avg(ifnull(comm,0))&gt;=100 and avg(ifnull(comm,0))&lt;=300 then &#x27;奖金一般&#x27; when avg(ifnull(comm,0))&lt;100 then &#x27;基本没有奖金&#x27; end comm_msg from emp group by deptno,job order by deptno desc ,avg(sal) desc;-- 7 列出员工表中每个部门的员工数，和部门 no -- group by deptno 每个部门-- select count(0) , deptno 员工数，和部门 noselect count(0) , deptno from emp group by deptno ;-- 8 得到工资大于自己部门平均工资的员工信息 -- 注意： 别名select * from emp e where sal &gt; (select avg(sal) from emp where deptno=e.deptno) ;-- 9 分组统计每个部门下，每种职位的平均奖金（也要算没奖金的人）和总工资(包括奖金) -- group by deptno,job ; 每个部门下，每种职位-- select avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) 平均奖金（也要算没奖金的人）和总工资(包括奖金) select deptno,job,avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) from emp group by deptno,job; 4. 多表查询 4.1 笛卡尔集【积】 Cross join行相乘 列相加 【大结果集】 bug 【避免该查询】忘记写 where 条件 ，或条件无效 1234-- 忘记写 where 条件SELECT * FROM emp,dept,salgrade ;-- 条件无效 SELECT * FROM emp,dept,salgrade WHERE emp.deptno=emp.deptno; 4.2 等值连接 Equi join&#x2F;Natural join两张表的数据 必须相关 【外键值 &#x3D; 另一张表的主键值】 等值连接 12-- 查询姓名 部门名称SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e , dept d WHERE e.deptno = d.deptno 自然连接【两表中同名的列】 12-- EMP deptno [emp 的 FK] Dept deptno [dept 的 PK]SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e NATURAL JOIN dept d ; 4.3 非等值连接 Non-Equijoin参考值 【emp表 sal 3000 salgrade表 3000 ？1201~4000】 1234567891011-- 查询工号，姓名 ，工资，工资等级SELECT e.empno, e.ename, e.sal, s.grade FROM emp e, salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal ; 4.4 自连接 Self join树型表 无限级分类表 【表的FK 指向自己表的主键】 必须使用别名 123456SELECT COUNT(0) FROM emp e,emp m ; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.empno = e.empno; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.mgr = m.empno; -- 自连接-- 查询员工姓名 工资 直接领导姓名 工资 SELECT e.ename emp_name,e.sal emp_sal,m.ename mgr_name,m.sal mgr_sal FROM emp e, emp m WHERE e.mgr = m.empno ; 4.5 左外连接 Left Outer Join123456789-- 查询所有员工姓名 部门名称 包括没有部门的员工SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno ; 4.6 右外连接 Right Outer Join123456789-- 查询所有部门名称 包括没有员工的 部门select e.ename, d.deptno, d.dname from emp e right outer join dept d on e.deptno = d.deptno ; 4.7 满外连接 Full Outer Joinmysql 不支持 Full join 【通过集合操作 union 合集】 12345678910111213141516171819-- 查询所有部门名称 包括没有员工的 部门 -- + 所有员工姓名 部门名称 包括没有部门的员工(SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno) UNION(SELECT e.ename, d.deptno, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno = d.deptno) 4.8 内连接 Inner Join12-- 查询 员工姓名 部门名SELECT e.ename,d.deptno,dname FROM emp e INNER JOIN dept d ON e.deptno = d.deptno ; 4.9 集合操作并集【UNION ，UNION ALL】 UNION 自动去重复 速度慢 UNION ALL 保留重复 速度快 注意： 列的个数相同 列的数据类型一致 无序 123456SELECT* FROM((SELECT * FROM emp WHERE deptno = 10 ORDER BY sal DESC )UNION(SELECT * FROM emp WHERE deptno = 20 ORDER BY sal DESC ))t ORDER BY t.sal DESC ; 5. 子查询子查询：where 子句 ，from子句，select 子句 , having 子句 123456789101112131415161718-- select 子句 [标量子查询]SELECT ename,(SELECT dname FROM dept WHERE deptno=e.deptno) dname FROM emp e;-- having 子句SELECT MIN(sal), deptno FROM emp GROUP BY deptno HAVING MIN(sal) = (SELECT MIN(min_sal) FROM (SELECT MIN(sal) min_sal FROM emp GROUP BY deptno) t) ; 子查询不返回 主查询不返回 12-- 查询工资比 工号8888 的员工还高员工姓名SELECT * FROM emp WHERE sal&gt;(SELECT sal FROM emp WHERE empno = 8888) ; 单列 对 多列 1SELECT * FROM emp WHERE sal&gt;(SELECT ename,sal FROM emp WHERE empno = 7788) ; 单行 对 多行 12-- Subquery returns more than 1 rowSELECT * FROM emp WHERE sal = (SELECT MIN(sal) FROM emp GROUP BY deptno) ; 5.1 单行子查询子查询结果【单行】 比较运算符 &#x3D; !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 12345678910111213-- 查询大于平均工资的员工SELECT * FROM emp WHERE sal &gt; (SELECT AVG(sal) FROM emp) ; -- 查询 7788 相同部门 工种的员工SELECT * FROM emp WHERE (deptno,job)=(SELECT deptno,job FROM emp WHERE empno = 7788) 注意：返回多行 【一行 对多行&#x2F;多值 ，一列对多列 ，NULL&#x2F;空值】 5.2 多行子查询返回 多行 【包含单行 –&gt; NULL值】 in 【 &#x3D; any ，&#x3D; some】 ，not in ， &gt; all &gt;&#x3D; all &lt; &lt;&#x3D; all ,&gt;any in ，not in 【无法使用索引查询，查询全表扫描】 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename,e.sal FROM emp e ,(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) tWHERE e.deptno = t.deptno AND e.sal = t.dept_min_sal ;-- 子查询SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) IN(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =ANY(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =SOME(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) exists ，not exists 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename, e.sal FROM emp e WHERE EXISTS (SELECT NULL FROM emp GROUP BY deptno HAVING deptno = e.deptno AND MIN(sal) = e.sal) ; in VS exists 1234in : 无法使用索引，全表扫描 not in 【注意去 null值】 主查询 3KW 子查询 1Kexists : 使用索引，不使用全表扫描 not exists 主查询 1k 子查询 3kw","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Mysql安装过程详解","slug":"Mysql安装过程详解","date":"2023-07-03T03:48:58.000Z","updated":"2023-07-11T01:36:53.605Z","comments":true,"path":"2023/07/03/Mysql安装过程详解/","link":"","permalink":"http://example.com/2023/07/03/Mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Mysql安装&#x2F;卸载1 卸载 2 安装下载https://downloads.mysql.com/archives/installer/ 安装 卸载不干净，无法安装 【解决方案】 https://blog.csdn.net/weixin_43147354/article/details/117241786 MicrosoftProgram_Install_and_Uninstall.meta.diagcab","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Java-IO流","slug":"Java-IO流","date":"2023-07-01T12:15:14.000Z","updated":"2023-07-01T14:36:24.329Z","comments":true,"path":"2023/07/01/Java-IO流/","link":"","permalink":"http://example.com/2023/07/01/Java-IO%E6%B5%81/","excerpt":"","text":"1. File1.1 File与流 1.2 File练习例11234567891011121314151617181920/*使用File对象，在C盘创建aaa/bbb/ccc的文件夹，在此文件夹下创建1.txt【C:/aaa/bbb/ccc/1.txt】 如果该文件存在，删除1.txt 如果该文件不存在，创建1.txt*/import java.io.File;import java.io.IOException;public class FileTest01 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\aaa\\\\bbb\\\\ccc\\\\1.txt&quot;); if (file.exists())&#123; file.delete(); &#125;else&#123; //创建文件夹 file.getParentFile().mkdirs(); //创建 文件 file.createNewFile(); &#125; &#125;&#125; 例21234567891011121314151617/*使用File对象 listFiles() 方法自定义类 implements FilenameFilterC:\\Program Files\\Java\\jdk1.8.0_321\\bin目录下，所有的 .exe结尾的文件打印出来。*/import java.io.File;import java.io.FilenameFilter;import java.io.IOException;import java.util.stream.Stream;public class FileTest02 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_361\\\\bin&quot;); String[] ay = file.list((dir, name) -&gt; name.endsWith(&quot;.exe&quot;)); Stream.of(ay).forEach(System.out::println); &#125;&#125; 2. 节点流2.1 字节流 2.2 节点流练习例312345678910111213141516171819202122232425/*使用FileOutputStream 向1.txt文件写入： A~Z 字符在 文件 结尾：a~z字符*/import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class FileOutputStreamTest03 &#123; public static void main(String[] args) throws IOException &#123; //输出流 自动创建文件 OutputStream os = new FileOutputStream(&quot;1.txt&quot;,true) ; //写 byte 比如：A for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125; /*for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125;*/ //建议： 可选 //os.flush(); os.close(); &#125;&#125; 例412345678910111213141516171819202122232425262728293031/*使用FileInputStream IDEA具体的JAVA文件 比如： Test1.java打印该Java文件中所有的内容*/import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class FileInputStreamTest04 &#123; public static void main(String[] args) throws IOException &#123; //输入流 注意：目标数据源 一定存在的 InputStream is = new FileInputStream(&quot;Test1.java&quot;) ; //读 /*while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; System.out.print((char)data); &#125;*/ int data = 0 ; while((data = is.read())!=-1)&#123; System.out.print((char)data); &#125; is.close(); &#125;&#125; 2.3 字符流 2.4 节点流 输入流 输出流 例51234567891011121314151617181920212223/*使用流 实现把图片从C盘拷贝D盘。*/import java.io.*;public class PicCopyTest05 &#123; public static void main(String[] args) throws IOException &#123; //1.输入流 怼到 目标数据源 InputStream is = new FileInputStream(&quot;D:\\\\Java180_2\\\\doc\\\\day01-html基础\\\\res\\\\mm.jpg&quot;) ; //2.输出流 项目下 OutputStream os = new FileOutputStream(&quot;meimei.jpg&quot;) ; //3. 读 while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; //4.写 os.write(data); &#125; System.out.println(&quot;====图片拷贝结束=========&quot;); &#125;&#125; 3. 处理流3.1 流嵌套 3.2 处理流 3.3 调包侠https://commons.apache.org/proper/commons-io/description.html 4. 对象流 例61234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用对象流 实现对对象实现读写功能*///写入import java.io.*;public class ObjectOutputStreamTest11 &#123; public static void main(String[] args) throws IOException &#123; //1.对象 创建商品对象 【A.瞬时状态 -- JVM 内存】 Goods goods = new Goods(&quot;G1001&quot;, &quot;苹果&quot;, 4.5D); //2. 写入 4.txt 文件 节点文件流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;4.txt&quot;)) ; /*OutputStream os = new FileOutputStream(&quot;4.txt&quot;) ; ObjectOutputStream oos = new ObjectOutputStream(os) ;*/ //【B.持久状态 -- 文件系统】 //goods.setName(&quot;香蕉&quot;); //对象流 写入 oos.writeObject(goods); oos.flush(); oos.close(); //【C.脱管状态 -- 脱离管理】 //goods.setName(&quot;菠萝&quot;); &#125;&#125;//读取import java.io.*;public class ObjectInputStreamTest12 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.读取 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;4.txt&quot;)) ; Object o = ois.readObject(); ois.close(); System.out.println(o); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-集合","slug":"Java-集合","date":"2023-06-29T14:07:43.000Z","updated":"2023-07-29T14:15:39.712Z","comments":true,"path":"2023/06/29/Java-集合/","link":"","permalink":"http://example.com/2023/06/29/Java-%E9%9B%86%E5%90%88/","excerpt":"","text":"1. Map集合框架类图 HashMap常用方法键值对（“key &#x3D; value”），顾名思义，每一个键会对应一个值。 APIAPI 是用于构建应用程序软件的一组子程序定义，协议和工具。一般来说，这是一套明确定义的各种软件组件之间的通信方法。 例1：1234567891011121314151617181920212223242526272829/*1.遍历集合，并将序号与对应人名打印。2.向该map插入一个编码为5姓名为李晓红3.移除该map中的编号为1的信息4.将map集合中编号为2的姓名信息修改为&quot;周琳&quot;*/import java.util.HashMap;import java.util.Map;public class Ex01 &#123; public static void main(String[] args) &#123; Map map =new HashMap();//多态 map.put(1,&quot;张三丰&quot;); map.put(2,&quot;周芷若&quot;); map.put(3,&quot;汪峰&quot;); map.put(4,&quot;灭绝师太&quot;); //1.循环遍历 map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); //2.插入 map.put(5,&quot;李晓红&quot;); //3.移除 map.remove(1); //4.修改 //map.put(2,&quot;周琳&quot;); map.replace(2,&quot;周琳&quot;); System.out.println(&quot;==============================&quot;); map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); &#125;&#125; java8 参考循环输出： 123456Map map = new HashMap() ;map.put(1,&quot;张三1&quot;) ;map.put(2,&quot;张三2&quot;) ;map.put(3,&quot;张三3&quot;) ;// java lambda表达式 类似 ES6 的箭头函数 【可推导即可省略】map.forEach((k,v)-&gt; System.out.println(&quot;序号:&quot;+k+&quot;,姓名:&quot;+v)); 例2：1234567891011121314151617181920212223242526/*有2个数组，第一个省份数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，第二个省会数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为key，第二个数组元素作为value存储到Map集合中。如&#123;黑龙江省=哈尔滨, 浙江省=杭州, …&#125;。*/import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class Ex02 &#123; public static void main(String[] args) &#123; String[] proAy = &#123;&quot;黑龙江省&quot;,&quot;浙江省&quot;,&quot;江西省&quot;,&quot;广东省&quot;,&quot;福建省&quot;&#125; ; String[] cityAy = &#123;&quot;哈尔滨&quot;,&quot;杭州&quot;,&quot;南昌&quot;,&quot;广州&quot;,&quot;福州&quot;&#125; ; Map map = new LinkedHashMap(); // 把 数组中的元素 存放在 map的 条目中 for (int i=0;i&lt;proAy.length;i++)&#123; map.put(proAy[i],cityAy[i]); &#125; //打印map 无需循环 &#123;key=value,key=value&#125; System.out.println(map); &#125;&#125; 例3：1234567891011/*定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。 List list = new ArrayList() ;例如：集合中有”abc”、”bcd”两个元素， list.add(“abc”) ; list.add(“bcd”) ;程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。 Map map = ... String 类 1. length() 字母个数 2. charAt() 根据索引 获得 字母*/ Hashtable1null值问题? 对比： 2. Iterator基本使用 例41234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用ArrayList存储多个学生信息1. 删除年龄&gt;18岁的学生2. 使用Iterator进行遍历 */import java.util.ArrayList;import java.util.Iterator;import java.util.function.Predicate;/** * 使用ArrayList存储多个学生信息 * 1. 删除年龄&gt;18岁的学生 * 2. 使用Iterator进行遍历 */public class Ex04 &#123; public static void main(String[] args) &#123; ArrayList&lt;Stu&gt; stuList = new ArrayList(); stuList.add(new Stu(19)) ; stuList.add(new Stu(39)) ; stuList.add(new Stu(14)) ; stuList.add(new Stu(16)) ; stuList.add(new Stu(26)) ; stuList.add(new Stu(12)) ; //推荐 java8的语法 removeIf(e-&gt;e.getAge()&gt;18) forEach(System.out::println) //stuList.removeIf( o -&gt; ((Stu)o).getAge()&gt;18 ) ; //stuList.removeIf( o -&gt; o.getAge()&gt;18 ) ; //stuList.forEach(System.out::println); //Iterator 判断有没有下一个元素 hasNext() 取出下一个元素 next() 删除当前元素 remove() Iterator&lt;Stu&gt; iterator = stuList.iterator(); while (iterator.hasNext()) &#123; //腐烂味道代码 坏味道代码 Stu stu = iterator.next(); if (stu.getAge()&gt;18)&#123; iterator.remove(); &#125; &#125; System.out.println(stuList); &#125;&#125; 参考java8 List 删除元素： 12345678List list = new ArrayList() ;list.add(new Stu(1,&quot;aaa&quot;,19)) ;list.add(new Stu(2,&quot;bbb&quot;,16)) ;list.add(new Stu(3,&quot;ccc&quot;,14)) ;//如果满足条件 进行删除list.removeIf(ele-&gt;((Stu)ele).getAge()&gt;18) ;//循环输出list.forEach(System.out::println); 3. 泛型为什么 怎么用 4. Set4.1 HashSet 例512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.HashSet;import java.util.Random;import java.util.Set;/** * 双色球规则： * 双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。 * 红色球号码从1—33中选择； * 蓝色球号码从1—16中选择； * 请随机生成一注双色球号码。 * （要求同色号码不重复） */public class Ex05 &#123; public static void main(String[] args) &#123; Random random = new Random(); // 蓝色球号码 int blueBall = random.nextInt(16)+1 ; HashSet&lt;Ball&gt; ballSet = new LinkedHashSet&lt;&gt;() ; // 一个 蓝色球 ballSet.add(new Ball(&quot;蓝球&quot;,blueBall)) ; while (ballSet.size() != 7) &#123; //红色球号码 int redBall = random.nextInt(33)+1 ; ballSet.add(new Ball(&quot;红球&quot;,redBall)) ; &#125; System.out.println(ballSet); &#125;&#125;class Ball&#123; private String color ; private Integer num ; public Ball(String color, Integer num) &#123; this.color = color; this.num = num; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Ball ball = (Ball) o; return Objects.equals(color, ball.color) &amp;&amp; Objects.equals(num, ball.num); &#125; @Override public int hashCode() &#123; return Objects.hash(color, num); &#125; @Override public String toString() &#123; return &quot;Ball&#123;&quot; + &quot;color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &quot;, num=&quot; + num + &#x27;&#125;&#x27;; &#125;&#125; 5. Map练习5.1 Map练习例61234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162一、利用Map，完成下面的功能：/*从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。如果该年没有举办世界杯，则输出：没有举办世界杯。*/import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Ex06 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //map.put(2023,null); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入年份:&quot;); //怼死 死去活来法 int year = scanner.nextInt(); String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg); scanner.close(); /*String team = map.get(year); if (team!=null)&#123; System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /*if (map.containsKey(year)) &#123; String team = map.get(year); System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /* String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg);*/ &#125;&#125; 例712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Scanner;/** * 二、在原有世界杯Map 的基础上， * 增加如下功能： * 读入一支球队的名字，输出该球队夺冠的年份列表。 * 例如， * 读入“巴西”，应当输出 1958 1962 1970 1994 2002 * 读入“荷兰”，应当输出 没有获得过世界杯 */public class Ex07 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //逆向思维 Map&lt;String, StringBuilder&gt; teamMap = new HashMap&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; //当前 队伍 map集合中 是否包含当前 队伍 if (teamMap.containsKey(name)) &#123; // 字符串 缓存中 添加新的年份 StringBuilder sb = teamMap.get(name); sb.append(year).append(&quot;\\t&quot;) ; &#125;else &#123; //如果不包含 直接存放当前年份 teamMap.put(name, new StringBuilder(year + &quot;\\t&quot;)); &#125; &#125;); // System.out.println(teamMap); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一支球队的名字:&quot;); //怼死 死去活来法 String year = scanner.next(); String msg = teamMap.getOrDefault(year, new StringBuilder(&quot;没有获得过世界杯&quot;)).toString(); System.out.println(msg); &#125;&#125; 123456789101112131415//另一种方法 String inputTeamName = scanner.next(); AtomicBoolean isPrint = new AtomicBoolean(true); map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; System.out.println(year); //System.exit(-1); isPrint.set(false); &#125; &#125;); if (isPrint.get()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; 123456789101112131415161718//第三种方法 String inputTeamName = scanner.next(); //存放 获得世界杯的年份集合 List&lt;Integer&gt; yearList = new ArrayList&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; yearList.add(year) ; &#125; &#125;); //集合为空 条件没有满足 if (yearList.isEmpty()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; yearList.forEach(System.out::println); 5.2 Map.Entry 5.3 Map综合案例1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * * 将以上对应关系的数据存储到map集合中，key：表示站编号，value：表示站名，并遍历打印(可以不按顺序打印)： * 例如： * 第10站: 森林公园南门 * 第6站: 育新 * 第12站: 奥体中心 * 第13站: 北土城 */public class EX &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); &#125;&#125; 例81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * *计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； */public class Ex08 &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); //站之间的数量 int money = caclMoney(13) ; System.out.println(&quot;共:&quot; + money); &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; Map&lt;Integer,Integer&gt; moneyMap = new HashMap&lt;&gt;() ; moneyMap.put(0,3) ; moneyMap.put(1,3) ; moneyMap.put(2,3) ; moneyMap.put(3,3) ; moneyMap.put(4,4) ; moneyMap.put(5,4) ; // .... moneyMap.put(0,3) ; moneyMap.put(0,3) ; return count ; /*if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ;*/ &#125;&#125; 例9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*计算地铁票价规则： 总行程 3站内（包含3站）收费3元， 3站以上但不超过5站（包含5站）的收费4元， 5站以上的，在4元的基础上，每多1站增加2元， 10元封顶；*/import java.util.ArrayList;import java.util.HashMap;import java.util.Map;public class Test09 &#123; public static void main(String[] args) &#123; ArrayList&lt;Num&gt; numList = new ArrayList(); Map map = new HashMap(); map.put(1,&quot;朱辛庄&quot;); map.put(2,&quot;育知路&quot;); map.put(3,&quot;平西府&quot;); map.put(4,&quot;回龙观东大街&quot;); map.put(5,&quot;霍营&quot;); map.put(6,&quot;育新&quot;); map.put(7,&quot;西小口&quot;); map.put(8,&quot;永泰庄&quot;); map.put(9,&quot;林萃桥&quot;); map.put(10,&quot;森林公园南门&quot;); map.put(11,&quot;奥林匹克公园&quot;); map.put(12,&quot;奥体中心&quot;); map.put(13,&quot;北土城&quot;); for (Object j : map.keySet())&#123; System.out.println(&quot;第&quot; +j +&quot;站: &quot; +map.get(j)); &#125; int i=1; numList.add(new Num(1,3)) ; numList.add(new Num(2,3)) ; numList.add(new Num(3,3)) ; numList.add(new Num(4,4)) ; numList.add(new Num(5,4)) ; numList.add(new Num(5+i,4+2*i)) ; /*numList.forEach((k,v)-&gt;&#123; if(k.equals()&lt;=3)&#123; System.out.println(k + &quot; &quot;); &#125; &#125;);*/ &#125;&#125;class Num&#123; int number ; int money; public int getMoney() &#123; return money; &#125; public int getNumber() &#123; return number; &#125; public Num(int number,int money) &#123; this.number = number; this.money = money; &#125; @Override public String toString() &#123; return &quot;homework.Num&#123;&quot; + &quot;number=&quot; + number + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 例1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * 打印格式（需要对键盘录入的上车站和到达站进行判断，如果没有该站，提示重新输入，直到站名存在为止）： 注意：每站需要2分钟 请输入上车站： 朱辛庄 请输入到达站： 西小口 从朱辛庄到西小口共经过6站收费6元，大约需要 12分钟； */public class Ex09 &#123; private static String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ; private static Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; public static void main(String[] args) &#123;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); String beginName = &quot;林萃桥&quot; ; String endName = &quot;平西府&quot;; int count = caclCount(beginName, endName); int time = count*2 ; //站之间的数量 int money = caclMoney(count) ; System.out.println(&quot;从&quot;+beginName+&quot;到&quot;+endName+&quot;共经过&quot;+count+&quot;站收费&quot;+money+&quot;元，大约需要 &quot;+time+&quot;分钟&quot;); &#125; /** * 根据 两站 站名 计算 之间 站之间的数量 * @param beginName * @param endName * @return */ private static int caclCount(String beginName,String endName)&#123; //map的 key站名 value 站序号 反转 Map&lt;String,Integer&gt; name2IndxMap = new HashMap&lt;&gt;() ; //站序号 站名 map.forEach((idx,name)-&gt; name2IndxMap.put(name,idx)); Integer beginIdx = name2IndxMap.get(beginName); Integer endIdx = name2IndxMap.get(endName); return Math.abs(beginIdx-endIdx) ; &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ; &#125;&#125; 6.Set扩展6.1 TreeSet 6.2 例11123456789101112131415161718192021222324252627/*学生类 姓名 分数 double 存放 TreeSet中 实现 根据 分数 从大到小 内部排序Comparable 外部排序 ComparatorSet&lt;Stu&gt; set = new TreeSet&lt;&gt;() ;set.add(new Stu(“aa”,98.5)) ;set.add(new Stu(“bb”,88.5)) ;*/package set;import java.util.*;public class Ex11 &#123; public static void main(String[] args) &#123; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; (int) (c1.getScore()-c2.getScore())) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; c1.getScore().compareTo(c2.getScore())) ;// Set&lt;Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparing(Customer::getScore)) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(set.Customer::getScore)) ; Set&lt;Customer&gt; set = new TreeSet&lt;&gt;() ; set.add(new Customer(&quot;小丽&quot;,500D)) ; set.add(new Customer(&quot;小红&quot;,400.8)) ; set.add(new Customer(&quot;小夏&quot;,400.3)) ; set.add(new Customer(&quot;小花&quot;,700D)) ; set.forEach(System.out::println); &#125;&#125; java8 外部排序写法： 1Set&lt;Stu&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(Stu::getAge)) ; 7. Collections7.1 辅助类 7.2 例1212345678910111213141516171819202122232425262728/* 1. List&lt;Stu&gt; Collections.sort(stuList) Comparable Collections.sort(stuList,...) Comparator 分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序， 如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。*/package collections;import set.Customer;import java.util.Arrays;import java.util.Collections;import java.util.List;public class Ex12 &#123; public static void main(String[] args) &#123; //集合中 存放 Customer List&lt;Customer&gt; customerList = Arrays.asList(new Customer(&quot;aaa&quot;,100D),new Customer(&quot;bbb&quot;,80.5D),new Customer(&quot;ccc&quot;,90D)) ; //jdk1.8 新特性 不使用辅助类 Collections //customerList.sort((c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); //使用 辅助类 Collections //Collections.sort(customerList); Collections.sort(customerList,(c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); customerList.forEach(System.out::println); &#125;&#125; 8. Map扩展8.1 LinkedHashSet 8.2 LinkedHashMap 8.3 ConcurrentHashMap 8.4 Properties 9.泛型扩展9.1 什么是泛型 9.2 泛型好处 9.3 使用前后对比 9.4 类型参数 9.5 方法参数 9.6 泛型不是协变的 9.7 类型通配符 9.8 泛型局限性","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java开发利器--idea安装过程详解","slug":"Java开发利器-idea安装过程详解","date":"2023-06-29T13:46:51.000Z","updated":"2023-07-03T05:31:41.850Z","comments":true,"path":"2023/06/29/Java开发利器-idea安装过程详解/","link":"","permalink":"http://example.com/2023/06/29/Java%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-idea%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"0. IDEA0.1 安装 0.2 配置破解11. 打开 readme.txt 安装步骤进行破解 JDK 字体 编码 0.3 运行创建项目 创建Java类 编写&#x2F;运行源代码 0.4 debug 0.5 卸载 删除安装目录：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"ES6及之后新特性一览","slug":"ES6及之后新特性一览","date":"2023-06-25T04:40:11.000Z","updated":"2023-07-01T08:40:14.329Z","comments":true,"path":"2023/06/25/ES6及之后新特性一览/","link":"","permalink":"http://example.com/2023/06/25/ES6%E5%8F%8A%E4%B9%8B%E5%90%8E%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/","excerpt":"","text":"let声明变量let 声明变量1.let 不允许重复声明变量 var 可以重复声明2.let 不支持变量的声明提升，var可以3.let声明的变量会被所有代码块（{}内的范围）限制作用范围 var只会受到函数影响4.let 声明的变量不和顶层变量挂钩 const 声明常量const 声明常量1.const 不可以重复声明2.不支持声明提升3.作用范围受{}影响4.不和最上层对象window挂钩const num &#x3D; 10;const num &#x3D; 20;&#x2F;&#x2F;Cannot redeclare block-scoped variable ‘num’if(true){ const a &#x3D; 20;}console.log(a); let和const区别1.let声明的变量可以被修改，const声明的是常量 不可以改变2.let声明时可以不赋值，const声明时必须赋值 变量的解构赋值解构赋值；就是快速的从对象或者数组中取出成员的一个语法方式 解构对象12345678const obj = &#123; name:&quot;zs&quot;, age:18, genders:&quot;男&quot;&#125;let name = obj.name;let age = obj.age;let genders = obj.genders; 123456789101112131415const obj2 = &#123; name:&quot;ls&quot;, age:18, genders:&quot;女&quot;&#125;//解构对象//前面的必须是&#123;&#125;表示要从obj2这个对象中获取对象成员//name age genders 都是obj2的现有成员//obj2必须是对象let&#123;name,age,genders&#125; = obj2;console.log(name,age,genders);let&#123;name:a,age:b,genders:c&#125; = obj2;console.log(a,b,c);let&#123;max,min,ceil,floor,random&#125;=Math;console.log(max(10,20,30)); 解构数组12345678//使用解构赋值的方式从数组中提取成员const arr2 = [&quot;一&quot;,&quot;二&quot;,&quot;三&quot;];//解构数组//a b c 分别对应这个数组中的索引下标0 1 2//arr2 必须是数组//如果解构失败，返回结果就是undefinedlet [a,b,c,d] = arr2;console.log(a,b,c,d); 模板字符串ES5中 表示字符串的时候使用’’或者””ES6中 还有一种可以表示字符串的方法 就是&#96;&#96;ES5 字符串 需要同行书写，换行后需要拼接字符串 12const str2 = &#x27;hello&#x27; +&#x27;world&#x27; ES6 可以直接换行使用 12const str3 = `hello world` &#96;&#96;的拼接方式与””不同 12console.log(&quot;我要&quot;+a+&quot;块钱&quot;)console.log(`我要$&#123;a&#125;块钱`) 字符串与数值拓展字符串12345678910111213let &#123;log&#125; = console;let str = &quot;Tom&quot;;//判断字符串中是否存在指定字符 返回true或者falselet res = str.includes(&quot;opm&quot;);//判断字符串中以指定字符开头 返回true或者falseres = str.startsWith(&quot;p&quot;)//判断字符串中以指定字符结尾 返回true或者falseres = str.endsWith(&quot;m&quot;)//repeat() 将字符串重复N次，返回一个新的字符串res = str.repeat(3)//TomTomTomres = str.repeat(2.5)//TomTomres = str.repeat(0)//&quot;&quot;log(res); 数值12345678910111213141516171819202122232425262728let&#123;log&#125; = console;//Number.isFinite() 判断被传入的内容是否为有限数值let res = Number.isFinite(100);//trueres = Number.isFinite(100/0);//falseres = Number.isFinite(Infinity);//falseres = Number.isFinite(NaN);//falseres = Number.isFinite(&quot;100&quot;)//false//Number.isInteger() 判断被传入的内容是否为整数res = Number.isInteger(100);//trueres = Number.isInteger(100.0);//trueres = Number.isInteger(100.1);//falseres = Number.isInteger(&quot;Tom&quot;);//falseres = Number.isInteger(&quot;100&quot;)//false//Math.trunc() 将括号内的参数转化为数字再去掉小数点res = Math.trunc(1.2);//1res = Math.trunc(1.8);//1res = Math.trunc(-1.8);//-1res = Math.trunc(&quot;Tom&quot;);//NaNres = Math.trunc(&quot;10.2&quot;);//10//Math.sign() 判断括号内的数是正数负数还是0res = Math.sign(200);//1res = Math.sign(-200);//-1res = Math.sign(0);//0res = Math.sign(-0);//-0res = Math.sign(&quot;asld&quot;);//NaN 数组拓展12345678910111213//...扩展运算符: let arr = [1,2,3]; let arr2 = [4,5,6]; let res =[...arr,...arr2]; console.log(res);//1，2，3，4，5，6function test()&#123; //arguments 是函数参数的集合 是个伪数组 console.log(arguments); //Array.from() 将 伪数组 转换为 真实数组 res = Array.from(arguments); console.log(res);&#125;test(1,2,3) document.querySelectorAll() 通过选择器获取所有相关元素 返回的是NodeList 伪数组document.querySelector() 通过选择器获取首个相关元素 直接返回元素对象find() 主要用于查找一个符合条件的数组元素findIndex() 主要用于查找一个符合条件的数组元素的下标它的参数是一个回调函数 在回调函数中可以制定寻找元素的条件当条件成立为true时间。返回该元素，如果没有符合的条件，返回undefined 123456let arr3 = [11,22,33,44,55]res = arr3.find(function(item)&#123;//item 表示数组内的每一个成员 return item&gt;20; console.log(item);&#125;)console.log(lis); fill() 使用括号内的参数，直接在数组内填充数据（替换和添加）第一个参数 是替换的新value值第二个参数 是替换的起始坐标第三个参数 是替换的结束坐标 123let arr5 = [1,&quot;纯爱&quot;,&quot;纯爱&quot;];arr5.fill(&quot;牛头人&quot;,1,2);console.log(arr5); 对象拓展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; let name = &quot;张三&quot; let obj = &#123; name:name, fn:function()&#123;&#125; &#125; console.log(obj) //如果对象的属性和value的变量相同，就可以只写一个属性名 let obj2 = &#123; name, //name:name getMessage()&#123;&#125;, getList()&#123;&#125; &#125; console.log(obj2) let msg = &quot;class&quot;; //对象的属性名可以使用表达式 需要用到符号 [表达式] let obj3 = &#123; [msg+&quot;one&quot;]:&quot;Tom&quot;, [`$&#123;msg&#125;xxx`]()&#123;&#125; &#125; console.log(obj3) let obj4 = &#123; name:&quot;jerry&quot;, age:14 &#125; //对象内可以使用拓展运算符 let obj5 = &#123; ...obj4//相当于通过for in遍历，属于深拷贝 &#125; console.log(obj5) //Object.assign() 将需要操作的元素复制到目标对象中 //第一个参数 目标参数 //第二个参数及后面所有额参数都是 需要操作的对象 //如果复制的数据是 值类型数据 实现的是深拷贝 //如果复制的数据是 引用类型数据 使用的任然是该数据的指针(引用地址)，实现的是浅拷贝(重点) let obj6 = &#123;&#125;; let obj7 = &#123; name:&quot;ggBANG&quot;,//值类型深拷贝 friends:[&quot;小A&quot;]//引用类型浅拷贝 &#125; Object.assign(obj6,obj7); obj6.age = 20; obj6.friends = &quot;小王&quot;; console.log(obj6) console.log(obj7)&lt;/script&gt; 函数拓展1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; function fn()&#123;&#125; let fn2 = function()&#123;&#125; // =&gt; const fn3 = (a,b) =&gt;&#123; console.log(a+b) &#125; fn3(1,2) // xxx.onclick = ()=&gt;&#123;&#125; // setInterval(()=&gt;&#123;&#125;) //传入一个参数a, 并且a为函数的返回值 //只有一个参数的情况下 小括号可以省略 //函数内 只有一行需要执行的代码的时候 花括号可以省略 const fn4 = a =&gt;a; fn4(10) //箭头函数制定参数默认值 const fn5 = (a=20,b=50) =&gt;&#123; console.log(a,b); &#125; fn5() let div = document.querySelector(&#x27;div&#x27;); //函数区别 //1.箭头函数的this指向 函数的声明处 //2.箭头函数中无法使用arguments //3.箭头函数不可以作为构造函数 使用 div.onclick= () =&gt;&#123; console.log(this); &#125; // const fn6 = () =&gt;&#123; // console.log(arguments); // &#125; // fn6(1,2,3) const Tom = () =&gt;&#123; console.log(&quot;123&quot;); &#125; new Tom() &lt;/script&gt; SymbolSymbol：表示独一无二的值 1234567891011121314151617var names = Symbol();console.log(names);//使用symbol 当作对象名var obj = &#123; [names]:&quot;Tom&quot;&#125;console.log(obj);//Symbol 函数可以接收一个字符串作为字符串，表示堆Symbol实例的描述//主要是为了在控制台上显示，比较容易区分const ages = Symbol(&quot;age&quot;)console.log(ages)var obj2 = &#123; [ages]:18, [names]:&quot;Tom&quot;&#125;//获取带有Symbol格式的属性console.log(obj2[ages]);//不要加.了 Reflect 是一个内置对象的反射机制，用来提供方法 拦截js的操作Reflect.ownKeys(obj)返回一个数组forEach（）实现遍历的方法 123Reflect.ownKeys(obj).forEach(function(item)&#123; console.log(item);&#125;) Iterator接口Iterator接口的作用为各种数据结构，提供一个统一的，简单的访问接口使数组格式的成员能够按照某种次序排列es6创造了一种新的遍历命令 for of 循环， Iterator接口主要供for…of循环Iterator接口遍历的过程创建一个指针对象，指向当前数据结构的起始位置,第一次调用指针对象的next方法，可以将指针指向该数据结构的第一个成员第二次调用指针对象的next方法，指针就指向该数据结构的第二个成员不断调用指针对象的next方法，直到他指向数据结构的结束位置 1234let item = arr[Symbol.iterator]();console.log(item);console.log(item.next());console.log(item.next()); ES6规定，默认的Iterator接口部署在数据结构[Symbol.iterator]属性或者说 只要有 数据结构 具备Symbol.iterator属性 就认为是可遍历的Symbol.iterator属性本身就是一个函数，就是当前数据结构默认的遍历器生成函数执行这个函数就会返回一个遍历器原生默认具备 iterator 接口的数据结构如下:Array Set Map String arguments NodeList Set数据结构Set类似于数组，成员的值是唯一的，没有重复的值Set.size() 返回Set实例的成员总数Set.add() 添加Set成员Set.delete()删除Set成员Set.has() 查看括号内的成员是否在Set中存在 返回布尔类型 1234567let s1 = new Set([1,2,3,4]);console.log(s1);let s2 = new Set();s2.add(&#x27;hello&#x27;);s2.add(&#x27;world&#x27;);s2.delete(&quot;world&quot;);s2.clear(); Set遍历Set.keys() 返回键名的遍历器Set.values() 返回键值的遍历器Set.entries() 返回键值对的遍历器 123456789let result =s2.keys();console.log(result); result =s2.values();console.log(result); result =s2.entries(); console.log(result); s1.forEach(function(item)&#123; console.log(item);&#125;) 数组去重方法一： 123456let arr = [19,20,19,19,20,21,30,90];let s1 = new Set(arr);console.log(s1);//输出的是一个对象//需要转换为数组的话s1 = Array.from(s1);//使用Array.from() 转换成数组console.log(s1); 方法二： 12let s2 = [...new Set(arr)];//...扩展运算符console.log(s2); Map12345678910111213141516171819202122232425&lt;script&gt; //Map 类型对象 键值对的集合，但是Map中的key不限于字符串，可以是各种类型的值 let M1 = new Map(); M1.set(&#x27;name&#x27;,&#x27;tom&#x27;); M1.set(&#123;a:1&#125;,&#x27;tom&#x27;); M1.set(&#x27;big&#x27;,&#x27;small&#x27;); //操作方法 //Map.set(key.value); 在Map对象中添加key和对应的value //Map.get(key); 在Map对象中获取key对象的value //Map.delete(key); 删除指定的key //Map.has(key); 查看key是否在map中存在 返回布尔类型 //Map.clear(); 清空 console.log(M1); console.log(M1.get(&quot;name&quot;)); M1.delete(&quot;name&quot;); console.log(M1); let res = M1.has(&#x27;big&#x27;); console.log(res); //Map遍历方法 与 Set相同 res = M1.keys() res = M1.values() res = M1.entries() console.log(M1); console.log(res);&lt;/script&gt; ProxyObject.defineProperty() 拦截并处理数据第一个参数 需要拦截处理的对象第二个对象 对象内的属性第三个对象 {}配置项，格式是个对象 1234567891011121314151617181920let obj = &#123; data: 111, name:&quot;zs&quot;, age:20 &#125;let box = document.getElementById(&quot;box&quot;)Object.defineProperty(obj, &quot;data&quot;, &#123; get() &#123;// 当使用对象内的指定属性时调用 console.log(&quot;get函数调用&quot;); &#125;, set(value)&#123; console.log(&quot;set函数接收到了:&quot;,value); if(value&gt;=1000)&#123; box.innerHTML =`数据较大,请重新输入`; &#125; else&#123; box.innerHTML = `数据合理放心使用`; &#125; &#125;&#125;) Proxy代理: 123456789101112131415let proxy = new Proxy(obj,&#123; get(target,key)&#123; //target 表示 需要代理的对象 //key 表示的是访问的属性 console.log(target,key); return target[key]; &#125;, set(target,key,value)&#123; //target 表示 需要代理的对象 //key 表示的是设置的属性 //value 设置的新值 console.log(&quot;set:&quot;,target,key,value); target[key] = value//确认操作 &#125;&#125;) ReflectReflect 主要用来获取目标对象的行为,它与Object类似，但更容易读 Promise对象回调地狱当一个回调函数嵌套另一个回调函数的时候就会出现嵌套结构当嵌套结构多的时候，就会出现回调地狱的情况回调地狱 其实就是由多个回调函数互相嵌套导致的，代码维护性非常差 同步异步异步 当一行代码还没有执行结束，就可以去执行另一行代码的顺序 叫做异步同步 当代码逐行执行过程就是同步的过程异步的操作：定时器 callbackpromise 是异步编程的一种统一的解决方案，比传统回调函数，更合理更强大 1234567891011121314151617const api = new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; if(true)&#123; resolve()//resolve 表示成功的回调函数 &#125; else&#123; reject()//reject 表示失败的回调函数 &#125; &#125;,1000)&#125;)api.then(()=&gt;&#123; console.log(&quot;yyyyy&quot;);//.then() 成功&#125;).catch(()=&gt;&#123; console.log(&quot;nnnnn&quot;);//.catch() 失败&#125;) Promise 对象通过自身的状态，来控制异步操作。Promise实例具有三种状态异步操作未完成(pending)异步操作完成(fulfilled)异步操作失败(rejected) 链式调用为什么promise可以实现链式调用因为当promise方法执行结束后仍然会返回一个promise对象 123456789101112131415const a = promise.then((res) =&gt; &#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 2000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 3000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 5000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;);&#125;).catch((err)=&gt;&#123; console.log(&quot;失败啦&quot;,err);&#125;)console.log(a) all方法Promise.all() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态都是fulfilled pAll的状态才是 fulfilled此时P1,P2,P3的返回值组成一个数组，传递给pAll中 race方法Promise.race() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态只要有一个fulfilled pRace的状态才是 fulfilled此时返回值是首次达到fulfilled状态的值除非全部reject否则不会触发.catch Generator函数ES6 提供的一种异步编程解决方案 123456789101112function *gen()&#123; console.log(1); yield;//yield 表示暂停执行标记，通过next方法恢复执行 console.log(2); yield; console.log(3);&#125;let g = gen()//next() 驱动下一步的执行g.next()g.next()g.next()console.log(g); Class语法与继承123456789101112131415class Person&#123;//创建一个Person类 也叫做 构造函数 //类中的属性需要使用constructor 构造器创建 constructor(name,age,height)&#123; this.name = name; this.age = age; this.height = height; &#125; // 在类中创造方法 say()&#123; console.log(&quot;这是Person类&quot;); &#125;&#125;let obj = new Person(&quot;zhangsan&quot;,19,&quot;180cm&quot;);console.log(obj);obj.say() class继承 123456789101112131415161718192021222324class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(&quot;这是&quot;,this.name,this.age,&quot;岁&quot;); &#125;&#125;const one = new Person(&quot;张飞&quot;,100);one.say();class Student extends Person&#123;//extends 表示StudentPerson类中继承 constructor(name,age,height)&#123; super(name,age);//super() 表示从父类中继承的属性内容 必须写在 construtor中 this.height = height; &#125; say()&#123; super.say(); console.log(&quot;是学生&quot;) &#125;&#125;let obj = new Student(&#x27;xz&#x27;,12,&#x27;120&#x27;);console.log(obj);obj.say();","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"Javascript 基础知识","slug":"Javascript-基础知识","date":"2023-06-12T05:11:08.000Z","updated":"2023-07-01T08:40:11.753Z","comments":true,"path":"2023/06/12/Javascript-基础知识/","link":"","permalink":"http://example.com/2023/06/12/Javascript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 JavaScrip简介JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。JavaScript 很容易学习。 ECMAScript 语法标准(es)JavaScript 输出JavaScript 可以通过不同的方式来输出数据：使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 外部的 JavaScript也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。 外部 JavaScript 文件的文件扩展名是 .js。 1&lt;script src=&quot;./01.js&quot;&gt;&lt;/script&gt; 变量1var a = 20; var 申明变量名a 变量名 用来存储变量20 变量&#x3D; 赋值符号 从右向左赋值 变量命名规则：1.可以是字母或者下划线_或者$开头2.长度不可超过255个字符3.名中不能含有空格，首字头不能是数字4.严格区分大小5.不能使用关键字或保留字6.汉字可使用不推荐当使用空的变量名时，得到的结果就是未定义 undefined使用不存在的变量名时，报错，d is not defined变量的声明提升:先使用变量再创建变量 得到的结果会是 undefined 只能提升变量名，不提升变量 12console.log(e);var e = 30; 相当于 123var e;console.log(e);var e = 30; 数据类型与转换基本数据类型:number 数字string 字符串 只要有引号包裹就是字符串boolean 布尔 true&#x2F;false将数据类型转化为number类型强制类型转换:Number（） 将数据类型转换成number转换字母等非数字内容的话会显示NaN (No a Number)parseFloat() 浮点型 将数据保留小数 并且转换为数字类型转换带数字的字符串时，必须开头为数字才能识别parseInt() 整型 将数据保留整数，并转换成数字类型isNaN()：判断内容是否是 非数字 如果是非数字 返回 true 反之为 false只查看数据内容，不查看数据类型数据类型转换为字符串强制类型转换String() 将数据类型转换为字符串xxx.toString() 将数据类型转换为字符串 需要转化的变量名写在前面将数据类型转换为布尔Boolean()0为false，其他为true值类型:number 数字string 字符串boolean 布尔null 空undefined未定义symbol 独一无二的引用数据类型：object 对象function函数array 数组tpyeof(undefined)&#x3D; undefined;tpyeof(null)&#x3D; object;tpyeof(error)&#x3D; object; 算数运算符+ 加法当符号两边都是数字的时候，会自动相加求和当符号两边有字符串时，会起到拼接字符串的作用（结果时字符串类型–隐式类型转换）当符号两边有布尔类型时，true为1，false为0 参与求和计算++ 自增加1++在后面 表示后加，处于正在加1的过程，还没加上，当再次使用变量时，才算自增结束++在前面 表示先加，直接自增结束，得到就是自增+1的结果- 减法当符号两边都是数字的时候，会自动相减求差当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算– 自减1，同自增* 乘法当符号两边都是数字的时候，会自动相乘求积当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算&#x2F; 除法当符号两边都是数字的时候，会自动相除求商当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算除数如果是0 得到的是 Infinity 无穷&#x2F;无限% 除余()优先运算符 比较运算符注意：&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D; 的不同&#x3D;&#x3D; 等号(只比较值，不比较数据类型)&#x3D;&#x3D;&#x3D; 全等号（值和数据类型都相同）&gt; 大于号&gt;&#x3D; 大于等于&lt; 小于&lt;&#x3D; 小于等于!&#x3D; 不等于!&#x3D;&#x3D; 不全等于 逻辑运算符&amp;&amp; 与 符号两边的表达都为true整个表达式的结果就是true 有一方为false，整个表达式的结果就是false|| 或 有一方为true，整个表达式的结果就是true！ 非 对象与事件实例化对象：var obj&#x3D;new Object();键值对（属性：属性值）obj.name&#x3D;”zs”;&#x2F;&#x2F;键值对就是XX&#x3D;XX字面量的方式创建对象: 12345var obj2 = &#123; name:&quot;1s&quot;, age:20, height:172&#125; 日期对象var&#x3D; new Date();date.getFullYear();获取当前年份getMonth 获取当前月份getDate日期getDay星期getHours小时getMinutes分钟getSeconds当前秒getMilliseconds 当前毫秒getTime从1970.1.1至今的毫秒数Math对象Math.max 返回最大数Math.min 返回最小数Math.ceil 天花板函数，有小数部分向上取整Math.floor 地板函数 舍掉小数部分Math.round(b) 四舍五入Math.random() 随机数字0-1 取不到1事件on绑定事件的关键字 click 点击事件box.onclick&#x3D;function(){}onblur 失去焦点 if else略 switchswitch 用来监视链路，捕获数据某种情况下需要执行的代码块switch 具有数据穿透性 需要break中断余下代码的执行default 相当于else 123456789101112switch(n)&#123; case 10: XXXX; break; case 20: XXXX; break; default: XXXX; break;&#125; 第二种情况：switch(true) 12345switch(true)&#123; case n&lt;10&amp;&amp;n&gt;=0: console.log(&quot;switch范围监测&quot;) break;&#125; 三目运算符表达式？ 结果1(true):结果2(false) 1a&gt;b ? console.log(&quot;a大&quot;):console.log(&quot;b大&quot;); for循环for循环执行顺序：for 首次执行 先创造变量 再判断条件 不走增量 直接执行代码块剩下的执行次数都是 先增量再判断 最后走代码块如果 变量不满足判断条件 循环结束for(初始化变量;判断条件；增量){重复执行代码块}break： 终止循环 终止整个循环体 余下代码不执行continue： 终止循环 终止当前次数的循环，余下代码不执行 while循环与do while循环1234while(i&lt;10)&#123; console.log(i); i++;&#125; 1234do &#123; i++; console.log(i); &#125; while (i &lt; 10) while 和 do while的区别while循环是 先判断再执行do while 循环 是先执行再判断 数组和数组api123456789101112131415161718192021222324252627282930313233var arr = new Array();//实例化数组// 数组内数据的序号 我们叫做下标（索引号）arr[0]=&quot;李白&quot;;arr[1]=&quot;白居易&quot;;console.log(arr);// 字面量的方式创建数组var arr2 = [&quot;ls&quot;,&quot;zs&quot;,123,false];console.log(arr2);// 数组的使用方式 数组名[下标]console.log(arr2[2]);// 数组名.length 数组内成员的个数console.log(arr2.length);//二维数组var arr4 = [1,3,4,[1,2,3]];console.log(arr4[3][1]);//多维数组var arr5 =[&#123; name:&quot;zs&quot;, age:18, friends:[&#x27;ls&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;ls&quot;, age:20, friends:[&#x27;zs&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;wr&quot;, age:22, friends:[&#x27;ls&#x27;,&#x27;zs&#x27;]&#125;] 数组的操作方法1.数组.includes() 查看数组内是否包含指定成员，如果是就返回true,如果不包含就返回false 2.Array.isArray() 判断是否是一个数组格式 返回 true 或 false 3.数组.indexOf() 查看数组内的成员，如果存在就返回首次出现的下标，如果不存在就返回-14.数组.lastIndexOf() 查看数组内的成员，如果存在就返回最后一次出现的下标，如果不存在就返回-15.数组.join() 在数组各元素之间插入相同的字符串拼接，将数组转换成字符串6.数组.push() 在原数组末尾添加新成员，返回新数组长度，原数组被改变7.数组.unshift() 在数组开头添加新成员，返回新数组长度，原数组被改变8.数组.pop() 删除数组最后一名成员，返回被删除内容，原数组被改变9.数组.shift() 删除数组开头的成员，返回被删除内容，原数组被改变 10.数组.reverse() 反转数据11.数组.splice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组改变当括号内有两个参数的时候，表示从当前下标开始一直截取到几个，返回被截取的内容，原数组改变当括号内有三个参数的时候，第三个参数表示在截取位置添加的新内容，返回被截取的内容，原数组改变12.数组.slice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组不改变当括号内有两个参数的时候，表示从当前下标开始到第二个参数下标结束，返回被截取的内容，原数组不改变var res &#x3D;arr.includes(“奥斯”); 字符串API字符串.length 获取字符串的长度字符串.split() 字符串转换成数组，根据括号的内容进行字符分割字符串.charAt() 返回指定下标处的字符字符串.indexOf() 返回查找首次出现字符的下标，如果不存在返回-1字符串.lastIndexOf() 返回查找最后一次出现字符的下标，如果不存在返回-1字符串.substr() 截取字符串 如果有一个参数 表示从当前下标开始截取到末尾 返回截取的内容如果有两个参数，表示从当前下标开始截取几个 返回截取的内容 函数匿名函数： 自调用 通过事件绑定在一起触发具名函数： function . 函数名()函数特性：不调用，不执行函数的使用叫做调用函数具有 预加载(函数的位置在定义先后不影响执行)具名函数的调用 函数名()return 返回值（余下代码不执行）function 函数名（形式参数）{}var a &#x3D; 函数名（实际参数）；封装函数 全局变量与局部变量变量是存在作用域的 分为 全局变量和局部变量局部变量： 在函数内部用var声明的变量就是局部变量（只在函数内部生效）全局变量：在函数外部用var声明的变量就是全局变量，可以在整个JS中生效不用var声明的，变量也是全局变量（不推荐使用）闭包：闭包的形式：多个函数互相嵌套闭包的目的：将内部函数的局部变量提到全局中去使用闭包的实现方式：不断地设置return 返回值闭包的缺点：会消耗电脑内存 影响性能 DOMdocument object model 文档对象模型 定时器1234567891011// setInterval(callback) 多次执行的定时器 callback参数 表示 回调函数start.onclick = function () &#123; timer = setInterval( function () &#123; console.log(1); &#125;, 1000) &#125; stop.onclick = function () &#123;// clearInterval(定时器的名字) 清除定时器 clearInterval(timer);&#125; thisthis 表示 这个this 在函数中 代指函数的调用者this在函数外 指向的是window对象，最大的对象 12345678910111213141516var lis = document.getElementsByTagName(&quot;li&quot;)console.log(this);for (var i = 0; i &lt; lis.length; i++)&#123; //属性绑定 写在循环的内部，事件的外部 // index 一般表示为下标 lis[i].index = i; lis[i].onclick = function() &#123; //先让所有颜色都变成蓝色 再让当前的这个变成红色 //这就是排他思想 for (var j = 0; j &lt; lis.length; j++)&#123; lis[j].style.background = &quot;skyblue&quot;; &#125; this.style.background = &quot;red&quot;; console.log(this.index);//获取到下标 &#125;&#125; 轮播图参考https://swiper.com.cn/ Node节点操作1.xx.parentNode 当前节点的父节点2.xx.childNodes 当前节点的所有子节点,包含文本节点(本次返回的text为回车造成的空格) 返回nodeList 伪数组3.xx.children 当前节点的所有子元素节点 返回HTMLCollection 伪数组4.xx.firstChild 当前节点的第一个子节点,包含文本节点5.xx.firstElementChild 当前节点的第一个子元素节点6.xx.lastChild 当前节点的最后一个子节点,包含文本节点7.xx.lastElementChild 当前节点的最后一个子元素节点8.xx.previousSibling 当前节点的前一个兄弟节点,包含文本节点9.xx.previousElementSibling 当前节点的前一个兄弟元素节点10.xx.nextSibling 当前节点的前一个兄弟节点,包含文本节点11.xx.nextElementSibling 当前节点的前一个兄弟元素节点节点的操作1.document.createElement() 创建节点2.xx.innerHTML 往节点内添加或替换内容(文本或标签)2.xx.innerText 往节点内添加或替换内容(文本)4.xx.appendChild() 往父节点的末尾添加新节点5.xx.insertBefore(新节点,目标节点) 将新节点添加到目标节点之前6.xx.cloneNode() 克隆节点,true的时候,将该节点及其子节点全部复制；flase的时候只复制节点本身。7.父节点.removeChild() 删除父节点的子节点 偏移量offsetWidth 元素自身的宽度 width+border+paddingoffsetHeight 元素自身的高度 同上offsetLeft 元素自身的位置offsetTop 元素自身的位置onscroll 滚动事件scroll卷曲的距离clientWidth可视区域的宽 width paddingclientWidth可视区域的宽 height padding document.body;&#x2F;&#x2F;获取body 标签document.documentElement&#x2F;&#x2F;获取html标签 事件对象event 事件对象 通过事件触发的时候调用函数内的参数该对象内包含了事件触发时的信息事件对象的兼容写法： 1var e = event || window.event;//兼容低版本ie浏览器 pageX 光标相对于网页的水平位置（ie无）*pageY 光标相对于网页的垂直位置（ie无）*screenX 光标相对于屏幕的水平位置screenY 光标相对于屏幕的垂直位置clientX 光标相对于可视区域的水平位置*clientY 光标相对于可视区域的垂直位置（重要且相同）xx.onkeypress 键盘按键 按下并且弹起xx.keyCode 表示键盘上对应按键的编码xx.onmouseenter 鼠标进入xx.onmouseleave 鼠标离开 事件冒泡和事件句柄事件冒泡：当一个元素的事件被触发的时候,比如鼠标点击了一个元素，同样的事件就会在这个元素的所有祖先元素上被触发这个过程就叫做事件冒泡,这个事件是从原始事件一直冒泡到dom树的最上层.不支持事件冒泡的事件: focus,blur,mouseenter,mouseleave,load,resize 12//阻止事件冒泡的兼容写法e.stopPropagation ? e.stopPropagation() :e.cancelBubble = true; 事件句柄:addEventLister 添加事件句柄第一个参数 事件的名称第二个参数 callback 回调函数第三个参数 false 触发的顺序是由内到外，叫做冒泡的顺序（默认）； true 触发的顺序是由外到内，叫做捕获的顺序同一个元素可以绑定多个相同事件，不会覆盖，挨个执行 123box.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;222&quot;); &#125;,true) 缓存注意：cookie localStorage sessionStorage的区别cookie 默认浏览器关闭时消失，存在于web服务器中，存储大小为4KBlocalStorage 本地储存 永久有效，除非手动删除，存储大小为5MBsessionStorage 会话存储 关闭浏览器或窗口事就消失，存储大小为5MBcookie缓存： 123456document.cookie=&quot;username = 李白&quot;//创建cookie缓存document.cookie=&quot;age = 30; expires = Tue, 20 Jun 2023 12:00:00 GMT&quot;//设置过期事件var res =document.cookie;var n = res.indexOf(&quot;=&quot;) +1 ;res = res.substr(n);console.log(res); localStorage缓存： 123456localStorage.setItem(&quot;NAME&quot;,&quot;TOM&quot;);//创建缓存 localStorage.setItem（key,value） localStorage.setItem(&quot;AGE&quot;,&quot;18&quot;);localStorage.removeItem(&quot;AGE&quot;);//删除指定缓存 localStorage.removeItem(key)var res = localStorage.getItem(&quot;NAME&quot;);//获取缓存 localStorage.getItem(key) var age = localStorage.getItem(&quot;AGE&quot;);localStorage.clear();//清空缓存 localStorage.clear() BOMbrowser object model 浏览器对象模型 Window对象window.open(“https://www.baidu.com&quot;//在当前窗口跳转window.close();&#x2F;&#x2F;关闭窗口 locationlocation.hostname web主机域名location.pathname 当前页面的路径location.port 端口号(0-65535)location.herf 整个URLlocation.protocol web协议常见的协议:http 和 https 的区别*http 免费 相对不安全，端口号默认80https 收费 比较安全，端口号默认443 secureftpfile history两种后退功能：history.back(); history.go(-1);两种前进功能：history.go(); history.go(1); navigatornavigator 设备信息对象navigator.appCodeName 浏览器代号navigator.appName 浏览器名称navigator.appVersion 浏览器版本navigator.vender 浏览器供应商navigator.cookieEnabled 浏览器是否启用了缓存navigator.platform 硬件平台navigator.userAgent 用户代理语言navigator.language 用户代理语言 正则表达式 实例化创建正则对象 1var reg = new RegExp(); &#x2F;&#x2F;字面量方式创造正则对象reg &#x3D; &#x2F;@&#x2F;; 含有@reg &#x3D; &#x2F;\\d&#x2F; 含有数字reg &#x3D; &#x2F;\\D&#x2F; 含有非数字reg &#x3D; &#x2F;\\s&#x2F; 含有不可见字符(空格，回车等)reg &#x3D; &#x2F;\\S&#x2F; 含有可见字符reg &#x3D; &#x2F;\\w&#x2F; 含有单词字符 字母 数字reg &#x3D; &#x2F;\\W&#x2F; 含有非单词字符 简单类reg &#x3D; &#x2F;[23]&#x2F; 含有2或者3负向类reg &#x3D; &#x2F;[^23]&#x2F; 含有非2或者3范围类reg.onblur &#x3D; &#x2F;[0-9]&#x2F; 含有0-9中的任意一个组合类reg &#x3D; &#x2F;[0-9a-z]&#x2F; 含有数字或者字母中的一个边界reg &#x3D; &#x2F;^12&#x2F; 必须以12开头reg &#x3D; &#x2F;23$&#x2F; 必须以23结束reg &#x3D; &#x2F;^123$&#x2F; 必须是123&#x2F;&#x2F;量词reg&#x3D; &#x2F;^123*$&#x2F; ‘3’的重复次数&gt;&#x3D;0次reg&#x3D; &#x2F;^123+$&#x2F; ‘3’的重复次数&gt;&#x3D;1次reg&#x3D; &#x2F;^123?$&#x2F; ‘3’的重复次数只能是0或1次reg&#x3D; &#x2F;^12{4}3$&#x2F; ‘2’的重复次数4次reg&#x3D; &#x2F;^12{4,}3$&#x2F; ‘2’的重复次数&gt;&#x3D;4次reg&#x3D; &#x2F;^12{4,10}3$&#x2F; ‘2’的重复次数4到10次 正则.test(需要校验的内容) 返回布尔类型 1var res = reg.test(inp.value); 高级JS(面向对象)值类型与引导类型值类型 ：number string boolean null undef symbol引用数据类型： array function object 值类型与引用数据类型的区别值类型 ：存储在栈中，内存空间固定当数据复制的时候，可以直接复制互不影响typeof 判断数据类型引用数据类型：存储在堆中，内存空间不固定浅拷贝：当数据复制的时候，只能复制数据的引用地址深拷贝：将数据复制并在堆中重新申请一片空间进行存储深拷贝实现的两种方式： 12var obj2 = JSON.stringify(obj);//对象 =&gt; string 将对象转换成json字符串var obj2 = JSON.parse(obj2);//string =&gt; 对象 将json字符串转换成对象 通过instanceof() 判断数据是哪一种引用类型（返回true&#x2F;false） 1var res = arr instanceof(Arry); 工厂模式和构造函数面向对象编程的基本特征封装： 将客观事物封装成抽象的类继承： 子类具有父类的公有属性多态： 对象的多功能，多方法，一个方法可以有多种表现形式字面量创建对象 创建量如果比较多就比较繁琐，并且对象之间没有关系 12345678var personOne = &#123; name:&quot;zs&quot;, age:20&#125;var personTwo = &#123; name:&quot;ls&quot;, age:24&#125; 通过封装的方式创建对象，解决代码重复的问题 123456function createPerson(name,age)&#123; return&#123; name:name, age:age &#125; &#125; 工厂模式 12345678function createPerson(name,age)&#123; var obj =new Object();//准备工厂环境 obj.name = name;//将属性进行加工 obj.age = age;//将属性进行加工 return obj;//将加工好的对象进行输出&#125;personOne = createPerson(&quot;王二&quot;,10);personTwo = createPerson(&quot;zy&quot;,30); 构造函数 12345678function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;var personOne = new CreatePerson(&quot;张三丰&quot;,&quot;108&quot;)var personTwo = new CreatePerson(&quot;孙悟空&quot;,&quot;正无穷&quot;)console.log(personOne);console.log(personTwo); 构造函数需要注意的事情：1.CreatePerson 称之为 构造函数 也叫做 类，构造函数就是类2.personOne 就是 CreatePerson 的实例对象3.构造函数中的this指向的是通过new实例化出来的4.必须使用new关键字 将函数实例化5.构造函数的开头必须大写6.构造函数会自动创造出来一个 constructor(构造器)属性，这是属性就是指向CreatePerson prototype原型属性，存在于每个构造函数之中通过prototype原型创建的方法可以在构造函数生成的实例中公用，有利于提升效率prototype 的顶端 是 object 123456789 function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;CreatePerson.prototype.say = function()&#123; console.log(&quot;yyy&quot;); return 0;&#125;var one = new CreatePerson(&quot;zs&quot;,20); 对象继承12345678910111213141516171819202122232425function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.run=function()&#123; console.log(&quot;啊啊啊啊啊&quot;);&#125;Person.prototype.findWork=function()&#123; console.log(&quot;working&quot;);&#125;function Man()&#123; console.log(&quot;nnnnn&quot;);&#125;//看似赋值的过程 =&gt; 实际上实现的是浅拷贝// Man.prototype = Person.prototype; //for in 循环（用来遍历对象）for(var k in Person.prototype)&#123; console.log(k);//k是对象的属性 Man.prototype[k] = Person.prototype[k]&#125;Man.prototype.jump = function()&#123; console.log(&quot;hhhhhhhhhhh&quot;); &#125;console.log(Man.prototype);console.log(Person.prototype); 多态多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态的实现方式：覆盖指子类重新定义父类方法，基于prototype继承就是。 call和apply和bind12345678910111213141516171819 //thiswindow.color = &quot;red&quot;;document.color = &quot;green&quot;;// console.log(window);var obj = &#123; color:&quot;white&quot;&#125;function changeColor(a,b)&#123; console.log(a+&quot;和&quot;+b+&quot;喜欢&quot;+this.color)&#125;//函数.call(this需要指向的对象，参数必须使用逗号分隔)changeColor(&quot;小王&quot;,&quot;小明&quot;);changeColor.call(document,&quot;小王&quot;,&quot;小明&quot;);changeColor.call(obj,&quot;小王&quot;,&quot;小明&quot;);//函数.apply(this需要指向的对象，参数必须使用数组)changeColor.apply(document,[&quot;小王&quot;,&quot;小明&quot;]);changeColor.apply(obj,[&quot;小王&quot;,&quot;小明&quot;]);//函数名.bind(this需要指向的对象，参数可以是任意形式)() 返回的是函数需要再次调用changeColor.bind(obj,[&quot;小李&quot;],[&quot;zs&quot;])()","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"MarkDown学习(一)","slug":"MarkDown学习-一","date":"2022-06-22T13:39:30.000Z","updated":"2023-07-02T17:10:54.433Z","comments":true,"path":"2022/06/22/MarkDown学习-一/","link":"","permalink":"http://example.com/2022/06/22/MarkDown%E5%AD%A6%E4%B9%A0-%E4%B8%80/","excerpt":"","text":"MarkDOwn初识标题要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 () (例如：### My Header)。 1234567# 1级标题## 2级标题### 3级标题#### 四级标题 ##### 五级标题 ###### 六级标题 字体1*斜体文本* 斜体文本 1**加粗文本** 加粗文本 1***加粗和斜体文本*** 加粗和斜体文本 1~~删除文本~~ 删除文本 1&gt; 引用文本 引用文本 列表有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 一： First item Second item Third item Fourth item 二： 12341. First item1. Second item2. Third item3. Fourth item First item Second item Third item Fourth item 三： 12341. First item8. Second item7. Third item3. Fourth item First item Second item Third item Fourth item 无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 123456- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 复选框列表（CheckBoxList） 123- [ ] List Item 1 unchecked- [x] List Item 2 checked- [X] List Item 3 checked List Item 1 unchecked List Item 2 checked List Item 3 checked 代码12345678910111213141516#[derive(Debug)]pub enum State &#123; Start, Transient, Closed,&#125;impl From&lt;&amp;&#x27;a str&gt; for State &#123; fn from(s: &amp;&#x27;a str) -&gt; Self &#123; match s &#123; &quot;start&quot; =&gt; State::Start, &quot;closed&quot; =&gt; State::Closed, _ =&gt; unreachable!(), &#125; &#125;&#125; 123456789101112[ &#123; &quot;title&quot;: &quot;apples&quot;, &quot;count&quot;: [12000, 20000], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;, &#123; &quot;title&quot;: &quot;oranges&quot;, &quot;count&quot;: [17500, null], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;] 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Gre\\&#x27;ater&#x27; return (param2 - param1 + 1 + 0b10l) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; 12345678910111213&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt; function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt; 123456789101112131415161718192021function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=&quot;$&#123;cls&#125;&quot;`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log(&#x27;undefined&#x27;); &#125; return ( &lt;div&gt; &lt;web-component&gt;&#123;block&#125;&lt;/web-component&gt; &lt;/div&gt; )&#125;export $initHighlight; 1234567891011121314#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125; 123456789101112CREATE TABLE &quot;topic&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;forum_id&quot; integer NOT NULL, &quot;subject&quot; varchar(255) NOT NULL);ALTER TABLE &quot;topic&quot;ADD CONSTRAINT forum_id FOREIGN KEY (&quot;forum_id&quot;)REFERENCES &quot;forum&quot; (&quot;id&quot;);-- Initialsinsert into &quot;topic&quot; (&quot;forum_id&quot;, &quot;subject&quot;)values (2, &#x27;D&#x27;&#x27;artagnian&#x27;); 12345678910111213#import &lt;UIKit/UIKit.h&gt;#import &quot;Dependency.h&quot;@protocol WorldDataSource@optional- (NSString*)worldName;@required- (BOOL)allowsToLive;@end@property (nonatomic, readonly) NSString *title;- (IBAction) show;@end 12345678910111213141516/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123; public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; 123456789101112131415import Foundation@objc class Person: Entity &#123; var name: String! var age: Int! init(name: String, age: Int) &#123; /* /* ... */ */ &#125; // Return a descriptive string for this person func description(offset: Int = 0) -&gt; String &#123; return &quot;\\(name) is \\(age + offset) years old&quot; &#125;&#125; 123456789101112131415@font-face &#123; font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123; color: #F0F0F0; background: #600; font-family: Chunkfive, sans;&#125;@import url(print.css);@media print &#123; a[href^=http]::after &#123; content: attr(href) &#125;&#125; 12345678910111213# The Greeter classclass Greeter def initialize(name) @name = name.capitalize end def salute puts &quot;Hello #&#123;@name&#125;!&quot; endendg = Greeter.new(&quot;world&quot;)g.salute 12345678910111213# MakefileBUILDDIR = _buildEXTRAS ?= $(BUILDDIR)/extras.PHONY: main cleanmain: @echo &quot;Building main facility...&quot; build_main $(BUILDDIR)clean: rm -rf $(BUILDDIR)/* 123456789101112package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan float64) ch &lt;- 1.0e10 // magic number x, ok := &lt;- ch defer fmt.Println(`exitting now\\`) go println(len(&quot;hello world!&quot;)) return&#125; 123456789101112131415#!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then echo &quot;Superuser rights required&quot; exit 2figenApacheConf()&#123; echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125; 123456789101112; boilerplate[package]name = &quot;some_name&quot;authors = [&quot;Author&quot;]description = &quot;This is \\a description&quot;[[lib]]name = $&#123;NAME&#125;default = Trueauto = nocounter = 1_000 超链接1这是一个链接 [百度](https://baidu.com)。 这是一个链接 百度。 图片1![图片alt](图片链接 &quot;图片title&quot;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2022-06-03T11:42:34.000Z","updated":"2023-07-02T17:10:41.054Z","comments":true,"path":"2022/06/03/我的第一篇博客文章/","link":"","permalink":"http://example.com/2022/06/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"一年前，就试着搭建了这个Hexo框架的微博，但是只是部署到了Github上，并没有打理自己的博客，也没有写一些内容，这和当初搭建博客的目的有点南辕北辙了。这段时间确实是让人比较疲惫且受挫，但还是得打起精神，继续前进。","categories":[],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"},{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]}