{"meta":{"title":"YukiCCC的博客","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-07-18T17:09:14.605Z","updated":"2023-07-18T17:09:14.605Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"自己想做的XXX件事： 干一份自己值得为之倾尽全力的工作 邂逅真爱 自驾游环游中国 考取研究生 研究生顺利毕业 学会射箭 学会写一手花体英文字 去日本旅行一次 学会骑马 去内蒙古玩一次 去舟山群岛到普陀山登顶 学会开车 拥有一台旗舰级顶级配置的电脑 让父母放心为他们分一次忧 开一次大排量摩托车 坐一次倒悬式的过山车 作为长辈给晚辈精心准备一次礼物 给家里坏掉的房门装锁 自己自驾游一座城市 写好中国字练一手好字"},{"title":"所有分类","date":"2023-07-01T08:25:42.219Z","updated":"2023-07-01T08:25:42.219Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-07-01T08:26:59.883Z","updated":"2023-07-01T08:26:59.883Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-01T08:54:37.410Z","updated":"2023-07-01T08:54:37.410Z","comments":true,"path":"data/friends.json","permalink":"http://example.com/data/friends.json","excerpt":"","text":"[{\"group\":\"分组1# 分组标题\",\"description\":\"友情链接\",\"items\":[{\"title\":\"Google\",\"avatar\":\"https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png\",\"url\":\"https://www.google.com/\",\"screenshot\":null,\"keywords\":null,\"description\":null},{\"title\":null,\"avatar\":null,\"url\":null,\"screenshot\":null,\"keywords\":null,\"description\":null}]}]"},{"title":"我的朋友们","date":"2023-07-01T08:26:42.238Z","updated":"2023-07-01T08:26:42.238Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"Java面试题-四(多线程)","slug":"Java面试题-四-多线程","date":"2023-09-18T05:21:24.000Z","updated":"2023-09-18T05:27:43.105Z","comments":true,"path":"2023/09/18/Java面试题-四-多线程/","link":"","permalink":"http://example.com/2023/09/18/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9B%9B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1. 说说并发与并行的区别 并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)； 并行： 单位时间内，多个任务同时执行。 2. 进程 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。 3. 线程 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。 从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。 4. 线程和进程的区别 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。 线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 一个程序至少一个进程，一个进程至少一个线程。 为什么会有线程？ 每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。 线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。 进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。 线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有的资源的变化。 进程线程的区别： 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 资源拥有：同一进程内的线程共享本进程的资源如内存、I&#x2F;O、cpu等，但是进程之间的资源是独立的。 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程是处理器调度的基本单位，但是进程不是。 两者均可并发执行。 优缺点： 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。 进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。 何时使用多进程，何时使用多线程？ 对资源的管理和保护要求高，不限制开销和效率时，使用多进程。 要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。 5. 为什么要使用多线程 先从总体上来说： 从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 再深入到计算机底层来探讨： 单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。 举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。 多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。 6. 什么是上下文切换？ 多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。 概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。 7. 在java程序中如何保证多线程的运行安全？ 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized） 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）； 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取共享变量时，它会去内存中读取新值。普通的共享变量不能保证可见性，因为普通共享变量被修改后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。更新主存的步骤：当前线程将其他线程的工作内存中的缓存变量的缓存行设置为无效，然后当前线程将变量的值跟新到主存，更新成功后将其他线程的缓存行更新为新的主存地址其他线程读取变量时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。 有序性：即程序执行的顺序按照代码的先后顺序执行。在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。可以通过volatile关键字来保证一定的“有序性”。当在处理并发编程的时候，只要程序满足了原子性，可见性和有序性，那么程序就不会发生脏数据的问题。 8. 编写多线程程序有几种实现方式 Java 5以前实现多线程有两种实现方法： 继承Thread类； 实现Runnable接口。 两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。 Java5之后还可以通过 实现Callable接口，此种实现可以带返回值 使用 Executor 框架创建线程池 9. 启动一个线程事调用run()还是start()方法？ 启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。 10. 说一下runnable和callable有什么区别？ Callable规定的方法是call(),Runnable规定的方法是run(). Callable的任务执行后可返回值，而Runnable的任务是不能返回值得 call方法可以抛出异常，run方法不可以 运行Callable任务可以拿到一个Future对象，Future 表示异步计算的结果。 它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如果线程没有执行完，Future.get()方法可能会阻塞当前线程的执行；如果线程出现异常，Future.get()会throws InterruptedException或者ExecutionException；如果线程已经取消，会跑出CancellationException。取消由cancel 方法来执行。isDone确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。Future接口的定义如下：Future模式Future模式在请求发生时，会先产生一个Future凭证给发出请求的客户，它的作用就像是Proxy物件，同时，由一个新的执行线程持续进行目标物件的生成（Thread-Per-Message），真正的目标物件生成之后，将之设定至Future之中，而当客户端真正需要目标物件时，目标物件也已经准备好，可以让客户提取使用。结合JDK的Future来看，就是你run线程后，你可以把线程的返回值赋给Future并返回一个Future对象。这时你可以立即拿到这个对象，然后进行下面的逻辑。但是如果你要get这个Future中的线程结果，就会被阻塞直到线程结束。就相当于现在的期房，你把手续和钱都交上去了，就可以马上拿到合同，但只有合同没有房子。这个时候你已经是有房一族了，你可以先去买家电买装修（走下面的其他逻辑）。但是你要把家电和装修放进去，就必须等到房子完工（阻塞）。 11. 线程有哪些状态 在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态； 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep,suspend等方法都可以导致线程阻塞。 死亡状态。如果一个线程的run方法执行结束，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪状态。 12. 线程的sleep()方法和yield()方法有什么区别？ sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 13. 线程的run()和start()有什么区别？ 在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。 实现并启动线程有两种方法 写一个类继承自Thread类，重写run方法。用start方法启动线程 写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动多线程 原理： 相当于玩游戏机，只有一个游戏机（cpu），可是有很多人要玩，于是，start是排队！等CPU选中你就是轮到你，你就run（），当CPU的运行的时间片执行完，这个线程就继续排队，等待下一次的run（）。 调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。 然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。 先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。 start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。 14. wait和sleep的区别（线程） sleep()来自 Thread 类，wait()来自 Object 类； 调用 sleep()方法，线程不会释放对象锁。而调用 wait 方法线程会释放对象锁； sleep()睡眠后不出让系统资源，wait 让其他线程可以占用 CPU； sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。而 wait()需要配合 notify()或者 notifyAll()使用。 15. Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？ sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。 wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 16. wait()和sleep()的区别 sleep()来自 Thread 类，wait()来自 Object 类； 调用 sleep()方法，线程不会释放对象锁。而调用 wait 方法线程会释放对象锁； sleep()睡眠后不出让系统资源，wait 让其他线程可以占用 CPU； sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。而 wait()需要配合 notify()或者 notifyAll()使用 17. 请说出与线程同步以及线程调度相关的方法 wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 18. 守护线程是什么 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分两种. 守护线程，比如垃圾回收线程，就是最典型的守护线程。 用户线程，就是应用程序里的自定义线程。 19. 说说线程的生命周期和状态 Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）： 由上图可以看出：线程创建之后它将处于 NEW（新建）状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。 1操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。 当线程执行 wait()方法之后，线程进入 WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞）状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止）状态 20. 使用多线程可能带来什么问题？ 并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。 21. 什么是线程死锁？如何避免死锁 认识线程死锁两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。 下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过 Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。 学过操作系统的朋友都知道产生死锁必须具备以下四个条件： 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 如何避免线程死锁? 我们只要破坏产生死锁的四个条件中的其中一个就可以了。 破坏互斥条件 这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件 一次性申请所有的资源。 破坏不剥夺条件 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 我们对线程 2 的代码修改成下面这样就不会产生死锁了。 我们分析一下上面的代码为什么避免了死锁的发生? 线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。 然后线程 1 再去获取 resource2 的监视器锁，可以获取到。 然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。 这样就破坏了破坏循环等待条件，因此避免了死锁。 22. 怎么防止死锁1. 什么是死锁 死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 例如，在某一个计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。 2. 死锁产生的原因 系统资源的竞争 系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。 进程运行推进顺序不合适 进程在运行过程中，请求和释放资源的顺序不当，会导致死锁 3. 死锁的四个必要条件 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 4. 死锁的避免与预防1. 死锁避免 死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。,安全状态是指：如果系统存在 由所有的安全序列{P1，P2，…Pn},则系统处于安全状态。一个进程序列是安全的，如果对其中每一个进程Pi(i &gt;&#x3D;1 &amp;&amp; i &lt;&#x3D; n)他以后尚需要的资源不超过系统当前剩余资源量与所有进程Pj(j &lt; i)当前占有资源量之和，系统处于安全状态则不会发生死锁。 不安全状态：如果不存在任何一个安全序列，则系统处于不安全状态。他们之间的对对应关系如下图所示： 下面我们来通过一个例子对安全状态和不安全状态进行更深的了解 如上图所示系统处于安全状态，系统剩余3个资源，可以把其中的2个分配给P3，此时P3已经获得了所有的资源，执行完毕后还能还给系统4个资源，此时系统剩余5个资源所以满足（P2所需的资源不超过系统当前剩余量与P3当前占有资源量之和），同理P1也可以在P2执行完毕后获得自己需要的资源。 如果P1提出再申请一个资源的要求，系统从剩余的资源中分配一个给进程P1，此时系统剩余2个资源，新的状态图如下：那么是否仍是安全序列呢那我们来分析一下 系统当前剩余2个资源，分配给P3后P3执行完毕还给系统4个资源，但是P2需要5个资源，P1需要6个资源，他们都无法获得资源执行完成，因此找不到一个安全序列。此时系统转到了不安全状态。 2. 死锁预防 我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。 破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。 破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。 - 23. 什么是线程池（thread pool）? 在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 24. 创建线程池有哪几种方式 通常开发者都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的Executors目前提供了5种不同的线程池创建配置： newCachedThreadPool（），它是用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置时间超过60秒，则被终止并移除缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。 newFixedThreadPool（int nThreads），重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动线程数目，将在工作队列中等待空闲线程出现；如果工作线程退出，将会有新的工作线程被创建，以补足指定数目nThreads。 newSingleThreadExecutor()，它的特点在于工作线程数目限制为1，操作一个无界的工作队列，所以它保证了所有的任务都是被顺序执行，最多会有一个任务处于活动状态，并且不予许使用者改动线程池实例，因此可以避免改变线程数目。 newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。 newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。 25. 线程池都有哪些状态 线程池的5种状态： Running ShutDown Stop Tidying Terminated。 线程池各个状态切换框架图： 1. RUNNING 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！ 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 2. SHUTDOWN 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。 3. STOP 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。 4. TIDYING 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。 5. TERMINATED 状态说明：线程池彻底终止，就变成TERMINATED状态。 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。 26. 举例说明同步和异步 如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 27. 说一下synchronized底层实现原理（详细版） 数据同步需要依赖锁，那锁的同步又依赖谁？synchronized给出的答案是在软件层面依赖JVM，而Lock给出的方案是在硬件层面依赖特殊的CPU指令，大家可能会进一步追问：JVM底层又是如何实现synchronized的？ 下面首先介绍synchronized的实现： synrhronized关键字简洁、清晰、语义明确，因此即使有了Lock接口，使用的还是非常广泛。其应用层的语义是可以把任何一个非null 对象 作为’锁’，当synchronized作用在方法上时，锁住的便是对象实例（this）；当作用在静态方法时锁住的便是对象对应的Class实例，因为 Class数据存在于永久带，因此静态方法锁相当于该类的一个全局锁；当synchronized作用于某一个对象实例时，锁住的便是对应的代码块。在 HotSpot JVM实现中，锁有个专门的名字：对象监视器。 1. 线程状态及状态转换 当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程： Contention List：所有请求锁的线程将被首先放置到该竞争队列 Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck Owner：获得锁的线程称为Owner !Owner：释放锁的线程 下图反映了个状态转换关系： 新请求锁的线程将首先被加入到ConetentionList中，当某个拥有锁的线程（Owner状态）调用unlock之后，如果发现 EntryList为空则从ContentionList中移动线程到EntryList，下面说明下ContentionList和EntryList 的实现方式： 1.1 ContentionList 虚拟队列 ContentionList 并不是一个真正的Queue，而只是一个虚拟队列，原因在于ContentionList是由Node及其next指 针逻辑构成，并不存在一个Queue的数据结构。ContentionList是一个后进先出（LIFO）的队列，每次新加入Node时都会在队头进行， 通过CAS改变第一个节点的的指针为新增节点，同时设置新增节点的next指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个Lock- Free的队列。 因为只有Owner线程才能从队尾取元素，也即线程出列操作无争用，当然也就避免了CAS的ABA问题。 1.2. EntryList EntryList与ContentionList逻辑上同属等待队列，ContentionList会被线程并发访问，为了降低对 ContentionList队尾的争用，而建立EntryList。Owner线程在unlock时会从ContentionList中迁移线程到 EntryList，并会指定EntryList中的某个线程（一般为Head）为Ready（OnDeck）线程。Owner线程并不是把锁传递给 OnDeck线程，只是把竞争锁的权利交给OnDeck，OnDeck线程需要重新竞争锁。这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在 Hotspot中把OnDeck的选择行为称之为“竞争切换”。 OnDeck线程获得锁后即变为owner线程，无法获得锁则会依然留在EntryList中，考虑到公平性，在EntryList中的位置不 发生变化（依然在队头）。如果Owner线程被wait方法阻塞，则转移到WaitSet队列；如果在某个时刻被notify&#x2F;notifyAll唤醒， 则再次转移到EntryList。 2. 自旋锁 那些处于ContetionList、EntryList、WaitSet中的线程均处于阻塞状态，阻塞操作由操作系统完成（在Linxu下通 过pthread_mutex_lock函数）。线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响 锁的性能缓解上述问题的办法便是自旋，其原理是：当发生争用时，若Owner线程能在很短的时间内释放锁，则那些正在争用线程可以稍微等一等（自旋）， 在Owner线程释放锁后，争用线程可能会立即得到锁，从而避免了系统阻塞。但Owner运行的时间可能会超出了临界值，争用线程自旋一段时间后还是无法 获得锁，这时争用线程则会停止自旋进入阻塞状态（后退）。基本思路就是自旋，不成功再阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有非 常重要的性能提高。自旋锁有个更贴切的名字：自旋-指数后退锁，也即复合锁。很显然，自旋在多处理器上才有意义。 还有个问题是，线程自旋时做些啥？其实啥都不做，可以执行几次for循环，可以执行几条空的汇编指令，目的是占着CPU不放，等待获取锁的机 会。所以说，自旋是把双刃剑，如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。显然，自旋的周期选择显得非常重要，但这与操作系统、硬 件体系、系统的负载等诸多场景相关，很难选择，如果选择不当，不但性能得不到提高，可能还会下降，因此大家普遍认为自旋锁不具有扩展性。 自旋优化策略 对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下： 如果平均负载小于CPUs则一直自旋 如果有超过(CPUs&#x2F;2)个线程正在自旋，则后来线程直接阻塞 如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋 自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差） 自旋时会适当放弃线程优先级之间的差异那synchronized实现何时使用了自旋锁？答案是在线程进入ContentionList时，也即第一步操作前。线程在进入等待队列时 首先进行自旋尝试获得锁，如果不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平。还有一个不公平的地方是自旋线程可能会抢占了 Ready线程的锁。自旋锁由每个监视对象维护，每个监视对象一个。 3.JVM1.6偏向锁 在JVM1.6中引入了偏向锁，偏向锁主要解决无竞争下的锁性能问题，首先我们看下无竞争下锁存在什么问题： 现在几乎所有的锁都是可重入的，也即已经获得锁的线程可以多次锁住&#x2F;解锁监视对象，按照之前的HotSpot设计，每次加锁&#x2F;解锁都会涉及到一些 CAS操 作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个 线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁&#x2F;解锁流程。但还有很多概念需要解释、很多引入的 问题需要解决： 3.1 CAS及SMP架构 CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构： 其意思是所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。 而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，经过调查发现， 其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的 接口。 Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总 线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致 性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。 而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。 Cache一致性： 上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：http://en.wikipedia.org/wiki/MESI_protocol，以后会仔细讲解这部分。 Cache一致性流量的例外情况：其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：http://blogs.oracle.com/dave/entry/biased_locking_in_hotspotNUMA(NonUniform Memory Access Achitecture）架构： 与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。 3.2 偏向解除 偏向锁引入的一个重要问题是，在多争用的场景下，如果另外一个线程争用偏向对象，拥有者需要释放偏向锁，而释放的过程会带来一些性能开销，但总体说来偏向锁带来的好处还是大于CAS代价的。 4. 总结 关于锁，JVM中还引入了一些其他技术比如锁膨胀等，这些与自旋锁、偏向锁相比影响不是很大，这里就不做介绍。 通过上面的介绍可以看出，synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。 28. 说一下synchronized底层实现原理（简单版） synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 29. synchronized和Lock有什么区别？ 首先synchronized是java内置关键字，在jvm层面，Lock是个java类； synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 30. 说说自己是怎么使用synchronized关键字，在项目中用到了吗synchronized关键字最主要的三种使用方式： 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 修饰静态方法: :也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到静态方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！ 下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。 面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！” 双重校验锁实现对象单例（线程安全） 另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行： 1.为 uniqueInstance 分配内存空间 2.初始化 uniqueInstance 3.将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 31. synchronized和volatile的区别是什么？ volatile是变量修饰符，而synchronized则作用于一段代码或者方法。 volatile只是在线程内存和main memory(主内存)间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源。 32. 什么是ThreadLocal？ThreadLocal和Synchonized的区别 线程局部变量。是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。 Java提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。 synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而 ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。 33. ThreadLocal是什么？有哪些使用场景？ ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 从数据结构入手下图为ThreadLocal的内部结构图 ThreadLocal结构内部从上面的结构图，我们已经窥见ThreadLocal的核心机制： 每个Thread线程内部都有一个Map。 Map里面存储线程本地对象（key）和线程的变量副本（value）但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 应用场景Hibernate的session获取场景吗？ 为什么每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。使用ThreadLocal的典型场景正如上面的数据库连接管理，线程会话管理等场景，只适用于独立变量副本的情况，如果变量为全局共享的，则不适用在高并发下使用。 总结 每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。 ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。 适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。 34. 谈谈synchronized和ReentrantLock的区别 两者都是可重入锁两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。 synchronized 依赖于 JVM 而 ReentrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。 ReentrantLock 比 synchronized 增加了一些高级功能相比synchronized，ReentrantLock增加了一些高级功能。 主要来说主要有三点： ①等待可中断； ②可实现公平锁； ③可实现选择性通知（锁可以绑定多个条件） ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。 两者都是可重入锁两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。 35. 如何让list变成线程安全 使用synchronized关键字； 使用Collections.synchronizedList();使用方法如下：假如你创建的代码如下： 1List&lt;Map&lt;String, Object&gt;&gt; data = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); 那么为了解决这个线程安全问题你可以这么使用Collections.synchronizedList()，如： 1List&lt;Map&lt;String, Object&gt;&gt; data = Collections.synchronizedList(new ArrayList&lt;Map&lt;String, Object&gt;()) 其他的都没变，使用的方法也几乎与ArrayList一样，大家可以参考下api文档； 额外说下 ArrayList与LinkedList；这两个都是接口List下的一个实现，用法都一样，但用的场所的有点不同，ArrayList适合于进行大量的随机访问的情况下使用，LinkedList适合在表中进行插入、删除时使用，二者都是非线程安全，解决方法同上（为了避免线程安全，以上采取的方法，特别是第二种，其实是非常损耗性能的）。 36. 说一下atomic的原理 在多线程的场景中，我们需要保证数据安全，就会考虑同步的方案，通常会使用synchronized或者lock来处理，使用了synchronized意味着内核态的一次切换。这是一个很重的操作。 有没有一种方式，可以比较便利的实现一些简单的数据同步，比如计数器等等。concurrent包下的atomic提供我们这么一种轻量级的数据同步的选择。 在以上代码中，使用AtomicInteger声明了一个全局变量，并且在多线程中进行自增，代码中并没有进行显示的加锁。以上代码的输出结果，永远都是2000000。如果将AtomicInteger换成Integer，打印结果基本都是小于2000000。 也就说明AtomicInteger声明的变量，在多线程场景中的自增操作是可以保证线程安全的。接下来我们分析下其原理。 原理这里，我们来看看AtomicInteger是如何使用非阻塞算法来实现并发控制的。AtomicInteger的关键域只有以下3个： 这里， unsafe是java提供的获得对对象内存地址访问的类，注释已经清楚的写出了，它的作用就是在更新操作时提供“比较并替换”的作用。实际上就是AtomicInteger中的一个工具。 valueOffset是用来记录value本身在内存的编译地址的，这个记录，也主要是为了在更新操作在内存中找到value的位置，方便比较。 value是用来存储整数的时间变量，这里被声明为volatile。volatile只能保证这个变量的可见性。不能保证他 的原子性。可以看看getAndIncrement这个类似i++的函数，可以发现，是调用了UnSafe中的getAndAddInt。 如何保证原子性：自旋 + CAS（乐观锁）。在这个过程中，通过compareAndSwapInt比较更新value值，如果更新失败，重新获取旧值，然后更新。 优缺点 CAS相对于其他锁，不会进行内核态操作，有着一些性能的提升。但同时引入自旋，当锁竞争较大的时候，自旋次数会增多。cpu资源会消耗很高。换句话说，CAS+自旋适合使用在低并发有同步数据的应用场景。 Java 8做出的改进和努力在Java 8中引入了4个新的计数器类型，LongAdder、LongAccumulator、DoubleAdder、DoubleAccumulator。他们都是继承于Striped64。 在LongAdder 与AtomicLong有什么区别？Atomic遇到的问题是，只能运用于低并发场景。因此LongAddr在这基础上引入了分段锁的概念。可以参考《JDK8系列之LongAdder解析》一起看看做了什么。大概就是当竞争不激烈的时候，所有线程都是通过CAS对同一个变量（Base）进行修改，当竞争激烈的时候，会将根据当前线程哈希到对于Cell上进行修改（多段锁）。 可以看到大概实现原理是：通过CAS乐观锁保证原子性，通过自旋保证当次修改的最终修改成功，通过降低锁粒度（多段锁）增加并发性能。 37. 多线程锁的升级原理是什么？ 多线程优化锁升级monitorenter与monitorexit这两个控制多线程同步的bytecode原语，是JVM依赖操作系统互斥(mutex)来实现的（系统调用）。互斥是一种会导致线程挂起，并在较短的时间内又需要重新调度回原线程的，较为消耗资源的操作。 JDK1.6对线程进行了优化，目的就是减少多线程编程下对锁竞争产生的性能开销。 无锁状态：没有加任何锁 偏向锁：如果程序中只有一个线程在访问对象，那么这个对象的锁就会偏向于这一个线程，之后一系列的原子操作都不会产生同步开销，直到其他线程在竞争锁的时候，偏向锁才会解除掉 轻量级锁（Lightweight Locking）:多个线程会去竞争锁，但是尽可能地减少多线程进入互斥的几率。它并不是要替代互斥，因为随着竞争越来越激烈，它最后也会升级成重量级锁（inflated 膨胀）乐观锁：多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起（适应性自旋：不要旋转太久，否则会消耗过多的cpu），而是被告知这次竞争中失败，并可以再次尝试。乐观锁就是轻量级锁，悲观锁就是重量级锁。 轻量级锁是如何实现的呢？ 利用了CPU原语CompareAndSwap(汇编指令为CMPXCHG)，尝试在进入互斥前，进行补救。轻量级锁加锁（竞争的线程不会阻塞，提高了程序的响应速度） 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。 重量级锁：重量锁又叫对象监视器（Monitor），它实际上是利用操作系统中的Mutex，除了具备Mutex互斥的功能，它还负责实现Semaphore的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Java面试题-三(JavaWeb)","slug":"Java面试题-三-JavaWeb","date":"2023-09-18T05:17:52.000Z","updated":"2023-09-18T05:20:30.377Z","comments":true,"path":"2023/09/18/Java面试题-三-JavaWeb/","link":"","permalink":"http://example.com/2023/09/18/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%89-JavaWeb/","excerpt":"","text":"1. 如何解决POST请求中文乱码问题，GET的又是如何处理的 解决post请求乱码问题： 在web.xml中配置一个CharacterEncodingFilter过滤器，设置成UTF-8； 123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; get请求中文参数出现乱码的解决方法有两个： 修改tomcat配置文件添加编码与工程编码一致，如下： 1&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 另一种方法对参数进行重新编码 1String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;) ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 2. Servlet接口中有哪些方法?Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： void init(ServletConfig config) throws ServietException void service(ServletRequest req，ServietResponse resp) throws ServietException,java.io.IOException void destory() java.lang.String getServletlnfo() ServletConfig getServletConfig() Web容器加载Servlet并将其实例化后，Servlet生命周期开始容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service(）方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用 Servlet的destroy()方法。 3. 转发（forward）和重定向（redirect）的区别？ 相同点： 都能跳转到其它页面 不同点： 转发请求只发出一次请求，而重定向发出多次请求 转发request对象是同一个,而重定向request对象是多个 转发地址栏不变,而重定向地址栏改变 转发的”&#x2F;“是相对于项目,而重定向的”&#x2F;“相对于WEB容器 转发只能转发到项目资源,而重定向可以是项目资源也可以是外部资源 请求转发有两种写法 1234//forward 一去不回头，在转发之后向控制台(System.out.println)仍然会输出，但out.println(&quot;xxx&quot;)不会在页面上输出request.getRequestDispatcher(&quot;/xx&quot;).forward(request,response);//include 一去还回头，在转发之后向控制台(System.out.println)仍然会输出，但out.println(&quot;xxx&quot;)也会在页面上输出request.getRequestDispatcher(&quot;/xx&quot;).include(request,response); 4. web项目”&#x2F;“的相对路径 的理解 web.xml里”&#x2F;“相当于项目 index.html里”&#x2F;“相当于web容器 请求转发里”&#x2F;“相当于项目 请求重定向”&#x2F;“相当于web容器 自己处理的相当于项目 服务器处理相当于web容器 5. jsp有哪些内置对象？作用分别是什么？ Jsp有9个内置对象： request：封装客户端的请求，其中包合来自GET或Post请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config: Web应用的配置对象； page: JsP页面本身（相当于Java程序中的this ） exception：封装页面抛出异常的对象。 6. GET与POST请求比较 使用GET方式传递参数: 在浏览器地址栏中输入某个地址或单击网页上一个超链接 ，浏览器发出的HTTP请求方式为GET 如果form表单中method属性设置成了”GET，浏览器提交这个FORM表单的HTTP请求方式也为GET 使用GET请求给WEB服务器传递参数的格式 （Query String Paramaters） 1http://localhost:8080/02_JavaWeb_Servlet_HTTP/loginServlet2?uname=%E5%BC%A0%E4%B8%89 缺点: 地址栏大小有限制，最多255个字符 不安全，如果是密码则在地址栏中会以明码显示 优点: 书签 http://localhost:8080/books/java100day?page=10; 使用POST方式传递参数 【推荐】 如果form表单中method属性设置成了”POST”，浏览器提交这个FORM表单的HTTP请求方式就为POST 在址址栏中看不到传递的数据，因为它是使用表单数据传递的(Form Datas) 优点： 大小没有限制 安全 7. 常用的Web服务器有哪些？ Unix和Linux平台下使用最广泛的免费HTTP服务器，Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。 选择Web服务器应考虑的因素有：性能、安全性、日志统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。 下面是对常见服务器的简介： IIS : Microsoft的Web服务器产品全称是Internet Information Services。IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务软件，其中包括Web服务器、FTP服务器、NNTF服务器、 SMTP服务器分别用于网页浏览、文件传输、新闻服务和邮件发送等方面它使得在网络（包括互联网和局域网上发布信息成了一件很容易的事。它提供ISAPI(lntranet Server API）作为扩展Web服务器功能的编程接口；同时它还提供一个Internet数据库连接器可以实现对数据库的查询和更新。 Kangle:Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务 软件。此外Kangle也是一款专为做虚拟主机研发的WEB 服务器。实现虚拟主机独立进程、独立身份运行。用户 之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。 WebSphere:WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IMB电子商务计划的核心部分它是基于Java的应用环境用于建立、部署和 处理Internet和Intranet Web应用程序适应各种Web应用程序服务器的需要。 WebLogic : WebLogic Server是一款多功能、基于标准 的Web应用服务器，为企业构建企业应用提供了坚实的 基础。针对各种应用开发、关键性任务的部署，各种系统性数据库的集成、跨Internet协作等Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业的应用都选择它来作为开发和部署的环境。WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位为构建集成化的企业级应用提供了稳固的基础。 Apache：目前Apache仍然是世界上用得最多的Web服 器，其市场占有率很长时间都保持在60％以上（目前的 场份额约40％左右）。世界上很多著名的网站都是Apache 的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix, Windows, Linux系统平台上）以及它的可移动性等方面。 Tomcat:Tomcat是一个开放源代码、运行Servlet和JSP的WEB容器。Tomcat实现了Servlet和JSP规范。此外Tomc at还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。 Nginx：读作 ‘engine x’，是一个高性能的HTTP和反向代理服务器也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。Nginx是由Igor Sysoev 俄罗斯访问量第二的Rambler站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可的形式发布，因它的稳定性、丰富的功能集、示例配置组件和低系统资源的消耗而闻名。在2014年下半年Nginx: 市场份额达到了14%。 8 . 过滤器的理解 JavaWEB有三大组件 ： Servlet、Filter和Listener。Filter就是其中之一。 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。 可以将一个或多个过滤器附加到一个 Servlet 或一组 Servlet。过滤器也可以附加到 JavaServer Pages (JSP) 文 件和 HTML 页面。调用 Servlet 或页面前都会先执行过滤器。 Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的： 在客户端的请求访问后端资源之前，拦截这些请求。 在服务器的响应发送回客户端之前，处理这些响应。 10. Ajax简介 AJAX &#x3D; Asynchronous JavaScript and XML（异步 JavaScript 和 XML）。 Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 Javascript 来操作 DOM 而更新页面。这其中最关键的一步就是从服务器获得请求数据。 XmlHttpRequest 是 ajax 的核心机制，它是在 IE5 中首先引入的，是一种支持异步请求的技术。简单的说，也就是 Javascript 可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 11. http响应码301和302代表的是什么？有什么区别？ 官方的比较简洁的说明： 301 代表永久性转移(Permanently Moved) 302 代表暂时性转移(Temporarily Moved ) 共同点： 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B） 不同点 301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），**搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。** 12. web.xml文件中可以配置哪些内容？web.xml 用于配置 Web 应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等。 13. 怎么防止表单重复提交？ 禁掉提交按钮。表单提交后使用 Javascript 使提交按钮 disable。 Post&#x2F;Redirect&#x2F;Get 模式。在提交后执行页面重定向，这就是所谓的 Post-Redirect-Get (PRG) 模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。 在 session 中存放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。 14. cookie简述 在 web 程序中是使用 HTTP 协议来传输数据的，因为 http 是无状态协议，一旦数据交换完毕，客户端和服务器端的连接就会关闭，再次交换数据需要建立新的连接，所以无法实现会话跟踪，cookie 技术则弥补了这一缺陷。 cookie 实际上一段的文本信息，客户端请求服务器。如果服务器需要记录该用户的状态，就使用 response 向客户端浏览器颁发一个 cookie。客户端浏览器会把 cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 cookie 一同提交给服务器。服务器检查该 cookie，以此来辨认用户的状态。服务器还可以根据需要修改 cookie 的内容。 cookie 生命周期:cookie 的 maxAge 决定 cookie 的生命周期，单位为秒（second）。cookie 通过 getMaxAge() 方法和 setMaxAge()方法来获得 maxAge 属性，如果 maxAhe 属性为正，则表示 cookie 会在 maxAge 秒之后自动失效。如果 maxAge 属性为负，则说明 cookie 仅在本浏览器窗口和本窗口打开的子窗口下有效，关闭窗口 cookie 则失效。maxAge 的默认值是-1 当 maxAge 的值为 0 时，表示删除 cookie。 15. cookie和session的区别 session: session机制采用的是在服务器端保持状态的方案 session会在一定时间内保存在服务器上。当访问增多,会比较占用你服务器的性能 考虑到减轻服务器性能方面,应当使用COOKIE cookie: cookie机制采用的是在客户端保持状态的方案 cookie不是很安全,别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session 16. 监听器有哪些方法和作用 JavaWEB有三大组件 ： Servlet、Filter和Listener。Listener就是其中之一。 三个分类 监听对象自身创建和销毁的监听器 （不常用 ） ServletContextListener Initialized:容器开始创建， Destroyed： 容器关闭时消亡 HttpSessionListener Initialized:session创建时创建， Destroyed： session失效时消亡 ServletRequestListener Initialized:request创建时创建， Destroyed： 页面访问结束时消亡 监听对象中属性的增加和删除的监听器 ServletContextAttributeListener attributeReplaced attributeAdded attributeRemoved HttpSessionAttributeListener ServletRequestAttributeListener 监听Httpsession状态的事件监听器 ,不需要在xml中配置，要在JavaBean上实现此接口。（不常用 ） HttpSessionActivationListener sessionDidActivate，sessionWillPassivate ，需要在META-INF中配置 HttpSessionBindingListener valueBound valueUnbound 总8个监听接口 Listener接口 Event类 ServletContextListener ServletContextEvent ServletContextAttributeListener ServletContextAttributeEvent HttpSessionListener HttpSessionEvent HttpSessionActivationListener HttpSessionAttributeListener HttpSessionBindingEvent HttpSessionBindingListener ServletRequestListener ServletRequestEvent ServletRequestAttributeListener ServletRequestAttributeEvent 17. 什么是跨域，如何实现跨域 跨域说明：当浏览器执行脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。 这里的同源指访问的协议、域名、端口都相同。 同源策略是由 Netscape 提出的著名安全策略，是浏览器最核心、基本的安全功能，它限制了一个源中加载脚本与来自其他源中资源的交互方式。 Ajax 发起的跨域 HTTP 请求，结果被浏览器拦截，同时 Ajax 请求不能携带与本网站不同源的 Cookie。 &lt;script&gt; &lt;img&gt; &lt;iframe&gt; &lt;link&gt; &lt;video&gt; &lt;audio&gt; 等带有 src 属性的标签可以从不同的域加载和执行资源。 实现跨域方式如下 1、jsonp利用了 script 不受同源策略的限制缺点：只能 get 方式，易受到 XSS攻击 2、CORS（Cross-Origin Resource Sharing）,跨域资源共享当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；后端在接受到请求后确定响应后会在后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错缺点：忽略 cookie，浏览器版本有一定要求 3、代理跨域请求前端向发送请求，经过代理，请求需要的服务器资源缺点：需要额外的代理服务器 4、Html5 postMessage 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本、多窗口、跨域消息传递缺点：浏览器版本要求，部分浏览器要配置放开跨域限制 5、6、基于 Html5 websocket 协议websocket 是 Html5 一种新的协议，基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求缺点：浏览器一定版本要求，服务器需要支持 websocket 协议 18. Jquery简介 JQuery 是一个 JavaScript 库。功能包括 HTML 元素选取和操作、CSS 操作、HTML 事件函数、 JavaScript 特效和动画、HTML DOM 遍历和修改、AJAX 和 Utilities。除此之外，JQuery 还提供了大量插件。 重点三个方向 基础语法： $(selector).action()。 选择器：主要分四大选择器，分别是基本选择器、层次选择器、过滤选择器、属性过滤选择器。 事件：例如 click()、dblclick()、mouseenter()、mouseleave()、mousedown()等。 19. session简介 session 也是一种记录客户状态的机制，不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器是时候把客户端信息以某种形式记录在服务器上，这就是 session 中查找该客户的状态。 session 生命周期： session 保存在服务器端，为了获得更高的存取速度，服务器一般把 session 放在内存。每个用户都会有一个独立的 session,如果 session 内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。 session 在用户第一次访问服务器的时候自动创建，需要注意只有访问 JSP，Servlet 等程序时才会创建 session；只要访问 HTML、IMAGE 等静态资源不会创建 session。如果尚未生成session,可以使用 request.getSession(true)强制生成 session。 session 生成后，只要用户访问，服务器就会更新 session 的最后访问时间，并维护该 session。用户每访问服务器一次，无论是否续写 session 服务器都认为该用户的 session 活跃（active）了一次。 Session 对应的类是 javax.servlet.http.HttpSession，每一个访问者都对应一个 session 对象，并将其状态信息保存在这个 session 对象中，session 对象的创建是在用户第一次访问服务器时产生的。 20. JSP和Servlet是什么关系？ Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。 Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。 21. JSP和Servlet是什么关系？ Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。 Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。 给人感觉，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。 22. 过滤器的生命周期 创建，随着WEB容器的启动而启动，这一点与Servlet有区别 void init(FilterConfig) 过滤 ： 每次请求时都会执行 doFilter（ServletRequest request, ServletResponse response, FilterChain chain） 消亡：随着WEB容器的结束而结束 destroy( )","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Java面试题-二(JVM)","slug":"Java面试题-二-JVM","date":"2023-09-18T05:14:23.000Z","updated":"2023-09-18T05:16:43.564Z","comments":true,"path":"2023/09/18/Java面试题-二-JVM/","link":"","permalink":"http://example.com/2023/09/18/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%8C-JVM/","excerpt":"","text":"JVM 有哪些组成部分 JVM 是运行在操作系统之上的，它与硬件没有直接的交互 如下图所示： 整个JVM 分为四部分： Class Loader 类加载器 : 类加载器的作用是加载类文件到内存 Execution Engine 执行引擎: 执行引擎也叫做解释器(Interpreter) ，负责解释命令，提交操作系统执行。 Native Interface 本地接口 本地接口的作用是融合不同的编程语言为Java 所用，它的初衷是融合C&#x2F;C++ 程序，Java 诞生的时候是C&#x2F;C++ 横行的时候，要想立足，必须有一个聪明的、睿智的调用C&#x2F;C++ 程序，于是就在内存中专门开辟了一块区域处理标记为native 的代码，它的具体做法是Native Method Stack 中登记native 方法，在Execution Engine 执行时加载native libraies 。目前该方法使用的是越来越少了，除非是与硬件有关的应用，比如通过Java 程序驱动打印机，或者Java 系统管理生产设备，在企业级应用中已经比较少见，因为现在的异构领域间的通信很发达，比如可以使用Socket 通信，也可以使用Web Service 等等。 Runtime data area 运行数据区 运行数据区是整个JVM 的重点。我们所有写的程序都被加载到这里，之后才开始运行，Java 生态系统如此的繁荣，得益于该区域的优良自治。 JVM加载class文件的原理机制 Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。 类装载方式，有两种 1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中 2.显式装载， 通过class.forname()等方法，显式加载需要的类 Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。 Java的类加载器有三个，对应Java的三种类:（java中的类大致分为三种： 1.系统类 2.扩展类 3.由程序员自定义的类 ） – Bootstrap Loader &#x2F;&#x2F; 负责加载系统类 (指的是内置类，像是String，对应于C#中的System类和C&#x2F;C++标准库中的类) | - - ExtClassLoader &#x2F;&#x2F; 负责加载扩展类(就是继承类和实现类) | - - AppClassLoader &#x2F;&#x2F; 负责加载应用类(程序员自定义的类) 原理机制 装载:查找和导入class文件; 连接: (1)检查:检查载入的class文件数据的正确性; (2)准备:为类的静态变量分配存储空间; (3)解析:将符号引用转换成直接引用(这一步是可选的) 初始化:初始化静态变量，静态代码块。 常见的 jvm 调优的参数有哪些?（1）-Xms20M 表示设置JVM启动内存的最小值为20M，必须以M为单位 （2）-Xmx20M 表示设置JVM启动内存的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免JVM内存自动扩展。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高 （3）-verbose:gc 表示输出虚拟机中GC的详细情况 （4）-Xss128k 表示可以设置虚拟机栈的大小为128k （5）-Xoss128k 表示设置本地方法栈的大小为128k。不过HotSpot并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说这个参数是无效的 （6）-XX:PermSize&#x3D;10M 表示JVM初始分配的永久代（方法区）的容量，必须以M为单位 （7）-XX:MaxPermSize&#x3D;10M 表示JVM允许分配的永久代（方法区）的最大容量，必须以M为单位，大部分情况下这个参数默认为64M （8）-Xnoclassgc 表示关闭JVM对类的垃圾回收 （9）-XX:+TraceClassLoading 表示查看类的加载信息 （10）-XX:+TraceClassUnLoading 表示查看类的卸载信息 （11）-XX:NewRatio&#x3D;4 表示设置 年轻代（包括Eden和两个Survivor区）&#x2F;老年代 的大小比值为1：4，这意味着年轻代占整个堆的1&#x2F;5 （12）-XX:SurvivorRatio&#x3D;8 表示设置2个Survivor区：1个Eden区的大小比值为2:8，这意味着Survivor区占整个年轻代的1&#x2F;5，这个参数默认为8 （13）-Xmn20M 表示设置年轻代的大小为20M （14）-XX:+HeapDumpOnOutOfMemoryError 表示可以让虚拟机在出现内存溢出异常时Dump出当前的堆内存转储快照 （15）-XX:+UseG1GC 表示让JVM使用G1垃圾收集器 （16）-XX:+PrintGCDetails 表示在控制台上打印出GC具体细节 （17）-XX:+PrintGC 表示在控制台上打印出GC信息 （18）-XX:PretenureSizeThreshold&#x3D;3145728 表示对象大于3145728（3M）时直接进入老年代分配，这里只能以字节作为单位 （19）-XX:MaxTenuringThreshold&#x3D;1 表示对象年龄大于1，自动进入老年代,如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代被回收的概率。 （20）-XX:CompileThreshold&#x3D;1000 表示一个方法被调用1000次之后，会被认为是热点代码，并触发即时编译 （21）-XX:+PrintHeapAtGC 表示可以看到每次GC前后堆内存布局 （22）-XX:+PrintTLAB 表示可以看到TLAB的使用情况 （23）-XX:+UseSpining 开启自旋锁 （24）-XX:PreBlockSpin 更改自旋锁的自旋次数，使用这个参数必须先开启自旋锁 （25）-XX:+UseSerialGC 表示使用jvm的串行垃圾回收机制，该机制适用于丹cpu的环境下 （26）-XX:+UseParallelGC 表示使用jvm的并行垃圾回收机制，该机制适合用于多cpu机制，同时对响应时间无强硬要求的环境下，使用-XX:ParallelGCThreads&#x3D;设置并行垃圾回收的线程数，此值可以设置与机器处理器数量相等。 （27）-XX:+UseParallelOldGC 表示年老代使用并行的垃圾回收机制 （28）-XX:+UseConcMarkSweepGC 表示使用并发模式的垃圾回收机制，该模式适用于对响应时间要求高，具有多cpu的环境下 （29）-XX:MaxGCPauseMillis&#x3D;100 设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 （30）-XX:+UseAdaptiveSizePolicy 设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等，此值建议使用并行收集器时，一直打开 说一下jvm有哪些垃圾回收器 先图解虚拟机所包含的收集器： 图中展示了7种作用于不同分代的收集器，3个属于年轻代、3个属于年老代，G1属于横跨年轻代和年老代的算法。 新生代收集器：Serial、ParNew、Parallel Scavenge 老年代收集器：CMS、Serial Old、Parallel Old 整堆收集器： G1 几个相关概念： 并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。 并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。 吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )）。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99% Serial 收集器Serial收集器是最基本的、发展历史最悠久的收集器。 特点：单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。 应用场景：适用于Client模式下的虚拟机。 Serial &#x2F; Serial Old收集器运行示意图 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。 除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。 特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 和Serial收集器一样存在Stop The World问题 应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。 ParNew&#x2F;Serial Old组合收集器运行示意图如下： Parallel Scavenge 收集器与吞吐量关系密切，故也称为吞吐量优先收集器。 特点：属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。 该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别） GC自适应调节策略：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。 Parallel Scavenge收集器使用两个参数控制吞吐量： XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间 XX:GCRatio 直接设置吞吐量的大小。 Serial Old 收集器Serial Old是Serial收集器的老年代版本。 特点：同样是单线程收集器，采用标记-整理算法。 应用场景：主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。 Server模式下主要的两大用途（在后续中详细讲解···）： 在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。 作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。 Serial &#x2F; Serial Old收集器工作过程图（Serial收集器图示相同）： Parallel Old 收集器是Parallel Scavenge收集器的老年代版本。 特点：多线程，采用标记-整理算法。 应用场景：注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器。 Parallel Scavenge&#x2F;Parallel Old收集器工作过程图： CMS收集器一种以获取最短回收停顿时间为目标的收集器。 特点：基于标记-清除算法实现。并发收集、低停顿。 应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b&#x2F;s服务。 CMS收集器的运行过程分为下列4步： 初始标记：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。 并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。 并发清除：对标记的对象进行清除回收。 CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS收集器的工作过程图： CMS收集器的缺点： 对CPU资源非常敏感。 无法处理浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。 因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。 G1收集器一款面向服务端应用的垃圾收集器。 特点如下： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。 分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。 可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。 G1为什么能建立可预测的停顿时间模型？ 因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这样就保证了在有限的时间内可以获取尽可能高的收集效率。 G1与其他收集器的区别： 其他收集器的工作范围是整个新生代或者老年代、G1收集器的工作范围是整个Java堆。在使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region）。虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。 G1收集器存在的问题： Region不可能是孤立的，分配在Region中的对象可以与Java堆中的任意对象发生引用关系。在采用可达性分析算法来判断对象是否存活时，得扫描整个Java堆才能保证准确性。其他收集器也存在这种问题（G1更加突出而已）。会导致Minor GC效率下降。 G1收集器是如何解决上述问题的？ 采用Remembered Set来避免整堆扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否处于多个Region中（即检查老年代中是否引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆进行扫描也不会有遗漏。 如果不计算维护 Remembered Set 的操作，G1收集器大致可分为如下步骤： 初始标记：仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。） 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行） 最终标记：为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set Logs里面，把Remembered Set Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。） 筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行） G1收集器运行示意图： 什么是GC？为什么要有GC？GC（Garbage Collection）是垃圾收集的意思，负责清除对象并释放内存。Java 提供的 GC 功能可以自动检测对象是否超过作用域从而达到自动回收内存的目的，从而防止内存泄漏。 讲一下java内存模型 在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。 而在当前的 Java 内存模型下，线程可以把变量保存本地内存比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。 Java中有哪几种引用？它们的含义和区别是什么？从JDK1.2开始，Java中的引用类型分为四种，分别是： ①强引用（StrongReference）②软引用（SoftRefernce）③弱引用（WeakReference）④虚引用（PhantomReference） 强引用-StrongReference这种引用是平时开发中最常用的，例如String strong &#x3D; new String(‘Strong Reference’)，当一个实例对象具有强引用时，垃圾回收器不会回收该对象，当内存不足时，宁愿抛出OutOfMemeryError异常也不会通过回收强引用的对象，因为JVM认为强引用的对象是用户正在使用的对象，它无法分辨出到底该回收哪个，强行回收有可能导致系统严重错误。 软引用-SoftReference如果一个对象只有软引用，那么只有当内存不足时，JVM才会去回收该对象，其他情况不会回收。软引用可以结合ReferenceQueue来使用，当由于系统内存不足，导致软引用的对象被回收了，JVM会把这个软引用加入到与之相关联的ReferenceQueue中。 当系统内存不足时，触发gc，这个Book就会被回收，reference 将不为null。 弱引用-WeakReference只有弱引用的对象，当JVM触发gc时，就会回收该对象。与软引用不同的是，不管是否内存不足，弱引用都会被回收。弱引用可以结合ReferenceQueue来使用，当由于系统触发gc，导致软引用的对象被回收了，JVM会把这个弱引用加入到与之相关联的ReferenceQueue中，不过由于垃圾收集器线程的优先级很低，所以弱引用不一定会被很快回收。下面通过一个主动触发gc的例子来验证此结论。 当然这不是每次都能复现，因为我们调用System.gc()只是告诉JVM该回收垃圾了，但是它什么时候做还是不一定的，但就我测试来看，只要多写几次System.gc()，复现的概率还是很高的。 虚引用-PhantomReference如果一个对象只有虚引用在引用它，垃圾回收器是可以在任意时候对其进行回收的，虚引用主要用来跟踪对象被垃圾回收器回收的活动，当被回收时，JVM会把这个弱引用加入到与之相关联的ReferenceQueue中。与软引用和弱引用不同的是，虚引用必须有一个与之关联的ReferenceQueue，通过phantomReference.get()得到的值为null 什么是双亲委派模式 双亲委派模型要求除顶层启动类加载器外其余类加载器都应该有自己的父类加载器；类加载器之间通过复用关系来复用父加载器的代码。 双亲委派模型工作工程：1.当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。2.当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。3.如果Bootstrap ClassLoader加载失败(在、lib中未找到所需类)，就会让Extension ClassLoader尝试加载。4.如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。5.如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。6.如果均加载失败，就会抛出ClassNotFoundException异常。 双亲委派模型的实现过程： 实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass()方法中： 首先会检查请求加载的类是否已经被加载过； 若没有被加载过： 递归调用父类加载器的loadClass(); 父类加载器为空后就使用启动类加载器加载； 如果父类加载器和启动类加载器均无法加载请求，则调用自身的加载功能。 双亲委派模型的优点： Java类伴随其类加载器具备了带有优先级的层次关系，确保了在各种加载环境的加载顺序。保证了运行的安全性，防止不可信类扮演可信任的类","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"集合面试题","slug":"集合面试题","date":"2023-09-18T04:58:37.000Z","updated":"2023-09-18T05:12:27.180Z","comments":true,"path":"2023/09/18/集合面试题/","link":"","permalink":"http://example.com/2023/09/18/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"List、Set和Map之间的区别是什么？ List 是可重复有序集合，Set 是不可重复无序集合，这两个接口都实现了 Collection 父接口。 Map 未继承 Collection，而是独立的接口，Map 是一种把键对象和值对象进行映射的集合，它的每一个元素都包含了一对键对象和值对象，Map 中存储的数据是没有顺序的， 其 key 是不能重复的，它的值是可以有重复的。 List 的实现类有 ArrayList，Vector 和 LinkedList： ArrayList 和 Vector 内部是线性动态数组结构，在查询效率上会高很多，Vector 是线程安全的，相比 ArrayList 线程不安全的，性能会稍慢一些。 LinkedList：是双向链表的数据结构存储数据，在做查询时会按照序号索引数据进行前向或后向遍历，查询效率偏低，但插入数据时只需要记录本项的前后项即可，所以插入速度较快。 Set 的实现类有 HashSet 和 TreeSet； HashSet：内部是由哈希表（实际上是一个 HashMap 实例）支持的。它不保证 set 元素的迭代顺序。 TreeSet：TreeSet 使用元素的自然顺序对元素进行排序，或者根据创建 Set 时提供的 Comparator 进行排序。 Map 接口有三个实现类：Hashtable，HashMap，TreeMap，LinkedHashMap； Hashtable：内部存储的键值对是无序的是按照哈希算法进行排序，与 HashMap 最大的区别就是线程安全。键或者值不能为 null，为 null 就会抛出空指针异常。 TreeMap：基于红黑树 (red-black tree) 数据结构实现，按 key 排序，默认的排序方式是升序。 LinkedHashMap：有序的 Map 集合实现类，相当于一个栈，先 put 进去的最后出来，先进后出。 List 和 Map 区别？ 一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List 中存储的数据是有顺序，并且允许重复；Map 中存储的数据是没有顺序的，其 key 是不能重复的，它的值是可以有重复的。 ArrayList 和 LinkedList有何区别 ArrayList 是基于动态数组的数据结构，LinkedList 是基于链表的数据结构； 对于查询和修改操作，ArrayList 较优 ; 对于新增和删除操作 add 和 remove，LinedList 较优 数组和ArrayList有何区别？ 简单理解ArrayList是一种可以自动扩充的数组 数组类型的变量在声明的同时必须进行实例化(至少得初始化数组的大小)，而ArrayList可以只是先声明。 数组对象的初始化必须只定指定大小，且创建后的数组大小是固定的， 而ArrayList的大小可以动态指定，其大小可以在初始化时指定，也可以不指定，也就是说该对象的空间可以任意增加。 数组只能存储同构的对象，而ArrayList可以存储异构的对象。 数组不能够随意添加和删除其中的项，而ArrayList可以在任意位置插入和删除项。 阐述ArrayList、Vector、LinkedList的存储性能和特性。 ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以查询数据快而插入数据慢 Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的历史集合类。 LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 List和Set集合的区别 相同点: List接口和Set接口都是Collection接口的子接口 不同点: 内容是否有序 list是一个有序集合，保持了每个元素的插入顺序,即输出顺序就是输入顺序;而set方法是无序集合，无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序 内容是否重复 list方法可以允许重复的对象 ; 而set方法不允许重复对象 内容是否可null list可以插入多个null元素；而set只允许插入一个null元素 实现类不一样 list方法常用的实现类有ArrayList、LinkedList 和 Vector。其中ArrayList 最为流行，它提供了使用索引的随意访问，而LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适，Vector 表示底层数组，线程安全 Set方法中最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和compareTo() 的定义进行排序的有序容器 List、Set、Map是否继承自Collection接口 List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 List、Set、Map三个接口存取元素时，各有什么特点？ List以特定索引来存取元素，可以有重复元素。 Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。 Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。 Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 遍历Map的方式 keys values entryset ArrayList初始化大小 ，扩容https://www.cnblogs.com/zeroingToOne/p/9522814.html 在JDK1.8中，如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容。 执行add(E e)方法时，先判断ArrayList当前容量是否满足size+1的容量；在判断是否满足size+1的容量时，先判断ArrayList是否为空，若为空，则先初始化ArrayList初始容量为10，再判断初始容量是否满足最低容量要求；若不为空，则直接判断当前容量是否满足最低容量要求；若满足最低容量要求，则直接添加；若不满足，则先扩容，再添加。 ArrayList的最大容量为Integer.MAX_VALUE 说一下HashSet的实现原理？ HashSet中存储内容不可重复且无序，这是因为HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT &#x3D; new Object(); 相关HashSet的操作，基本上都是直接调用底层HashMap的键操作 说一下HashMap底层执行原理HashMap的数据结构首先有一个数组，如果hashMap不进行扩容的话默认是16个长度的数组，如果有hash冲突的话会使用单向链表来解决冲突。 HashMap的存储结构 数组、链表、红黑树（jdk1.8） HashMap中不单单只有数组结构，还有链表、红黑树 HashMap的特点 快速存储（put） 快速查找（时间复杂度O(1)）（get） 可伸缩（数组可以变长；单向链表长度超过8以后可以变成红黑树） Hash算法（HashMap的核心）要了解HashMap底层执行原理必须了解HashMap的核心–hash算法 Hash算法 所有的Java对象（Object.hashCode可以得到一个hash值）都有hashCode(hashMap中使用对象的hashCode 去计算hash值) 具体的hash值的计算方法：（hashCode）^(hashCode&gt;&gt;&gt;16) 这样算可以确保得出的数足够的随机、分散（算数组下标的时候要使用这个hash值，hash值足够的随机、分 散才能保证算出的数组下标的值足够的分散）。 数组下标计算 hashMap底层是数组组成的，数组的默认大小是16，数组的下标是如何计算的呢 使用2.1计算出来的hash值再进行运算计算出来的：hash%16 HashMap中算下标的方式：hash&amp;(16-1) 这样的效率会更高 Hash冲突 原因：不同的对象计算出来数组下标是相同的 单向链表：用于解决Hash冲突的方案，加入一个next记录下一个节点。如果链表非常长的话，效率是非常低的，所以在jdk1.8之后采用了红黑树。 HashMap扩容 HashMap底层是用数组存储数据的，数组存储的话不可能所有的数组存满16以后就变成链表，上面说了链表过长会影响效率，链表只是为了解决冲突准备的。 数组扩容的原理：存储量达到75% （一个数组有16个长度，75%大概就是12个长度）就对数组进行扩容，由于计算机里都是二进制的，所以扩容的标准是最好是变长2倍。75%是基于时间与空间的考虑，如果扩容比例设得很小，例如是50%,那么有一半的空间是浪费的，如果比例设置得很高，例如是90%，当发生hash冲突的时候很难去触发这个条件。 红黑树 红黑树是一种二叉树，有着高效的检索效率 触发条件：在链表的长度大于8的时候，将后面的数据存在红黑树中 。当链表的长度小于6的时候，又会把红黑树转化成链表 Hashtable和ConCurrenthashMap如何实现线程安全？ 在平时开发过程中为了提高性能或业务解耦，会引入多线程，同时在开发web应用的时候，每个web容器在处理用户请求的时候会把用户的请求放到线程里面去执行，这就意味着即使我们不主动的去使用多线程，在实际运行的过程中，我们的程序还是处在一个多线程的环境。如果不做任何的同步控制，我们的代码在多线程环境下是不安全的。 由此及彼，我们看看HashMap的源码，观察一下它是否是线程安全的。 观察我们最常用的get和put方法，它们并没有做同步的控制，所以HashMap在多线程环境中是线程不安全的。 在jdk里，java为我们提供了一个线程安全的Map，就是所谓的HashTable。我们可以观察一下HashTable的 源码，可以发现它的get和put方法都使用了内置锁进行同步控制，HashTable在所有真正和数据交互的方法 上面都加了Synchronized。 那么既然有了一个线程安全的Map，为什么Jdk的并发包中还会有一个ConcurrentHashMap呢？ 从HashTable的源码中我们了解到，不管是读（get）还是写（put）,所有的这些方法都使用了synchronized 关键字修饰，那么在多线程环境下，这样的效率是非常低下的，而ConcurrentHashMap针对这个问题而提 出的。 ConcurrentHashMap是如何在保证性能的情况下来实现线程的安全呢？这就要了解ConcurrentHashMap的 内部实现了 ConcurrentHashMap内部实现 HashMap中都有所谓Hash的说法，那么Hash到底是什么意思呢？ 假如现在有1000个元素，我们要把这1000个元素放到100个桶里面，这个过程就是所谓的Hash过程，我们可以通过取余来决定哪个元素放在哪个桶，如下图我们给100个桶标上下标，从1~100。元素1%100 &#x3D; 1，所以元素1就放在第1个桶。这就是Hash的基本思想。按照上面的取余过程，1和101都会放在第1个桶中，对于HashMap来说，会把1和101以链表的形式挂载第1个桶上，每个桶都有单独的一个锁（ConcurrentHashMap中分段锁的概念）。 分段锁在jdk1.7和jdk1.8的实现有所不同。 在jdk1.7及以前的实现里，把上面说的100个桶分为N个段，每个段里面有自己独立的一个锁。而jdk1.8及以后则是每个桶有自己独立的锁。总的来说就是jdk1.8之后的锁的粒度更细一些。 hashMap 和hashTable的区别相同点： ​ 两者都实现了 Map 接口 不同点: HashMap 允许空键值，Hashtable 键和值不允许空； HashMap 继承自 AbstractMap，Hashtable 继承自 Dictionary 类； HashMap 的方法不是同步的，Hashtable 的方法是同步的。 如何决定使用HashMap还是TreeMap？ HashMap：基于哈希表实现，使用HashMap要求添加的键明确定义了hasCode（）和equals（），为了优化hashMap空间的使用，可以调优初始容量和负载因子。hashmap适用于在map中插入，删除和定位元素。hashmap的结果是没有排序的的。 TreeMap：基于红黑树实现，TreeMap没有调优选项，该树总是处于平衡状态。treemap适用于按自然顺序或自定义顺序遍历键（key），TreeMap实现SortMap接口，能够把保存的额近路根据键排序，默认是按键值的升序排序，也可以指定排序的比较器。 TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。 TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。 Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持） 迭代器iterator是什么？ 为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator). 对 Collection 进行迭代的类，称其为迭代器。还是面向对象的思想，专业对象做专业的事情，迭代器就是专门取出集合元素的对象。但是该对象比较特殊，不能直接创建对象（通过new），该对象是以内部类的形式存在于每个集合类的内部。 如何获取迭代器？Collection接口中定义了获取集合类迭代器的方法（iterator（）），所以所有的Collection体系集合都可以获取自身的迭代器。 Iterable 正是由于每一个容器都有取出元素的功能。这些功能定义都一样，只不过实现的具体方式不同（因为每一个容器的数据结构不一样）所以对共性的取出功能进行了抽取，从而出现了Iterator接口。而每一个容器都在其内部对该接口进行了内部类的实现。也就是将取出方式的细节进行封装。 使用Iterator的简单例子 Iterator怎么使用？有什么特点？ Java中使用Iterator来遍历集合元素，Iterator遍历集合元素有以下几个特点: Iterator遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出ConcurrentModificationEception的异常。 Iterator遍历集合元素的过程中可以通过remove方法来移除集合中的元素。 Iterator必须依附某个Collection对象而存在，Iterator本身不具有装载数据对象的功能。 Iterator.remove方法删除的是上一次Iterator.next()方法返回的对象。 强调以下next（）方法，该方法通过游标指向的形式返回Iterator下一个元素。 Iterator的常用方法: boolean hasNext() ;判断迭代器中是否还有下一个元素，有则返回true Object next(); 返回迭代器中下一个元素 void remove() ; 删除集合里上一个next方法调用的时候返回的对象元素 void forEachRemaining(Consumer action) ;使用Lambdda表达式的形式输出Iterator中所以的元素。注意该方法其实是间接调用next()方法进行遍历，所以再次是next（）方法的时候Iterator中的对象已经被遍历完了。 Iterator和ListIterator之间有什么区别？ Iterator 用来遍历 Set 和 List 集合，而 ListIterator 只能遍历 List； Iterator 只可以向前遍历，而 LIstIterator 可以双向遍历； ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。 Collection和Collections有什么区别？ Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 sort( ) synchronizedCollection( ) synchronizedList( ) synchronizedSet( ) synchronizedMap( ) 53. 怎么确保一个集合不能被修改？我们很容易想到用final关键字进行修饰，我们都知道 final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的。 那么，我们怎么确保一个集合不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。 那我们应该怎么做才能确保集合不被修改呢？我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。 同理：Collections包也提供了对list和set集合的方法。Collections.unmodifiableList(List)Collections.unmodifiableSet(Set) 哪些集合类是线程安全的一、概念： 线程安全：就是当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染的情况。 线程不安全：就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染的情况。 对于线程不安全的问题，一般会使用synchronized关键字加锁同步控制。 线程安全工作原理： jvm中有一个main memory对象，每一个线程也有自己的working memory，一个线程对于一个变量variable进行操作的时候， 都需要在自己的working memory里创建一个copy,操作完之后再写入main memory。 当多个线程操作同一个变量variable，就可能出现不可预知的结果。 而用synchronized的关键是建立一个监控monitor，这个monitor可以是要修改的变量，也可以是其他自己认为合适的对象(方法)，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完加载load到working memory 到 use &amp;&amp; 指派assign 到 存储store 再到 main memory的过程。才会释放它得到的锁。这样就实现了所谓的线程安全。 二、线程安全(Thread-safe)的集合对象： Vector 线程安全： HashTable 线程安全： Concurrenthashmap线程安全(分段锁) 三、非线程安全的集合对象： ArrayList ： LinkedList： HashMap： HashSet： TreeMap： TreeSet：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"java基础","slug":"java基础","date":"2023-09-18T02:36:14.000Z","updated":"2023-09-18T02:38:07.719Z","comments":true,"path":"2023/09/18/java基础/","link":"","permalink":"http://example.com/2023/09/18/java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTML: 表单元素: input, textarea, select, checkbox, radio. 块状元素和行内元素的特点. 图片的属性：src, alt. 链接的属性：href, target. 路径问题：相对路径和绝对路径. 文件上传时form的注意事项：action, method=&quot;post&quot;, enctype=&quot;multipart/form-data&quot;. CSS: 选择器：id, 类, 标签（元素）, 属性, 子孙，子，兄弟，相邻兄弟，伪类，伪元素. display, float, 清除浮动（clear）. position：static, relative, absolute, fixed. 盒子模型（box model）. border-style, border-radius. JavaScript (JS): 弱类型，可以多次声明，赋不同类型的值. var, const, let. break, continue, return. 循环标签 tag: for() &#123; for () &#123; break tag; &#125; &#125;. 输出到控制台：console.log(&quot;aa&quot;);. DOM操作：创建元素，删除节点，事件处理，事件委托. BOM操作：alert(), prompt, confirm, 定时器（setInterval, setTimeout）. 对象创建：let a = &#123;&#125;. 原型链 (prototype). 闭包. ES6的语法，包括箭头函数，模板字符串，解构等. 异步操作：Promise对象，async和await. 模块化：export, import from. 改变上下文（this）：apply, bind, call. 函数中的arguments和callee（不常用）. Java: Java的发展史，JVM的特点，JDK, JRE, JVM之间的关系. 常见运算符：++, --, +=, &amp;, &amp;&amp;, |, ||, ^, instanceof. 基本数据类型和类型转换的示例. switch语句的使用. 数组的创建，扩容，排序和查找. 基本数据类型：byte, short, int, long, float, double, char, boolean. 面向对象编程的三个特点：封装，继承，多态. 访问修饰符：private, default, protected, public. static关键字，final关键字，abstract关键字. 抽象类，接口，内部类的概念. 常用的包装类：Integer, Character. 字符串 (String) 的常见方法和比较. Comparable和Comparator的使用. 替换文件名的示例.","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Java面试题(一)","slug":"Java面试题-一","date":"2023-09-14T11:05:39.000Z","updated":"2023-09-18T04:57:05.264Z","comments":true,"path":"2023/09/14/Java面试题-一/","link":"","permalink":"http://example.com/2023/09/14/Java%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%80/","excerpt":"","text":"String s &#x3D; new String(“xyz”);创建了几个字符串对象？两个对象，一个是静态区的“xyz”，一个是用new创建的对象 String是最基本的数据类型吗？ 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean； 除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。 两个对象值相同（x.equals(y)&#x3D;&#x3D;true），但却可有不同的hashcode，这句话对不对？不对，如果两个对象x和y满足x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的： 如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同； 如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 java中如何实现序列化，有什么意义？ 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。 构造方法有哪些特性？ 特征 没有返回类型 方法名与类名一致 作用 创建对象 实例化一个类，首先调用类的对应的构造方法。当类中没有任意构造方法，JVM会自动创建空的构造方法(空参和空实现)。一但类的有了任意的构造方法，则JVM不会再自动的创建任意形式的构造方法。 初始成员变量 其它 构造方法调用时也要保证参数的类型、个数和顺序要一致 构行方法也可以有方法重载 Anonymous Inner Class(匿名内部类)是否可以继承其他类？是否可以实现接口？可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。 什么是方法的返回值？返回值在类的方法里的作用是什么？方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用：接收出接货，使得它可以作用于其他的操作！ 面向对象三大特征 封装 : 安全性 体现:把属性私有化，通过公共的get&#x2F;set或is&#x2F;set进行公开出去，以后通过方法对属性进行操作。这样做的好处，是在方法中可以对属性的安全性和有效性作出验证。 继承 : 重用性、扩展性 满足is a的关系 用到extends关键字 子类能继承父类中非私有的属性和方法 方法重写 @Override 使用super关键字 this: 代表当前类的对象 super: 代表当前类的父类对象 在java中的类是单继承 任何类的祖类都是Object，可以省略 extends Object 多态性：维护性、扩展性 口诀: 父类引用指向父类实例，只能调用父类的属性和方法 子类引用指向子类实例，可以调用父类中非私有的属性和方法 父类引用指向子类实例，只能调用父类的属性和方法，但是方法被子类重写，以子类的实现为准。 开闭原则 对扩展开放 对修改关闭 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？帮助子类做初始化工作 switch是否能作用在byte上，是否能作用在long上，是否能作用在String上 在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。 从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型 从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 用最有效率的方法算出2乘以8等于几？12 &lt;&lt; 3 因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是 2 &lt;&lt; 3。 访问修改符的理解 java中共有四个修饰符 private 同一个类 default 同一个包 protected 同一个包+不同包子类 public 所有包 注:访问修饰符最低原则，为了安全性 类有两个 public 所有类 default 同一个包 方法和属性有四个 private 同一个类 default 同一个包 protected 同一个包+不同包子类 public 所有包 Object类中常用的方法 Object clone() : 克隆。protected它r指的是在同一个包，或不同包子类中能访问 boolean equals(Object) : 地址相等 void finalize() : 垃圾回收器调用此方法来回收对象所占空间。protected Class getClass() ：得到Class对象 int hasCode() :对象的哈希码。同个对象的哈唏码一致。 String toString() ：把对象用字符串输。一般我们自定义的类都会重写此方法。 void wait() ：线程所用方法，后面讲 void notify() ：线程所用方法，后面讲 void notifyAll() ：线程所用方法，后面讲 方法重写的特性 父子类 方法名相同，参数列表相同 子类的访问修饰符&gt;&#x3D;父类 子类返回类型&lt;&#x3D;父类（&lt;&#x3D;指是父子类） 子类抛的异常&lt;&#x3D;父类（&lt;&#x3D;指是父子类） 方法重载的特性 在同一个类下 方法名一样 参数的类型、个数和‘顺序’至少有一个不一样 重载和重写的区别 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 值传递与引用区别 值传递: 参数的类型为值类型时，则为值传递。值传递，传递的是值复本。 引用传递: 参数的类型为引用类型时，则为引用传递。引用传递，传递的是引用的复本。 两者区别: 值传递，在方法里改变值，之前的值不会改变 引用传递，在方法里改变值，之前的值会发生改变。但String、StringBufferer、StringBuilder和枚举除外。 String、StringBuffer和StringBuilder区别String 是不能改变自身， StringBuffer和StringBuilder是改变自身 StringBuffer是线程安全的，相对而言性能较差，StringBuilder是线和不安全的，相对而言性能较好 成员变量与局部变量的区别有哪些？ 从语法形式上看: 成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数； 成员变量可以被 public,protected,default,private, static和final 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），而局部变量则不会自动赋值。 抽象类与接口有什么区别 相同点: 都可以有静态常量 都可以有抽象方法 都不能被实例化 区别点: 抽象类中有属性、实现的方法、抽象方法等，但接口中只公共静态常量、公共抽象方法 抽象类中的访问修饰符有四种，但接口中只有public访问修饰符 子类单继承抽象类，子类多实现接口，接口多继承接口 抽象类中包含构造方法，接口没有构造方法 使用时机 当所有方法都不知道如何实现时，用接口。一般用标准的制订（方法功能描述） 当有些方法知道如何实现，有些不知道时，使用抽象。 示例 数据访问实现 使用接口制订数据访问方法的标签 使用抽象类 实现接口，实现其中公共代码。（已知如何实现），未知实现（不清楚具体数据）写成抽象方法。 使用MySQL数据类 继承 抽象类，实现抽象方法。（已知用MySQL数据库实例 ） 使用Oralce数据类 继承 抽象类，实现抽象方法。（已知用Oralce数据库实例 ） 队列和栈是什么？有什么区别？ 队列（Queue）：是限定只能在表的一端进行插入和另一端删除操作的线性表 栈（Stack）：是限定之能在表的一端进行插入和删除操作的线性表 队列和栈的规则 ： 队列：先进先出 栈：先进后出 队列和栈的遍历数据速度 ： 队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快 栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，遍历数据时需要微数据开辟临时空间，保持数据在遍历前的一致性 Java有没有goto？goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 是否可以从一个static方法内部发出对非static方法的调用 ？不能直接调用 ，但可以通类的对象进行调用 类中的静态方法和静态变量，也称类方法和类变量 静态方法中只能直接调用静态方法和静态变量，如果要调用非静态的内容，必须通过实例.方法()或实例.变量的方式 去进行调用 java中的final关键字有哪些用法？修饰类：表示该类不能被继承； 修饰方法：表示方法不能被重写； 修饰变量：表示变量只能一次赋值以后值不能被修改（常量） final，finally和finalize的区别？ final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。 finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句： 1final StringBuffer a=new StringBuffer(&#x27;immutable&#x27;); 执行如下语句将报告编译期错误： 1a=new StringBuffer(&#x27;&#x27;); 但是，执行如下语句则可以通过编译： 1a.append(&#x27; broken!&#x27;); 抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 异常该如何处理 try : 存放可能出现异常的代码块，一但在此代码块中有了异常，则立即到跳转到catch中，并把对应异常对象传递给Catch中的形参，如果赋值不对应，则仍然处理不了 不能单独使用 catch ：捕获处理 不能单独使用 与try匹配catch可以有多个，分别捕获处理不同的异常，范围大异常一定要后面 当所有catch中的类型都不能匹配时，则相当于catch捕获处理不，仍然终止程序 finally ：最终地无论如何也要执行的代码，一般用于资源的释放。比如，文件的关闭，数据库连接关闭 不能单独使用 try-catch try-catch-catch try-finally 这种情况要注意，如果没catch，则在try中有了异常，相当于没有处理，程序程序会终止，只不过会执行finally中的语句，一般不省略catch throw : 抛的是一个对象 ，放置在方法里边 一般有了throw，要加上throws throw是抛给上一级处理，上一级指的是谁调用谁处理 上一级可以选择try-catch掉，也可以选择继续抛，如果到了main仍然继续抛出，则相当于抛了JVM，且等于没有处理异常，程序终止，所以一般到main必须处理掉。 throws : 抛的是异常类型，放置方法后面，可以有多个 异常分类和常见异常 运行时异常 ： 都是RuntimeException的子类 ArithmeticException ArrayIndexOutofBoundsException NullPointerException 非运行时异常（编译时异常）: 都是Exception的子类 ParseException IOException ClassNotFoundException 运行异常与非运行时异常有何异同？ 运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。 受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。 错误与异常的区别 Object Throwable Error Exception Error类: 一般指的是硬件问题，跟程序员无关，比如说硬盘空间不足，内容不够 Exception类: 一般指提程序员不小心造成的，有可能在某些时候出现（偶现），或都每次都出现（必须），这些异常本可以避免的。例如：算术异常、空指针异常和下标越界异常等 注: 我们只关心异常，所以以后我提到异常也好，错误也罢，全指异常。 Exception是所有异常类的祖类 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？创建类的对象+初始化成员变量 可以执行，因为一个类即使没有声明构造方法 JVM会自动创建的空参参数的构造方法。 静态方法和实例方法有何不同 在外部调用静态方法时，可以使用’类名.方法名’的方式，也可以使用’对象名.方法名’的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问直接实例成员变量和和实例方法；实例方法可以直接文章实例方法和实例变量，也可以访问静态方法 请手写一下冒泡排序【插入】，接着再用递归的方式写一遍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) &#123;// 12,45,9,67,455,用冒泡排序实现升序排列。 int[] arr = &#123; 12, 45, 9, 67, 455 &#125;; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println(&quot;排序后：&quot;); for (int i = 0; i &lt; arr.length; i++) System.out.print(arr[i] + &quot;\\t&quot;); //创建一个数组用于排序 int[]arr2=&#123;1,4,3,2,6,12,10&#125;; //调用递归的冒泡 arr2=recursiveBubble(arr2,arr2.length); for(int i=0;i&lt;arr2.length;i++)&#123; System.out.print(arr2[i]); &#125; &#125;//冒泡排序之递归方法public static int[] recursiveBubble(int[] arr2,int e)&#123; if(e==0)&#123; return arr2; &#125; else&#123; for(int i=0;i&lt;e-1;i++)&#123; int temp=0; if(arr2[i]&gt;arr2[i+1])&#123; temp=arr2[i]; arr2[i]=arr2[i+1]; arr2[i+1]=temp; &#125; &#125; e--; //System.out.println(e); recursiveBubble(arr2,e); &#125; return arr2;&#125; 静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同?Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。 Math.round(11.5)等于多少？Math.round(-11.5)等于多少？Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。 阐述静态变量和实例变量的区别。 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝； 实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 请讲讲冒泡排序、快速排序、插入排序 这两种排序的原理冒泡排序原理：1，比较相邻的元素。如果第一个比第二个大，就交换他们两个。2，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3，针对所有的元素重复以上的步骤，除了最后一个。4，持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 快速排序原理：1，先定义两个指针，一个在最前面，一个在最后面，第一次要对数组进行划分，先找出一个中间数，2，一般默认把第一个数作为中间数，然后从后往前找比中间数小的，把他放在前一个指针的位置，3，在从前往后找比中间数大的，找到后把它放在第二个指针的位置，直到前面和后面的指针指向同一个位置，4，我们就把中间值放在这里即可，这样根据中间数，把整个需要排序的数组分为两部分，5，前一部分都小于中间数，后一部分都大于中间数，此时这两部分的数还是无序的，最后递归调用排序方法，对两部分分别进行排序即可。 插入排序原理： 说说你对多态的理解 现象： 调用同一个类型对象的同一个方法，会出现不同的结果 实现多态的三个条件： 1）要有继承； 2）要有方法重写； 3）要有父类指针（引用）指向子类对象。 多态的原理： 动态连编，根据实际对象的类型来判断重写方法的调用。多态的原理：动态连编，根据实际对象的类型来判断重写方法的调用 写clone方法时，通常都有一行代码，是什么？clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。 Java中是如何支持正则表达式操作的？Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。 Java序列化中如果有写字段不想进行序列化，怎么办？对于不想进行序列化的变量，使用transient关键字修饰。transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。 构造器（constructor）是否可被重写（override）构造器不能被继承，因此不能被重写，但可以被重载。 65. int和Integer的区别？ java是一个的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 自动装箱与拆箱装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； &#x3D;&#x3D;与equals的区别？ &#x3D;&#x3D; 值类型：判断是值是否相等 引用类型：判断是引用地址是否相等 equals() 是Object中的方法，表示地址是否相等 但String 中的 equals 方法是被重写过的，它表示的是值相等 构造方法调用顺序实例化一个子类首先会调用父类中的空的构造方法，再调用子类中对应的构造方法 除非在子类构造方法的第一行有super(xxx)，则调用父类对应构造方法。 一般在子类构造方法的第一行即为super()，默认是可以省略的，所以推荐在父类一般保留一个空的构造方法 java和 javaX有什么区别刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。所以，实际上java和javax没有区别。这都是一个名字 &amp;和&amp;&amp;的区别 &amp;按位与；&amp;&amp;逻辑与。 &amp;非短信与; &amp;&amp;运算符是短路与运算 逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。 &amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;， 例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(‘’)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。 注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 说一下类加载的执行过程java程序在执行过程中，类，对象以及它们成员加载、初始化的顺序如下： 首先加载父类。 对静态成员进行加载，主要包括静态成员变量的初始化，静态语句块的执行，在加载时按代码的先后顺序进行。 加载非静态的成员，主要包括非静态成员变量的初始化，非静态语句块的执行，在加载时按代码的先后顺序进行。 最后执行构造器，构造器执行完毕，对象生成。 java中实现多态的机制是什么靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 是否可以继承string类String 类是final类，不可以被继承。 数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？ 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； 一种方法是将基本数据类型与空字符串（’’）连接（+）即可获得其所对应的字符串； 另一种方法是调用String 类中的valueOf()方法返回相应字符串 接口是否可以继承（extends）接口，抽象类是否可以实现(implements)接口,抽象类是否可以继承具体类(concrete class)? 接口可以继承接口，而且支持多重继承。 抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员 简述一下你了解的设计模式？ 所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式， 包括： Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式），Chain Of Responsibility（责任链模式）。面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I&#x2F;O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 什么是单例模式？实现步骤？单例模式分为： 懒汉式：用的时候，才去创建对象（不会出现线程问题的单例模式） 饿汉式：类一加载就创建对象（可能会线程问题的单例模式） 饿汉代码 外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。 123456789 public class SingletonClass &#123; private static SingletonClass instance = new SingletonClass(); public static SingletonClass getInstance() &#123; return instance; &#125; private SingletonClass() &#123; &#125; &#125; 懒汉代码 上面的代码虽然简单，但无论这个类是否被使用，都会创建一个instance对象 123456789101112public class SingletonClass &#123; private static SingletonClass instance = null; public static SingletonClass getInstance() &#123; if(instance == null) &#123; instance = new SingletonClass(); &#125; return instance; &#125; private SingletonClass() &#123; &#125; &#125; 上述代码会有线程安全的问题 12345678910111213141516public class SingletonClass &#123; private static SingletonClass instance = null; public synchronized static SingletonClass getInstance() &#123; if(instance == null) &#123; instance = new SingletonClass(); &#125; return instance; &#125; private SingletonClass() &#123; &#125; &#125; 性能调优一下,double-check 123456789101112131415public class SingletonClass &#123; private static SingletonClass instance = null; public static SingletonClass getInstance() &#123; if (instance == null) &#123; synchronized (SingletonClass.class) &#123; if (instance == null) &#123; instance = new SingletonClass(); &#125; &#125; &#125; return instance; &#125; private SingletonClass() &#123; &#125; &#125; 创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JMM规范并没有规定。 线程1开始创建SingletonClass的实例，此时线程B调用了getInstance()方法，首先判断instance是否为null。按照我们上面所说的内存模型，1已经把instance指向了那块内存，只是还没有调用构造方法，因此2检测到instance不为null，于是直接把instance返回了——问题出现了，尽管instance不为null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还是毛坯房 只要我们简单的把instance加上volatile关键字就可以了。volatile在Java并发编程中常用于保持内存可见性和防止指令重排序 123456789101112131415public class SingletonClass &#123; private volatile static SingletonClass instance = null; public static SingletonClass getInstance() &#123; if (instance == null) &#123; synchronized (SingletonClass.class) &#123; if(instance == null) &#123; instance = new SingletonClass(); &#125; &#125; &#125; return instance; &#125; private SingletonClass() &#123; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"}]},{"title":"区块链基础知识","slug":"区块链基础知识","date":"2023-09-14T03:38:17.000Z","updated":"2023-09-14T03:40:11.743Z","comments":true,"path":"2023/09/14/区块链基础知识/","link":"","permalink":"http://example.com/2023/09/14/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"区块链与隐私保护技术：构建安全可信的去中心化世界随着数字化时代的不断发展，个人数据的保护和隐私成为了一个极其重要的议题。同时，区块链技术的兴起也引发了人们对隐私保护的新思考。本文将探讨区块链与隐私保护的关系，以及当前正在发展的技术和方法，以确保在去中心化世界中维护个人数据的安全和隐私。 区块链基础知识在深入讨论区块链与隐私保护的关系之前，我们需要先了解一些区块链的基础知识。 区块链是什么？ 区块链是一种去中心化的分布式账本技术，最初用于支持加密货币比特币。它是一个由多个区块组成的链式结构，每个区块包含一组交易记录。这些区块按照时间顺序连接在一起，并且通过密码学技术保护其完整性和安全性。 区块链的关键特性 区块链的关键特性包括： 去中心化：没有中央权威机构控制区块链，而是由网络中的多个节点共同维护和验证交易。 不可篡改性：一旦数据被添加到区块链，几乎不可能修改或删除。 透明性：区块链上的所有交易都是公开可见的，任何人都可以查看。 安全性：区块链使用密码学技术来保护数据的机密性和完整性。 区块链与隐私保护的挑战 尽管区块链具有许多优点，但它也带来了一些隐私保护的挑战。其中一些挑战包括： 交易透明性：区块链上的所有交易都是公开的，这意味着交易的参与者和交易金额都可以被追踪。 无法删除数据：一旦数据上链，就很难删除或修改，这可能会导致个人敏感信息的永久性泄露。 链外数据：虽然区块链上的交易数据是公开的，但与之相关的链外数据（如身份信息）可能不受同样的保护，容易被恶意利用。 隐私保护技术为了解决区块链上的隐私保护问题，许多技术和方法已经被提出和发展。以下是一些常见的隐私保护技术： 零知识证明（Zero-Knowledge Proofs） 零知识证明是一种密码学技术，允许一个人向另一方证明他们知道某些信息，而不必透露这些信息的内容。这在区块链上的隐私保护中非常有用。通过零知识证明，用户可以验证自己的交易有效性，而无需公开其交易详细信息。zk-SNARKs（零知识可验证的非交互式参数）是一种常见的零知识证明机制，用于保护以太坊等区块链的隐私。 链上混币技术 链上混币技术允许用户将他们的加密货币与其他用户的加密货币混合在一起，以增加交易的隐私性。这使得很难追踪特定的加密货币流动路径。CoinJoin和Confidential Transactions是两个常见的链上混币技术。 侧链和二层解决方案 侧链和二层解决方案是构建在主区块链之上的附加层，它们可以提供更高级的隐私保护。例如，Lightning Network是比特币的二层解决方案，允许快速且低成本的交易，同时减少了主区块链上的交易记录。 匿名性币种 一些加密货币专注于提供更强的隐私保护。例如，Monero和Zcash都使用不同的隐私技术来确保交易的完全匿名性。这些币种的交易数据被设计成不可追踪和不可链接。 多方计算（Multi-Party Computation） 多方计算是一种协议，允许多个参与者在不透露私有数据的情况下进行计算。这可以用于在区块链上进行私有智能合约的执行，而不泄露相关数据。 去中心化身份验证 去中心化身份验证技术允许用户在区块链上验证其身份，同时控制其个人数据。用户可以选择性地透露身份信息，以确保他们的隐私得到保护。 这些技术共同构建了区块链生态系统，使其成为一个安全、可信、去中心化的基础设施，可用于各种应用程序，从加密货币到供应链管理和智能合约。区块链技术的不断发展和创新将继续推动数字经济的进步。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Excel导入导出","slug":"Excel导入导出","date":"2023-09-14T03:30:44.000Z","updated":"2023-09-14T03:33:10.361Z","comments":true,"path":"2023/09/14/Excel导入导出/","link":"","permalink":"http://example.com/2023/09/14/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"Excel导入导出1. 简介1.1 实现方式 Apache POI POI（Poor Obfuscation Implementation）是Apache提供的操作ms office文档的API，主要针对excel进行操作。 官网 https://poi.apache.org Apache维护 EasyPOI easypoi功能如同名字easy，主打的功能就是容易，让一个没见接触过poi的人员就可以方便的写出Excel导出、Excel导入。 通过简单的注解和模板语言(熟悉的表达式语法)，完成以前复杂的写法。 官网 http://doc.wupaas.com/docs/easypoi 个人维护 EasyExcel EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。 他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。 官网 https://easyexcel.opensource.alibaba.com 阿里维护 1.2 Excel简介excel的基础元素： 工作簿 workbook 就是一个文件 工作表 sheet 属于工作簿 行 row 属于工作表 单元格 cell 属于行，如C2，表示第二行第三列 2. 用法2.1 Apache POI步骤： 添加依赖 123456&lt;!--poi--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;5.2.3&lt;/version&gt;&lt;/dependency&gt; 基本用法 12345678910111213141516171819202122232425262728293031@Testpublic void write() throws Exception &#123; // 1、创建工作簿 Workbook workbook = new HSSFWorkbook(); // 2、创建工作表 Sheet sheet = workbook.createSheet(&quot;wanho&quot;);// 指定工作表名 // 3、创建行 Row row = sheet.createRow(2); // 创建第3行，索引从0开始 // 4、创建单元格 Cell cell = row.createCell(2); // 创建第3行第3列 cell.setCellValue(&quot;南京万和&quot;); // 设置单元格内容 // 5.输出到硬盘 workbook.write(new FileOutputStream(&quot;/Users/txy/Desktop/test.xls&quot;)); System.out.println(&quot;写入成功！&quot;); workbook.close();&#125;@Testpublic void read() throws Exception &#123; // 1、读取工作簿 Workbook workbook = new HSSFWorkbook(new FileInputStream(&quot;/Users/txy/Desktop/test.xls&quot;)); // 2、读取工作表 Sheet sheet = workbook.getSheet(&quot;wanho&quot;); // 根据名称读取工作表 // Sheet sheet = workbook.getSheetAt(0); //根据索引读取工作表，索引从0开始 // 3、读取行 Row row = sheet.getRow(2); // 读取第3行 // 4、读取单元格 Cell cell = row.getCell(2); // 读取第3行第3列 System.out.println(&quot;第3行第3列内容为：&quot; + cell.getStringCellValue()); workbook.close();&#125; 2.2 EasyPOI步骤： 添加依赖 123456&lt;!--easypoi--&gt;&lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt; 基本用法 @Excel 标注在属性上，对Excel列进行描述 工具类： ExcelExportUtil 导出Excel ExcelImportUtil 导入Excel 2.3 EasyExcel步骤： 添加依赖 123456&lt;!--easyexcel--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt; 基本用法 常用注解 @ExcelProperty 标注在属性上，对Excel列进行描述 @ColumnWidth 标注在类和属性上，设置列宽 @ContentStyle 标注在类上，设置内容样式 @HeadFontStyle 标注在类上，设置表头样式 @DateTimeFormat 标注在属性上，设置日期的格式 ….. 工具类： EasyExcel.write() 导出Excel EasyExcel.read() 导入Excel","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"SQL语句中不同类型的join的区别","slug":"SQL语句中不同类型的join的区别","date":"2023-09-03T15:34:05.000Z","updated":"2023-09-03T15:35:49.225Z","comments":true,"path":"2023/09/03/SQL语句中不同类型的join的区别/","link":"","permalink":"http://example.com/2023/09/03/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84join%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"sql之left join、right join、inner join的区别left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录inner join(等值连接) 只返回两个表中联结字段相等的行 举例如下：表A记录如下：aID aNum1 a200501112 a200501123 a200501134 a200501145 a20050115 表B记录如下:bID bName1 20060324012 20060324023 20060324034 20060324048 2006032408 1.left joinsql语句如下:select * from Aleft join Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 20060324045 a20050115 NULL NULL （所影响的行数为 5 行）结果说明:left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID &#x3D; B.bID).B表记录不足的地方均为NULL.2.right joinsql语句如下:select * from Aright join Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404NULL NULL 8 2006032408 （所影响的行数为 5 行）结果说明:仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.3.inner joinsql语句如下:select * from Ainnerjoin Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404 结果说明: 很明显,这里只显示出了 A.aID &#x3D; B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Spring常用注解","slug":"Spring常用注解","date":"2023-08-29T00:52:13.000Z","updated":"2023-08-29T01:08:47.798Z","comments":true,"path":"2023/08/29/Spring常用注解/","link":"","permalink":"http://example.com/2023/08/29/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"@Param@Param()注解，标注在参数前，为参数指定占位符名称 1public User selectByUsernameAndPassword(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); @Component 及@Repository、@Service、@Controller@Component 定义组件Bean，添加到IoC容器中，不区分组件类型区分组件类型的注解：@Repository 表示Dao组件@Service 表示Service组件@Controller 表示Controller组件 @RequestMapping：@RequestMapping： @ResponseBody@ResponseBody：将方法返回值写到响应体中，一般用来处理Ajax请求，返回JSON数据也可以使用@RestController，相当于@Controller+@ResponseBody注意：ResponseBody与RequestBody区别 @RequiredArgsConstructor：该注解作用于类上 标记为final的对象,会自动进行注入 使用lombok的 @NonNull 注解标记的对象,会自动进行注入 @Resource：@Resource和@Autowired注解都是用来实现依赖注入的。只是@AutoWried按by type自动注入，而@Resource默认按byName自动注入。 @Resource有两个重要属性，分别是name和type @Json衍生@JsonFormat指定序列化和反序列化时的格式，一般用于指定日期、时间和数字的格式@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”,timezone &#x3D; “GMT+8”)，设置响应时的日期格式 @JsonProperty指定序列化和反序列化时的名称 @JsonAlias指定反序列化时的备用别名 @JsonIgnore指定序列化和反序列化时忽略属性 参数来源注解@RequestParam表示参数来源于请求参数，默认为所有参数添加该注解，参数值来源于同名称的请求参数 @PathVariable表示参数来源于URL（URL就是请求路径） @PathVariable：spring3.0的一个新功能：接收请求路径中占位符的值 @PathVariable(“xxx”) 通过 @PathVariable 可以将URL中占位符参数{xxx}绑定到处理器类的方法形参中@PathVariable(“xxx“)@RequestMapping(value&#x3D;”user&#x2F;{id}&#x2F;{name}”)请求路径：http://localhost:8080/hello/show5/1/james @RequestHeader表示参数来源于请求头 @CookieValue表示参数来源于Cookie @RequestBody表示参数来源于请求体，用来接收前端传递给后端的 json 格式的数据 @RequestMapping及其衍生变体@RequestMapping表示共享映射,用于将任意HTTP 请求映射到控制器方法上。如果没有指定请求方式，将接收GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT所有的HTTP请求方式。@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping 都是HTTP方法特有的快捷方式@RequestMapping的变体，分别对应具体的HTTP请求方式的映射注解。 @Transactional@Transactional也可以配置在类上，如果方法上没有配置@Transactional，则使用类上的事务配置 使用@Transactional 注解管理事务的实现步骤分为两步。 第一步，在 xml 配置文件中添加如清单 1 的事务配置信息。除了用配置文件的方式，@EnableTransactionManagement 注解也可以启用事务管理功能。这里以简单的 DataSourceTransactionManager 为例。 第二步，将@Transactional 注解添加到合适的方法上，并设置合适的属性信息。 SpringBoot@SpringBootApplication标注在类上，表示这是一个SpringBoot应用，通过运行该类的main方法来启动SpringBoot应用 @SpringBootConfiguration标注在类上，表示这个类是SpringBoot的配置类 层级关系：@SpringBootConfiguration——&gt;@Configuration——&gt;@Component @Configuration标注在类上，表示这个类是Spring的配置类，相当于是一个xml配置文件 @EnableAutoConfiguration开启自动配置功能，SpringBoot会自动完成许多配置，简化了以前繁琐的配置 @ComponentScan标注在类上，指定要扫描的包，默认只扫描主程序类所在的包及其子包 可以使用@ComponentScan手动指定要扫描的包 @MapperScan：指定Dao接口所在的包API：@Api标注在类上，对类进行说明 @ApiOperation标注在方法上，对方法进行说明 @ApiParam标注在参数上，对方法的参数进行说明 @ApiModel标注在模型Model上，对模型进行说明 @ApiModelProperty标注在属性上，对模型的属性进行说明 @ApiIgnore标注在类或方法上，表示忽略这个类或方法","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Shiro学习","slug":"Shiro学习","date":"2023-08-24T03:15:48.000Z","updated":"2023-08-25T08:34:55.874Z","comments":true,"path":"2023/08/24/Shiro学习/","link":"","permalink":"http://example.com/2023/08/24/Shiro%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Shiro简介1. Shiro是什么？Apache Shiro是一个强大且易用的开源Java安全框架，执行身份认证、授权、密码学和会话管理等 Spring Security也是一个开源的权限管理框架，Spring Security 和 Shiro 的比较如下： Spring Security 是一个重量级的安全管理框架； Shiro 则是一个轻量级的安全管理框架 Spring Security 概念复杂，配置繁琐； Shiro 概念简单、配置简单 Spring Security 功能强大； Shiro 功能简单，但在一般的 SSM 项目中也够用了 Spring Security 依赖于Spring运行； Shiro则相对独立 Spring Security 一般与 Spring Boot&#x2F;Spring Cloud 项目组合使用； Shiro 一般与 SSM 项目结合使用 虽然在 Spring Boot 项目中一般使用 Spring Security ，但也可以使用 Shiro 2. 基本功能​ 身份认证、授权、加密、会话管理 ​ Web支持、缓存、多线程、测试、允许一个用户假装为另一个用户的身份进行访问、记住我 ​ ​ 3. 单词​ authentication [ɔ:ˌθentɪ’keɪʃn] 认证、身份验证 ​ authorization [ˌɔ:θəraɪˈzeɪʃn] 授权 ​ cryptography [krɪpˈtɒgrəfi] 密码学 ​ subject [ˈsʌbdʒɪkt] 主题、学科、主体 ​ token [ˈtəʊkən] 令牌 ​ strategy [ˈstrætədʒi] 策略 ​ realm 领域、范围 ​ principal [ˈprɪnsəpl] 当事人、用户 ​ credentials [krəˈdenʃlz] 凭证 二、身份认证1. 认证流程图​ 2. 执行过程分为五步： Subject 用户主体：请求的发起者，即访问应用的用户 Security Manager 安全管理器：Shiro的核心，用来分发请求，对Shiro中的其他对象进行管理 Authenticator 认证器：用来进行认证操作 Authentication Strategy 认证策略 ：对于多个realm，可以对认证realm的个数进行配置 三种认证策略：AtLeastOneSuccessfulStrategy、FirstSuccessfulStrategy、AllSuccessfulStrategy Realm 安全数据源：用来进行数据匹配的，可以通过多种数据源进行匹配认证，如文件、数据库、QQ、微信、手机号等 3. url过滤场景：有些url的访问需要登录才能访问，如后台管理界面，未登录时不允许访问，自动跳转到登录页面 解决：使用Shiro过滤器，配置url过滤规则 常用的过滤规则： anon 表示url不需要验证 authc 表示url需要登录验证，如果未登录，默认跳转到&#x2F;login.jsp，参考FormAuthenticationFilter类 roles 表示url需要角色验证 perms 表示url需要权限验证 ​ 注：默认所有url都不需要验证，相当于是anon 三、SpringBoot整合Shiro 1. 搭建项目环境步骤： 创建一个springboot工程，选择以下模块：Web、Lombok、DevTools 添加依赖 12345&lt;!--jsp--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml 12345678910server: port: 8080 servlet: context-path: /shirospring: mvc: view: prefix: / suffix: .jsp 创建前端页面 ​ 在webapp文件夹中创建index.jsp和login.jsp index.jsp 12345678910111213141516171819202122&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--受限资源--%&gt; &lt;h1&gt;系统主页&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;用户管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;订单管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;物流管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; login.jsp 12345678910111213141516171819&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;登录界面&lt;/h1&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 配置SpringBoot，兼容JSP 测试 访问 http://localhost:8080/shiro/login.jsp 、 http://localhost:8080/shiro/index.jsp 2. 整合Shiro步骤： 添加依赖 123456&lt;!--shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt; 自定义Realm 123456789101112131415161718192021/** * 自定义Realm，继承AuthorizingRealm */public class ShiroRealm extends AuthorizingRealm &#123; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; return null; &#125;&#125; 创建配置类ShiroConfig 123456789101112131415161718192021222324252627282930313233343536373839404142@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/index.jsp&quot;, &quot;authc&quot;);// 表示这个资源需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); return realm; &#125;&#125; 测试 ​ 访问 http://localhost:8080/shiro/index.jsp，发现会自动跳转到login.jsp，因为这个资源需要登录认证 3. 认证和退出步骤： 在index.jsp添加欢迎信息和退出 12欢迎您：&lt;shiro:principal/&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;退出登录&lt;/a&gt; 编写UserController 1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/login&quot;) public String login(String username, String password) &#123; // 获取主体对象 Subject subject = SecurityUtils.getSubject(); try &#123; subject.login(new UsernamePasswordToken(username,password)); return &quot;index&quot;; &#125; catch (UnknownAccountException e) &#123; e.printStackTrace(); System.out.println(&quot;用户不存在！&quot;); &#125; catch (IncorrectCredentialsException e) &#123; e.printStackTrace(); System.out.println(&quot;密码错误！&quot;); &#125; catch (AuthenticationException e)&#123; e.printStackTrace(); System.out.println(&quot;认证失败！&quot;); &#125; return &quot;redirect:/login.jsp&quot;; &#125; @RequestMapping(&quot;logout&quot;) public String logout() &#123; Subject subject = SecurityUtils.getSubject(); subject.logout(); return &quot;redirect:/login.jsp&quot;; &#125;&#125; 修改自定义的ShiroRealm 123456789101112131415161718192021222324public class ShiroRealm extends AuthorizingRealm &#123; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 if (!&quot;admin&quot;.equals(username)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，然后交由凭证匹配器（CredentialsMatcher）进行凭证的判断，默认是对密码进行判断 return new SimpleAuthenticationInfo(username,&quot;123&quot;,this.getName()); // 参数：用户信息、密码、realm名称 &#125;&#125; 修改配置类ShiroConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/user/login&quot;,&quot;anon&quot;);// 表示这个为公共资源，一定是在受限资源上面 map.put(&quot;/**&quot;,&quot;authc&quot;);//表示这个为受限资源，需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); return realm; &#125;&#125; 测试 登录和退出的功能正常 未登录时不能访问index.jsp 4. 加密的认证通常需要对密码进行加密，常用的散列算法有md5、sha等，都是非对称的算法 对于普通的散列加密，如果知道加密后的值，可以通过穷举算法，暴力破解出对应的明文 所以建议进行散列加密时可以添加salt（盐），相当于对原始密码+盐进行散列加密，盐值一般放在数据库中 同时可以配置散列次数，次数一般放在配置文件中 步骤： 创建数据库 12345678910drop database if exists shiro;create database shiro charset utf8;use shiro; create table t_user ( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(40) comment &#x27;用户名&#x27;, password varchar(40) comment &#x27;密码&#x27;, salt varchar(255) comment &#x27;盐值&#x27;) engine=innodb default charset=utf8 comment &#x27;用户表&#x27;; 添加依赖 1234567891011121314151617&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920server: port: 8080 servlet: context-path: /shirospring: mvc: view: prefix: / suffix: .jsp datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/shiro?useUnicode=true&amp;characterEncoding=utf8 username: root password: rootmybatis: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml 创建注册页面register.jsp 12345678910111213141516171819&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;注册界面&lt;/h1&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/register&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;立即注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建Entity、Mapper、Service、Controller 修改自定义的ShiroRealm 123456789101112131415161718192021222324252627282930313233public class ShiroRealm extends AuthorizingRealm &#123; @Autowired private UserService userService; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 User user = userService.findByUsername(username); if (ObjectUtils.isEmpty(user)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，交由AuthenticatingRealm进行密码匹配（使用密码匹配器CredentialsMatcher） return new SimpleAuthenticationInfo( user.getUsername(), // 用户信息 user.getPassword(), // 密码 ByteSource.Util.bytes(user.getSalt()), // salt盐值 this.getName()); //realm名称 &#125;&#125; 修改配置类ShiroConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/user/login&quot;,&quot;anon&quot;);// 表示这个为公共资源，一定是在受限资源上面 map.put(&quot;/user/register&quot;,&quot;anon&quot;); map.put(&quot;/register.jsp&quot;,&quot;anon&quot;); map.put(&quot;/**&quot;,&quot;authc&quot;);//表示这个为受限资源，需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); // 创建密码匹配器，支持散列算法 HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(); credentialsMatcher.setHashAlgorithmName(&quot;md5&quot;); // 设置加密算法 credentialsMatcher.setHashIterations(1024); // 设置散列次数 // 设置密码匹配器 realm.setCredentialsMatcher(credentialsMatcher); return realm; &#125;&#125; 测试 ​ 注册和登录的功能正常 五、授权1. 简介授权也称为访问控制，控制用户对资源的访问 权限：增删改查 CRUD 角色：权限的集合，如系统管理员、老师、学生 2. 授权流程图​ 执行过程，分为4步： Subject 发送请求，对角色和权限进行判断 hasRole()、isPermitted() SecurityManager 接收Subject的请求 Authorizer 授权器 Realm 查询角色和权限信息 3. 基本用法步骤： 创建数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455drop database if exists shiro;create database shiro charset utf8;use shiro; create table t_user ( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(40) comment &#x27;用户名&#x27;, password varchar(40) comment &#x27;密码&#x27;, salt varchar(255) comment &#x27;盐值&#x27;) engine=innodb default charset=utf8 comment &#x27;用户表&#x27;;create table t_role ( id int not null primary key auto_increment, name varchar(60) default null) engine=innodb default charset=utf8 comment &#x27;角色表&#x27;;create table t_perms ( id int not null primary key auto_increment, name varchar(80) default null, url varchar(255) default null) engine=innodb default charset=utf8 comment &#x27;权限表&#x27;;create table t_user_role ( id int not null primary key auto_increment, userid int default null, roleid int default null) engine=innodb default charset=utf8 comment &#x27;用户角色表&#x27;;create table t_role_perms ( id int not null primary key auto_increment, roleid int default null, permsid int default null) engine=innodb default charset=utf8 comment &#x27;角色权限表&#x27;;insert into t_user values (null, &#x27;aaa&#x27;, &#x27;37c80a50a975580fb2fb287bee20a04a&#x27;, &#x27;K2*LWFB#&#x27;); -- 密码为123insert into t_user values (null, &#x27;bbb&#x27;, &#x27;93a2dc457a2f9c50fa0a9f2b9de9f456&#x27;, &#x27;DwOkv&amp;WW&#x27;); -- 密码为123insert into t_user values (null, &#x27;ccc&#x27;, &#x27;37c80a50a975580fb2fb287bee20a04a&#x27;, &#x27;K2*LWFB#&#x27;); -- 密码为123insert into t_role values (null, &#x27;admin&#x27;);insert into t_role values (null, &#x27;user&#x27;);insert into t_role values (null, &#x27;stu&#x27;);insert into t_perms values (null, &#x27;admin:*:*&#x27;, null);insert into t_perms values (null, &#x27;user:*:*&#x27;, null);insert into t_perms values (null, &#x27;user:find:*&#x27;, null);insert into t_user_role values (null, 1, 1);insert into t_user_role values (null, 1, 2);insert into t_user_role values (null, 2, 2);insert into t_user_role values (null, 3, 3);insert into t_role_perms values (null, 1, 1);insert into t_role_perms values (null, 2, 2);insert into t_role_perms values (null, 2, 3);insert into t_role_perms values (null, 3, 3); 创建Entity、Mapper、Service 修改自定义的ShiroRealm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ShiroRealm extends AuthorizingRealm &#123; @Resource private UserService userService; @Resource private PermsService permsService; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = (String) principalCollection.getPrimaryPrincipal(); // 获取角色信息 User user = userService.findRolesByUsername(username); List&lt;String&gt; roles = user.getRoles().stream().map(Role::getName).collect(Collectors.toList()); // 获取权限信息 List&lt;String&gt; perms = user.getRoles().stream().flatMap(role -&gt; &#123; List&lt;Perms&gt; list = permsService.findPermsByRoleId(role.getId()); return list.stream().map(Perms::getName); &#125;).collect(Collectors.toList()); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addRoles(roles); info.addStringPermissions(perms); System.out.println(roles); System.out.println(perms); return info; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 User user = userService.findByUsername(username); if (ObjectUtils.isEmpty(user)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，然后交由凭证匹配器（CredentialsMatcher）进行凭证的判断，默认是对密码进行判断 return new SimpleAuthenticationInfo( user.getUsername(), // 用户信息 user.getPassword(), // 密码 ByteSource.Util.bytes(user.getSalt()), // salt盐值 this.getName()); //realm名称 &#125;&#125; 测试 ​ 不同用户由于角色和权限的不同，登录后看到的系统主页是不一样的！ 六、JWT1. 简介 JWT（JSON Web Token）是目前最流行的跨域认证解决方案。 传统的认证流程，使用session： 12345671、用户向服务器发送用户名和密码2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等3、服务器向用户返回一个 session_id，写入用户的 Cookie4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份存在的问题：扩展性差、服务器内存占用较高 JWT的认证流程，使用token： 123451、用户向服务器发送用户名和密码2、服务器验证通过后，会生成一个token（JWT），表示用户的身份3、服务器向用户返回该token，客户端存储token，可以存储在Cookie、localStorage或sessionStorage中4、用户随后的每一次请求，都要带上这个token，一般放请求头中携带5、服务器收到token并验证是否有效，由此得知用户的身份。 2. JWT原理JWT 原理：服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 12345&#123; &quot;姓名&quot;: &quot;张三&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2023年6月12日0点0分&quot;&#125; 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。 为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 优点： 服务器不再保存任何 session 数据，服务器变成无状态了 由客户端保存身份信息，即JWT令牌 token，一般存储在客户端的localStorage中 客户端每次请求时，JWT令牌随着请求头一起提交 3. JWT数据结构实际的 JWT 大概就像下面这样。 它是一个很长的字符串，中间用点.分隔成三个部分。 JWT的三个部分如下： Header（头部） Payload（载荷） Signature（签名） 3.1 头部（Header）Header 部分是一个 JSON 对象，用于描述该JWT的基本信息，例如签名所用的算法及令牌的类型等。 1234&#123; &quot;alg&quot;:&quot;HS256&quot;, &quot;typ&quot;:&quot;JWT&quot;&#125; 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；type属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 注： Base64URL 算法和 Base64 算法基本类似，但有一些小的不同，其会将个别特殊符合替换掉。 3.2 载荷（Playload）Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 除了官方字段，你还可以在这个部分自定义私有字段，下面就是一个例子。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 这个 JSON 对象也要使用 Base64URL 算法转成字符串。 1eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 注意：由于Base64URL是对称算法，可以被解密为明文信息，所以一般不建议存放敏感数据。 3.3 签名（Signature）Signature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。 4. 优缺点优点： 因为json的通用性，所以JWT是可以跨语言的 因为有了payload部分，所以JWT可以在自身存储一些其他业务所必要的非敏感信息 便于传输，JWT的构成非常简单，字节占用很小，所以它是非常便于传输的 它不需要在服务端保存会话信息，所以易于扩展，例如集群或微服务环境下。 JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 缺点： JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次 JWT 不加密的情况下，不能将敏感数据写入 JWT。 由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 5. 在Java中使用JWT步骤： 添加依赖 123456&lt;!--java-jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 基本用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class JwtTest &#123; /** * 生成令牌 */ @Test public void generate()&#123; Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;(); payload.put(&quot;id&quot;,1001); payload.put(&quot;name&quot;,&quot;tom&quot;); Calendar c = Calendar.getInstance(); c.add(Calendar.SECOND,30); // JWTCreator.Builder builder = JWT.create(); String token = JWT.create() .withPayload(payload) // 载荷 .withExpiresAt(c.getTime()) // 过期时间 .sign(Algorithm.HMAC256(&quot;secret&quot;)); // 签名：算法和密钥 System.out.println(token); &#125; /** * 校验令牌 * 如果令牌过期，会抛异常TokenExpiredException * 一般会返回boolean，表示校验是否通过 */ @Test public void valid()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; try &#123; JWT.require(Algorithm.HMAC256(&quot;secret&quot;)).build().verify(token); &#125; catch (Exception e) &#123; // 如果令牌过期，会抛异常TokenExpiredException e.printStackTrace(); &#125; &#125; /** * 解析令牌 * 如果令牌过期，会抛异常TokenExpiredException */ @Test public void parse()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; DecodedJWT decodedJWT = JWT.require(Algorithm.HMAC256(&quot;secret&quot;)).build().verify(token); // 获取载荷中的信息 Long id = decodedJWT.getClaim(&quot;id&quot;).asLong(); String name = decodedJWT.getClaim(&quot;name&quot;).asString(); System.out.println(id+&quot;-&quot;+name); &#125; /** * 反码令牌 * 直接获取载荷信息，不会校验是否过期 */ @Test public void decode()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; DecodedJWT decodedJWT = JWT.decode(token); Long id = decodedJWT.getClaim(&quot;id&quot;).asLong(); String name = decodedJWT.getClaim(&quot;name&quot;).asString(); System.out.println(id+&quot;-&quot;+name); &#125;&#125; 七、整合步骤： 创建一个springboot工程，选择以下模块：Web、Lombok、DevTools、Spring Data Redis 添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!--mysql、druid、mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--knife4j--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--java-jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- easy-captcha --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt; &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- hutool --&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.15&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920212223242526272829303132server: port: 8080spring: # DruidDataSource datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/project?useUnicode=true&amp;characterEncoding=utf8 username: root password: root # knife4j mvc: pathmatch: matching-strategy: ant_path_matcher # redis redis: host: localhost port: 6379 database: 0# MyBatismybatis: type-aliases-package: net.wanho.po mapper-locations: classpath:mapper/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl map-underscore-to-camel-case: true# PageHelperpagehelper: helper-dialect: mysql 数据库 123456789101112131415161718192021drop database if exists project;create database project charset utf8;use project;create table user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(50) unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, status tinyint comment &#x27;帐号状态（0正常 1停用）&#x27;) engine innodb default charset utf8 comment &#x27;用户表&#x27;;create table student( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(50) comment &#x27;姓名&#x27;, age int comment &#x27;年龄&#x27;, gender varchar(50) comment &#x27;性别&#x27;, address varchar(50) comment &#x27;地址&#x27;, birth date comment &#x27;生日&#x27;) engine innodb default charset utf8 comment &#x27;学生表&#x27;;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"}]},{"title":"Vue3学习","slug":"Vue3学习","date":"2023-08-22T08:31:19.000Z","updated":"2023-08-23T00:52:03.095Z","comments":true,"path":"2023/08/22/Vue3学习/","link":"","permalink":"http://example.com/2023/08/22/Vue3%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、简介1. 介绍​ Vue 2 将于 2023 年 12 月 31 日停止维护，详见 Vue 2 延长 LTS。 ​ Vue 3是Vue.js的下一个主要版本，最初于2020年9月发布，Vue 3支持Vue 2的大多数特性。 2. 优点 更快更省 Object.defineProperty ——&gt; Proxy 重构 Virtual DOM 运行速度更快，打包体积更小 更好的TypeScript集成 团队开发更轻松 架构更灵活，阅读源码更轻松 可以独立使用Vue内部模块 组合式API（Composition API） 一组低侵入式的、函数式的 API 更好的逻辑复用与代码组织 更好的类型推导 二、创建Vue3项目1. 简介Vue.js官方提供了两种创建Vue 3项目的方式：vue-cli 或 vite 区别如下: 运行方式不同 vue-cli使用Webpack进行项目打包，这意味着启动和打包速度相对较慢 vite使用ES模块系统，利用浏览器原生的模块解析器来运行，启动速度更快，打包速度也更快。 默认配置有区别 vue-cli提供了更多的默认配置和插件，可以帮助开发者更快地创建和部署Vue.js项目 vite则采用更加精简的配置和插件，让开发者自由地选择第三方插件和配置模块。 2. 使用 viteVite是一种新型前端构建工具，能够显著提升前端开发体验。 特点： 快速的冷启动，不需要等待打包操作 即时的热模块更新，替换性能和模块数量的解耦让更新飞起 真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变 操作步骤： 123456789# 创建项目npm init vue@latest # 基于Vite# 安装依赖cd vue3-projectnpm install# 运行项目npm run dev 三、API 风格Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API 1. 选项式 API (Options API)使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。 选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。 123456789101112131415161718192021222324&lt;script&gt;export default &#123; // data() 返回的属性将会成为响应式的状态，并且暴露在 this 上 data() &#123; return &#123; count: 0 &#125; &#125;, // methods 是一些用来更改状态与触发更新的函数，它们可以在模板中作为事件处理器绑定 methods: &#123; increment() &#123; this.count++ &#125; &#125;, // 生命周期钩子会在组件生命周期的各个不同阶段被调用，例如这个函数就会在组件挂载完成后被调用 mounted() &#123; console.log(`The initial count is $&#123;this.count&#125;.`) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 2. 组合式 API (Composition API)通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。 在单文件组件中，组合式 API 通常会与&lt;script setup&gt;搭配使用。这个 setup 属性是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，&lt;script setup&gt; 中的导入和顶层变量&#x2F;函数都能够在模板中直接使用。 下面是使用了组合式 API 与 &lt;script setup&gt; 改造后和上面的模板完全一样的组件： 1234567891011121314151617181920&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 响应式状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() =&gt; &#123; console.log(`The initial count is $&#123;count.value&#125;.`)&#125;)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 四、响应式APIVue 3 提供的一组具有响应式特性的函数式API，都是以函数形式提供的 1. reactivereactive()函数接收一个普通对象，返回该普通对象的响应式代理对象 简单来说，就是用来创建响应式的数据对象 12345678910&lt;script setup&gt; // 导入reactive函数 import &#123; reactive &#125; from &#x27;vue&#x27; // 创建响应式数据对象，是一个代理对象 const user = reactive(&#123; name:&#x27;tom&#x27;, age:18 &#125;)&lt;/script&gt; 2. refref()函数接收一个参数值，返回一个响应式的数据对象。该对象只包含一个指向内部值的 .value 属性 在模板中访问时，无需通过.value属性，它会自动展开 3. toReftoRef()函数用来将 reactive 对象的一个属性创建为一个 ref，并且这个 ref 具有响应性，可以被传递。 4. toRefstoRefs()函数用来将 reactive 对象创建为一个普通对象，但该普通对象的每个属性都是一个 ref，并且这个 ref 具有响应性，可以被传递。 5. computedcomputed() 函数用来创建计算属性，函数的返回值是一个 ref 的实例 6. watchwatch() 函数用来监视数据的变化，从而触发特定的操作 6. watchEffectwatchEffect()函数接收一个函数作为参数，并立即执行该函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。 五、组件间数据传递1. 父子组件父向子传递数据：属性绑定+数据拦截 使用defineProps接收父组件传递的数据 子向父传递数据：事件监听+事件触发 使用defineEmits自定义事件，然后触发事件 注：defineProps 和 defineEmits是自动导入的，不需要手动导入 2. 依赖注入依赖注入就是祖先组件向后代组件传递数据，使用provide() 和 inject() 函数来实现 在祖先组件中使用provide()函数向下传递数据 在后代组件中使用inject()函数获取上层传递过来的数据 六、生命周期钩子函数Vue 3 中的生命周期函数和 Vue 2.x 相比做了一些调整和变化，对应关系如下： beforeCreate -&gt; 使用 setup() created -&gt; 使用 setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured 七、模板 Refs通过 ref()函数还可以引用页面上的元素或组件，功能类似于 vue 2.x中的 vm.$refs 步骤： 创建一个空的 ref 对象并返回它 在页面上为元素添加 ref 属性，并设置属性值与创建的 ref 对象的名称相同 当页面渲染完成后，可以通过该 ref 对象获取到页面中对应的DOM元素 八、Pinia状态管理Pinia（小菠萝）是一个轻量级的、基于Vue 3的状态管理库，提供了更简单的 API，支持Typescript和组合式API风格。 与Vuex相比，Pinia抛弃了Mutation操作，保留state、getters、actions，且提供了更简便的用法。 官网 https://pinia.vuejs.org/zh/ 基本用法，步骤： 定义store 1234567891011121314import &#123; ref, computed &#125; from &#x27;vue&#x27;import &#123; defineStore &#125; from &#x27;pinia&#x27;export const useUser = defineStore(&#x27;user&#x27;, () =&gt; &#123; const msg = ref(&#x27;welcome to pinia&#x27;) const reverseMsg = computed(() =&gt; msg.value.toUpperCase().split(&#x27; &#x27;).reverse().join(&#x27; &#x27;)) function setMsg(newValue) &#123; msg.value = newValue &#125; return &#123; msg, reverseMsg, setMsg &#125;&#125;) 使用store 1234567891011&lt;script setup&gt; import &#123; useUser &#125; from &#x27;@/stores/user&#x27; const user = useUser()&lt;/script&gt;&lt;template&gt; &lt;p&gt;&#123;&#123; user.msg &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; user.reverseMsg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;user.setMsg(&#x27;hello world&#x27;)&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt; 附录：vite常用插件1. unplugin-auto-importunplugin-auto-import 自动导入插件，能够自动引入ref、reavtive等函数，不需要再自己引入 步骤： 安装插件 执行npm install -D unplugin-auto-import 配置插件，编辑vite.config.js 123456789101112131415import AutoImport from &#x27;unplugin-auto-import/vite&#x27;export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; imports:[&#x27;vue&#x27;,&#x27;vue-router&#x27;,&#x27;pinia&#x27;] // 自动导入相关函数 &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 2. vite-plugin-pagesvite-plugin-pages 自动读取指定目录下的文件，生成路由信息，不需要自己去逐个配置路由 步骤： 安装插件 执行npm install -D vite-plugin-pages 配置插件，编辑vite.config.js 123456789101112131415161718192021import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Pages from &#x27;vite-plugin-pages&#x27;export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; imports:[&#x27;vue&#x27;,&#x27;vue-router&#x27;,&#x27;pinia&#x27;] // 自动导入相关函数 &#125;), Pages(&#123; dirs:[ &#123; dir: &quot;src/views&quot;, baseRoute: &quot;&quot; &#125;], // 修改默认文件夹 importMode: &quot;async&quot; &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 自动生成路由，编辑router&#x2F;index.js 12345678import routes from &#x27;~pages&#x27;const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes&#125;)export default router 注意： vite-plugin-pages默认读取的页面文件夹是 pages，默认读取的页面是 index.vue 所以最好先在pages文件夹下面创建一个 index.vue文件","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"JDK8新特性","slug":"JDK8新特性","date":"2023-08-22T08:30:50.000Z","updated":"2023-08-22T08:32:35.087Z","comments":true,"path":"2023/08/22/JDK8新特性/","link":"","permalink":"http://example.com/2023/08/22/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"一、类型推断的改进类型推断(推导) 是 JDK7的特性，JDK8中做了改进。 二、默认方法JDK8 新增了接口的默认方法，默认方法就是一个在接口中有具体实现的方法，即非抽象方法。 定义默认方法时需要使用 default 关键字进行修饰。 也可以定义静态方法，且不需要使用 default 修饰。 三、Lambda表达式Lambda 表达式是一个匿名函数，允许把函数作为一个方法的参数。 Lambda 表达式可以认为是对匿名内部类的一种简化，使代码变的更简洁紧凑。 但并不是所有的匿名内部类都可以简化为Lambda表达式，只有函数式接口的匿名内部类才可以使用Lambda表达式来进行简化 函数式接口：就是接口中只有一个抽象方法，Lambda表达式正好是针对这个唯一的抽象方法使用的 Lambda表达式的语法： 123(parameters) -&gt; expression或(parameters) -&gt; &#123; statement; &#125; 注意: 参数类型是可选的 : 可以省略参数的类型声明，由编译器统一识别，进行类型推断 参数小括号是可选的 : 当方法只有一个参数时，可以省略参数小括号 方法体大括号是可选的: 当方法体只包含一条语句时，可以省略方法体大括号 return关键字是可选的 : 当方法体只包含一条语句，且需要返回该语句的执行结果时，可以省略return 四、方法引用方法引用是一种语法糖操作，作用是简化Lambda在调用已经存在的方法时的表达式。 方法引用可以直接引用已有Java类或对象的方法或构造方法，使用一对冒号 :: 方法引用的几种类型： 静态方法引用（类名::静态方法名） 实例方法引用（对象名::实例方法名） 类的实例方法引用（类名::实例方法名） 构造方法引用（类名::new） 五、函数式接口函数式接口 Functional Interface：就是有且只有一个抽象方法的接口，但可以有多个非抽象方法。 函数式接口（的实现类的对象）可以隐式转换为Lambda表达式，进行简化。 Java 8 提供了一个特殊的注解**@FunctionalInterface**，用于标注一个接口是函数式接口 1234567891011121314151617181920212223242526272829/** * JDK8之前的函数式接口 */java.lang.Runnablejava.lang.Comparable&lt;T&gt;java.util.Comparator&lt;T&gt;java.io.FileFilterjava.io.FilenameFilterjava.lang.reflect.InvocationHandler...... /** * JDK8新增的函数式接口，主要在java.util.function包中 */ // 消费型接口java.util.function.Consumer&lt;T&gt; void accept(T t); // 接收一个参数, 无返回// 供给型接口java.util.function.Supplier&lt;T&gt; T get(); // 无参数, 返回一个结果// 函数型接口java.util.function.Function&lt;T, R&gt; R apply(T t); // 接收一个参数, 返回一个结果// 断言型接口java.util.function.Predicate&lt;T&gt; boolean test(T t); // 接收一个参数, 返回一个布尔值的结果 六、Stream API1. 简介Java 8 API 添加了一个新的抽象称为Stream流，它可以让你以一种声明的方式来处理数据。 Stream主要用于集合操作，支持链式编程，极大的简化了代码。 Stream将要处理的元素集合看作为一种流，数据在流的管道中传输，可以在管道的节点上对元素进行处理，如：筛选、排序、聚合等。 元素流在管道中经过 中间操作 的处理，最后由 终止操作 得到前面处理的结果。 Stream流的操作步骤： 获取Stream对象 中间操作（实现要做的数据处理操作） 终止操作 2. 获取Stream对象三种方式： 通过Collection接口中的stream方法或parallelStream方法获取集合的流 通过Arrays类中的stream方法获取数组的流（串行流） 通过Stream接口中的of方法获取一个或多个元素的流（串行流） 3. 基本使用3.1 Stream特点Stream不会存储元素 Stream不会改变源对象，它会返回一个持有结果的新Stream对象。 Stream中间操作都会返回一个持有结果的新Stream对象，可以对新的Stream继续执行其他的中间操作，这样的多个连续操作，可以串联成一个管道。 Stream的中间操作是延迟执行的，需要执行终止操作，才会真正的执行中间操作。 3.2 惰性求值多个中间操作可以连起来，形成一个流水线。除非流水线上触发了终止操作，否则中间操作不会被执行。 只有当发生终止操作时，才会一次性处理全部的操作，这种情况称为 惰性求值 。 3.3 内部迭代以前对集合遍历都是通过 Iterator 或 For-Each 的方式，这种显式的在集合外部进行迭代的方式称为 外部迭代。 在集合内部进行迭代的方式称为 内部迭代。例如：集合的forEach方法、Stream的操作的forEach方法（是一个终止操作）。 4. 中间操作4.1 筛选与切片filter(Predicate predicate) 从流中获取符合条件的元素 limit(long maxSize) 截断流，使其元素不超过指定数量 skip(long n) 跳过多个元素，返回一个扔掉了 n 个元素的流，如果流中的元素不足 n，则返回一个空的流 distinct() 通过流中的元素的 hashCode和equals方法进行判断是否重复 4.2 映射map(Function&lt;T, R&gt; mapper) 将回调方法的操作应用到每一个元素上，将其映射成一个新的元素。 flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper) 将流中的每一个元素都转换成一个流，然后将所有的流连成一个新的流。 mapToInt(ToIntFunction&lt;T&gt; mapper) 将流中的每一个元素转换成int类型的元素，然后返回包含所有转换后值的流 mapToLong(ToLongFunction&lt;T&gt; mapper) 将流中的每一个元素转换成long类型的元素，然后返回包含所有转换后值的流 mapToDouble(ToDoubleFunction&lt;T&gt; mapper) 将流中的每一个元素转换成double类型的元素，然后返回包含所有转换后值的流 peek(Consumer&lt;? super T&gt; action) 作用与map()类似，但无需返回值，属于消费型接口 4.3 排序sorted() 返回一个新的流，其中元素按照自然顺序升序排序。 sorted(Comparator&lt;T&gt; comparator) 根据比较器指定的排序规则，对流中的元素进行排序。 5. 终止操作5.1 查找与匹配forEach(Consumer c)遍历流中的数据,该方法接收一个Consumer函数式接口，会将每一个流的元素交给函数 allMatch(Predicate&lt;T&gt; predicate) 元素全部满足要求时，才会返回 true，否则返回 false（短路操作） anyMatch(Predicate&lt;T&gt; predicate) 元素只要有一个满足要求，就会返回 true，否则返回 false（短路操作） noneMatch(Predicate&lt;? super T&gt; predicate) 元素全部不满足要求时，才会返回 true，否则返回 false（短路操作） findFirst() 取出流中第一个元素，会把结果封装成 Optional 类型的对象。 findAny() 取出符合要求的一个元素(任意的、只要满足要求即可)。 count() 统计流中的元素个数。 max(Comparator&lt;T&gt; comparator) 找最大的元素。 min(Comparator&lt;T&gt; comparator) 找最小的元素。 5.2 归约归约：将流中的元素反复结合起来，得到一个值。 reduce(BinaryOperator&lt;T&gt; accumulator) 对流中的元素进行累计操作。前一次的操作结果会作为下一次操作的参数，最终返回一个 使用 Optional 封装的累计结果。 reduce(T identity, BinaryOperator&lt;T&gt; accumulator) 对流中的元素进行累计操作。根据初始值 identity 进行累计操作，最终返回一个和流中元素类型一致的结果。 5.3 收集collect(Collector&lt;T, A, R&gt; collector) 收集处理的结果，将流转换成指定集合，一般通过Collectors工具类指定集合类型 七、Optional 类型Optional 是一个容器，可以保存 T 类型的值，或仅仅保存null。 Optional 主要的作用是用来解决空指针异常的。 Optional 提供了很多有用的方法，这样程序员就不用显式进行空值判断了。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Redis学习","slug":"Redis学习","date":"2023-08-21T13:30:53.000Z","updated":"2023-08-22T08:33:47.976Z","comments":true,"path":"2023/08/21/Redis学习/","link":"","permalink":"http://example.com/2023/08/21/Redis%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Redis简介1. 关于NoSQLNoSQL的全称是Not only SQL，意即”不仅仅是SQL”，是一项全新的数据库革命性运动 NoSQL，泛指非关系型的数据库，如Redis、MongoDB和memcached等内存数据库。 产生背景： 海量数据、数据多样化和实时性 高并发、高可扩和高性能 2. Redis是什么Redis是一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求。 Redis数据就是以key-value形式来存储数据： key只能是字符串类型 value可以是以下五种类型：String、List、Set、Sorted-Sets、Hash 3. Redis优势优点： 应用广泛，技术成熟，简单易用 基于内存，高性能（Redis读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s ） 丰富的数据类型 数据持久化 支持主从备份和读写分离 支持集群 4. Redis的应用场景 缓存（数据查询、短连接、菜单内容、新闻内容、商品内容等） 分布式集群架构中的session分离 聊天室的在线好友列表 任务队列（秒杀、抢购、12306等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） 二、安装Redis1. 安装1.1 WindowsRedis程序文件redis-win.zip 解压到无空格无中文目录下 redis-server.exe 启用服务的命令 redis-cli.exe 连接服务端的命令 端口号6379 12345678# 默认连接【本机+6379】redis-cli# 指定连接 -h ip -p 端口redis-cli -h 127.0.0.1 -p 6379# 连接好了，退出exit# 关闭redis服务器redis-cli shutdown 使用图形化客户端工具 Redis Desktop Manager.exe 1.2 Linux​ 步骤： 解压redis-3.2.8.tar.gz 12cd ~/softwaretar -zxf redis-3.2.8.tar.gz 编译 12cd redis-3.2.8make 安装 12mkdir ~/software/redis-binmake install PREFIX=~/software/redis-bin/ #PREFIX选项用来指定安装的位置 启动redis 12345cd ~/software/redis-bin/bin/./redis-server #使用默认配置文件启动，默认配置文件所在目录redis-3.2.8/redis.conf或cp ~/software/redis-3.2.8/redis.conf myredis.conf #复制默认配置文件到当前目录，并改名./redis-server myredis.conf #使用指定的配置文件启动 连接redis 123./redis-cli #默认连接本机的6379端口(redis默认使用的端口号)或./redis-cli -h IP地址 -p 端口号 #连接指定主机、指定端口的redis，如./redis-cli -h localhost -p 6379 测试 12127.0.0.1:6379&gt; set name tom127.0.0.1:6379&gt; get name 关闭 方式1：在服务器窗口中按 Ctrl+C 方式2：在客户端连接后输入 shutdown 或 直接输入 redis-cli shutdown ​ 查看进程 123ps -ef | grep redis #查看redis的进程信息或lsof -i:6379 #查看6379端口的进程信息 2. 配置编辑redis.conf配置文件： 123456789daemonize yes #配置为守护进程，后台启动port 6379 #修改监听端口#让redis支持远程访问，默认只允许本地访问#bind 127.0.0.1 #注释掉该行，允许所有主机访问redisprotected-mode no #关闭保护模式requirepass 123 #配置redis密码，使用时需要输入auth 123进行认证，认证后才能操作redis 三、Redis数据类型1. String类型1.1 简介​ 字符串类型是Redis中最为基础的数据存储类型，它是以二进制形式存储的，这便意味着该类型可以存储任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。 1.2 操作 set&#x2F;get&#x2F;append&#x2F;strlen 12345678910111213141516171819202122$ redis-cli 127.0.0.1:6379&gt; select 0 #切换到第1个数据库（默认共有16个数据库，通过数字来进行命名，索引从0开始）OK127.0.0.1:6379&gt; keys * #显示所有的键key(empty list or set)127.0.0.1:6379&gt; set name tom #设置键OK127.0.0.1:6379&gt; get name #获取键对应的值&quot;tom&quot;127.0.0.1:6379&gt; append mykey &quot;hello&quot; #如果该键不存在，则创建，返回当前value的长度(integer) 5127.0.0.1:6379&gt; append mykey &quot; world&quot; #如果该键已经存在，则追加，返回追加后value的长度(integer) 11127.0.0.1:6379&gt; get mykey #获取mykey的值&quot;hello world&quot;127.0.0.1:6379&gt; strlen mykey #获取mykey的长度(integer) 11#EX和PX表示失效时间，单位为秒和毫秒，两者不能同时使用；NX表示数据库中不存在时才能设置,XX表示存在时才能设置127.0.0.1:6379&gt; set mykey &quot;this is test&quot; EX 5 NX OK127.0.0.1:6379&gt; get mykey&quot;this is test&quot; ​ 注：命令不区分大小写，但key和value区分大小写 incr&#x2F;decr&#x2F;incrby&#x2F;decrby 1234567891011121314151617181920127.0.0.1:6379&gt; flushdb #清空数据库OK127.0.0.1:6379&gt; set mykey 20OK127.0.0.1:6379&gt; incr mykey #递增1(integer) 21127.0.0.1:6379&gt; decr mykey #递减1(integer) 20127.0.0.1:6379&gt; del mykey #删除该键(integer) 1127.0.0.1:6379&gt; decr mykey(integer) -1127.0.0.1:6379&gt; del mykey(integer) 1127.0.0.1:6379&gt; incr mykey(integer) 1127.0.0.1:6379&gt; incrby mykey 5 #递增5，即步长(integer) 15127.0.0.1:6379&gt; decrby mykey 10 #递减10(integer) 5 2. List类型2.1 概述​ 在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。​ 从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。 2.2 操作 lpush&#x2F;lpushx&#x2F;lrange 1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; flushdbOK#创建键mykey及与其关联的List，然后将参数中的values从左到右依次插入127.0.0.1:6379&gt; lpush mykey a b c d(integer) 4#获取从位置0开始到位置2结束的3个元素127.0.0.1:6379&gt; lrange mykey 0 21) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;#获取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;a&quot;#获取从倒数第3个到倒数第2个的元素127.0.0.1:6379&gt; lrange mykey -3 -21) &quot;c&quot;2) &quot;b&quot;#lpushx表示键存在时才能插入，mykey2键此时并不存在，因此该命令将不会进行任何操作，其返回值为0127.0.0.1:6379&gt; lpushx mykey2 e (integer) 0#可以看到mykey2没有关联任何List Value127.0.0.1:6379&gt; lrange mykey2 0 -1(empty list or set)#mykey键此时已经存在，所以该命令插入成功，并返回链表中当前元素的数量127.0.0.1:6379&gt; lpushx mykey e(integer) 5#获取该键的List中的第一个元素127.0.0.1:6379&gt; lrange mykey 0 01) &quot;e&quot; lpop&#x2F;llen 123456789101112127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; lpush mykey a b c d(integer) 4#取出链表头部的元素，该元素在链表中就已经不存在了127.0.0.1:6379&gt; lpop mykey&quot;d&quot;127.0.0.1:6379&gt; lpop mykey&quot;c&quot;#在执行lpop命令两次后，链表头部的两个元素已经被弹出，此时链表中元素的数量是2127.0.0.1:6379&gt; llen mykey(integer) 2 lrem&#x2F;lindex&#x2F;lset&#x2F;ltrim 12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; flushdbOK#准备测试数据127.0.0.1:6379&gt; lpush mykey a b c d a c(integer) 6#从头部(left)向尾部(right)操作链表，删除2个值等于a的元素，返回值为实际删除的数量127.0.0.1:6379&gt; lrem mykey 2 a(integer) 2#查看删除后链表中的全部元素127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;c&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;#获取索引为1(头部的第二个元素)的元素值127.0.0.1:6379&gt; lindex mykey 1&quot;d&quot;#将索引为1(头部的第二个元素)的元素值设置为新值e127.0.0.1:6379&gt; lset mykey 1 eOK#查看是否设置成功127.0.0.1:6379&gt; lindex mykey 1&quot;e&quot;#索引值6超过了链表中元素的数量，该命令返回nil127.0.0.1:6379&gt; lindex mykey 6(nil)#设置的索引值6超过了链表中元素的数量，设置失败，该命令返回错误信息。127.0.0.1:6379&gt; lset mykey 6 h(error) ERR index out of range#仅保留索引值0到2之间的3个元素，注意第0个和第2个元素均被保留。127.0.0.1:6379&gt; ltrim mykey 0 2OK#查看trim后的结果127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;c&quot;2) &quot;e&quot;3) &quot;c&quot; 3. Set类型3.1 概述​ 在Redis中，我们可以将Set类型看作为没有排序的字符集合，也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。Set可包含的最大元素数量是4294967295。​ 和List类型不同的是，Set集合中不允许出现重复的元素，这一点和Java中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions并、intersections交和differences差。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。 3.2 操作 sadd&#x2F;smembers&#x2F;sismember&#x2F;scard 123456789101112131415161718192021222324252627#由于该键myset之前并不存在，因此参数中的三个成员都被正常插入127.0.0.1:6379&gt; sadd myset a b c(integer) 3#查看集合中的元素，从结果可以，输出的顺序和插入顺序无关(无序的)127.0.0.1:6379&gt; smembers myset1) &quot;a&quot;2) &quot;c&quot;3) &quot;b&quot;#由于参数中的a在myset中已经存在，因此本次操作仅仅插入了d和e两个新成员（不允许重复）127.0.0.1:6379&gt; sadd myset a d e(integer) 2#查看插入的结果127.0.0.1:6379&gt; smembers myset1) &quot;a&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;b&quot;5) &quot;e&quot;#判断a是否已经存在，返回值为1表示存在127.0.0.1:6379&gt; sismember myset a(integer) 1#判断f是否已经存在，返回值为0表示不存在127.0.0.1:6379&gt; sismember myset f(integer) 0#获取集合中元素的数量127.0.0.1:6379&gt; scard myset(integer) 5 srandmember&#x2F;spop&#x2F;srem&#x2F;smove 123456789101112131415161718192021222324252627282930313233343536373839127.0.0.1:6379&gt; del myset(integer) 1#准备测试数据127.0.0.1:6379&gt; sadd myset a b c d(integer) 4#查看集合中的元素127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot;4) &quot;b&quot;#随机返回一个成员，成员还在集合中127.0.0.1:6379&gt; srandmember myset&quot;c&quot;#取出一个成员，成员会从集合中删除127.0.0.1:6379&gt; spop myset&quot;b&quot;#查看移出后Set的成员信息127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot;#从Set中移出a、d和f三个成员，其中f并不存在，因此只有a和d两个成员被移出，返回为2127.0.0.1:6379&gt; srem myset a d f(integer) 2#查看移出后的输出结果127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;127.0.0.1:6379&gt; del myset(integer) 1#为后面的smove命令准备数据127.0.0.1:6379&gt; sadd myset a b(integer) 2127.0.0.1:6379&gt; sadd myset2 c d(integer) 2#将a从myset移到myset2，从结果可以看出移动成功127.0.0.1:6379&gt; smove myset myset2 a(integer) 1 3.3 应用范围 可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。 充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。 4. Sorted-Sets类型4.1 概述​ Sorted-Sets和Sets类型极为相似，也称为Zset，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序（默认）。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。​ 在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。 4.2 操作 zadd&#x2F;zrange&#x2F;zcard&#x2F;zrank&#x2F;zcount&#x2F;zrem&#x2F;zscore&#x2F;zincrby 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#添加一个分数为1的成员127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot;(integer) 1#添加两个分数分别是2和3的两个成员127.0.0.1:6379&gt; zadd myzset 2 &quot;two&quot; 3 &quot;three&quot;(integer) 2#通过索引获取元素，0表示第一个成员，-1表示最后一个成员。WITHSCORES选项表示返回的结果中包含每个成员及其分数，否则只返回成员127.0.0.1:6379&gt; zrange myzset 0 -1 WITHSCORES1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;5) &quot;three&quot;6) &quot;3&quot;#获取myzset键中成员的数量 127.0.0.1:6379&gt; zcard myzset(integer) 3#获取成员one在集合中的索引，0表示第一个位置127.0.0.1:6379&gt; zrank myzset one(integer) 0#成员four并不存在，因此返回nil127.0.0.1:6379&gt; zrank myzset four(nil)#获取符合指定条件的成员数量，分数满足表达式1 &lt;= score &lt;= 2的成员的数量127.0.0.1:6379&gt; zcount myzset 1 2(integer) 2#删除成员one和two，返回实际删除成员的数量127.0.0.1:6379&gt; zrem myzset one two(integer) 2#查看是否删除成功127.0.0.1:6379&gt; zcard myzset(integer) 1#获取成员three的分数。返回值是字符串形式127.0.0.1:6379&gt; zscore myzset three&quot;3&quot;#由于成员two已经被删除，所以该命令返回nil127.0.0.1:6379&gt; zscore myzset two(nil)#将成员three的分数增加2，并返回该成员更新后的分数127.0.0.1:6379&gt; zincrby myzset 2 three&quot;5&quot;#将成员three的分数增加-1，并返回该成员更新后的分数127.0.0.1:6379&gt; zincrby myzset -1 three&quot;4&quot;#查看在更新了成员的分数后是否正确127.0.0.1:6379&gt; zrange myzset 0 -1 withscores1) &quot;three&quot;2) &quot;4&quot; zrangebyscore&#x2F;zremrangebyscore&#x2F;zremrangebyrank 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; del myzset(integer) 1127.0.0.1:6379&gt; zadd myzset 1 one 2 two 3 three 4 four(integer) 4#通过分数获取元素，获取分数满足表达式1 &lt;= score &lt;= 2的成员127.0.0.1:6379&gt; zrangebyscore myzset 1 21) &quot;one&quot;2) &quot;two&quot;#-inf表示第一个成员，+inf表示最后一个成员，limit后面的参数用于限制返回成员的数量，#2表示从位置索引(0-based)等于2的成员开始，取后面3个成员，类似于MySQL中的limit127.0.0.1:6379&gt; zrangebyscore myzset -inf +inf withscores limit 2 31) &quot;three&quot;2) &quot;3&quot;3) &quot;four&quot;4) &quot;4&quot;#根据分数删除成员，删除分数满足表达式1 &lt;= score &lt;= 2的成员，并返回实际删除的数量127.0.0.1:6379&gt; zremrangebyscore myzset 1 2(integer) 2#看一下上面的删除是否成功127.0.0.1:6379&gt; zrange myzset 0 -11) &quot;three&quot;2) &quot;four&quot;#根据索引删除成员，删除索引满足表达式0 &lt;= rank &lt;= 1的成员127.0.0.1:6379&gt; zremrangebyrank myzset 0 1(integer) 2#查看上一条命令是否删除成功127.0.0.1:6379&gt; zcard myzset(integer) 0 4.3 应用范围 可以用于大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOP 10的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。 Sorted-Sets类型还可用于构建索引数据。 5. Hash类型5.1 概述 可以将Redis中的Hash类型看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。 5.2 操作 hset&#x2F;hget&#x2F;hlen&#x2F;hexists&#x2F;hdel&#x2F;hsetnx 12345678910111213141516171819202122232425262728293031#给键值为myhash的键设置字段为field1，值为itany127.0.0.1:6379&gt; hset myhash field1 &quot;itany&quot;(integer) 1#获取键值为myhash，字段为field1的值127.0.0.1:6379&gt; hget myhash field1&quot;itany&quot;#myhash键中不存在field2字段，因此返回nil127.0.0.1:6379&gt; hget myhash field2(nil)#给myhash关联的Hashes值添加一个新的字段field2，其值为liu127.0.0.1:6379&gt; hset myhash field2 &quot;liu&quot;(integer) 1#获取myhash键的字段数量127.0.0.1:6379&gt; hlen myhash(integer) 2#判断myhash键中是否存在字段名为field1的字段，由于存在，返回值为1127.0.0.1:6379&gt; hexists myhash field1(integer) 1#删除myhash键中字段名为field1的字段，删除成功返回1127.0.0.1:6379&gt; hdel myhash field1(integer) 1#再次删除myhash键中字段名为field1的字段，由于上一条命令已经将其删除，因为没有删除，返回0127.0.0.1:6379&gt; hdel myhash field1(integer) 0#通过hsetnx命令给myhash添加新字段field1，其值为itany，因为该字段已经被删除，所以该命令添加成功并返回1127.0.0.1:6379&gt; hsetnx myhash field1 &quot;itany&quot;(integer) 1#由于myhash的field1字段已经通过上一条命令添加成功，因为本条命令不做任何操作后返回0127.0.0.1:6379&gt; hsetnx myhash field1 &quot;itany&quot;(integer) 0 hincrby 1234567891011121314127.0.0.1:6379&gt; del myhash(integer) 1#准备测试数据127.0.0.1:6379&gt; hset myhash field 5(integer) 1#给myhash的field字段的值加1，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field 1(integer) 6#给myhash的field字段的值加-1，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field -1(integer) 5#给myhash的field字段的值加-10，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field -10(integer) -5 hmset&#x2F;hmget&#x2F;hgetall&#x2F;hkeys&#x2F;hvals 123456789101112131415161718192021222324127.0.0.1:6379&gt; del myhash(integer) 1#为该键myhash，一次性设置多个字段，分别是field1 = &quot;hello&quot;, field2 = &quot;world&quot;127.0.0.1:6379&gt; hmset myhash field1 &quot;hello&quot; field2 &quot;world&quot;OK#获取myhash键的多个字段，其中field3并不存在，因为在返回结果中与该字段对应的值为nil127.0.0.1:6379&gt; hmget myhash field1 field2 field31) &quot;hello&quot;2) &quot;world&quot;3) (nil)#返回myhash键的所有字段及其值，从结果中可以看出，他们是逐对列出的127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;hello&quot;3) &quot;field2&quot;4) &quot;world&quot;#仅获取myhash键中所有字段的名字127.0.0.1:6379&gt; hkeys myhash1) &quot;field1&quot;2) &quot;field2&quot;#仅获取myhash键中所有字段的值127.0.0.1:6379&gt; hvals myhash1) &quot;hello&quot;2) &quot;world&quot; 四、Key操作命令1. 命令列表 命令用法 解释 keys pattern 获取所有匹配pattern参数的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。 del key [key…] 从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。 exists key 判断指定键是否存在。 persist key 如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。 expire key seconds 该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 ttl key 获取该键所剩的超时描述。 type key 获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。 2. 操作 keys&#x2F;del&#x2F;exists 123456789101112131415161718192021222324252627282930313233127.0.0.1:6379&gt; flushdbOK#添加String类型的数据127.0.0.1:6379&gt; set mykey 2OK#添加List类型的数据127.0.0.1:6379&gt; lpush mylist a b c(integer) 3#添加Set类型的数据127.0.0.1:6379&gt; sadd myset 1 2 3(integer) 3#添加Sorted-Set类型的数据127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot; 2 &quot;two&quot;(integer) 2#添加Hash类型的数据127.0.0.1:6379&gt; hset myhash username &quot;tom&quot;(integer) 1#根据参数中的模式，获取当前数据库中符合该模式的所有key，从输出可以看出，该命令在执行时并不区分与Key关联的Value类型127.0.0.1:6379&gt; keys my*1) &quot;myset&quot;2) &quot;mykey&quot;3) &quot;myzset&quot;4) &quot;myhash&quot;5) &quot;mylist&quot;#删除了两个Keys127.0.0.1:6379&gt; del mykey mylist(integer) 2#查看刚刚删除的Key是否还存在，从返回结果看，mykey确实已经删除了127.0.0.1:6379&gt; exists mykey(integer) 0#查看一下没有删除的Key，以和上面的命令结果进行比较127.0.0.1:6379&gt; exists myset(integer) 1 ttl&#x2F;persist&#x2F;expire 12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; flushdbOK#准备测试数据，将该键的超时设置为100秒127.0.0.1:6379&gt; set mykey &quot;hello&quot; ex 100OK#通过ttl命令查看还剩多少秒127.0.0.1:6379&gt; ttl mykey(integer) 97#立刻执行persist命令，该存在超时的键变成持久化的键，即将该Key的超时去掉127.0.0.1:6379&gt; persist mykey(integer) 1#ttl的返回值告诉我们，该键已经没有超时了127.0.0.1:6379&gt; ttl mykey(integer) -1#为后面的expire命令准备数据127.0.0.1:6379&gt; del mykey(integer) 1127.0.0.1:6379&gt; set mykey &quot;hello&quot;OK#设置该键的超时被100秒127.0.0.1:6379&gt; expire mykey 100(integer) 1#用ttl命令看当前还剩下多少秒，从结果中可以看出还剩下96秒127.0.0.1:6379&gt; ttl mykey(integer) 96#重新更新该键的超时时间为20秒，从返回值可以看出该命令执行成功127.0.0.1:6379&gt; expire mykey 20(integer) 1#再用ttl确认一下，从结果中可以看出被更新了127.0.0.1:6379&gt; ttl mykey(integer) 17#立刻更新该键的值，以使其超时无效。127.0.0.1:6379&gt; set mykey &quot;world&quot;OK#从ttl的结果可以看出，在上一条修改该键的命令执行后，该键的超时也无效了127.0.0.1:6379&gt; ttl mykey(integer) -1 type 123456789101112131415161718192021222324127.0.0.1:6379&gt; del mykey(integer) 1#添加不同类型的测试数据127.0.0.1:6379&gt; set mykey 2OK127.0.0.1:6379&gt; lpush mylist a b c(integer) 3127.0.0.1:6379&gt; sadd myset 1 2 3(integer) 3127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot; 2 &quot;two&quot;(integer) 2127.0.0.1:6379&gt; hset myhash username &quot;tom&quot;(integer) 1#分别查看数据的类型127.0.0.1:6379&gt; type mykeystring127.0.0.1:6379&gt; type mylistlist127.0.0.1:6379&gt; type mysetset127.0.0.1:6379&gt; type myzsetzset127.0.0.1:6379&gt; type myhashhash 五、持久化1. 概述Redis提供了两种数据持久化的方式： RDB 该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘。 AOF 该机制将以日志的形式记录服务器所处理的每一个写操作 在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。 2. RDBRedis Database：通过单文件的方式来持久化 RDB是默认的持久化方式，默认存储在启动redis服务器时所在当前目录下的dump.rdb文件中，一般都会修改存储在一个固定的目录中 编辑配置文件： 1234$ vi myredis.conf dbfilename dump.rdb #持久化文件的名称 #dir ./ #持久化文件的目录,默认为执行redis-server命令时所在的当前目录 dir /home/soft01/software/dump/ #修改存储位置为一个固定的目录 持久化的时机： 在数据库关闭时会持久化（需要注意的是在数据库宕机时不会生成，数据可能会丢失） 满足特定条件时会持久化，编辑配置文件： 1234$ vi myredis.conf save 900 1 #在900秒内，只要有1个key发生变化，就会dump持久化 save 300 10 save 60 10000 优缺点： 缺点：可能会丢失数据 优点：效率比较高 3. AOFAppend Only File：通过操作日志的方式来持久化 编辑配置文件： 12345$ vi myredis.conf appendonly yes #开启aof模式的持久化 appendfilename &quot;appendonly.aof&quot; #aof的持久化文件 appendfsync everysec #每一秒进行一次持久化操作，可取值：always、everysec、no dir /home/soft01/software/dump/ #持久化文件的目录，与RDB相同 优缺点： 缺点：效率比较差 优点：丢失数据量比较少 六、SpringBoot整合Redis1. 用法步骤： 创建一个SpringBoot工程，选择以下模块：Spring Data Redis、Web、Lombok、DevTools 配置redis 12345678910111213spring: redis: host: localhost port: 6379 password: database: 0 # lettuce连接池配置 lettuce: pool: max-wait: 10000 max-idle: 20 min-idle: 10 max-active: 8 注：Java中操作Redis主要有两种客户端：jedis和lettuce，SpringBoot中默认使用的是lettuce 基本操作 使用SpringDataRedis提供的工具类：RedisTemplate 2. RedisConfig配置类1234567891011121314151617181920212223242526/** * Redis配置类 */@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // 设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); // 设置key的序列化方式 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setHashKeySerializer(stringRedisSerializer); // 设置value的序列化方式 GenericJackson2JsonRedisSerializer jsonRedisSerializer =new GenericJackson2JsonRedisSerializer(); redisTemplate.setValueSerializer(jsonRedisSerializer); redisTemplate.setHashValueSerializer(jsonRedisSerializer); return redisTemplate; &#125;&#125; 七、Redis应用：验证码将验证码存储在Redis中 添加依赖，使用captcha生成验证码 123456&lt;!--easy-captcha--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt; &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"如何解决跨域问题","slug":"如何解决跨域问题","date":"2023-08-21T03:44:39.000Z","updated":"2023-09-07T02:40:21.490Z","comments":true,"path":"2023/08/21/如何解决跨域问题/","link":"","permalink":"http://example.com/2023/08/21/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"方法一定义一个配置类，实现WebMvcConfigurer接口，重写addCorsMappings方法 123456789101112@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOriginPatterns(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;*&quot;) .maxAge(3600); &#125;&#125; 方法二在xml中添加如下配置: 123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;/mvc:cors&gt; 方法三在vue项目中vue.config.js内配置代理： 1234567891011121314module.exports = defineConfig(&#123; transpileDependencies: true, devServer: &#123; // 配置代理 proxy:&#123; &#x27;/api&#x27;:&#123; // 所有以/api开头的请求都会被代理到target上 target: &#x27;http://localhost:8080&#x27;, // 代理的目标地址 changeOrigin: true, // 支持跨域 pathRewrite: &#123; // 重写路径 &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125; 在main.js中配置axios： 1234// axios配置import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;/api/&#x27;Vue.prototype.$http = axios 在组件中method中定义方法： 123async getCode()&#123; const &#123;data:res&#125; = await this.$http.get(&#x27;captchaImage&#x27;)&#125;,","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"SpringBoot学习","slug":"SpringBoot学习","date":"2023-08-17T08:36:01.000Z","updated":"2023-08-17T08:40:14.997Z","comments":true,"path":"2023/08/17/SpringBoot学习/","link":"","permalink":"http://example.com/2023/08/17/SpringBoot%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、SpringBoot简介1. SpringBoot是什么？产生背景：Spring开发变的越来越笨重，大量的XML文件、繁琐的配置、复杂的部署流程、整合第三方框架难度大等，导致开发效率低下 SpringBoot是一个用来简化Spring应用的初始创建和开发过程的框架，简化配置，实现快速开发 融合了整个Spring技术栈，JavaEE开发的一站式解决方案 参考：Spring官网 https://spring.io/projects 2. 为什么使用SpringBoot？优点： 快速创建独立运行的Spring项目并与主流框架集成 内置Servlet容器，应用无需打成WAR包 使用starter(启动器)管理依赖并进行版本控制 大量的自动配置，简化开发 提供准生产环境的运行时监控，如指标、健康检查、外部配置等 无需配置XML，没有冗余代码生成，开箱即用 二、第一个SpringBoot程序1. 环境要求 SpringBoot 2.x JDK 8及以上 Maven 3.5及以上 Tomcat 9及以上 2. 操作步骤步骤： 创建一个maven的java工程 传统web应用需要创建一个web工程，后期要打成war包，然后放到tomcat中，太麻烦 而SpringBoot应用只需要创建一个java工程，后期直接打成可执行的jar包，其内置tomcat 导入SpringBoot的相关依赖 12345678910111213&lt;!-- 继承SpringBoot的父工程 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- 添加web应用的starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写Controller 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; return &quot;Hello World&quot;; &#125;&#125; 编写主程序类，用来启动SpringBoot应用 12345678910/** * 使用@SpringBootApplication标注主程序类，表示这是一个SpringBoot应用 */@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 启动SpringBoot应用 SpringApplication.run(MainApplication.class, args); //传入主程序类的Class对象 &#125;&#125; 注：主程序类必须放到其他类的上层包中，因为默认只扫描主程序类所在的包及其子包 运行主程序并访问测试 http://localhost:8080/hello 部署打包 添加spring-boot-maven-plugin插件，将应用打成可执行的jar包，然后直接执行java -jar springboot01-helloworld-1.0-SNAPSHOT.jar 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 分析HelloWorldPOM文件： 父项目是spring-boot-starter-parent 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt; 父项目的父项目是spring-boot-dependencies，用来管理SpringBoot应用中依赖的版本，进行版本控制 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt; 通过启动器starter指定依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 主程序类： @SpringBootApplication 标注在类上，表示这是一个SpringBoot应用，通过运行该类的main方法来启动SpringBoot应用 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration 标注在类上，表示这个类是SpringBoot的配置类 层级关系：@SpringBootConfiguration——&gt;@Configuration——&gt;@Component @Configuration标注在类上，表示这个类是Spring的配置类，相当于是一个xml配置文件 @EnableAutoConfiguration 开启自动配置功能，SpringBoot会自动完成许多配置，简化了以前繁琐的配置 @ComponentScan 标注在类上，指定要扫描的包，默认只扫描主程序类所在的包及其子包 可以使用@ComponentScan手动指定要扫描的包 三、基本用法1. 快速创建项目步骤： 使用Spring Initializer快速创建SpringBoot项目 ​ 选择SpringBoot 2.x 版本 ​ 勾选Web、Lombok模块 基本操作 ​ 默认生成的.mvn、.gitignore、mvnw、mvnw.cmd，可以直接删除 ​ resources文件夹的目录结构 1234|-resources |-static // 存放静态资源，如css、js、imgs等 |-templates // 存放模板页面，可以使用模板引擎，如thymeleaf、freemarker等 |-application.properties // SpringBoot应用的配置文件，可以修改默认设置 ​ 注：SpringBoot生成的可执行jar包使用嵌入式的Tomcat，默认不支持JSP 修改banner图案 ​ 在resources&#x2F;目录下创建名为banner.txt的文件，内容如下生成 ​ 在线生成：https://patorjk.com/software/taag ​ 经典图案 ：https://blog.csdn.net/vbirdbest/article/details/78995793 1234567891011121314151617181920212223::Spring Boot Version:: $&#123;spring-boot.version&#125;////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88&quot; . &quot;88 //// (| ^_^ |) //// O\\ = /O //// ____/`---&#x27;\\____ //// .&#x27; \\\\| |// `. //// / \\\\||| : |||// \\ //// / _||||| -:- |||||- \\ //// | | \\\\\\ - /// | | //// | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | //// \\ .-\\__ `-` ___/-. / //// ___`. .&#x27; /--.--\\ `. . ___ //// .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. //// | | : `- \\`.;`\\ _ /`;.`/ - ` : | | //// \\ \\ `-. \\_ __\\ /__ _/ .-` / / //// ========`-.____`-.___\\_____/___.-`____.-&#x27;======== //// `=---=&#x27; //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG ////////////////////////////////////////////////////////////////////// 2. 配置文件2.1 简介SpringBoot的默认全局配置文件有两个： application.properties application.yml 注：文件名固定，存放在classpath:/ 或 classpath:/config/目录下 2.2 YAML文件YAML是专门用来写配置文件的语言，文件的后缀名为.yml，语法规则： 使用缩进表示层级关系，相同层级的元素左侧要对齐 键和值之间以冒号+空格隔开 key: value # 表示注释 1234server: port: 8081 servlet: context-path: /springboot02 2.3 多环境切换针对不同的环境，可以提供不同的配置，例如，不同环境下使用的数据库配置大多是不同的 常用的环境： 开发环境 dev 测试环境 test 生产环境 prod 可以通过命名约定来定义多个配置文件，格式：application-&#123;profile&#125;.yml 然后在application.yml文件中使用spring.profiles.active 来激活某一个环境配置 123spring: profiles: active: dev 3. 热部署​ 使用SpringBoot提供的devtools实现热部署 ​ 原理：实时监控classpath下文件的变化（即编译后的target目录），如果发生变化则自动重启 ​ 配置：添加devtools的依赖即可（需要开启IDEA的自动编译） 1234567&lt;!-- devtools热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 补充：开启IDEA的自动编译，IDEA默认是不自动编译的 Settings——&gt;搜索Compiler——&gt;勾选Build project automatically Help——&gt;Find Action——&gt;搜索Registry——&gt;勾选compiler.automake.allow.parallel 4. 定义配置类4.1 添加组件通过定义配置类 向容器中添加组件，使用注解：@Configuration和@Bean 123456789101112// 标注在类上，表示这是一个配置类，相当于以前编写的Spring配置文件@Configurationpublic class SpringConfig &#123; // 标注在方法上，向容器中添加一个组件，将方法的返回值添加到容器中，方法名作为组件id @Bean public Date date()&#123; Calendar c = Calendar.getInstance(); c.set(2008,5,10); return c.getTime(); &#125;&#125; 4.2 跨域访问定义一个配置类，实现WebMvcConfigurer接口，重写addCorsMappings方法 123456789101112@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOriginPatterns(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;*&quot;) .maxAge(3600); &#125;&#125; 5. 数据校验5.1 简介数据校验就是数据的合法性检查，在服务器端也可以对数据进行校验，一般使用 JSR303 校验 JSR303是Java为Bean数据合法性校验提供的标准框架，是一种声明式校验 JSR303通过在Bean属性上标注类似于@NotNull、@Max等注解来指定校验规则，并通过标准的验证接口对Bean进行验证 注解 功能 @Null 必须为null @NotNull 不能为null @NotBlank 字符串不能为null，且长度大于 0，会去掉前后空格 @Max(value) 数字必须小于等于指定值 @Min(value) 数字必须大于等于指定值 @Size(min,max) 长度必须在指定的范围内（可以是字符串、数组、集合等） @Past 时间必须是过去的时间 @Future 时间必须是将来的时间 @Pattern 必须符合指定的正则表达式 JSR303的扩展： Hibernate Validator扩展注解 Hibernate Validator是JSR303的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解 注解 功能 @Length(min,max) 字符串长度必须在指定范围之间 @NotEmpty 字符串不能为空 @Email 必须是合法的邮箱 @Range(min,max,message) 数值必须在指定的范围内 5.2 基本用法步骤： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在Bean上添加校验注解 12345678910111213141516171819202122@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable &#123; private Integer id; @NotBlank(message = &quot;用户名不能为空&quot;) private String username; @NotBlank(message = &quot;密码不能为空&quot;) @Length(min = 6,max = 12,message = &quot;密码长度必须在6~12之间&quot;) private String password; @Range(min = 18,max = 30,message = &quot;年龄只能在18~30之间&quot;) private int age; @NotNull(message = &quot;生日不能为空&quot;) @Past(message = &quot;生日必须是过去的时间&quot;) @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birthday;&#125; 在方法形参前添加@Valid注解 12345678910@RestControllerpublic class AjaxController &#123; @RequestMapping(&quot;/addUser&quot;) public String addUser(@Valid User user)&#123; // @Valid 开启对User对象的数据校验 System.out.println(user); return &quot;success&quot;; &#125;&#125; 6. 定时任务6.1 简介在项目开发中，经常需要编写定时任务来执行一些周期性的任务。 比如定时备份数据库、定时发送邮件、定时清理数据、定时提醒或通知等。 例如生活中网上购物时如果用户收到了商品，但一直没有确认收货，过了一个星期这个订单就需要自动转变为已收货状态，这种实时性不高的情景就可以用定时任务实现。 定时任务的实现： Quartz框架：是一个开源的任务调度框架 Spring Boot内置定时任务 Cron表达式是一个字符串，由6个字段组成，每个字段使用空格隔开 ，用于指定定时任务的执行时间。也称为七子表达式 字段 取值范围 说明 秒 0-59 分 0-59 时 0-23 日 1-31 月 1-12 星期 0-7 0和7都表示星期日 年 1970~2099 此项非必需，可以省略 使用以下特殊字符来指定执行时间： 星号（*）：表示匹配该字段的所有可能值 问号（?）：表示不关心该字段具体的值 斜线（&#x2F;）：表示指定一个间隔 逗号（,）：表示列举多个值 连字符（-）：表示指定一个范围 6.2 基本用法我们可以使用Spring Boot提供的定时任务，非常简单。 步骤： 定制任务，使用@Scheduled 1234567891011121314@Componentpublic class MyScheduledTasks &#123; @Scheduled(fixedRate = 3000) // 每隔3秒执行一次 public void task1() &#123; System.out.println(&quot;定时任务1执行了！&quot;); &#125; @Scheduled(cron = &quot;0 0 3 * * ?&quot;) // 每天凌晨3点执行 public void task2() &#123; System.out.println(&quot;定时任务2执行了！&quot;); &#125;&#125; 启用定时任务，使用@EnableScheduling 123456789@SpringBootApplication@EnableScheduling // 开启定时任务public class Springboot02QuickApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot02QuickApplication.class, args); &#125;&#125; 7. 日志SLF4j是一个日志标准，提供了日志接口，并不是日志系统的具体实现，其具体实现有：log4j、log4j2、slf4j-simple、logback等。 SpringBoot默认使用的日志是logback 常见的日志级别： debug、info、warn、error 使用步骤： 创建logback.xml日志配置文件，默认会自动加载该文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;!--日志存放目录--&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;./logs&quot; /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式：%d表示日期，%thread表示线程名，%-5level表示级别从左显示5个字符宽度，%logger&#123;50&#125;表示logger名字最长50个字符，%msg表示日志消息，%n表示换行符 --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 DEBUG --&gt; &lt;appender name=&quot;DEBUG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;!--日志文件名--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/debug/manage-remote-debug.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;16&lt;/MaxHistory&gt; &lt;!--日志文件切割大小--&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--过滤日志级别--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 INFO --&gt; &lt;appender name=&quot;INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/info/manage-remote-info.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;16&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 WARN --&gt; &lt;appender name=&quot;WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/warn/manage-remote-warn.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;24&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 ERROR --&gt; &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/error/manage-remote-error.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;32&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 设置logger --&gt; &lt;logger name=&quot;net.wanho&quot; level=&quot;debug&quot;/&gt; &lt;!-- 设置root --&gt; &lt;root level=&quot;warn&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;INFO&quot; /&gt; &lt;appender-ref ref=&quot;WARN&quot; /&gt; &lt;appender-ref ref=&quot;ERROR&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; 记录日志 123456789101112131415161718192021@Slf4j // lombok注解，自动创建log对象public class LogTest &#123; // private static final Logger log = LoggerFactory.getLogger(LogTest.class); @Test public void test() &#123; log.debug(&quot;debug消息&quot;); log.info(&quot;info消息&quot;); log.warn(&quot;warn消息&quot;); log.error(&quot;error消息&quot;); try &#123; System.out.println(5/0); &#125; catch (Exception e) &#123; log.error(e.getMessage()); throw new RuntimeException(e); &#125; &#125;&#125; 注：可以在IDEA中安装Grep Console插件，便于在控制台以不同颜色区别日志级别 四、整合MyBatis123456789drop database if exists springboot;create database springboot charset utf8;use springboot;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(100) not null unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 1. MyBatis步骤： 创建一个工程，选择以下模块：Web、MyBatis、Lombok 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt; 注：SpringBoot默认使用的连接池是HikariCP，是一款轻量、高性能的连接池。 配置application.yml 12345678910111213# 配置MyBatismybatis: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml configuration: # 打印sql log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 下划线映射为驼峰 map-underscore-to-camel-case: true# 配置PageHelperpagehelper: helper-dialect: mysql 使用@MapperScan指定Dao接口所在的包 12345678@SpringBootApplication//指定Dao接口所在的包，动态创建Dao实现类@MapperScan(&quot;net.wanho.mapper&quot;)public class Springboot04MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04MybatisApplication.class, args); &#125;&#125; 配置Dao、Service、Controller等 可以在Dao接口上添加@Repository 或 @Mapper，以解决在Service层注入时提示找不到bean的问题 2. MyBatis-Plus参考：http://mp.baomidou.com 2.1 基本用法步骤： 创建一个springboot工程，选择以下模块：Web、Lombok 添加依赖 1234567891011121314151617&lt;!--mbyatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920212223242526# 配置DataSourcespring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8 username: root password: root initialSize: 5 maxActive: 50 minIdle: 3 maxWait: 5000# 配置MyBatis-Plusmybatis-plus: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml configuration: # 打印sql log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 下划线映射为驼峰 map-underscore-to-camel-case: true global-config: db-config: # id-type: auto # 使用数据库的自动增长，不可作为分布式ID使用 id-type: assign_id # 使用雪花算法自动生成long类型的数字，分布式的情况下可使用 配置MybatisPlusConfig 1234567891011121314@Configuration@MapperScan(&quot;net.wanho.mapper&quot;)public class MyBatisPlusConfig &#123; /** * 配置MP的分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 定义Mapper，继承BaseMapper 12345/** * 继承BaseMapper接口，通用Mapper */public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 注：当数据库表名和字段名 与 类名和属性名不一致时，需要使用@TableName、@TableId、@TableField注解对实体类进行标注 定义Service，使用通用Service 12345678910111213/** * 继承IService接口，通用Service */public interface UserService extends IService&lt;User&gt; &#123;&#125;/** * 继承ServiceImpl类，通用Service实现类 */@Service@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125; 使用Mybatis-plus提供的接口 2.2 逻辑删除物理删除和逻辑删除： 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 步骤： 在表中添加逻辑删除标识列 1is_deleted tinyint default 0 comment &#x27;是否删除（0表示正常，1表示删除）&#x27; 在实体类中添加逻辑删除属性 123@TableLogic@TableField(value = &quot;is_deleted&quot;)private Integer isDeleted; ​ 也可以进行全局配置 123456mybatis-plus: global-config: db-config: logic-delete-field: isDeleted # 全局逻辑删除字段 logic-delete-value: 1 # 标识删除的值(默认为1) logic-not-delete-value: 0 # 逻辑未删除值(默认为0) 测试 测试删除：实际上执行的是更新操作 12-- 实际执行的SQLupdate t_user set is_deleted=1 where id = 1 and is_deleted=0 ​ 测试查询：不会查询被逻辑删除的数据 12-- 实际执行的SQLselect id,username,password,is_deleted t_from user where is_deleted=0 2.3 自动填充在对数据库表进行操作时经常会遇到一些字段，每次都使用相同的方式填充值，比如创建时间、更新时间等。 在阿里巴巴的开发手册中建议每个数据库表都必须要有create_time 和 update_time字段，以便记录每次操作的时间。 此时我们可以使用MyBatis Plus的自动填充功能，完成这些字段的自动填充赋值。 步骤： 在表中添加列 12create_time datetime comment &#x27;创建时间&#x27;,update_time datetime comment &#x27;更新时间&#x27; 在实体类中添加属性 12345@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 创建元对象处理器，实现MetaObjectHandler接口，用于对字段进行填充 1234567891011121314151617@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill ....&quot;); this.strictInsertFill(metaObject, &quot;createTime&quot;, () -&gt; new Date(), Date.class); this.strictInsertFill(metaObject, &quot;updateTime&quot;, () -&gt; new Date(), Date.class); &#125; @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;start update fill ....&quot;); this.strictUpdateFill(metaObject, &quot;updateTime&quot;, () -&gt; new Date(), Date.class); &#125;&#125; 测试 ​ 测试新增：会自动对create_time和update_time进行填充赋值 ​ 测试修改：会自动对update_time进行填充赋值 五、Restful API1.简介Representational State Transfer，简称为REST， 即表现层状态转化 Restful是一种网络应用程序的设计方式与开发方式，基于HTTP 表现层 Representational 资源的表现层，指的是资源的具体呈现形式，如HTML、JSON等 状态转化 State Transfer 指的是状态变化，通过HTTP方法来实现 通过不同的请求方式实现不同的功能，实现表现层状态转化 GET 获取资源，即查询操作 POST 新建资源，即添加操作 PUT 更新资源，即修改操作 DELETE 删除资源，即删除操作 2.设计原则Restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计 Restful API设计原则： 尽量将API 部署在一个专用的域名下，如 http://wanho.net/api 或 http://api.wanho.net API的版本应该在URL中体现，如 http://wanho.net/api/v2 URL中不要使用动词，应使用资源名词，且使用名词的复数形式，如： 功能说明 请求类型 URL 获取用户列表 GET http://wanho.net/api/v2/users 根据id获取用户 GET http://wanho.net/api/v2/users/id 添加用户 POST http://wanho.net/api/v2/users 根据id删除用户 DELETE http://wanho.net/api/v2/users/id 修改用户 PUT http://wanho.net/api/v2/users 注：简单来说，可以使用同一个 URL ，通过约定不同的 HTTP 方法来进行不同的业务操作 服务器响应时返回JSON对象，包含业务逻辑状态码、响应的消息、响应的查询结果 3. 基本用法​ @GetMapping ​ @PostMapping ​ @PutMapping ​ @DeleteMapping 4. 接口测试Postman​ Postman是一款非常优秀的调试工具，可以用来模拟发送各类HTTP请求，进行接口测试。 六、API接口文档1. 简介通常情况下，我们会创建一份API文档来记录所有的接口细节，供其他开发人员使用提供的接口服务，但会存在以下的问题： 接口众多，并且细节复杂 需要根据接口的变化，不断修改API文档，非常麻烦，费时费力 Swagger的出现就是为了解决上述的这些问题，减少创建API文档的工作量 后端人员在代码里添加接口的说明内容，就能够生成可预览的API文档，无须再维护Word文档 让维护文档和修改代码整合为一体，在修改代码逻辑的同时方便的修改文档说明 提供了页面测试功能，便于对接口进行测试 Knife4j是对Swagger的封装，对接口文档UI进行了优化，并做了增强，用起来更方便 2. 使用步骤使用步骤： 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt; 创建配置类 1234567891011121314151617181920212223242526272829303132@Configuration@EnableKnife4j // 启用Knife4jpublic class Knife4jConfig &#123; /** * 创建Restful API文档内容 */ @Bean public Docket Api() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .groupName(&quot;商城模块&quot;) .select() // 指定要暴露的接口所在包 .apis(RequestHandlerSelectors.basePackage(&quot;net.wanho.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; /** * API的基本信息 */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;商城项目后端API接口文档&quot;) .description(&quot;欢迎访问后端API接口文档&quot;) .contact(new Contact(&quot;tangxiaoyang&quot;,&quot;https://github.com/tangyang8942&quot;,&quot;tangxiaoyang@qq.com&quot;)) .version(&quot;1.0&quot;) .build(); &#125;&#125; 配置application.yml 1234spring: mvc: pathmatch: matching-strategy: ant_path_matcher # 用于解决SpringBoot2.6+版本与Swagger的兼容性问题 添加文档内容 使用Swagger提供的注解对接口进行说明，常用注解： @Api 标注在类上，对类进行说明 @ApiOperation 标注在方法上，对方法进行说明 @ApiParam 标注在参数上，对方法的参数进行说明 @ApiModel 标注在模型Model上，对模型进行说明 @ApiModelProperty 标注在属性上，对模型的属性进行说明 @ApiIgnore 标注在类或方法上，表示忽略这个类或方法 查看接口文档页面，并测试接口 启动SpringBoot程序，访问http://localhost:端口/doc.html，查看接口文档 可以在接口文档中对接口进行测试 七、代码生成器Generator1. 简介MyBatis-Plus代码生成器，快速生成 Entity、Mapper、Service、Controller 层代码，支持模板引擎自定义配置 12345678910111213141516171819202122232425drop database if exists springboot;create database springboot charset utf8;use springboot;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(100) not null unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, is_deleted tinyint default 0 comment &#x27;是否删除（0表示正常，1表示删除）&#x27;, create_time datetime comment &#x27;创建时间&#x27;, update_time datetime comment &#x27;更新时间&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;;create table t_dept( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;部门名称&#x27;)engine innodb default charset utf8 comment &#x27;部门表&#x27;;create table t_emp( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;姓名&#x27;, salary double comment &#x27;工资&#x27;, dept_id int comment &#x27;部门编号&#x27;, foreign key (dept_id) references t_dept(id))engine innodb default charset utf8 comment &#x27;员工表&#x27;; 2. 基本用法步骤： 创建一个SpringBoot工程，选择以下模块：Web、Lombok 添加依赖 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--mbyatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-plus-generator--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--beetl模板引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;com.ibeetl&lt;/groupId&gt; &lt;artifactId&gt;beetl&lt;/artifactId&gt; &lt;version&gt;3.15.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--guava--&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;32.0.0-jre&lt;/version&gt;&lt;/dependency&gt; 快速生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class CodeGenerator &#123; private static String projectPath = &quot;/Users/txy/code/IdeaProjects/framework/springboot05-generator&quot;; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator generator = new AutoGenerator(); // 1、全局配置 GlobalConfig gc = new GlobalConfig(); gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); gc.setAuthor(&quot;汤小洋&quot;); gc.setOpen(false); gc.setFileOverride(true); // 重新生成时文件是否覆盖 gc.setServiceName(&quot;%sService&quot;); // Service接口的命名方式 gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); gc.setBaseResultMap(true); gc.setBaseColumnList(true); generator.setGlobalConfig(gc); // 2、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;); dsc.setDriverName(&quot;com.mysql.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); generator.setDataSource(dsc); // 3、包配置 PackageConfig pc = new PackageConfig(); pc.setParent(&quot;net.wanho&quot;); pc.setEntity(&quot;po&quot;); // entity 层 pc.setMapper(&quot;mapper&quot;); // mapper 层 pc.setService(&quot;service&quot;); // service层 pc.setController(&quot;controller&quot;); // controller 层 generator.setPackageInfo(pc); // 4、自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setTablePrefix(&quot;t_&quot;); // 过滤表前辍 strategy.setNaming(NamingStrategy.underline_to_camel); //数据库表映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); //数据库列映射到实体属性的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 // 逻辑删除 strategy.setLogicDeleteFieldName(&quot;is_deleted&quot;); // 自动填充 List&lt;TableFill&gt; tableFillList = new ArrayList&lt;&gt;(); tableFillList.add(new TableFill(&quot;create_time&quot;, FieldFill.INSERT)); tableFillList.add(new TableFill(&quot;update_time&quot;, FieldFill.INSERT_UPDATE)); strategy.setTableFillList(tableFillList); generator.setStrategy(strategy); // 6、设置解析模板 generator.setTemplateEngine(new BeetlTemplateEngine() &#123; // 获取主键 String primaryKey = &quot;&quot;; String primaryKeyUnderline=&quot;&quot;; @Override public AbstractTemplateEngine init(ConfigBuilder configBuilder) &#123; AbstractTemplateEngine engine = super.init(configBuilder); // 映射文件放到resources目录下 configBuilder.getPathInfo().put(&quot;xml_path&quot;, projectPath + &quot;/src/main/resources/mapper/&quot; + pc.getModuleName()); return engine; &#125; @Override public Map&lt;String, Object&gt; getObjectMap(TableInfo tableInfo) &#123; for (TableField tableField : tableInfo.getFields()) &#123; if (tableField.isKeyFlag()) &#123; primaryKey = tableField.getPropertyName(); primaryKeyUnderline = tableField.getName(); break; &#125; &#125; // 获取源码中的map Map objectMap = super.getObjectMap(tableInfo); // 额外添加两个键值对 objectMap.put(&quot;entityCamel&quot;, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, tableInfo.getEntityName())); objectMap.put(&quot;primaryKey&quot;, primaryKey); objectMap.put(&quot;primaryKeyUnderline&quot;, primaryKeyUnderline); return objectMap; &#125; &#125;); // 7、执行生成 generator.execute(); &#125;&#125; 自定义模板 可以根据需求自定义模板 entity.java.btl mapper.java.btl mapper.xml.btl service.java.btl serviceImpl.java.btl controller.java.btl 测试 3. 多表查询MyBatis-Plus默认只能完成单表的操作，多表操作仍然需要自己写。 步骤： 在Emp实体类中添加属性 123@ApiModelProperty(value = &quot;部门&quot;)@TableField(exist = false) // 表示该属性不是数据库表中的字段private Dept dept; 编辑EmpMapper.java和EmpMapper.xml 123456public interface EmpMapper extends BaseMapper&lt;Emp&gt; &#123; List&lt;Emp&gt; selectAll(); IPage&lt;Emp&gt; selectByPage(IPage&lt;Emp&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;Emp&gt; queryWrapper);&#125; 1234567891011121314151617&lt;resultMap id=&quot;EmpMap&quot; type=&quot;Emp&quot; extends=&quot;BaseResultMap&quot;&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;dept_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;dept_name&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap&quot;&gt; select e.*, d.name as dept_name from t_emp e left join t_dept d on e.dept_id = d.id&lt;/select&gt;&lt;select id=&quot;selectByPage&quot; resultMap=&quot;EmpMap&quot;&gt; select e.*, d.name as dept_name from t_emp e left join t_dept d on e.dept_id = d.id $&#123;ew.customSqlSegment&#125;&lt;/select&gt; 编辑EmpService和EmpServiceImpl 123456public interface EmpService extends IService&lt;Emp&gt; &#123; List&lt;Emp&gt; findAll(); IPage&lt;Emp&gt; findByPage(IPage&lt;Emp&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;Emp&gt; queryWrapper);&#125; 12345678910111213@Servicepublic class EmpServiceImpl extends ServiceImpl&lt;EmpMapper, Emp&gt; implements EmpService &#123; @Override public List&lt;Emp&gt; findAll() &#123; return this.baseMapper.selectAll(); &#125; @Override public IPage&lt;Emp&gt; findByPage(IPage&lt;Emp&gt; page, Wrapper&lt;Emp&gt; queryWrapper) &#123; return this.baseMapper.selectByPage(page,queryWrapper); &#125;&#125; 测试 123456789101112131415161718192021@SpringBootTestclass EmpServiceImplTest &#123; @Resource private EmpService empService; @Test public void findAll() &#123; System.out.println(empService.findAll()); &#125; @Test public void findByPage() &#123; Page&lt;Emp&gt; page = new Page&lt;&gt;(1, 3); QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.likeRight(&quot;e.name&quot;, &quot;1&quot;); empService.findByPage(page, wrapper); System.out.println(page.getRecords()); &#125;&#125; 八、MyBatis-Plus-Join1. 简介官网 https://mybatisplusjoin.com/ 2. 基本用法步骤： 添加依赖 123456&lt;!--mybatis-plus-join--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-join-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.5&lt;/version&gt;&lt;/dependency&gt; 编辑EmpMapper.java，继承自MPJBaseMapper 12public interface EmpMapper extends MPJBaseMapper&lt;Emp&gt; &#123;&#125; 测试 12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass EmpMapperTest &#123; @Resource private EmpMapper empMapper; @Test public void selectAll()&#123; MPJLambdaWrapper&lt;Emp&gt; wrapper = new MPJLambdaWrapper&lt;Emp&gt;() .selectAll(Emp.class) // 查询Emp类的所有字段 .selectAs(Dept::getName, EmpDTO::getDeptName)// 查询Dept类的name字段 .leftJoin(Dept.class, Dept::getId, Emp::getDeptId) // 左连接 .orderByDesc(Emp::getId); List&lt;EmpDTO&gt; list = empMapper.selectJoinList(EmpDTO.class, wrapper); list.forEach(System.out::println); &#125; @Test public void selectByPage()&#123; Page&lt;EmpDTO&gt; page = new Page&lt;&gt;(1, 3); empMapper.selectJoinPage(page, EmpDTO.class, new MPJLambdaWrapper&lt;Emp&gt;() .selectAll(Emp.class) .selectAs(Dept::getName, EmpDTO::getDeptName) .leftJoin(Dept.class, Dept::getId, Emp::getDeptId) .eq(Dept::getId, 1)); page.getRecords().forEach(System.out::println); &#125;&#125; 九、综合案例基于SpringBoot的日记管理系统（diary） 后端 SpringBoot 前端 LayUI","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Vue基础学习(三)","slug":"Vue基础学习-三","date":"2023-08-15T04:58:17.000Z","updated":"2023-08-15T05:00:12.576Z","comments":true,"path":"2023/08/15/Vue基础学习-三/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%B8%89/","excerpt":"","text":"一、组件化与模块化1. 组件化​ 组件化，是从UI界面的角度进行划分的，将页面构成拆分为一个个组件，方便UI组件的重用 ​ 组件包含：页面构成（template）、样式（css）、功能（js） 2. 模块化​ 模块化，是从代码逻辑的角度进行划分的，将项目按照一定的规则拆分成一个个模块，进行组合使用 ​ 方便代码的分层开发，保证每个功能模块的职能单一 二、构建模块化环境1. 开发环境模块化开发一般需要独立的开发环境，一般都基于 Node.js 和 webpack 进行环境搭建 Node.js 独立JS运行环境和模块系统支持 webpack 自动化的前端构建工作流工具，类似于gulp，但功能更强大 Vue模块化项目环境搭建，可以通过官方提供的环境构建工具 Vue CLI ，称为Vue脚手架 2. Vue脚手架2.1 简介 @vue/cli是一个Vue脚手架，用来快速构建模块化项目结构 cli：command line interface 命令行接口 通过命令行的方式快速构建Vue模块化项目运行环境 2.2 安装脚手架系统环境： node环境：node -v npm环境：npm -v nrm环境： nrm ls 安装@vue&#x2F;cli： 全局安装：npm install @vue/cli -g （需要具有管理员权限） 验证安装：vue --version 查看帮助：vue --help 常用命令： 创建项目：vue create 项目名 或 vue ui 为项目增加扩展插件：vue add 插件 3. 使用脚手架创建项目切换到项目的存放目录，执行 vue create 项目名称，进入交互模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 1.选择构建模式Vue CLI v4.1.2? Please pick a preset: (Use arrow keys) default (babel, eslint) # 默认选项，只包含基础依赖 ——&gt; 直接执行第6步❯ Manually select features # 自定义环境，手动选择特性依赖 # 2.自定义环境的选择Vue CLI v4.1.2? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) # 选择需要的环境特性 ❯◉ Babel # ES6语法兼容转换器（Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，避免运行环境不支持） ◯ TypeScript # TS语法支持 ◯ Progressive Web App (PWA) Support # 构建渐进式Web应用，优化用的 ◯ Router # 集成路由功能 ◯ Vuex # 集成统一数据状态管理器 ◉ CSS Pre-processors # CSS预编译，支持使用LESS、SASS等动态样式语言 ◉ Linter / Formatter # 代码规范检查和格式化检测 ◯ Unit Testing # 单元测试 ◯ E2E Testing # 端到端测试 # 3.所选环境的进一步配置# 如果选择了CSS Pre-processors，则需要选择 动态样式语言? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys) Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) ❯ Less Stylus # 如果选择Linter / Formatter，则需要选择 代码规范检查的规则? Pick a linter / formatter config: (Use arrow keys)❯ ESLint with error prevention only # 使用ESLint，仅检测错误（ESLint是用来统一代码规范和风格的工具） ESLint + Airbnb config # 使用 eslint+airbnb 前端规范 ESLint + Standard config # 使用标准规范 ESLint + Prettier # 使用严格规范# 选择代码规范检查的时机? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◉ Lint on save # 文件保存时 ◯ Lint and fix on commit # 代码整理和提交时 # 4.选择工具配置文件的存放位置? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)❯ In dedicated config files # 存放在独立的配置文件中 In package.json # 集成在package.json文件中 # 5.是否将上述配置保存为一个预设选项，方便以后创建项目使用? Save this as a preset for future projects? Yes? Save preset as: mypreset# 6.创建项目，安装所需依赖Vue CLI v4.1.2✨ Creating project in /Users/appleuser/Desktop/aa-aa.🗃 Initializing git repository...⚙ Installing CLI plugins. This might take a while..........🎉 Successfully created project first-project.👉 Get started with the following commands: 4. 启动项目切换到项目的根目录，执行 npm run serve 启动开发服务器，然后根据提示url访问 npm run 命令名称 是npm内置的脚本执行命令，该命令会自动搜索执行目录下package.json文件中的scripts对应的命令并执行 三、项目结构1. 文件结构​ 通过多个关联文件构成模块化开发环境，最终由webpack工具进行打包合并 12345678910111213141516|-项目名称 |-node_modules # 项目运行所依赖的模块，内容较多，文件较大，拷贝项目时一般不拷贝此目录，可通过npm install自动下载安装 |-public # 项目的静态资源目录，如html、css、js、image等，服务器访问的根目录，对外公开的资源 |-index.html # 默认访问的页面文件 |-src # 源代码目录 |-assets # 静态资源目录 |-components # 自定义组件目录 |-App.vue # 项目的主组件 |-main.js # 项目的启动文件 |-.browserslistrc # 项目的浏览器适配版本 |-.eslintrc.js # eslint配置文件，定义语法校验规则 |-.gitignore # git配置文件，定义忽略文件列表 |-babel.config.js # babel配置文件，定义ES语法转换规则 |-package-lock.json # 对项目的安装模块信息进行本地记录 |-package.json # node项目的描述文件，定义项目的相关描述信息 |-README.md # 项目的说明文件，对项目进行说明介绍 2. 核心文件详解​ Vue模块化项目启动时会自动查找两个核心文件： index.html 和 main.js 2.1 index.html​ index.html是访问应用时默认显示的页面文件，也是Vue项目的容器定义文件 2.2 main.js​ main.js是项目的启动文件，也是Vue模块化项目的整合入口文件 123456/** * 使用ES6提供的模块导入导出功能 */import 模块名 from 文件路径 // 导入模块，模块名可自定义export default &#123;&#125; // 导出模块，默认导出 2.3 App.vue​ App.vue是Vue中提供的一种特殊的组件定义文件，这类文件用于描述模块化项目中的组件 ​ App.vue是项目的主组件，其他组件都是在该组件下加载的 3. 单文件组件​ 以.vue结尾的文件，是Vue.js自定义的一种文件格式，称为单文件组件 ​ 一个.vue文件就是一个单独的组件，在文件内封装了该组件相关的html、css和js，实现了对一个组件的封装 ​ .vue文件由三部分组成： 1234567891011&lt;template&gt; &lt;!-- html，组件的页面结构 --&gt;&lt;/template&gt;&lt;script&gt; // js，组件的功能配置&lt;/script&gt;&lt;style&gt; /* css，组件的样式 */&lt;/style&gt; 四、模块化开发1. 组件样式全局样式和局部样式： 在style标签中定义的样式，默认为全局样式，在所有组件中都有效 可以为style标签指定scoped属性，此时定义的样式为局部样式，只在当前组件中有效 用法：&lt;style scoped&gt; 动态样式支持： 可以为style标签指定lang属性，设置当前使用的样式语言，如：css、less、sass、stylus等 默认使用的是css语法，可以使用动态样式语言 用法：&lt;style lang=&quot;动态样式语言&quot;&gt; 2. 脚本架配置文件vue.config.js 是Vue脚手架@vue&#x2F;cli的全局配置文件，是一个可选的配置文件，如果不存在则使用默认配置，如果项目的根目录中存在这个文件，则项目运行时会自动加载 编辑vue.config.js文件 12345678module.exports = &#123; // 项目的基础url publicPath:&#x27;/film/&#x27;, // 开发服务器的配置 devServer: &#123; port: 8888 &#125;｝ 注：修改vue.config.js文件后，需要重启项目才生效 3. 项目打包当项目要部署上线时，需要先对开发环境的项目进行打包构建操作，生成一个由纯静态文件构成的项目 切换到项目的根目录，执行 npm run build 对项目进行打包构建操作 默认会在项目的根目录下生成一个dist目录，该目录中存放打包后的项目静态文件，可直接部署到生产环境中 打包后可将dist目录中的静态文件拷贝到任意Web服务器中部署运行 生产环境和开发环境： 由于生产环境和开发环境可能会有所不同，有时会导致资源无法访问，此时需要对环境进行配置 编辑vue.config.js文件 123456789101112module.exports = &#123; // 项目的基础url，所有静态资源在加载时的基础路径BASE_URL // publicPath:&#x27;/film/&#x27;, // 判断环境，分别指定生成环境production和开发环境development的地址 publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/film/&#x27; : &#x27;/&#x27;, // 开发服务器的配置 devServer: &#123; port: &#x27;8888&#x27; // 使用的端口 &#125;, // 打包时是否生成map文件，主要用于生成环境下调试js源代码，建议改为false productionSourceMap: false,&#125; 五、全局功能定义1. 简介用于统一定义全局的功能，如：全局组件、全局插件、全局过滤器、全局指令等 使用Vue提供的全局方法Vue.use()，一般在 main.js 文件中使用 Vue.use(Object) 参数Object是一个必须提供install方法的对象，Vue.use会自动调用执行install方法 2. 用法​ 全局组件、全局插件 六、数据交互1. 简介Vue模块化项目的数据交互，使用的就是AJAX技术，发送异步请求 实现异步请求的模块有很多，官方推荐使用 axios 模块 axios是一个基于Promise的HTTP请求客户端，用来发送AJAX请求 2. 安装axios切换到项目的根目录，执行 npm install axios --save 安装模块 在需要使用axios的文件中，通过import axios from &#39;axios&#39;导入模块 导入模块后，可以使用axios对象提供的方法： axios.get(url[, config]) axios.delete(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) 补充：Restful请求，根据HTTP请求方式来区分对资源的操作 GET 获取资源 POST 新建资源 PUT 更新资源 DELETE 删除资源 3. 用法3.1 基本用法使用axios.get(url[,config]) ，传参方式： 通过url传参，即查询字符串方式 通过params选项传参 使用axios.post(url[,data,[config]])，传参方式： 通过查询字符串方式 使用qs模块进行转换import qs from &#39;qs&#39; 注：对于post方式请求，axios发送数据时默认的数据格式为Request Payload，并非我们常用的Form Data格式，所以参数不能直接以json形式传递 3.2 全局引入全局引入axios并添加到Vue原型中，避免在组件中重复引用axios，简化使用 在main.js中导入axios模块 为Vue函数添加一个原型属性$http，指向axios对象 在组件中无需再引入axios模块，直接使用this.$http即可 4. 跨域访问发送请求时，如果协议、主机或端口，只要有任何一个不同，则为跨域访问 两种解决方式： 后端允许跨越访问，设置响应头为Access-Control-Allow-Origin 在前端构建代理服务器，进行请求的转发。配置代理服务器的步骤： 编辑vue.config.js文件 ，添加代理服务器配置 1234567// 配置代理服务器，解决开发阶段的跨域问题（只在开发阶段有效）proxy: &#123; &#x27;/data&#x27;: &#123; // 所有以/data开头的请求都需要被代理转发 target: &#x27;http://127.0.0.1:80&#x27;, // 转发到的目标服务器 logLevel: &#x27;debug&#x27; // 开启调试模式 &#125; &#125; 重启开发服务器，查看日志输出 七、路由1. 简介SPA应用：Single Page Application 单页应用程序 就是只有一个Web页面的应用，所有的操作都在这个页面上完成（容器页面） 浏览器一开始会加载相应的HTML、CSS和JavaScript，然后将所有的活动都局限在该Web页面中 当用户与应用程序交互时通过JavaScript动态更新页面中的内容 在开发SPA单页应用时，需要在不同的组件间切换，从而实现在一个容器页面中显示不同的内容 我们可以使用Vue Router来开发单页应用，根据不同的url地址，路由跳转到不同的组件 路由是一种组件动态分发机制，通过url路径进行组件的切换 根据url路径查找对应的组件，然后将组件显示到指定的页面位置 2. 基本用法创建项目时选择Router路由功能 123456789|-项目名称 |-node_modules |-vue-router # 路由模块 |-src |-router |-index.js # 路由配置文件 |-views # 视图组件目录 |-App.vue |-main.js 核心文件详解：main.js、index.js、App.vue 提供了两个路由组件 &lt;router-link&gt;组件：用来定义导航，默认会创建&lt;a&gt;标签，根据指定的url路径跳转到组件 &lt;router-view&gt;组件：用来渲染url路径对应的组件，将组件显示到当前定义的位置 3. 路由嵌套当应用由多层嵌套的组件构成时，需要使用嵌套路由 关于url路径的定义： 根路径 根路径就是/，默认访问项目时显示的就是根路径对应的组件，即默认显示的组件 嵌套路由的路径 子级路由可以使用相对路径或绝对路径 通配路径 可以使用通配符 *来设置当url路径不存在时显示的组件 4. 路由传参通过&lt;router-link&gt;的to属性传递参数 两种方式： 查询字符串传参 传递参数： 字符串形式 语法：to=&quot;路径?参数名=参数值&amp;参数名=参数值&quot; 对象形式 语法：:to=&quot;&#123;path:&#39;组件的url路径&#39;，query:&#123;key:value,key:value&#125;&#125;&quot; 或 ​ :to=&quot;&#123;name:&#39;组件的路由名称&#39;，query:&#123;key:value,key:value&#125;&#125;&quot; 获取参数： 使用路由对象vm.$route.query获取参数信息 Rest风格传参 传递参数： 字符串形式 语法：to=&quot;/路径/参数/参数&quot; 将参数伪装成请求地址的一部分 在定义路由时需要在url路径中通过:参数名指定参数 对象形式 语法：:to=&quot;&#123;name:&#39;组件的路由名称&#39;，params:&#123;key:value,key:value&#125;&#125;&quot; 对于Rest风格的对象形式传参，只能使用路由名称的形式 获取参数： 使用路由对象vm.$route.params获取参数信息 5. 路由对象路由对象$route，表示当前激活的路由的状态信息，称为激活路由信息对象 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$route访问，且访问的都是同一个对象 该对象中存储着当前激活路由的相关信息 123456$route.path // 当前激活路由的路径$route.fullPath // 当前激活路由的完整路径$route.name // 当前激活路由的名称，即命名路由的name$route.query // 当前激活路由的字符串查询传递的参数$route.params // 当前激活路由的rest方式传递的参数$route.meta // 当前激活路由的元信息 路由元信息： 在定义路由时，可以通过meta属性为当前路由指定一些自定义配置项，称为元信息 在组件中可以通过$route.meta获取到这些元信息 6. 路由守卫也称为路由导航守卫，用来对路由导航进行守卫，控制导航的跳转，可以进行权限的控制 全局前置守卫：使用 router.beforeEach 12345678const router = new VueRouter(&#123; ... &#125;)// 当一个导航触发时，全局前置守卫将被调用 router.beforeEach((to, from, next) =&gt; &#123; // to 即将要访问的目标路由对象 // from 来源于哪个路由对象 // next 是一个函数，表示下一步怎么做，如：next()表示放行，next(&#x27;/login&#x27;)表示跳转到/login路径 &#125;) 全局解析守卫：使用router.beforeResolve 全局后置钩子：使用router.afterEach 7. 路由模式通过mode选项可以修改路由的模式 两种模式： hash模式（默认值） 原理：使用HTML的锚点技术，实现路由匹配和跳转 ​ 通过location.hash获取url中的锚点值，完成 url 跳转，且不会重新加载页面，即不刷新页面 缺点：地址中会出现#号，比较丑陋 history模式 原理：使用HTML5的History技术 ​ 通过history.pushState 完成 url 跳转，且不会重新加载页面 缺点：在生产环境下，如果用户在浏览器中直接访问url路径，则会报错 Not Found ​ 所以在生产环境下，需要后台服务器的配置支持才行（在开发环境下是没问题的） 8. 编程式导航除了使用&lt;router-link&gt;组件来定义导航链接，还可以通过编写js代码，调用路由实例$router的方法来实现路由跳转，称为编程式导航 路由实例$router，表示构建路由时的实例对象，主要用来对路由进行控制，称为 路由控制对象 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$router访问，且访问的都是同一个对象 该对象中包含控制路由的相关方法 1234$router.push(location) // 跳转到指定页面，参数location可以为字符串或对象$router.forward() // 向前一步$router.back() // 后退一步$router.go(n) // 向前或后退多少步 八、Vuex1. 简介Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 采用集中式存储管理应用中所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 简单来说，就是用来集中管理数据的，统一维护项目中的数据状态，相当于是一个全局的数据存储对象store，在所有组件中都可以访问 应用场景：适合于大型的单页应用程序 2. 基本用法创建项目时选择Vuex功能 1234567|-项目名称 |-node_modules |-vuex # vuex模块 |-src |-store |-index.js # vuex配置文件 |-main.js Vuex的核心是store（存储），相当于是一个容器，核心概念： State 定义属性，用来存储状态数据 Getter 定义属性，用来获取从state派生出的状态数据，类似于计算属性 Mutation 定义变化，用来改变状态数据（突变），只能是同步操作，需要通过commit来提交变化mutations Action 定义方法，用来改变状态数据，可以包含异步操作，类似于mutations，但mutations只能是同步操作 Module 用来分模块组织Vuex 3. 使用Vuex3.1 在Vuex中定义状态配置store对象： 定义state 定义getters 定义mutations 定义actions 定义modules 3.2 在组件中访问状态在组件中访问store对象，两种方式： 方式1：通过存储对象$store访问 存储对象$store，表示Vuex中定义的数据存储对象store，包含Vuex中的所有数据信息 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$store访问，且访问的都是同一个对象 方式2：通过辅助函数访问 Vuex中提供了一些辅助函数，用于获取Vuex中的数据信息，如： mapState() 获取state mapGetters() 获取getters mapMutations() 获取mutations mapActions() 获取actions 注：需要先导入辅助函数import &#123;mapState,mapGetters,mapActions&#125; from &#39;vuex&#39; 4. 模块化当应用变得非常复杂时，store对象会变得相当臃肿，store&#x2F;index.js文件内容会非常多 此时可以将store分成多个模块，每个模块拥有自己的state、getters、mutations、actions 可以根据业务分模块，如：用户数据、产品数据、购物车数据、订单数据等 可以根据页面分模块，如：主页数据、搜索页数据、详情页数据等 Vuex模块化的项目结构： 12345678910111213|-src |-store |-index.js |-state.js // 根级别的state |-getters.js // 根级别的getters |-mutations.js // 根级别的mutations |-actions.js // 根级别的actions |-modules // 分为多个模块，每个模块都可以拥有自己的state、getters、actions、mutations |-user.js // 用户模块 |-product.js // 产品模块 |-cart.js // 购物车模块 |-order.js // 订单模块 |-.... 九、Element UI1. 简介​ Element是饿了么团队提供的一套基于Vue的桌面端组件库，可以快速的搭建网站，提高开发效率 ​ 官方文档 https://element.eleme.cn 2. 用法执行 vue add element为项目安装Element插件 123? How do you want to import Element? Fully import # 完整引入? Do you wish to overwrite Element&#x27;s SCSS variables? No ? Choose the locale you want to load zh-CN ​","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue基础学习(二)","slug":"Vue基础学习-二","date":"2023-08-15T04:44:48.000Z","updated":"2023-08-15T04:54:35.537Z","comments":true,"path":"2023/08/15/Vue基础学习-二/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/","excerpt":"","text":"一、组件1. 简介​ Component 组件是可复用的Vue实例，且带有一个名字，可以把组件作为自定义元素来使用 ​ 将项目中重复出现的页面结构定义为Vue的一个组件实例，或将特殊功能封装成组件 2. 构造器继承函数构造器继承函数，语法： Vue.extend(options) 以基础 Vue 构造器为蓝本，创建一个具有指定配置项的“子类”构造器，也称为组件构造器 可以使用该子类构造器来创建Vue实例（组件） data选项必须以函数形式声明，函数内返回一个包含初始数据的对象 二、定义组件组件分类： 全局组件，在所有Vue实例中都可以使用 局部组件，只能在构建组件的 Vue实例的容器范围内使用 1. 全局组件全局组件的定义，通过全局方法 Vue.component()来定义 两种写法 方式1：Vue.component(组件名, 组件构造器) 先创建组件构造器，然后由组件构造器创建组件 方式2：Vue.component(组件名, 选项对象) 直接创建组件，传入一个选项对象 本质上还是自动调用 Vue.extend 先创建组件构造器 注：组件必须在一个已存在的Vue实例中使用，不能在页面独立使用和存在 2. 局部组件​ 局部组件的定义，依赖于某个Vue实例，通过选项 components:&#123;&#125; 来定义 ​ 用法： 123456new Vue(&#123; components:&#123; &quot;component-a&quot;:Vue.extend(&#123; /* ... */ &#125;), &quot;component-b&quot;:&#123; /* ... */ &#125; &#125;&#125;) 三、组件间数据传递1. 组件间的关系​ 页面组件的关系结构，是一个由许多组件构成的树状结构，组件间存在着两种关系：父子关系、非父子关系 ​ 默认情况下，每个组件实例都是独立的，组件间无法直接访问数据，因此需要进行组件间的数据传递，也称为组件间的通信 2. 父子组件间的数据传递2.1 父向子传递数据技术：属性绑定+数据拦截 步骤： 父组件在调用子组件时，以属性绑定的方式将要传递的数据绑定在子组件标签上 在子组件对象中，使用props选项声明获取的数据，进行绑定属性的拦截，即接收来自父组件的数据 2.2 子向父传递数据技术：事件监听+事件触发 步骤： 父组件在调用子组件时，监听子组件触发的自定义事件，并在父组件中定义回调方法，用来接收数据 在子组件中使用vm.$emit(事件名,数据)触发自定义事件 补充： 子组件向父组件传递数据是不具有响应式的，即子组件数据发生变化时并不会主动触发$emit更新父组件中数据 可以监视子组件数据的变化，当数据发生变化时手动触发$emit更新父组件中数据 四、内置全局组件Vue提供了全局的内置组件，这些组件主要完成的都是功能封装 1. 动态组件多个组件使用同一个挂载点，然后动态地在它们之间切换，称为动态组件 用法：&lt;component :is=&quot;&quot;&gt;&lt;/component&gt; 2. 缓存组件缓存非活动的组件，可以保留组件状态，避免重新渲染，默认每次都会销毁非活动组件并重新创建 一般会结合动态组件使用，用于缓存非活动的组件实例，避免组件的重复创建和删除，提高性能 用法：&lt;keep-alive&gt;动态组件&lt;/keep-alive&gt; 注：&lt;keep-alive&gt;是一个抽象组件，它自身不会渲染为一个 DOM 元素，也不会出现在组件链中 3. 分发组件实现内容的分发，可以在定义组件时指定插槽位置，调用组件时提供要替换插槽位置的内容 在开发组件时，如果组件模板中部分内容暂时不确定，则可以通过&lt;slot&gt;插槽定义页面占位 当调用组件时，再定义对应的内容，会自动替换到插槽位置 用法：&lt;slot&gt;&lt;/slot&gt; 具名插槽：为插槽指定名称，根据插槽名称进行内容分发 在定义插槽时，在slot标签上通过name属性为插槽指定名称 在提供插槽内容时，通过为template标签指定v-slot指令，并以指令参数表示插槽名称 插槽数据作用域：让插槽内容能够访问子组件中的数据，通过作用域插槽控制内容分发时变量的取值范围 在定义插槽时，在slot标签上通过v-bind进行数据绑定 在提供插槽内容时，通过v-slot指令接收绑定的数据，获取的是一个自定义对象","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue基础学习","slug":"Vue基础学习","date":"2023-08-15T03:31:38.000Z","updated":"2023-08-15T03:49:00.320Z","comments":true,"path":"2023/08/15/Vue基础学习/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、MVVM1. 简介Model-View-ViewModel 模型-视图-视图模型 模型：构成页面内容的相关数据 视图：展示数据的页面 视图模型：介于模型和视图之间，它是连接view和model的桥梁，也是mvvm设计模式的核心思想 2. MVVM框架实现MVVM设计思想的框架： 基本上都高度封装了view-model的交互过程，完成对DOM功能的极限封装 开发者几乎不用操作DOM就可以完成页面和数据的关联交换 开发者只需关心页面的构成和数据的构成，无需关心页面和数据的状态关系 Vue、React、Angular等就是实现MVVM设计思想的前端框架 二、Vue1. 简介 Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架（入门简单、学习成本低，随着深入学习可以根据需求进行功能扩展） Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合 通过简洁的API实现响应的数据绑定和灵活的视图组件 由个人维护：尤雨溪，华人 2. 基本使用Vue的页面使用方式： 即在页面中直接引入Vue核心库的js文件 该方式只是为了让开发者在学习Vue语法时可以快速掌握 实际上Vue并不适合直接使用 页面方式进行语法定义，更推荐使用模块化方式 使用步骤： 获取Vue核心库的js文件 通过地址 https://cdn.jsdelivr.net/npm/vue/dist/vue.js 下载 使用 npm 下载： npm install vue 在页面中引入Vue 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; 创建Vue实例并应用 3. 调试工具安装vue-devtools插件，便于在Chrome浏览器中调试vue 步骤： 将vue-devtools.zip解压缩 打开Chrome浏览器的更多工具——&gt;扩展程序 将解压后的chrome目录拖放到扩展程序中即可 在VSCode中安装Vue相关插件：Vue 3 Snippets、Vetur、Vue Peek、vue-helper 三、基本交互1. 插值表达式语法： &#123;&#123; &#125;&#125; 由两对大括号组成，称为“Mustache”语法 作用：用于在页面标签中插入值，进行数据的绑定显示，且当值发生变化时标签会重新渲染加载，称为响应式特性，即数据状态同步操作 用法：&lt;标签&gt;&#123;&#123; Vue对象数据仓库变量|JS表达式|JS内置对象 &#125;&#125;&lt;/标签&gt; 只能用在标签中间的内容位置 可以绑定三种数据： 数据仓库中的变量 简单的JS表达式 JS内置对象 2. 指令2.1 简介指令 (Directives）是用来扩展html标签的功能，以v-作为前缀 语法： &lt;标签 v-指令名[:参数][.修饰符][=&quot;指令值&quot;]&gt;&lt;/标签&gt; 指令名：指令的名称 指令值：指令的取值，可选 参数：限制当前指令的操作范围，可选 修饰符：限制当前指令的触发条件，可选 特性：无痕迹特性 代码开发时的vue语法，在项目运行时会被删除，不会显示 Vue对象和容器在完成语法解析后，不会在浏览器上保留vue语法定义 2.2 常用指令 指令 取值 作用 v-text string 更新元素的textContent v-html string 更新元素的innerHTML v-pre 无 跳过当前元素和子元素的编译过程，不对vue语法进行编译执行 v-once 无 对当前元素和子元素的vue功能只执行一次 v-cloak 无 在vue实例构建完成前，隐藏未编译的vue语法，需要配合css样式一起使用 v-on Function | Object | Array | 行内表达式 绑定事件监听器，用于事件绑定 v-show any 根据表达式的boolean结果，切换元素的 display CSS 属性，控制元素的显示隐藏 v-if、v-else-if、v-else any 根据表达式的boolean结果，执行元素的创建和删除操作，控制元素的显示隐藏 v-for Array | Object | number | string 基于数据多次渲染元素或模板块，用于循环数据 v-bind any 动态的为标签绑定属性，用于属性绑定 2.3 指令详解v-on事件绑定指令 语法：&lt;标签 v-on[:参数][.修饰符]=&quot;取值&quot;&gt;&lt;/标签&gt; 缩写：可以使用@替代v-on: 参数：指定事件的名称，即事件类型 取值：Function | Object | Array | 行内表达式 修饰符： 按键修饰符——&gt;只有当点击对应的按键时才触发 功能修饰符——&gt;实现特定的功能 修饰符 含义 .capture 添加事件监听器时使用事件捕获模式 .stop 阻止事件传播，调用 event.stopPropagation() .self 只当事件是元素本身触发时才执行回调，即不是事件传播引起的 .prevent 阻止事件的默认行为，调用 event.preventDefault() .once 事件只触发一次 v-bind属性绑定指令 语法：&lt;标签 v-bind[:参数]=&quot;取值&quot;&gt;&lt;/标签&gt; 缩写：省略v-bind 参数：指定要绑定的属性 取值：any 注意：特殊属性的绑定，如boolean类型属性、class、style 3. 响应式原理响应式的概念：实际上就是所谓的数据状态同步操作，当内存中变量数据发生变化时，页面会及时做出响应，进行页面重构渲染 响应式的基础：：Object.defineProperty(obj, prop, descriptor) 用于定义一个对象上的属性以及这个属性的描述符 obj : 操作的目标对象 prop：操作的属性名称 descriptor：属性的详细定义 get（function）：拦截属性的取值操作，为取值操作提供扩展功能 set（function）：拦截属性的赋值操作，为赋值操作提供扩展功能 响应式的原理： 数据劫持 使用Object.defineProperty()实现，称为JS的数据劫持 ​ 注：Vue 不支持 IE8 以及更低版本浏览器 4. 双向数据绑定v-model双向数据绑定指令 语法：&lt;标签 v-model[.修饰符]=&quot;取值&quot;&gt;&lt;/标签&gt; 取值：随表单控件类型不同而不同 限制：仅限于表单中可输入或者可选择的元素，如&lt;input&gt;、&lt;select&gt; 、&lt;textarea&gt; 修饰符： 修饰符 含义 .lazy 使用 change 事件替代input事件 .number 将输入的值转换为数字 .trim 去除首尾的空格 双向数据绑定： 模型数据变化时重新渲染页面（基于Object.defineProperty） 页面数据变化时自动更新模型数据（基于元素事件监听） 四、数据控制​ 对数据进行包装处理和监控 1. 计算属性​ 计算属性（computed）也是用来存储属性数据的，但具有以下特点： 可以对数据进行逻辑处理操作，实现数据包装 计算属性通常依赖于当前Vue对象中的普通属性 当依赖的普通属性发生变化时计算属性也会变化，实现数据监控 ​ 计算属性由两部分组成： get 用来获取计算属性 set 用来设置计算属性 ​ 默认计算属性只有get，如果需要set，可以自己添加，此时需要以对象的形式配置 2. 监视器监视器（watch）是用来监视数据的变化，对数据进行监控 12345678910new Vue(&#123; watch: &#123; 变量:function(newValue, oldValue)&#123;&#125;, // 监控方法 变量:&#123; handler: function(newValue, oldValue)&#123;&#125;, // 监控方法 deep: true, // 开启深度监视 immediate: true // 开启初始化触发 &#125; &#125;,&#125;) 五、实例属性和方法1. 简介​ 通过Vue实例对象可以直接访问的属性和方法，称为实例属性和实例方法 ​ 实例属性和方法都以 $ 开头 2. 实例属性 vm.$el：当前Vue实例使用的根 DOM 元素 vm.$data：当前Vue实例观察的数据对象 vm.$options：当前Vue实例的初始化选项 vm.$refs：当前Vue实例容器中定义了ref属性的所有 DOM 元素 3. 实例方法 vm.$mount：手动挂载Vue实例 vm.$destroy：销毁Vue实例，只会销毁vue的实例对象，不会销毁与其关联的页面容器 vm.$nextTick：在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM并操作 vm.$set：为对象|数组添加一个属性|元素，并实现响应式，触发更新视图，实时监视，等同于全局方法 Vue.set vm.$delete：删除对象|数组的属性|元素，触发更新视图，等同于全局方法 Vue.delete 六、模板和渲染函数1. 模板​ 模板（template）就是定义Vue时指定的页面结构构成 默认使用el选项指定的挂载元素的内容来构成页面模板，同时指定挂载位置 可以使用 template 选项独立定义页面模板，此时el挂载元素的内容将被忽略 2. 渲染函数​ 渲染函数（render）用于通过JavaScript方式定义页面结构模板 默认通过el或template方式定义的页面模板也会被render渲染函数执行 可以使用 render 选项独立定义页面结构的渲染函数，此时template模板将被忽略 优先级：render &gt; template &gt; el 3. 虚拟DOM 模板转换为视图的过程： 将模板template编译成渲染函数render，执行渲染函数就可以得到一个虚拟节点树，即虚拟DOM 然后将虚拟节点树转换为真实DOM，映射到视图上 当Model数据更新时，Vue能够智能地计算出需要重新渲染的节点并对虚拟DOM进行修改（打补丁），然后再更新到视图上 虚拟DOM是什么？ 虚拟DOM（vdom）是一个用JavaScript对象方式描述的页面节点结构树，通过对象的属性来描述节点 实际上它只是对真实DOM的抽象，最终会通过一系列操作使这个虚拟DOM变为真实的DOM，显示在页面上 为什么使用虚拟DOM（优点）： 提高DOM更新效率，提升渲染性能 提供快速的DOM变化比较 减少页面中DOM重新渲染的次数（基于diff算法：找出本次DOM需要更新的节点来更新，其他的不更新） 注：JavaScript直接操作真实DOM时效率是比较低的，需要频繁的操作。 七、生命周期1. 简介Vue实例从创建到销毁的过程，称为生命周期，共有八个阶段： beforeCreate、created beforeMount 、mounted beforeUpdate、updated beforeDestroy、destroyed 在生命周期的每个阶段都提供了相应的钩子函数，可以在钩子函数中执行操作，控制生命周期的各个阶段 2. 生命周期流程 八、自定义指令分类：局部指令、全局指令 1. 局部指令在某个Vue实例中定义的指令，只在该Vue实例关联的容器中有效 123456789101112new Vue(&#123; directives:&#123; 指令名称:&#123; // 提供了5个钩子函数，在不同时机执行 bind: function (参数) &#123;&#125;, inserted: function (参数) &#123;&#125;, update: function (参数) &#123;&#125;, componentUpdated: function (参数) &#123;&#125;, unbind: function (参数) &#123;&#125; &#125; &#125;&#125;); 钩子函数的参数： 1234bind: function (el, binding, vnode, oldVnode) &#123; // el 指令所绑定的元素，DOM对象 // binding 一个对象，包含指令的相关信息&#125; 2. 全局指令使用全局方法 Vue.directive(指令ID,定义对象)定义的指令，在所有Vue实例中都有效 12345678Vue.directive(&#x27;指令名称&#x27;,&#123; // 提供了5个钩子函数，在不同时机执行 bind: function (参数) &#123;&#125;, inserted: function (参数) &#123;&#125;, update: function (参数) &#123;&#125;, componentUpdated: function (参数) &#123;&#125;, unbind: function (参数) &#123;&#125;&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"SpringMVC学习","slug":"SpringMVC学习","date":"2023-08-14T06:41:15.000Z","updated":"2023-08-15T02:49:51.535Z","comments":true,"path":"2023/08/14/SpringMVC学习/","link":"","permalink":"http://example.com/2023/08/14/SpringMVC%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、SpringMVC简介1. 什么是MVC​ M：model 数据模型，封装了业务逻辑，对业务数据进行处理 ​ V：view 视图，封装了显示逻辑，如HTML、JSP、Excel、PDF等 ​ C：controller 控制器，控制整个网站的处理流程，协调视图与模型 ​ MVC是一种Web应用架构，是一种代码设计思想 ​ 思想：将所有客户端请求全部交由控制器，由控制器将其分发，并将结果响应回客户端 ​ 注：区别MVC和三层架构 2. SpringMVC优点​ 简单，使用注解配置替代原生XML配置 ​ 效率高，单例的，将Controller层对象交给IoC容器管理 ​ 扩展性好，方便用户自定义 ​ SpringMVC和Spring无缝衔接 3. 实现原理3.1 流程图 3.2 执行过程分为六步： DispatcherServlet SpringMVC核心控制器：主要作用是用来分发，不进行任何处理 HandlerMapping 映射处理器：根据请求URL映射到具体的处理器Handler Handler就是Controller层实现类，也可称为Controller或Action HandlerAdapter 适配器：用来适配不同的处理器Handler 处理器有两种实现方式：实现接口、基于注解，所以执行之前需要先适配，这样才能知道如何执行 Handler 处理器：执行处理具体业务，并产生数据模型Model和视图名View Handler将数据模型和视图封装成ModelAndView对象并返回 ViewResolver 视图解析器：根据视图名解析为具体的视图，一般多为jsp页面，然后封装为View对象 View 视图：使用具体视图技术进行渲染，结合Model展示数据 视图有很多种形式，如jsp、freemarker、velocity、pdf、excel等 二、第一个SpringMVC程序1. 添加依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&lt;/dependency&gt; 2. 创建Controller12345678910@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public ModelAndView sayHello(String name)&#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;msg&quot;,&quot;Hello &quot;+name); mav.setViewName(&quot;hello&quot;); return mav; &#125;&#125; 3. 核心配置文件名称自定义，如springmvc.xml 1234567891011&lt;!-- 扫包 --&gt;&lt;context:component-scan base-package=&quot;controller&quot;/&gt;&lt;!-- mvc的注解驱动 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 配置ViewResolver --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/view/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 4. 配置核心控制器在web.xml中配置SpringMVC核心控制器，需要指定配置文件的路径 1234567891011121314&lt;!-- 配置DispatcherServlet，核心控制器，本质上就是一个Servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5. 静态资源处理当配置DispatcherServlet的url-pattern为/时，会拦截所有请求（包括静态资源），导致所有静态资源都无法访问 两种处理方式： 使用tomcat提供的默认Servlet 1&lt;mvc:default-servlet-handler/&gt; 使用SpringMVC提供的处理方式 1&lt;mvc:resources mapping=&quot;/imgs/**&quot; location=&quot;/WEB-INF/imgs/&quot; /&gt; 三、方法的返回值1. 返回值类型共有四种类型： ModelAndView 表示数据模型和视图 String 三种形式（写法）： 普通字符串 ——&gt; 表示视图名称，转发到指定视图 forward:url ——&gt; 转发到指定url redirect:url ——&gt; 重定向到指定url void 表示使用HttpServletResponse处理响应 Object 一般需要结合@ResponseBody使用 2. @ResponseBody将方法返回值写到响应体中，一般用来处理Ajax请求，返回JSON数据 SpringMVC默认使用jackson处理json数据的转换，所以需要引入jackson的依赖 可以使用@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;)，设置响应时的日期格式 123456&lt;!--jackson--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 注：也可以使用@RestController，相当于@Controller+@ResponseBody 常用注解： @JsonFormat 指定序列化和反序列化时的格式，一般用于指定日期、时间和数字的格式 @JsonProperty 指定序列化和反序列化时的名称 @JsonAlias 指定反序列化时的备用别名 @JsonIgnore 指定序列化和反序列化时忽略属性 注： json序列化：将Java对象转换为json字符串 json反序列化：将json字符串转换为Java对象 3. 跨域访问允许跨域访问 方式一：使用@CrossOrigin注解，可以在类或方法上添加该注解 方式二：在xml中添加如下配置 123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;/mvc:cors&gt; 四、方法的参数1. JavaEE组件HttpServletRequest HttpServletResponse HttpSession 2. String、基本类型及包装类@RequestParam 表示参数来源于请求参数，默认为所有参数添加该注解，参数值来源于同名称的请求参数 @PathVariable 表示参数来源于URL（URL就是请求路径） @RequestHeader 表示参数来源于请求头 @CookieValue 表示参数来源于Cookie @RequestBody 表示参数来源于请求体，用来接收前端传递给后端的 json 格式的数据 请求的方式必须为post，post请求才会有请求体 请求的内容类型必须为 json格式，需要设置contentType为application/json;charset=utf8 4. 自定义对象例如：User、UserDTO、UserVo等 @ModelAttribute 将请求数据转换为对象，默认为所有自定义类型添加该注解 要求对象的属性名必须与参数名相同 可以使用@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)，设置接收时的日期格式 注意： 可以使用SpringMVC提供的CharacterEncodingFilter解决POST请求中文乱码问题 控制台输出有乱码时，可以设置tomcat的VM options为-Dfile.encoding=utf8 五、请求路径1. @RequestMapping该注解可以定义在方法上，也可以定义在类上，表示层级关系 请求映射路径的写法： 固定写法 value和path属性互为别名，其值是一个数组，可以指定多个值，允许通过多个路径访问 Rest风格 {变量}表示URL中的占位符，URL中必须有对应的值，可以结合@PathVariable获取值 2. 限定请求方式method属性 限定请求方式：GET、POST、PUT、DELETE等 也可使用@GetMapping、@PostMapping、@PutMapping、@DeleteMapping等注解限定请求方式 六、全局异常处理步骤： 定义一个异常处理类，添加@ControllerAdvice或@RestControllerAdvice 定义异常处理方法，添加@ExceptionHandler 七、拦截器拦截器Interceptor对请求进行拦截处理，类似于过滤器Filter 步骤： 定义一个类，实现HandlerInterceptor接口 1234567891011121314151617181920212223public class HelloInterceptor implements HandlerInterceptor &#123; // 调用目标处理方法之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;HelloInterceptor.preHandle&quot;); return true; // true表示放行，继续调用目标处理方法，false表示不放行 &#125; // 调用目标处理方法之后执行，渲染视图之前 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;HelloInterceptor.postHandle&quot;); &#125; // 渲染视图之后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;HelloInterceptor.afterCompletion&quot;); &#125;&#125; 配置拦截器 12345678&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot; /&gt; &lt;mvc:mapping path=&quot;/path/**&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/path/path1&quot;/&gt; &lt;!-- 排除拦截该请求 --&gt; &lt;bean class=&quot;interceptor.HelloInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 八、文件上传SpringMVC为文件上传提供了支持，基于commons-fileupload 步骤： 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 配置文件解析器 12345&lt;!-- 配置文件解析器，id名称必须为multipartResolver --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot;/&gt;&lt;/bean&gt; 编写页面 12345&lt;form id=&quot;uploadForm&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt; &lt;br&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;doUpload()&quot;&gt;&lt;/form&gt; 编写FileController类 123456789101112131415161718192021/* * 通过参数CommonsMultipartFile接收文件 * 必须在参数前添加@RequestParam注解，否则无法接收文件 */@PostMapping(&quot;/upload&quot;)public AjaxResult upload2(String name, @RequestParam CommonsMultipartFile avatar, HttpServletRequest req) throws IOException &#123; System.out.println(name); System.out.println(avatar); System.out.println(avatar.getOriginalFilename()); // 文件名 System.out.println(avatar.getSize()); // 文件大小 System.out.println(avatar.getInputStream()); // 文件的输入流 String uploadPath = req.getServletContext().getRealPath(&quot;upload&quot;); String filename = UUID.randomUUID() + &quot;.&quot; + FileNameUtil.getSuffix(avatar.getOriginalFilename()); String filePath = uploadPath + File.separator + filename; System.out.println(filePath); avatar.transferTo(new File(filePath)); return AjaxResult.success(filename);&#125; ​ 注：maven打包时默认会忽略空目录，不对空目录进行打包，可以先手动创建一个文件 九、综合案例基于SSM的员工管理系统（ssm-ems） 后端 SSM 前端 LayUI","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Spring学习","slug":"Spring学习","date":"2023-08-10T02:57:52.000Z","updated":"2023-08-11T00:31:36.372Z","comments":true,"path":"2023/08/10/Spring学习/","link":"","permalink":"http://example.com/2023/08/10/Spring%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Spring简介1. Spring是什么？​ spring单词本义是“春天”，程序员的春天 ​ 是一个开源的控制反转(IoC)和面向切面(AOP)的容器框架，用来简化企业开发 ​ 官网：https://spring.io 2. 为什么使用Spring​ 降低组件之间的耦合度，实现软件各层之间的解耦 ​ 提供了众多的技术支持 ​ 对主流框架提供了集成 3. 核心概念IoC：Inversion Of Control 控制反转 控制反转(IoC)就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护由外部容器负责，这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。 外部容器&#x2F;IoC容器：存放对象（bean）的容器 12345678//Service依赖于DAOpublic class UserServiceImpl&#123; //UserDaoImpl由应用内部(Service)创建及维护 private UserDao userDao = new UserDaoImpl(); public void regist(User user)&#123; userDao.insert(user); &#125;&#125; DI：Dependency Injection 依赖注入 依赖注入(DI)就是指在运行期，由外部容器动态地将依赖对象注入到组件中。 1234567891011//依赖对象的创建及维护由外部容器负责public class UserServiceImpl&#123; private UserDao userDao; //通过setter方法，让容器把创建好的依赖对象注入到Service中 public void setUserDao(UserDao userDao)&#123; this.userDao=userDao &#125; public void regist(User user)&#123; userDao.insert(user); &#125;&#125; 二、第一个Spring程序1. 添加依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.27&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 核心配置文件​ 用来进行bean的配置，文件名可自定义，一般默认为applicationContext.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd &quot;&gt; &lt;!-- 定义一个bean id：指定bean的名称 class：指定bean的类型 --&gt; &lt;bean id=&quot;helloSpring&quot; class=&quot;ioc01.HelloSpring&quot;&gt; &lt;!-- 为bean中的属性注入值 --&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3. 操作1234567public static void main(String[] args) &#123; // 获取IoC容器，读取配置文件，初始化Spring上下文 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc01/applicationContext.xml&quot;); // 根据id名称获取bean的实例 HelloSpring helloSpring=(HelloSpring) ac.getBean(&quot;helloSpring&quot;); helloSpring.show();&#125; 4. 案例用户登陆 12345678910&lt;bean id=&quot;userDao&quot; class=&quot;ioc02.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;ioc02.service.impl.UserServiceImpl&quot;&gt; &lt;!-- 通过ref属性注入bean --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userController&quot; class=&quot;ioc02.controller.UserController&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;&lt;/bean&gt; 三、数据装配1. 简介为bean中的属性注入值，称为数据的装配，可装配不同类型的数据： 简单类型 ——&gt; 使用value ​ 基本类型及包装类型、String 其他bean的引用 ——&gt; 使用ref 集合类型 ——&gt;使用相对应的子元素 数组 List Set Map Properties 注：数据装配是通过setter方法进行的，所以必须有setter方法 2. 基本用法123456789101112131415161718192021222324252627282930313233&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;property name=&quot;otherBean&quot; ref=&quot;otherBean&quot;/&gt; &lt;property name=&quot;arrays&quot;&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;lists&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;otherBean&quot;/&gt; &lt;bean class=&quot;ioc03.OtherBean&quot;&gt; &lt;property name=&quot;sex&quot; value=&quot;male&quot;/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aaa&quot; value-ref=&quot;otherBean&quot;/&gt; &lt;entry key=&quot;bbb&quot; value-ref=&quot;otherBean&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/test&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3. 自动装配对于其他bean的引用的装配，IoC容器可以根据bean的名称、类型或构造方法进行自动的注入，称为自动装配 通过bean元素的autowire来配置 1234567891011&lt;!-- 自动装配 autowire 可取值如下： no：不进行自动装配，默认值，同default byName：根据属性名自动装配，自动查找与属性名相同的bean byType：根据属性类型自动装配，自动查找与属性类型相同的bean constructor：根据构造方法自动装配 根据构造方法参数的名称或类型进行自动装配，只要有一个可以装配就行 此时与setter方法无关，可以没有setter方法 --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; autowire=&quot;constructor&quot;/&gt; 四、bean管理1. bean生命周期​ 生命周期：实例化–&gt;数据装配–&gt;初始化方法–&gt;使用–&gt;销毁方法–&gt;从容器中销毁 1234&lt;!-- 生命周期的扩展 init destory --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ​ 在bean实例化并进行数据装配后，会调用初始化方法，执行初始化操作 ​ 在bean销毁之前会调用销毁方法，执行销毁前的操作 2. bean实例化时机​ 默认预先实例化，即在容器启动时实例化，可以设置懒实例化，在第一次使用bean时实例化 123&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; lazy-init=&quot;true&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3. bean作用域​ 在IoC容器中bean默认是单例的 ​ 通过bean元素的scope属性来设置bean的作用域，即是否为单例模式 123456&lt;!-- scope属性 可取值如下： singleton：单例，在容器启动时初始化，默认值 prototype：多例，在每次获取bean时初始化 --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; scope=&quot;prototype&quot;/&gt; 4. 在普通类中获取bean实际开发中，并不是所有类都需要交由IoC容器管理，某些类并不需要交由容器管理，如各种工具类，本身都提供了静态方法 问题：没有交由容器管理的类，容器是无法进行数据装配的，如何在这些类中获取容器中的bean呢？ 解决：使用ApplicationContextAware获取容器，然后从容器中获取bean 定义IoC容器工具类，步骤： 定义一个类，实现ApplicationContextAware接口 将该类添加到IoC容器中，当实例化时会自动注入当前的ApplicationContext 调用IoC容器工具类，从容器中获取bean 1234567891011121314151617181920212223242526272829303132public class ApplicationContextHolder implements ApplicationContextAware&#123; private static ApplicationContext ac; /** * 会自动注入当前的IoC容器 */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.ac = applicationContext; &#125; /** * 根据名称获取bean * @param beanName * @return */ public static Object getBean(String beanName)&#123; return ac.getBean(beanName); &#125; /** * 根据类型获取bean * @param clazz * @return * @param &lt;T&gt; */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123; return ac.getBean(clazz); &#125;&#125; 五、注解配置1. 简介​ Spring提供了一系列注解来替代配置文件，简化配置 ​ 使用注解时，需要扫描注解所在的包 123&lt;context:component-scan base-package=&quot;net.wanho.dao.impl&quot;/&gt;&lt;context:component-scan base-package=&quot;net.wanho.service.impl&quot;/&gt;&lt;context:component-scan base-package=&quot;net.wanho.controller&quot;/&gt; 2. 常用注解2.1 定义组件@Component 定义组件Bean，添加到IoC容器中，不区分组件类型 区分组件类型的注解： @Repository 表示Dao组件 @Service 表示Service组件 @Controller 表示Controller组件 注：以上三个注解和@Component的作用相同，只是用来表示不同的组件类型 2.2 数据装配注解方式的数据装配是直接使用属性进行注入，不是使用setter方法，所以可以没有setter方法 简单类型 123456789@Value(&quot;666&quot;)private int num;@Value(&quot;true&quot;)private Boolean flag;// @Value(&quot;tom&quot;)@Value(&quot;$&#123;username&#125;&quot;)private String username; 12&lt;!-- 引用属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:ioc/info.properties&quot;/&gt; 其他bean的引用，使用@Autowired 或 @Resource 12345678910111213141516171819202122232425262728// @Autowired // Spring提供的注解，默认按类型注入，如果有多个同类型的，则按名称注入@Resource // Java提供的注解，默认按名称注入，如果没找到，则按类型注入private OtherBean otherBean;/* * 方式1：基于field注入，即在属性上面添加@Autowired或@Resource */@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao;&#125;/* * 方式2：基于constructor注入，即在构造方法上面添加@Autowired或@Resource * 优点：可以为final属性注入、质量高（Spring官方推荐） */@Controller@RequiredArgsConstructor // 可以使用lombok的@RequiredArgsConstructor注解来生成带参构造方法（属性要使用final修饰）public class UserController &#123; private final UserService userService; // @Autowired // 如果类中只有一个构造方法，可以省略该注解 // public UserController(UserService userService) &#123; // this.userService = userService; // &#125;&#125; 2.3 bean生命周期1234567891011// 相当于init-method@PostConstructpublic void init() &#123; System.out.println(&quot;SpringBean.init()&quot;);&#125;// 相当于destroy-method@PreDestroypublic void destroy() &#123; System.out.println(&quot;SpringBean.destroy()&quot;);&#125; 2.4 bean实例化时机123// 默认是预实例化，配置为懒初始化@Lazypublic class SpringBean &#123;&#125; 2.5 scope作用域123//默认是单例，配置为非单例@Scope(&quot;prototype&quot;)public class SpringBean &#123;&#125; 六、AOP1. 简介​ AOP：Aspect Oriented Programming 面向切面编程，是OOP面向对象编程的一种补充 ​ 将程序中的交叉业务逻辑（事务、日志、异常等）代码提取出来，封装成切面，由AOP容器在适当的时机（位置）将封装的切面动态的织入到具体业务逻辑中。 2. 作用 在不改变原有代码的基础上动态添加新的功能 模块化，将分散在各层中的相同代码，通过横向切割的方式抽取到单独的模块中 方便维护 可扩展性强 3. 原理AOP的原理是使用动态代理技术 动态代理的含义： 代理类是在程序运行期间由JVM根据反射等机制动态生成的，自动生成代理类和代理对象 所谓动态是指在程序运行前不存在代理类的字节码文件，代理类和委托类的关系是在程序运行时确定 动态代理的两种技术： jdk技术：适用于有接口时使用，目标对象必须实现一个或多个接口，否则无法使用jdk动态代理 cglib技术：适用于无接口时使用（有接口时也可以使用） 注：Spring默认使用的是jdk动态代理，SpringBoot默认使用的是cglib动态代理 4. 用法步骤： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;&lt;/dependency&gt; 配置Advice 定义增强类并添加@Component和@Aspect注解，表示其为一个切面 配置Pointcut 定义切点表达式 在一个空方法上添加@Pointcut注解，配置切点表达式 为方法添加通知类型注解并指定切点 @Before 前置通知，在方法执行前添加功能 @AfterReturning 后置通知，在方法执行后添加功能 @AfterThrowing 异常通知，在方法抛出异常后添加功能 @Around 环绕通知 在方法执行前后添加功能 配置自动创建代理并织入 1&lt;aop:aspectj-autoproxy /&gt; 七、Spring整合JDBC12345678910drop database if exists spring;create database spring charset utf8;use spring;create table t_user( id int primary key auto_increment, username varchar(50) not null unique, password varchar(50) not null) charset utf8; 1. 基本用法步骤： 添加依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 配置 DataSource–&gt;JdbcTemplate–&gt;Dao–&gt;Service–&gt;Controller 123456@Repositorypublic class UserDaoJdbcImpl implements UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate; // ...&#125; 1234567891011121314&lt;context:property-placeholder location=&quot;classpath:datasource.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2. 事务操作​ JDBC默认是自动提交事务的，每执行完一条SQL语句就提交事务 ​ 问题：如果Service层出现异常，并不会回滚，怎么办？ ​ 解决：配置事务操作（使用的是环绕通知） 1234567&lt;!-- 定义事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务的注解驱动 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 12345678910111213141516// @Transactional也可以配置在类上，如果方法上没有配置@Transactional，则使用类上的事务配置@Transactional(propagation = Propagation.REQUIRED,rollbackFor = Exception.class)public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override @Transactional(propagation = Propagation.SUPPORTS, readOnly = true) public User login(String username, String password) &#123; &#125; @Override //@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, noRollbackFor = ArithmeticException.class, timeout = 3000) public void regist(UserVo userVo) &#123; &#125;&#125; 3. 事务属性和事务特性3.1 事务属性​ 五个事务属性：传播属性、隔离级别、回滚条件、只读优化、超时处理 传播属性 propagation：定义事务的边界，用来配置当前方法是否需要有事务，常用取值： REQUIRED 必须添加事务，如果当前没有事务则创建一个新的事务，一般用于增删改 SUPPORTS 可以没有事务，如果当前有事务则运行，如果没有事务也可以运行，一般用于查询 隔离级别 isolation：用来解决事务并发时会出现的一些问题，四种隔离级别，由低到高依次为： READ_UNCOMMITTED 读未提交——&gt;可能出现脏读、不可重复读、幻读 READ_COMMITTED 读已提交——&gt;避免脏读，但可能出现不可重复读、幻读 REPEATABLE_READ 可重复读——&gt;避免脏读、不可重复读，但可能出现幻读（MySQL默认隔离级别） SERIALIZABLE 可序列化（串行）——&gt;避免脏读、不可重复读、幻读，相当于是单并发，没意义 事务并发时会出现的三个问题（脏读、不可重复读、幻读或虚读）： 脏读: 一个事务读取到另一个事务中没有提交的数据，一般不会发生，如MySQL、Oracle底层默认都是只读取提交的数据 12345-- 打开两个session，即同时登陆两个账户mysql -uroot -pset autocommit=off; insert into t_user values(null,&#x27;alice&#x27;,&#x27;123&#x27;);select * from t_user; 不可重复读 : 一个事务已经读取数据，另一个事务在修改数据，可能导致使用的数据与数据库不同步 幻读或虚读 : 一个事务已经读取数据量，另一个事务在添加或删除数据，可能导致使用的数据量与数据库不一致 注：不可重复读和虚读都是小概率事件，实际开发中一般不需要配置隔离级别，大多是通过定时任务来检查+人工审核 回滚条件 rollback：默认抛出RuntimeException时才进行回滚 ​ rollbackFor&#x3D;”” 表示发生该异常时回滚 ​ noRollbackFor&#x3D;”” 表示发生该异常时不回滚 只读优化 readOnly：在该事务中只能读取，一般用于查询 超时处理 timeout：配置事务超时的时间，一般不配置 3.2 事务特性​ 四个事务特性：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、永久性(Durability) ​ 简称为ACID 八、Spring整合MyBatis​ 步骤： 添加依赖 12345678910111213141516&lt;!-- Spring整合MyBatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.13&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 创建Mapper映射文件 映射文件存放位置，两种形式： 将映射文件放在resources目录下 映射文件会进行打包部署 将映射文件放在java目录下 默认只会对该目录下的java代码进行打包部署，如果希望对该目录下的配置文件也进行打包，需要添加额外的配置 编辑pom.xml文件： 123456789101112131415161718192021&lt;build&gt; &lt;resources&gt; &lt;!-- 将java目录下的配置文件也进行打包 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 配置 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 可以引用独立的mybatis配置文件，也可以不用 --&gt; &lt;!-- &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 指定映射文件所在路径 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:org/wanho/mapper/*Mapper.xml&quot;&gt;&lt;/property&gt; &lt;!-- 为映射的类指定别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;net.wanho.entity&quot;&gt;&lt;/property&gt; &lt;!-- 自定义配置 --&gt; &lt;property name=&quot;configuration&quot;&gt; &lt;bean class=&quot;org.apache.ibatis.session.Configuration&quot;&gt; &lt;!-- 打印sql --&gt; &lt;property name=&quot;logImpl&quot; value=&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;/&gt; &lt;!-- 下划线映射为驼峰 --&gt; &lt;property name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 分页插件 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;helperDialect&quot;&gt;mysql&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 通过反射创建Dao实现类，然后放到IoC容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 指定Dao接口所在的包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;net.wanho.dao&quot;/&gt; &lt;!--注入sqlSessionFactory，通过value注入String类型的名称--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"MyBatis学习","slug":"MyBatis学习","date":"2023-08-08T05:28:46.000Z","updated":"2023-08-09T02:44:35.508Z","comments":true,"path":"2023/08/08/MyBatis学习/","link":"","permalink":"http://example.com/2023/08/08/MyBatis%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、简介1. MyBatis是什么MyBatis的前身叫iBatis 是一个持久层框架，或称为 ORM框架 用来访问数据库，做数据持久化操作 本质上只是对JDBC进行封装，简化JDBC繁琐的操作 ​ 注：框架就是别人写好的，对某些技术进行的封装，封装成对应的jar、js、css等，我们可以直接拿过来使用，简化开发 2. 持久层​ DAO：Data Access Object 数据访问对象 ​ 用来对数据进行持久化操作，如将数据存入数据库、硬盘等，可以永久保存 3. ORMObject Relational Mapping 对象关系映射 Java程序和数据库之间的映射关系： 类 ——&gt; 表 对象 ——&gt; 一条数据 属性 ——&gt; 列 4. 回顾JDBC​ JDBC访问数据库的步骤 1234567891011Class.forName(driverClassName);Connection conn = DriverManager.getConnection(url,user,password);PrepareStatement ps = conn.preparedStatement(sql);//ps.executeUpdate()ResultSet rs = ps.executeQuery();while(rs.next)&#123; //RM(RowMapper)行映射&#125;rs.close();ps.close();conn.close(); 数据库操作中的可变部分： 连接信息 dirverClassName、 url、user、password（也称为数据源datasource） SQL语句 RM行映射 二、第一个MyBatis程序1. 创建项目并添加依赖1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 数据库设计1234567891011drop database if exists mybatis;create database mybatis charset utf8;use mybatis;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(20) unique not null comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, phone varchar(20) comment &#x27;电话&#x27;, address varchar(100) comment &#x27;地址&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 3. 创建主配置文件config主配置文件，在一个mybatis工程中有且只有一个 用来配置与整个工程相关的信息，如环境配置、别名配置、插件配置、注册mapper文件等 文件名可自定义，一般命名为mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments：配置当前工程中可能使用的所有数据库环境 default属性：指定默认使用的环境，取值为某一个environment的id --&gt; &lt;environments default=&quot;hello&quot;&gt; &lt;!-- envirinment：配置某一个数据库环境，可以有多个 id属性：指定该环境的唯一标识符 --&gt; &lt;environment id=&quot;hello&quot;&gt; &lt;!-- transactionManager：配置事务管理器 type属性：指定事务管理器的类型，取值有两种： jdbc：使用简单的jdbc事务操作，如开启、提交、回滚 在mybatis中，默认是关闭自动提交事务的，即conn.setAutoCommit(false) managed：将事务交给其他框架/容器来处理，如spring mybatis不负责事务，什么都不会做 --&gt; &lt;transactionManager type=&quot;jdbc&quot;&gt;&lt;/transactionManager&gt; &lt;!-- dataSource：配置数据源 type属性：配置数据源的类型，取值有三种： UNPOOLED：简单的JDBC配置，未使用连接池，相当于DriverManager.getConnection(url,username,password) POOLED：使用连接池技术 JNDI：通过外部容器获取连接 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--&lt;environment id=&quot;world&quot;&gt;--&gt; &lt;!--&lt;transactionManager type=&quot;&quot;&gt;&lt;/transactionManager&gt;--&gt; &lt;!--&lt;dataSource type=&quot;&quot;&gt;&lt;/dataSource&gt;--&gt; &lt;!--&lt;/environment&gt;--&gt; &lt;/environments&gt; &lt;!-- 注册当前工程中使用的所有映射文件 --&gt; &lt;mappers&gt; &lt;!-- mapper：注册某一个mapper文件，可以有多个 resource属性：指定映射文件的路径，写的是相对于src的路径，使用正斜杠分隔 --&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 小技巧： 创建配置文件的模板：Settings——&gt;搜索template——&gt;File and Code Templates——&gt;Files——&gt;Create Template 4. 创建映射文件mapper映射配置文件，在一个mybatis工程中可以有多个mapper文件 用来配置dao功能相关的sql操作，如sql语句、CURD操作、字段映射等 每个实体类对应一个映射文件，每一个mapper文件相当于原来三层架构中dao实现类 文件名可自定义，一般命名为XxxMapper.xml，放到mapper文件夹中 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace属性：指定当前mapper配置文件的唯一标识符，取值为对应接口的全名--&gt;&lt;mapper namespace=&quot;dao.UserDao&quot;&gt; &lt;!-- insert：用来执行添加操作 id属性：表示当前的方法名，取值必须与接口中的方法名相同 parameterType属性：表示方法的参数类型 如果参数是对象，可以使用类的全名 如果参数是普通数据，可以使用mybatis中的别名，见参考文档12页 标签体：编写sql语句 使用#&#123;xxx&#125;表示占位符 如果参数是对象，则xxx为对象的属性 如果参数是普通数据，则xxx为参数名 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;entity.User&quot;&gt; insert into t_user (username, password, phone, address) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt; 小技巧： 去除背景：Settings——&gt;Editor——&gt;Color Scheme——&gt;General——&gt;Code——&gt;Injected language fragment，取消勾选右边的Background XML注释风格：Settings——&gt;Editor——&gt;Code Style——&gt;XML——&gt;Code Generation，取消勾选下面的两个 编写SQL时提示表和列： 在右侧的工具栏，添加数据库连接 Settings——&gt;搜索SQL Dialects——&gt;将右边的都选择为MySQL 5. 测试类1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; /** * 创建SqlSession，称为持久化管理器，是MyBatis操作的核心 */ // 1.创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); // 2.创建SqlSessionFactory，读取核心配置文件 SqlSessionFactory factory = builder.build(Test01.class.getClassLoader().getResourceAsStream(&quot;mybatis-config.xml&quot;)); // 3.创建SqlSession SqlSession session = factory.openSession(); // Connection connection = session.getConnection(); // System.out.println(connection); User user = new User(); user.setUsername(&quot;alice&quot;); user.setPassword(&quot;123&quot;); user.setPhone(&quot;110&quot;); user.setAddress(&quot;南京&quot;); /** * 获取DAO实现类的实例，并执行数据库操作 */ UserDao userDao = session.getMapper(UserDao.class); // 参数为接口的Class对象 // System.out.println(userDao); // 代理对象，通过代理自动生成DAO的实现类 userDao.insertUser(user); session.commit(); // 提交事务&#125; 6. MyBatisUtil工具类MyBatisUtil工具类： （1）MyBatisUtils主要职责是：● 帮助我们初始化SqlSessionFactory这个对象；同时让SqlSessionFactory全局唯一；● 获得SqlSession对象的方法；● 关闭SqlSession对象的方法； （2）在实际开发中，会经常使用MyBatisUtils工具类； 添加模板，实现快捷操作：Settings——&gt;搜索template——&gt;Live Templates 12345678910111213SqlSession session = null;try &#123; session = MyBatisUtil.getSession(); $END$ session.commit();&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();&#125; finally &#123; MyBatisUtil.close();&#125; 三、config文件1. settings123456&lt;!-- 自定义配置 --&gt;&lt;settings&gt; &lt;!-- 打印sql --&gt; &lt;!--&lt;setting name=&quot;logImpl&quot; value=&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;/&gt;--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; logImpl可以输出日志注：setting一定要在environment的上面，否则会报错。 2. typeAliases12345678910111213141516&lt;!-- 配置别名，为当前工程中的某些类指定别名--&gt;&lt;typeAliases&gt; &lt;!-- typeAlias：为某个类配置别名 type属性：指定类名 alias属性：指定类的别名 --&gt; &lt;!--&lt;typeAlias type=&quot;entity.User&quot; alias=&quot;User&quot;/&gt;--&gt; &lt;!-- package：为某个包下的所有类配置别名 name属性：指定包名，该包下所有类的别名就是其类名（别名不区分大小写，但建议与类名完全一致） --&gt; &lt;package name=&quot;entity&quot;/&gt;&lt;/typeAliases&gt; 3. properties1234&lt;!-- 引用外部的properties文件--&gt;&lt;properties resource=&quot;datasource.properties&quot;&gt;&lt;/properties&gt; 1234567&lt;!-- 通过$&#123;key&#125;访问properties文件中的值--&gt;&lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; 四、mapper文件1. insert​ 保存返回主键 123456789101112&lt;!-- useGeneratedKeys属性：设置保存时是否返回主键，取值有两个： false：表示不返回主键，默认值 true：表示返回主键，会自动将返回的主键绑定到参数对象的主键属性中 keyProperty属性：指定对象的哪个属性为主键属性，即主键所映射的属性，必须指定--&gt;&lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user (username, password, phone, address) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;address&#125;)&lt;/insert&gt; 2. update1234567891011&lt;!-- update：执行修改操作--&gt;&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update t_user set username=#&#123;username&#125;, password=#&#123;password&#125;, phone=#&#123;phone&#125;, address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; 3. delete1234567&lt;!-- delete：执行删除操作--&gt;&lt;delete id=&quot;deleteById&quot; parameterType=&quot;int&quot;&gt; delete from t_user where id=#&#123;id&#125;&lt;/delete&gt; 4. select123456789101112131415161718192021222324252627282930313233343536&lt;!-- select：执行查询操作 resultType属性：表示返回的结果类型 如果返回的是一个对象，会自动进行映射 前提条件：查询结果的字段名必须与对象的属性名完全相同--&gt;&lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select id,username,password,phone,address from t_user where id=#&#123;id&#125;&lt;/select&gt;&lt;!-- 当方法返回值为对象集合时，resultType指定的是集合中对象的类型，而非集合本身--&gt;&lt;select id=&quot;selectAll&quot; resultType=&quot;User&quot;&gt; &lt;!-- include：用于引用sql代码段 refid属性：指定要引用的sql代码段的id值 --&gt; select &lt;include refid=&quot;userColumn&quot;/&gt; from t_user&lt;/select&gt;&lt;!-- 模糊查询--&gt;&lt;select id=&quot;selectByUsername&quot; resultType=&quot;User&quot;&gt; select &lt;include refid=&quot;userColumn&quot;/&gt; from t_user &lt;!-- 方式1：使用concat()函数拼接 --&gt; &lt;!-- where username like concat(&#x27;%&#x27;,#&#123;username&#125;,&#x27;%&#x27;) --&gt; &lt;!-- 方式2：传参时直接拼接上% --&gt; where username like #&#123;username&#125;&lt;/select&gt; 5. sql片段123456789101112&lt;!-- sql：定义sql代码段，便于复用 id属性：指定该sql代码段的唯一标识符--&gt;&lt;sql id=&quot;UserColumn&quot;&gt; id,username,password,phone,address&lt;/sql&gt;&lt;sql id=&quot;BaseQuery&quot;&gt; select id,username,password,phone,address from t_user&lt;/sql&gt; 五、手动映射​ 当数据库查询结果的字段名与Java对象的属性名不同时，如何映射？ 1234567create table t_user2( user_id int primary key auto_increment comment &#x27;编号&#x27;, user_username varchar(20) unique not null comment &#x27;用户名&#x27;, user_password varchar(50) comment &#x27;密码&#x27;, user_phone varchar(20) comment &#x27;电话&#x27;, user_address varchar(100) comment &#x27;地址&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 1. 使用别名123456789101112131415&lt;!-- 使用别名：为查询结果的每个字段指定别名，与对象的属性名相同，此时相当于自动映射--&gt;&lt;select id=&quot;selectById2&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select user_id id, user_username username, user_password password , user_phone phone , user_address address from t_user2 where user_id=#&#123;id&#125;&lt;/select&gt; 2. 使用resultMap123456789101112131415161718&lt;!-- resultMap：定义结果映射，将数据库的字段与对象的属性进行映射 id属性：指定该resultMap的唯一标识符 type属性：映射的对象类型--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id：配置主键映射 result：配置其他映射 property属性：映射的属性名 column属性：映射的字段名 --&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;user_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;user_password&quot;/&gt; &lt;result property=&quot;phone&quot; column=&quot;user_phone&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;user_address&quot;/&gt;&lt;/resultMap&gt; 1234567891011121314&lt;!-- resultMap属性：引用一个resultMap，使用该resultMap进行手动映射 其值为已存在的某一个resultMap标签的id值--&gt;&lt;select id=&quot;selectById3&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt; select user_id, user_username, user_password , user_phone, user_address from t_user2 where user_id=#&#123;id&#125;&lt;/select&gt; 六、多个参数1. 使用@Param()注解12// 使用@Param()注解，标注在参数前，为参数指定占位符名称public User selectByUsernameAndPassword(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); 1234567&lt;!-- 使用@Param()定义的名称引用指定的参数--&gt;&lt;select id=&quot;selectByUsernameAndPassword&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;pwd&#125;&lt;/select&gt; ​ 注：如果方法只有一个参数，不需要加@Param注解，可以在占位符#{ }中使用任意名称 2. 将参数封装为对象12345&lt;!-- 将多个参数封装成一个对象，然后传递该对象 --&gt;&lt;select id=&quot;selectByUsernameAndPassword2&quot; parameterType=&quot;UserDTO&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; ​ 注：可以自定义一个参数对象，如UserDTO、UserParam等 3. 将参数封装为Map1234567&lt;!-- 将多个参数封装成一个Map集合，在#&#123;&#125;占位符中根据key获取value--&gt;&lt;select id=&quot;selectByUsernameAndPassword3&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; ​ 注：parameterType属性可以省略 4. #{}与${}的区别#{ }的含义 #{ }表示一个占位符 即JDBC中的？ 占位不会出现SQL注入的问题 ${ }的含义 ${}表示一个拼接符 拼接会导致SQL注入，如查询条件输入&#39;&#39; or 1=1就会有注入情况 如果排序时要指定排序列名和排序方式，此时就必须使用字符的拼接，即使用${ } 七、动态SQL​ 根据条件的不同，动态的拼接SQL语句，称为动态SQL ​ 传统JDBC拼接： 12345678StringBuffer sql=new StringBuffer();sql.append(&quot;select * from t_user where 1=1&quot;);if(username!=null &amp;&amp; !&quot;&quot;.equals(username))&#123; sql.append(&quot; and username=? &quot;);&#125;if(password!=null &amp;&amp; !&quot;&quot;.equals(password))&#123; sql.append(&quot; and password=? &quot;);&#125; 1. if1234567891011121314151617181920&lt;!-- if标签：用来进行条件的判断 test属性：判断表达式的值，如果为true，则拼接该sql片段，否则不拼接--&gt;&lt;select id=&quot;selectByParams&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where 1=1 &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; and password = #&#123;password&#125; &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; and phone = #&#123;phone&#125; &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; and address = #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 2. choose123456789101112131415161718192021222324252627&lt;!-- choose标签：用来进行条件的选择，只会拼接一个SQL when标签： test属性：判断表达式的值，如果为true，则拼接该sql片段，此时不再判断其它when otherwise标签：当所有when都不成立时，则拼接该sql片段--&gt;&lt;select id=&quot;selectByParams2&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where &lt;choose&gt; &lt;when test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; username = #&#123;username&#125; &lt;/when&gt; &lt;when test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password = #&#123;password&#125; &lt;/when&gt; &lt;when test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; phone = #&#123;phone&#125; &lt;/when&gt; &lt;when test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; address = #&#123;address&#125; &lt;/when&gt; &lt;otherwise&gt; 1=1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 3. where1234567891011121314151617181920212223&lt;!-- where标签：一般结合if或choose一起使用 作用：1.添加where关键字 2.删除sql片段的第一个连接关键字，如and、or等 3.如果没有拼接任何sql片段，则不会添加where关键字--&gt;&lt;select id=&quot;selectByParams3&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; &lt;where&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; or password = #&#123;password&#125; &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; and phone = #&#123;phone&#125; &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 4. set1234567891011121314151617181920212223&lt;!-- set标签：一般结合if或choose一起使用 作用：1.添加set关键字 2.删除sql片段的末尾逗号--&gt;&lt;update id=&quot;updateUser2&quot; parameterType=&quot;User&quot;&gt; update t_user &lt;set&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password = #&#123;password&#125;, &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; phone = #&#123;phone&#125;, &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; address = #&#123;address&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; 5. trim123456789101112131415161718192021222324&lt;!-- trim标签： 作用：1.在开头或末尾添加特定的前缀prefix或后缀suffix 2.删除开头prefixOverrides或末尾suffixOverrides的特定内容 注：当属性值可能有多个时，可以使用竖杠|来表示或者的意思，且竖杠的后面不能有空格--&gt;&lt;insert id=&quot;insertUser2&quot; parameterType=&quot;User&quot;&gt; insert into t_user &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;id,&lt;/if&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;username,&lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;password,&lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt;phone,&lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt;address,&lt;/if&gt; &lt;/trim&gt; values &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;#&#123;id&#125;,&lt;/if&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt;#&#123;phone&#125;,&lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt;#&#123;address&#125;,&lt;/if&gt; &lt;/trim&gt;&lt;/insert&gt; 6. foreach12345678910111213141516&lt;!-- foreach标签：当参数是集合时，用来对集合进行遍历，一般用在in条件中 collection属性：要遍历的集合，默认List集合指定为list，Map集合指定为map，数组指定为array item属性：迭代变量 open属性：遍历前添加的字符串 close属性：遍历后添加的字符串 separator属性：元素分隔符 index属性：当前迭代元素的索引--&gt;&lt;select id=&quot;selectByIds&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where id in &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; 八、多表关系映射1. 简介关联关系： 多对一，多个员工都在同一个部门中 一对多，一个部门中有多个员工 一对一，一个员工只能有一个身份证 多对多，一个员工可以同时开发多个项目，一个项目也可以同时有多个员工开发 数据库设计： 123456789101112create table t_dept( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;部门名称&#x27;)engine innodb default charset utf8 comment &#x27;部门表&#x27;;create table t_emp( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;姓名&#x27;, salary double comment &#x27;工资&#x27;, dept_id int comment &#x27;部门编号&#x27;, foreign key (dept_id) references t_dept(id))engine innodb default charset utf8 comment &#x27;员工表&#x27;; 2. 保存操作12345678&lt;mapper namespace=&quot;dao.DeptDao&quot;&gt; &lt;insert id=&quot;insertDept&quot; parameterType=&quot;Dept&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_dept (name) values (#&#123;name&#125;) &lt;/insert&gt;&lt;/mapper&gt; 12345678&lt;mapper namespace=&quot;dao.EmpDao&quot;&gt; &lt;insert id=&quot;insertEmp&quot; parameterType=&quot;Emp&quot;&gt; insert into t_emp (name, salary, dept_id) values (#&#123;name&#125;,#&#123;salary&#125;,#&#123;dept.id&#125;) &lt;/insert&gt;&lt;/mapper&gt; 3. 多对一在一个对象中定义另一个对象的属性 两种实现方式： 使用关联属性，即直接使用association标签 使用嵌套查询，即使用association的select属性，引用其他select，通过多个单表查询来实现 12345678910111213141516171819202122232425262728293031323334353637383940&lt;resultMap id=&quot;BaseMap&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;EmpMap&quot; type=&quot;Emp&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- association：用于配置关联属性，多对一的关系 property属性：当前需要映射的是对象中的哪个属性 javaType属性：当前映射的属性的Java类型 标签体：对当前映射的属性所在的表进行映射 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;deptId&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;deptName&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;EmpMap2&quot; type=&quot;Emp&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- select属性：引用其他的select查询配置 值为：select所在Mapper文件的namespace.select的id值 column属性：当前查询的某列，作为查询条件，传递给引用的select查询配置的参数 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot; select=&quot;dao.DeptDao.selectById&quot; column=&quot;dept_id&quot;&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap&quot;&gt; select &lt;include refid=&quot;EmpColumn&quot;/&gt; from t_emp e left join t_dept d on e.dept_id=d.id&lt;/select&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap2&quot;&gt; select id,name,salary,dept_id from t_emp&lt;/select&gt; 嵌套查询的缺点：效率低，会进行多次查询，存在N+1问题 首先查询了1次emp表，获取到N条dept_id的记录 对于每一个不同的dep_id，都会去dept表中进行一次查询，可能会查询N次 所以，总查询次数可能为：1次emp表+N次dept表 4. 一对多在一个对象中定义另一个对象的集合 两种实现方式： 使用集合属性，即直接使用collection标签 使用嵌套查询，即使用collection的select属性，引用其他select，通过多个单表查询来实现 12345678910111213141516171819202122232425262728293031323334353637&lt;resultMap id=&quot;BaseMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;DeptMap&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- collection：用于配置集合属性，一对多的关系 property属性：当前需要映射的集合属性 ofType属性：集合属性中对象的类型 标签体：对集合属性中对象所在的表进行映射 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;empId&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;empName&quot;/&gt; &lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;DeptMap2&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- select属性 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot; select=&quot;dao.EmpDao.selectByDeptId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;DeptMap&quot;&gt; select &lt;include refid=&quot;DeptColumn&quot;/&gt; from t_dept d left join t_emp e on d.id=e.dept_id&lt;/select&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;DeptMap2&quot;&gt; select id,name from t_dept&lt;/select&gt; 5. 懒加载1234567891011121314&lt;resultMap id=&quot;DeptMap2&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- fetchType属性：指定集合属性的加载时机 lazy：延迟加载，当使用到集合属性时，才会加载 eager：立即加载，查询主表时，就会查询集合属性 也可以在主配置文件中，通过setting标签，配置全局的fetchType属性 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot; select=&quot;dao.EmpDao.selectByDeptId&quot; column=&quot;id&quot; fetchType=&quot;lazy&quot;/&gt;&lt;/resultMap&gt;&lt;settings&gt; &lt;!-- 懒加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 九、缓存1. 简介将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据库的压力，同时提高系统性能。 合理使用缓存是优化中最常见的操作。 2. 一级缓存一级缓存是SqlSession级别的，存储在SqlSession中，默认是开启的 一般来说，一个请求中的所有增删改查操作都是在 同一个sqlSession里面的，可以认为每个请求都有自己的一级缓存 如果同一个SqlSession会话中 2个查询中间有一个 insert 、update或delete 语句，那么之前查询的所有缓存都会清空 流程： 用户发起查询请求，查找某条数据，SqlSession 先去缓存中查找，是否有该数据，如果有，读取； 如果没有，从数据库中查询，并将查询到的数据放入一级缓存区域，供下次查找使用。 当SqlSession 执行commit，即增删改操作时会清空缓存。这么做的目的是避免脏读。 生效的条件： 必须使用同一SqlSession，执行同一个查询方法才会有效 同一个SqlSession，如果查询条件不同，则无效 同一个SqlSession，如果两次查询期间执行了任何一次的增删改操作，则无效 3. 二级缓存二级缓存是 mapper 级别的缓存，多个SqlSession去操作同一个Mapper的sql语句时，多个SqlSession可以共用二级缓存 二级缓存是跨SqlSession的，因此二级缓存的作用范围更大 二级缓存默认是关闭的，需要手动开启 流程： 开启二级缓存后，用户查询时，会先去二级缓存中找，找不到了再去一级缓存中找 一级缓存也没有查询到，则查询数据库 当SqlSession会话提交或者关闭时，一级缓存的数据会刷新到二级缓存中 启用二级缓存：在 XxxMapper.xml 映射文件中，添加：&lt;cache/&gt; 十、分页插件1. 简介​ PageHelper是一款基于mybatis的分页插件 2. 用法2.1 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 2.2 插件的配置​ 在mybatis核心配置文件中配置插件 123456&lt;plugins&gt; &lt;!-- 配置mybatis分页插件 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 2.3 使用​ 分为三步： 123456789101112131415161718192021// 1.配置分页信息，指定页码、页大小int pageNum = 3;int pageSize = 4;PageHelper.startPage(pageNum, pageSize);// 2.获取原始数据UserDao userDao = session.getMapper(UserDao.class);List&lt;User&gt; users = userDao.selectAll();for (User user:users)&#123; System.out.println(user);&#125; // 3.将原始数据封装成分页数据PageInfo&lt;User&gt; pageInfo=new PageInfo&lt;&gt;(users);System.out.println(pageInfo);System.out.println(&quot;页码：&quot;+pageInfo.getPageNum());System.out.println(&quot;页大小：&quot;+pageInfo.getPageSize());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;分页数据：&quot;+pageInfo.getList()); 十一、其他1. MyBatisX​ 一款全免费且强大的 IDEA 插件，支持跳转，自动补全生成 SQL，代码生成。 1234567891011create table t_product( pro_id int primary key auto_increment comment &#x27;编号&#x27;, pro_name varchar(100) comment &#x27;产品名称&#x27;, pro_price decimal(10,2) comment &#x27;产品价格&#x27;, pro_number int comment &#x27;产品数量&#x27;, pro_introduce text comment &#x27;产品介绍&#x27;, pro_state tinyint comment &#x27;产品状态(0未通过,1审核中,2已审核)&#x27;, add_time datetime comment &#x27;添加时间&#x27;, is_del tinyint comment &#x27;是否删除(0正常,1删除)&#x27;) engine innodb default charset utf8 comment &#x27;产品表&#x27;; 1234&lt;settings&gt; &lt;!-- 下划线映射为驼峰 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 2. MyBatisCodeHelperPro​ 功能更强大，收费！","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"}]},{"title":"Maven学习","slug":"Maven学习","date":"2023-08-07T01:16:39.000Z","updated":"2023-08-08T05:29:16.903Z","comments":true,"path":"2023/08/07/Maven学习/","link":"","permalink":"http://example.com/2023/08/07/Maven%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Maven简介1. 什么是Maven​ maven [ˈmeɪvn] 专家、内行 ​ Apache Maven 是一个软件项目管理和构建工具，可以帮助创建和管理项目 ​ 基于项目对象模型（POM：Project Object Model）的概念，帮助开发者构建一个项目的完整生命周期 ​ 官网：http://maven.apache.org/ 2. 为什么使用Maven 项目的管理工具 项目规模很大时一定会将项目进行拆分，拆分成多个工程，使用Maven在多个工程之间建立依赖关系 jar包的管理工具 通过仓库管理jar包、解决jar包的依赖、自动下载jar包 自动化的构建工具 编译代码、执行测试、打包、部署等 3. 术语 中央仓库 是一个网络仓库，用于存放jar包和maven插件 https://repo1.maven.org/maven2 https://mvnrepository.com 本地仓库 从中央仓库下载的jar包的存放位置，也是一个仓库，只不过是存放在本地电脑上 镜像仓库 对中央仓库做的镜像（mirror） 阿里云提供的镜像仓库 https://maven.aliyun.com/repository/public 私服 局域网内部搭建的maven服务器 二、安装Maven1. 下载安装包​ 从maven官网下载安装包，这里使用apache-maven-3.6.0-bin.tar.gz 2. 解压安装包​ 将安装包解压到无中文、无空格的路径下，如：D:\\software\\apache-maven-3.6.0 ​ 配置环境变量，将bin目录添加到Path变量中，如：D:\\software\\apache-maven-3.6.0\\bin ​ 测试，在DOS窗口中执行以下命令： 1mvn -version 3. 配置本地仓库本地仓库的默认位置： ~&#x2F;.m2&#x2F;repository（如 C:&#x2F;Users&#x2F;登录用户&#x2F;.m2&#x2F;repository） 修改本地仓库的位置：编辑conf&#x2F;setting.xml文件 1234&lt;settings&gt; &lt;!--指定本地仓库的位置--&gt; &lt;localRepository&gt;D:\\maven-repos&lt;/localRepository&gt;&lt;/settings&gt; 4. 配置镜像仓库​ 使用maven时默认从中央仓库下载所需的包(插件)，比较慢，可以配置使用阿里云提供的镜像仓库 ​ 编辑maven主目录下的&#x2F;conf&#x2F;setting.xml文件，在&lt;mirrors&gt;&lt;/mirrors&gt;标签中添加如下内容： 123456&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;!-- 名称自定义，必须唯一 --&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;!-- 所有访问都使用该镜像仓库 --&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 5. 配置Maven的JDK版本​ 修改maven默认使用的jdk版本，编辑conf&#x2F;setting.xml文件，在profiles标签里面添加如下内容 123456789101112&lt;profile&gt; &lt;id&gt;jdk‐1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 三、使用Maven1. 在IDEA中集成maven指定Maven主目录和配置文件：Settings——&gt;搜索Maven——&gt;Maven Home directory和User settings file 注：切换Porject后要重新配置maven 2. 创建maven项目File——&gt;New——&gt;Module——&gt;Maven Archetype Archetype：maven-archetype-quickstart（Java项目） &#x2F; maven-archetype-webapp（Java Web项目） GroupId : net.wanho.shop（组织域名反向+项目名称） ArtifactId : shop-product（模块名称） Version : 1.0.1（版本） 3. 目录结构Maven项目的目录结构如下： 1234567891011121314|-项目名称 |-src //程序代码 |-main //主代码 |-java //源代码 |-用于存放源代码，相当于传统项目中的src，传统项目的包名.类名，如net.wanho.shop.dao |-resources //配置文件 |-用于存放配置文件 |-webapp //网站根目录 |-WEB-INF |-web.xml |-test //测试代码，目录结构和main中完全一致 |-java |-resources |-pom.xml //maven核心配置文件 如果没有对应的目录，可以自己创建，但必须符合该目录结构 在IDEA中目录是分类型的，常用的有四种： Sources Root：主代码的目录——&gt;src&#x2F;main&#x2F;java Test Sources Root：测试代码的目录——&gt;src&#x2F;test&#x2F;java Resources Root：主代码所需资源的目录——&gt;src&#x2F;main&#x2F;resources Test Resources Root：测试代码所需资源的目录——&gt;src&#x2F;test&#x2F;resources 默认情况下新建的目录是普通的Directory，创建后可以设置目录的类型： 右击目录——&gt;Mark Directory As 每种目录的图标有所不同 4. 执行maven操作在IDEA中管理所有Maven项目：View——&gt;Tool Windows——&gt;Maven Maven项目的生命周期： 命令 作用 描述 clean 清理 删除target目录 compile 编译 将main&#x2F;中的源代码编译成字节码文件，放在target&#x2F;classes目录下 test 测试 执行测试类（使用JUnit），并生成测试报告，放在target&#x2F;surefire-reports目录下 package 打包 将java项目打包成jar，将web项目打包成war，放在target目录下 install 安装 将项目的jar包安装到本地仓库，供其他项目使用 注意： 问题：在Maven Projects中项目显示为灰色，表示该maven项目未被管理，不可用 解决：在Maven Projects里点击”+”，选择项目对应的pom.xml文件 四、pom.xml文件1. 简介​ pom:project object model 项目对象模型 ​ pom.xml是Maven的核心配置文件，与项目构建相关的所有配置都在该文件中 2. 坐标​ 用来唯一的标识每个项目，必须为项目定义坐标，且坐标必须唯一 ​ Maven坐标是通过一些元素定义的：groupId、artifactId、version 123456789&lt;!-- 坐标： groupId：定义组织id，表示当前模块隶属的项目，采用&quot;组织域名反向+项目名称&quot; artifactId：定义模块id version：定义当前的版本--&gt;&lt;groupId&gt;net.wanho.shop&lt;/groupId&gt;&lt;artifactId&gt;shop-product&lt;/artifactId&gt;&lt;version&gt;1.0.1&lt;/version&gt; 3. dependency​ 如何查找一个jar包的坐标? https://mvnrepository.com 12345678910111213141516171819202122232425262728293031&lt;!-- dependency基本配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; ​ scope表示依赖的作用域，用来配置依赖的jar包的可作用范围，即在什么地方可以使用 取值 含义 举例 compile 表示该依赖可以在整个项目中使用，参与打包部署，默认值 fastjson test 表示该依赖只能在测试程序中使用，不参与打包和部署 junit provided 表示编写源代码的时候需要，不参与打包部署 lombok、servlet-api（因为tomcat中已有） runtime 表示运行时需要，编译代码时不需要 mysql-connector（通过接口反射加载） 4. properties​ 全局属性，一般情况下用于定义全局的jar的版本 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 可以自定义标签名，然后使用 $&#123;标签名&#125; 获取标签中的值 一般情况下用于定义全局的jar的版本，相当于定义全局变量 --&gt; &lt;spring.version&gt;5.3.27&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 注：快速将jar包的版本添加到properties中：右击版本号——&gt;Refactor——&gt;Property 5. repositories​ 用于配置当前工程使用的远程仓库 ​ 查找顺序：本地仓库、pom.xml中配置的远程仓库、maven主录下的conf&#x2F;setting.xml中配置的远程仓库 1234567&lt;repositories&gt; &lt;!-- 有些最新版本的jar包，在中央仓库中可能并没有，此时可以指定其他可用的远程仓库 --&gt; &lt;repository&gt; &lt;id&gt;springio&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 6. plugins插件是一种工具，如 maven-clean-plugin插件是用来清理项目的工具 maven-compile-plugin插件是用来编译代码的工具 tomcat7-maven-plugin插件是用来将web项目自动打包并部署到tomcat的工具 1234567891011121314&lt;build&gt; &lt;plugins&gt; &lt;!-- tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8888&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 7. 案例Web应用的开发，模块名称：shop-user 步骤： 添加依赖 12345678910111213&lt;!-- servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 创建HelloServlet类 1234567891011121314151617@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setAttribute(&quot;name&quot;,&quot;tom&quot;); List&lt;Integer&gt; nums = Arrays.asList(13, 25, 38); req.setAttribute(&quot;nums&quot;,nums); Properties p=new Properties(); p.load(HelloServlet.class.getClassLoader().getResourceAsStream(&quot;stu.properties&quot;)); System.out.println(p); req.setAttribute(&quot;age&quot;,p.getProperty(&quot;age&quot;)); req.setAttribute(&quot;sex&quot;,p.getProperty(&quot;sex&quot;)); req.getRequestDispatcher(&quot;/index.jsp&quot;).forward(req,resp); &#125;&#125; 创建index.jsp 1234567891011121314151617&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--默认生成的web.xml文件使用的是web-app_2_3.dtd，会忽略EL表达式，需要启用EL表达式--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;name&#125; &lt;br&gt; &lt;ul&gt; &lt;c:forEach items=&quot;$&#123;hobbies&#125;&quot; var=&quot;hobby&quot;&gt; &lt;li&gt;$&#123;hobby&#125;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; stu.properties 123name=aliceage=21sex=male 五、Maven中的关系1. 继承含义：一个Maven工程继承自另一个Maven工程，分别称为子工程、父工程 场景：实际开发中一个大项目会拆分为多个子项目（子模块&#x2F;子工程），多个子工程使用的技术基本都相同，即多个子工程中使用的是相同的依赖或插件等配置，此时可以把相同配置抽取到一个父工程中，进行统一管理，保持一致性，简化pom.xml配置 步骤： 创建三个工程：子工程child01和child02、父工程parent 将父项目的打包方式设置为pom 12345678&lt;!-- 打包方式 jar：java项目的打包方式，默认值 war：web项目的打包方式 pom：父项目的打包方式 注：将父工程打包方式设置为pom后，父工程将不会被打包，因此不要在父工程中写java代码，父工程只是用来简化POM配置 --&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 在子项目中引用父项目，指定父项目的坐标，并指定父项目pom.xml文件的路径 12345678&lt;!-- 引用父项目，指定父项目的坐标 --&gt;&lt;parent&gt; &lt;groupId&gt;net.wanho.study&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 指定父项目pom.xml文件的相对物理路径 --&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; 注：如果子项目的位置是在父项目所在的目录中，则可以省略不配置relativePath项 问题：有时并不是父项目的所有ja包都需要被子项目继承，但又希望能够对依赖进行统一管理，如：jar包版本的控制，怎么办？ 解决：配置dependencyManagement 步骤： 在父项目中配置dependencyManagement此时父项目只进行jar包的管理，父项目的jar包默认并不会被子项目继承 12345678910111213141516171819202122&lt;!-- dependencyManagement表示父项目只进行依赖的管理，依赖默认不会被子项目继承 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在子项目中引用父项目中的依赖 如果子项目想继承父项目的jar包，需要在子项目中手动引用，且引用时只需要配置groupId和artifactId，无需指定版本version 123456789101112131415&lt;dependencies&gt; &lt;!-- 父项目配置dependencyManagement后默认并不会继承过来，需要手动在子项目中引用 只需要指定groupId和artifactId，无需指定版本version 可以指定要引用的依赖，并不一定要使用父项目中所有的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 聚合将多个子项目聚合到一个父项目中，然后通过对该父项目进行操作，从而实现对所有的聚合项目的操作 在父项目中聚合子项目： 12345&lt;!-- 聚合子项目，指定子项目的根目录--&gt;&lt;modules&gt; &lt;module&gt;../child01&lt;/module&gt; &lt;module&gt;../child02&lt;/module&gt;&lt;/modules&gt; 3. 依赖项目C —&gt; 项目B —&gt; 项目A 概念：如果项目C依赖于项目B，项目B依赖于项目A，则项目C也依赖于项目A，这叫依赖的传递 步骤： 配置依赖关系 child03——&gt;child02——&gt;child01 在child01中添加依赖时，child02和child03会传递该依赖，也会出现该依赖 3.1 控制依赖的传递并不是所有的依赖都会被传递： scope为compile的依赖会被传递 scope为test和provided的依赖不会被传递 配置optional为true的依赖不会被传递 123456&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 表示该jar包不传递 --&gt;&lt;/dependency&gt; 3.2 继承和依赖的区别继承： 使用&lt;parent&gt; 继承是指子项目可以继承父项目的数据和配置，从而简化配置 继承时父项目一般都是自己创建的项目，也可以是第三方的 依赖： 使用&lt;dependencies&gt; 依赖是指jar包可以通过依赖的方式引入 依赖时所依赖的jar包一般多是第三方的，也可以是自己创建的依赖项目 六、Maven综合应用1. 分析将项目分为多个工程，可以按层次分，也可以按模块分，或者同时按层次和模块分 以ums为例，使用Maven创建和管理项目： 父工程：ums-parent dao工程：ums-dao service工程：ums-service web工程：ums-web 2. 步骤2.1 创建工程 创建父工程：ums-parent File——&gt;New——&gt;Module——&gt;Maven Archetype——&gt;maven-archetype-quickstart GroupId：net.wanho.ums ArtifactId：ums-parent Context root：~&#x2F;IdeaProjects&#x2F;framework&#x2F;ums-parent 创建子工程：ums-dao 右键ums-parent父工程——&gt;New——&gt;Module——&gt;Maven Archetype——&gt;maven-archetype-quickstart ArtifactId：ums-dao Content root：~&#x2F;IdeaProjects&#x2F;framework&#x2F;ums-parent&#x2F;ums-dao 创建子工程：ums-service 创建子工程：ums-web，web工程 2.2 配置依赖 在父工程中配置依赖管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;javax.servlet-api.version&gt;4.0.1&lt;/javax.servlet-api.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;mysql-connector-java.version&gt;5.1.38&lt;/mysql-connector-java.version&gt; &lt;fastjson.version&gt;1.2.31&lt;/fastjson.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;hutool-all.version&gt;5.8.15&lt;/hutool-all.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hutool --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;$&#123;hutool-all.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在各个子工程中引用依赖 ums-dao 123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; ums-service 123456&lt;!-- 依赖于dao --&gt;&lt;dependency&gt; &lt;groupId&gt;net.wanho.ums&lt;/groupId&gt; &lt;artifactId&gt;ums-dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; ums-web 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 依赖于service --&gt; &lt;dependency&gt; &lt;groupId&gt;net.wanho.ums&lt;/groupId&gt; &lt;artifactId&gt;ums-service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 部署访问 先对其他模块进行install操作，然后再对ums-web进行部署访问 2.3 配置dao子工程​ create.sql 123456789drop database if exists ums;create database ums charset utf8;use ums;create table t_user( id int primary key auto_increment, username varchar(100), password varchar(100), age int) engine=Innodb charset utf8; ​ datasource.properties 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ums?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=root 2.3 配置service子工程2.4 配置web子工程2.5 测试​ 只要修改了其他模块，都需要先对这些模块进行install操作，然后再对ums-web进行部署访问","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"}]},{"title":"Java-后端多表增删改查","slug":"Java-后端多表增删改查","date":"2023-07-30T11:27:36.000Z","updated":"2023-08-03T02:36:11.461Z","comments":true,"path":"2023/07/30/Java-后端多表增删改查/","link":"","permalink":"http://example.com/2023/07/30/Java-%E5%90%8E%E7%AB%AF%E5%A4%9A%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","excerpt":"","text":"1. Many2One1.1 数据建模关系图 表结构123456789101112131415161718192021222324252627282930313233drop table if exists t_clazz;/*==============================================================*//* Table: t_clazz 父 *//*==============================================================*/create table t_clazz( bno varchar(20) not null, name varchar(20), primary key (bno));alter table t_clazz comment &#x27;班级表&#x27;;drop table if exists t_student;/*==============================================================*//* Table: t_student 子 *//*==============================================================*/create table t_student( sid varchar(20) not null comment &#x27;学号 主键&#x27;, name varchar(20) comment &#x27;姓名&#x27;, age int(3) comment &#x27;年龄&#x27;, sex int(1) comment &#x27;性别 0 男 1 女&#x27;, bno varchar(20), primary key (sid));alter table t_student comment &#x27;学生信息表&#x27;;alter table t_student add constraint FK_stu_clazz_bno foreign key (bno) references t_clazz (bno) on delete restrict on update restrict; 表数据12345678910111213141516171819public abstract class BaseTest &#123; protected JDBCTemplate jdbcTemplate = new JDBCTemplate() ; // 初始化 测试环境 @Before public void before()&#123; //清空表数据 truncate table 截断表 无法使用 关联关系 先删除儿子 在删除爹 jdbcTemplate.update(&quot;delete from t_student &quot;) ; jdbcTemplate.update(&quot;delete from t_clazz &quot;) ; //插入班级数据 jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B001&#x27;,&#x27;Java177&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B002&#x27;,&#x27;Java178&#x27;)&quot;) ; //插入 68 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student(sid,name,age,sex,bno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;张三&quot;+(i+1)+&quot;&#x27;,18,0,&#x27;B001&#x27;)&quot;) ; &#125; &#125;&#125; 1.2 领域建模1234public class Clazz &#123; private String bno ; private String name ;&#125; 1234567public class Student &#123; private String sid ; private String name ; private Integer age ; private Integer sex ; private Clazz clazz = new Clazz() ;&#125; 1.3 列表DAO12-- 分页查询的SQL： select sid,s.name,age,sex,c.bno &quot;clazz.bno&quot;,c.name &quot;clazz.name&quot; from t_student s left join t_clazz c on s.bno = c.bno where 1=1 12345// t_student表 t_clazz表 同名列 二义性 条件查询需指定 哪个表的nameif (query!=null &amp;&amp; StringUtils.isNotEmpty(query.getName())) &#123; sb.append(&quot; and s.name like ?&quot;) ; paramList.add(&quot;%&quot;+query.getName()+&quot;%&quot;); &#125; jsplist-stu.jsp 12345678910111213141516171819202122232425262728293031&lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;班号&lt;/th&gt; &lt;th&gt;班名&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;studentPage.list&#125;&quot; var=&quot;student&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;sid&quot; value=&quot;$&#123;student.sid&#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.clazz.bno&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.clazz.name&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-stu.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-stu.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt;&lt;/table&gt; 1.4 新增beforeDAO123public interface ClazzDAO &#123; List&lt;Clazz&gt; selectAll() ;&#125; 1234567891011public class ClazzDAOImpl implements ClazzDAO &#123; private JDBCTemplate jdbcTemplate = new JDBCTemplate() ; @Override public List&lt;Clazz&gt; selectAll() &#123; String DQL = &quot;select bno,name from t_clazz&quot; ; Object[] paramAy = &#123;&#125; ; return jdbcTemplate.queryList(DQL,Clazz.class,paramAy); &#125;&#125; Service123456789101112public class ClazzService &#123; private ClazzDAO clazzDAO = new ClazzDAOImpl() ; /** * 查询所有班级 * @return */ public Collection&lt;Clazz&gt; list()&#123; return clazzDAO.selectAll(); &#125;&#125; Controller1234567891011121314151617@WebServlet(...&quot;/toAddView-stu.do&quot;&#125;)public class StudentServlet extends HttpServlet &#123; private ClazzService clazzService = new ClazzService() ; ... service(..)&#123; else if (&quot;/toAddView-stu.do&quot;.equals(requestURI))&#123; this.toAddView(request,response) ; &#125; &#125; //跳转到新增学生界面 protected void toAddView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Collection&lt;Clazz&gt; clazzList = clazzService.list(); request.setAttribute(&quot;clazzList&quot;,clazzList); request.getRequestDispatcher(&quot;/add-stu.jsp&quot;).forward(request,response); &#125;&#125; Jsplist-stu.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toAddView-stu.do&quot; class=&quot;btn btn-primary&quot;&gt;添加学生&lt;/a&gt; add-stu.jsp 1234567891011&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;班级&lt;/label&gt; &lt;select name=&quot;clazz.bno&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择班级--&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;option value=&quot;$&#123;clazz.bno&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/div&gt; 1.5 新增DAO123456@Overridepublic boolean insert(Student student) &#123; String DQL = &quot;insert into t_student(sid,name,age,sex,bno) values (?,?,?,?,?)&quot; ; Object[] paramAy = &#123;student.getSid(),student.getName(),student.getAge(),student.getSex(),student.getClazz().getBno()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; Controller12//重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/page-stu.do&quot;); 1.6 查看jspmodify-stu.jsp 123456789101112131415&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;班级&lt;/label&gt; &lt;select name=&quot;clazz.bno&quot; class=&quot;form-control&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择班级--&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;option value=&quot;$&#123;clazz.bno&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/div&gt;//设置下拉框被选中$(&quot;select&quot;).val(&quot;$&#123;student.clazz.bno&#125;&quot;) Controller123456789101112protected void view(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得查看的学生编号 String sid = request.getParameter(&quot;sid&quot;); //2.调用业务方法 Student student = studentService.get(sid); //3.request作用域中设置 学生信息 request.setAttribute(&quot;student&quot;,student); Collection&lt;Clazz&gt; clazzList = clazzService.list(); request.setAttribute(&quot;clazzList&quot;,clazzList); //4.跳转页面 服务器内部跳转 request.getRequestDispatcher(&quot;/modify-stu.jsp&quot;).forward(request,response); &#125; DAO1String DQL = &quot;select sid,s.name,age,sex,c.bno \\&quot;clazz.bno\\&quot;,c.name \\&quot;clazz.name\\&quot; from t_student s left join t_clazz c on s.bno = c.bno where s.sid=?&quot; ; 1.7 修改DAO123456@Overridepublic boolean update(Student student) &#123; String DQL = &quot;update t_student set name=?,age=?,sex=?,bno=? where sid=?&quot; ; Object[] paramAy = &#123;student.getName(),student.getAge(),student.getSex(),student.getClazz().getBno(),student.getSid()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; 2. One2Many2.1 列表[单表]controller1234567891011121314151617181920212223242526272829303132@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;&#125;)public class ClazzServlet extends HttpServlet &#123; /** 班级业务实例 */ private ClazzService clazzService = new ClazzService() ; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得请求的url 包含项目名 String requestURI = request.getRequestURI(); //2. 去掉项目名 /list-stu.do /add-stu.do requestURI = requestURI.replace(request.getContextPath(),&quot;&quot;); //3.判断 url 与方法 调用 if (&quot;/list-clazz.do&quot;.equals(requestURI))&#123; this.list(request,response) ; &#125; &#125; /** * * @param request * @param response * @throws ServletException * @throws IOException */ protected void list(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 调用业务方法 Collection&lt;Clazz&gt; clazzCollection = clazzService.list(); //2. 把查询数据保存 四种(pageContext,request,session,application)属性作用域中 set ==&gt; list-stu.jsp get request.setAttribute(&quot;clazzList&quot;,clazzCollection); //3. 跳转到 list-stu.jsp request.getRequestDispatcher(&quot;/list-clazz.jsp&quot;).forward(request,response); &#125;&#125; jspindex.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/list-clazz.do&quot;&gt;班级列表&lt;/a&gt; &lt;br&gt; list-clazz.jsp 1234567891011 &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;bno&quot; value=&quot;$&#123;clazz.sid&#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;clazz.bno&#125;&lt;/td&gt; &lt;td&gt;$&#123;clazz.name&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-clazz.do?sid=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-clazz.do?sid=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 2.2 新增准备【裸跳页面】逻辑上： 直接怼到页面 比如 add-clazz.jsp OCP A. 代码复用 B.新增班级 【权限访问控制？当前登录用户是否有权限？】 jsplist-clazz.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toAddView-clazz.do&quot; class=&quot;btn btn-primary&quot;&gt;添加班级&lt;/a&gt; add-clazz.jsp 1234567891011121314151617181920212223242526272829&lt;h1&gt;新增班级&lt;/h1&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/add-clazz.do&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sid&quot;&gt;班号&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sid&quot; name=&quot;bno&quot; value=&quot;$&#123;param.bno&#125;&quot; placeholder=&quot;请输入班号&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sname&quot;&gt;班名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sname&quot; name=&quot;name&quot; value=&quot;$&#123;param.name&#125;&quot; placeholder=&quot;请输入班名&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;新增&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;重置&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; Controller1234567891011// ClazzServlet@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;&#125;).... else if(&quot;/toAddView-clazz.do&quot;.equals(requestURI))&#123; this.toAddView(request,response) ; &#125;//跳转到新增班级界面protected void toAddView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher(&quot;/add-clazz.jsp&quot;).forward(request,response);&#125; 2.3 新增【单表】controller12345678910111213141516171819202122232425262728//添加新的请求 url@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;&#125;)//添加判断 调用自定义的方法else if(&quot;/add-clazz.do&quot;.equals(requestURI))&#123; this.add(request,response) ;&#125;protected void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置请求中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); //调用 自定义 工具类 实现：解析请求自动封装 pojo中 Clazz clazz = RequestUtil.parseParameter(request, Clazz.class); //4. 调用业务方法 boolean saveRs = clazzService.save(clazz); //5. 根据业务方法的返回值 if (saveRs)&#123; //6.响应 //重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do&quot;); return; &#125; //新增失败 view实现显示效果 request.setAttribute(&quot;errorMsg&quot;,&quot;班号已经存在！！！&quot;); //使用服务器内部跳转 request.getRequestDispatcher(&quot;/toAddView-clazz.do&quot;).forward(request,response);&#125; Service12345678910111213... ClazzService &#123; public boolean save(Clazz clazz) &#123; //获得新增的班号 String bno = clazz.getBno() ; //1.判断是否 新增的班号 db 中已经存在 Clazz dbClazz = clazzDAO.selectById(bno); if (dbClazz!=null)&#123; return false ; &#125; //班号不存在 向数据库插入数据 return clazzDAO.insert(clazz) ; &#125;&#125; DAO12345... ClazzDAO&#123; Clazz selectById(String bno); boolean insert(Clazz clazz);&#125; 123456789101112131415... ClazzDAOImpl ... &#123; @Override public Clazz selectById(String bno) &#123; String DQL = &quot;select bno,name from t_clazz where bno=?&quot; ; Object[] paramAy = &#123;bno&#125; ; return jdbcTemplate.queryObject(DQL,Clazz.class,paramAy); &#125; @Override public boolean insert(Clazz clazz) &#123; String DQL = &quot;insert into t_clazz(bno,name) values (?,?)&quot; ; Object[] paramAy = &#123;clazz.getBno(),clazz.getName()&#125; ; return jdbcTemplate.update(DQL,paramAy); &#125;&#125; 2.4 删除【单表&#x2F;子记录依赖】jsplist-clazz.jsp 123 &lt;form action=&#x27;$&#123;pageContext.request.contextPath&#125;/del-clazz.do&#x27;&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;bno&quot; value=&quot;$&#123;clazz.bno&#125;&quot; /&gt;&lt;/td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-clazz.do?bno=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; controller1234567891011121314151617181920@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;&#125;)else if(&quot;/del-clazz.do&quot;.equals(requestURI))&#123; this.del(request,response) ;&#125;protected void del(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得 删除的班号 String[] idAy = request.getParameterValues(&quot;bno&quot;); //把数组 拼接成一个 字符串 String id =&quot;&quot;; for (String s : idAy) &#123; id +=s+&quot;,&quot; ; &#125; id = id.substring(0,id.length()-1) ; //2. 调用业务方法 boolean removeRs = clazzService.remove(id); String msg = removeRs?&quot;&quot;:&quot;del-fail&quot; ; response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do?msg=&quot;+msg);&#125; Service123456789101112131415161718public class ClazzService &#123; private StudentDAO studentDAO = new StudentDAOImpl() ; public boolean remove(String id) &#123; //字符串 转成数组 String[] sidAy = id.split(&quot;,&quot;); for (String bno : sidAy) &#123; //根据FK 查询学生列表 List&lt;Student&gt; studentList = studentDAO.selectByFk(bno); //删除班级编号 在学生表中出现了 不能删除 if (!studentList.isEmpty())&#123; return false ; &#125; &#125; //调用批处理删除 return clazzDAO.delete(sidAy) ; &#125;&#125; DAOStudentDAO1List&lt;Student&gt; selectByFk(String bno) ; 123456@Overridepublic List&lt;Student&gt; selectByFk(String bno) &#123; String DQL = &quot;select sid,name,age,sex from t_student where bno=?&quot; ; Object[] paramAy = &#123;bno&#125; ; return jdbcTemplate.queryList(DQL,Student.class,paramAy);&#125; ClazzDAO1boolean delete(String ... idAy) ; 123456789101112public class ClazzDAOImpl implements ClazzDAO &#123; @Override public boolean delete(String... sidAy) &#123; String DML = &quot;delete from t_clazz where bno=?&quot; ; Object[][] paramAy = new Object[sidAy.length][1] ; for (int i = 0; i &lt; sidAy.length; i++) &#123; paramAy[i][0] = sidAy[i] ; &#125; return jdbcTemplate.updateBatch(DML,paramAy); &#125;&#125; 2.5 查看【N+1】jsplist-clazz.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-clazz.do?bno=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; modify-clazz.jsp 1234567891011121314151617&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sname&quot; name=&quot;name&quot; value=&quot;$&#123;clazz.name&#125;&quot; placeholder=&quot;请输入班名&quot;/&gt;&lt;c:forEach items=&quot;$&#123;clazz.studentList&#125;&quot; var=&quot;student&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; Controller1234567891011121314151617@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;,&quot;/view-clazz.do&quot;&#125;)else if(&quot;/view-clazz.do&quot;.equals(requestURI))&#123; this.view(request,response) ;&#125;protected void view(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得查看的学生编号 String bno = request.getParameter(&quot;bno&quot;); //2.调用业务方法 Clazz clazz = clazzService.get(bno) ; //3.request作用域中设置 学生信息 request.setAttribute(&quot;clazz&quot;,clazz); //4.跳转页面 服务器内部跳转 request.getRequestDispatcher(&quot;/modify-clazz.jsp&quot;).forward(request,response);&#125; Service12345678910 public Clazz get(String bno) &#123; //N+1查询 //1. 根据班级id 查询 班级对象 单表查询 Clazz clazz = clazzDAO.selectById(bno); //2. 根据班级id 查询当前班级的学生列表 单表查询 List&lt;Student&gt; studentList = studentDAO.selectByFk(bno); //3.当前班级对象的 stuList属性进行赋值 clazz.setStudentList(studentList); return clazz ;&#125; 2.6 修改【单表】jspmodify-clazz.jsp 12&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/modify-clazz.do&quot; method=&quot;post&quot;&gt; .... controller123456789101112131415161718192021222324@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;,&quot;/view-clazz.do&quot;,&quot;/modify-clazz.do&quot;&#125;)else if(&quot;/modify-clazz.do&quot;.equals(requestURI))&#123; this.modify(request,response) ;&#125;protected void modify(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置请求中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); //调用 自定义 工具类 实现：解析请求自动封装 pojo中 Clazz clazz = RequestUtil.parseParameter(request, Clazz.class); //4. 调用业务方法 boolean modifyRs = clazzService.modify(clazz); //5. 根据业务方法的返回值 if (modifyRs)&#123; //6.响应 //重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do&quot;); return; &#125; request.setAttribute(&quot;errorMsg&quot;,&quot;修改班级失败！！！&quot;); request.getRequestDispatcher(&quot;/view-clazz.do&quot;).forward(request,response);&#125; Service123public boolean modify(Clazz clazz) &#123; return clazzDAO.update(clazz) ;&#125; DAO1boolean update(Clazz clazz); 123456@Overridepublic boolean update(Clazz clazz) &#123; String DQL = &quot;update t_clazz set name=? where bno=?&quot; ; Object[] paramAy = &#123;clazz.getName(),clazz.getBno()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; 3. Many2Many3.1 数据建模表关系 表结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869drop table if exists t_clazz;/*==============================================================*//* Table: t_clazz 父 *//*==============================================================*/create table t_clazz( bno varchar(20) not null, name varchar(20), primary key (bno));alter table t_clazz comment &#x27;班级表&#x27;;drop table if exists t_student;/*==============================================================*//* Table: t_student 子 *//*==============================================================*/create table t_student( sid varchar(20) not null comment &#x27;学号 主键&#x27;, name varchar(20) comment &#x27;姓名&#x27;, age int(3) comment &#x27;年龄&#x27;, sex int(1) comment &#x27;性别 0 男 1 女&#x27;, bno varchar(20), primary key (sid));alter table t_student comment &#x27;学生信息表&#x27;;drop table if exists t_teacher;/*==============================================================*//* Table: t_teacher *//*==============================================================*/create table t_teacher( tno varchar(20) not null, tname varchar(20), primary key (tno));alter table t_teacher comment &#x27;教师表&#x27;;drop table if exists t_student_teacher;/*==============================================================*//* Table: t_student_teacher *//*==============================================================*/create table t_student_teacher( tno varchar(20) not null, sid varchar(20) not null comment &#x27;学号 主键&#x27;, primary key (tno, sid));alter table t_student_teacher comment &#x27;教师学生关系表&#x27;;alter table t_student_teacher add constraint FK_stu_teacher_teacher_tno foreign key (tno) references t_teacher (tno) on delete restrict on update restrict;alter table t_student_teacher add constraint FK_stu_teacher_stu_sid foreign key (sid) references t_student (sid) on delete restrict on update restrict;alter table t_student add constraint FK_stu_clazz_bno foreign key (bno) references t_clazz (bno) on delete restrict on update restrict; 表数据12345678910111213141516171819202122232425@Beforepublic void before()&#123; //清空表数据 truncate table 截断表 无法使用 关联关系 先删除儿子 在删除爹 jdbcTemplate.update(&quot;delete from t_student_teacher &quot;) ; jdbcTemplate.update(&quot;delete from t_teacher &quot;) ; jdbcTemplate.update(&quot;delete from t_student &quot;) ; jdbcTemplate.update(&quot;delete from t_clazz &quot;) ; //插入班级数据 jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B001&#x27;,&#x27;Java177&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B002&#x27;,&#x27;Java178&#x27;)&quot;) ; //插入学生 68 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student(sid,name,age,sex,bno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;张三&quot;+(i+1)+&quot;&#x27;,18,0,&#x27;B001&#x27;)&quot;) ; &#125; //插入教师数据 jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T001&#x27;,&#x27;赵贺贺&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T002&#x27;,&#x27;赵健&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T003&#x27;,&#x27;马美平&#x27;)&quot;) ; //插入学生与教师关系表 68*2 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student_teacher(sid,tno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;T001&#x27;),(&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;T002&#x27;)&quot;) ; &#125;&#125; 3.2 列表pojo1234public class Teacher &#123; private String tno ; private String tname ;&#125; 12345public class Student &#123; ... /**Many2Many 一个学生拥有多个老师 */ private List&lt;Teacher&gt; teacherList ;&#125; DAO123public interface TeacherDAO &#123; List&lt;Teacher&gt; selectBySid(String sid) ;&#125; 123456789public class TeacherDAOImpl implements TeacherDAO &#123; private JDBCTemplate jdbcTemplate = new JDBCTemplate() ; @Override public List&lt;Teacher&gt; selectBySid(String sid) &#123; String DQL = &quot;select tno,tname from t_teacher where tno in (select tno from t_student_teacher where sid = ?)&quot; ; Object[] paramAy = &#123;sid&#125; ; return jdbcTemplate.queryList(DQL, Teacher.class,paramAy); &#125;&#125; service123456789101112131415161718192021public class StudentService &#123; private TeacherDAO teacherDAO = new TeacherDAOImpl() ; public void selectPage(Page&lt;Student, StudentQuery&gt; page)&#123; //1.统计总记录数 long count = studentDAO.count(page.getCond()); //2.查询当前页面的数据 List&lt;Student&gt; studentList = studentDAO.selectPage(page); //循环所有的学生列表 for (Student student : studentList) &#123; //根据学号查询老师信息 List&lt;Teacher&gt; teacherList = teacherDAO.selectBySid(student.getSid()); //设置到 当前学生的 关联老师集合属性 student.setTeacherList(teacherList); &#125; //3. 设置总记录数 page.setTotalRecord(count); //4. 设置当前页的数据 page.setList(studentList); &#125;&#125; jsplist-stu.jsp 123456&lt;td&gt; &lt;c:forEach items=&quot;$&#123;student.teacherList&#125;&quot; var=&quot;teacher&quot; varStatus=&quot;vs&quot;&gt; $&#123;teacher.tname&#125; &lt;c:if test=&quot;$&#123;not vs.last&#125;&quot;&gt;,&lt;/c:if&gt; &lt;/c:forEach&gt;&lt;/td&gt; 3.3 显示关联教师DAO123public interface TeacherDAO &#123; List&lt;Teacher&gt; selectAll();&#125; 12345678public class TeacherDAOImpl implements TeacherDAO &#123; @Override public List&lt;Teacher&gt; selectAll() &#123; String DQL = &quot;select tno,tname from t_teacher&quot; ; Object[] paramAy = &#123;&#125; ; return jdbcTemplate.queryList(DQL, Teacher.class,paramAy); &#125;&#125; Service123456789101112131415161718public class StudentService &#123; private TeacherDAO teacherDAO = new TeacherDAOImpl() ; /** * 根据id 查询学生信息 * @param sid * @return */ public Student get(String sid)&#123; //学生信息 班级信息 Student student = studentDAO.selectById(sid) ; // N+1 根据学生id 查询关联的教师 List&lt;Teacher&gt; teacherList = teacherDAO.selectBySid(sid); // 设置当前学生关联的教师信息 student.setTeacherList(teacherList); return student ; &#125;&#125; Controller1234567891011121314151617181920@WebServlet(.... &quot;/toSelectView-teacher.do&quot;&#125;)else if (&quot;/toSelectView-teacher.do&quot;.equals(requestURI))&#123; this.toSelectTeacherView(request,response) ;&#125;protected void toSelectTeacherView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得学生的id String sid = request.getParameter(&quot;sid&quot;); //2.查询当前学生信息 Student student = studentService.get(sid); //3.查询所有的老师信息 List&lt;Teacher&gt; teacherList = teacherService.list() ; //4. 数据存放在作用域中 request.setAttribute(&quot;student&quot;,student); request.setAttribute(&quot;teacherList&quot;,teacherList); request.getRequestDispatcher(&quot;/select-teacher.jsp&quot;).forward(request,response);&#125; Jsplist-stu.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toSelectView-teacher.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;关联教师&lt;/a&gt; select-teacher.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div class=&quot;container&quot;&gt; &lt;h1&gt;学生选择教师&lt;/h1&gt; &lt;div class=&quot;widget-content padded clearfix&quot;&gt; &lt;!-- 学生基本信息 --&gt; &lt;table class=&quot;table detail-view&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性别&lt;/th&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;td&gt;$&#123;student.clazz.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;!-- 教师信息 --&gt; &lt;form action=&quot;&quot;&gt; &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/th&gt; &lt;th&gt;工号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;teacherList&#125;&quot; var=&quot;teacher&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;tno&quot; value=&quot;$&#123;teacher.tno&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;$&#123;teacher.tno&#125;&lt;/td&gt; &lt;td&gt;$&#123;teacher.tname&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;关联教师&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 循环当前学生的关联老师信息 &lt;c:forEach items=&quot;$&#123;student.teacherList&#125;&quot; var=&quot;teacher&quot;&gt; $(&quot;:checkbox[value=&#x27;$&#123;teacher.tno&#125;&#x27;]&quot;).prop(&#x27;checked&#x27;,true) &lt;/c:forEach&gt;&lt;/script&gt; 3.4 设置关联教师jspselect-teacher.jsp 123456 &lt;!-- 教师信息 --&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/set-teacher.do&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sid&quot; value=&quot;$&#123;student.sid&#125;&quot;&gt;.... &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;tno&quot; value=&quot;$&#123;teacher.tno&#125;&quot;/&gt;&lt;/td&gt; DAO12345public interface StudentDAO &#123; boolean deleteRefBySid(String sid) ; boolean insertRef(Student student) ;&#125; 12345678910111213141516171819202122232425public class StudentDAOImpl implements StudentDAO &#123; @Override public boolean deleteRefBySid(String sid) &#123; String DQL = &quot;delete from t_student_teacher where sid = ?&quot; ; Object[] paramAy = &#123;sid&#125; ; return jdbcTemplate.update(DQL,paramAy); &#125; @Override public boolean insertRef(Student student) &#123; //获得当前学生的学号 String sid = student.getSid(); //获得当前学生关联的教师信息 List&lt;Teacher&gt; teacherList = student.getTeacherList(); String DML = &quot;insert into t_student_teacher(sid,tno) values(?,?)&quot; ; Object[][] paramAy = new Object[teacherList.size()][2] ; for (int i = 0; i &lt; teacherList.size(); i++) &#123; //教师信息 Teacher teacher = teacherList.get(i); paramAy[i][0] = sid ; paramAy[i][1] = teacher.getTno() ; &#125; return jdbcTemplate.updateBatch(DML,paramAy); &#125;&#125; Service12345678910public class StudentService &#123; public boolean setTeacher(Student student)&#123; //1.中间表删除 当前学号 关联所有信息 boolean delRs = studentDAO.deleteRefBySid(student.getSid()) ; //2.批量新增 中间表 关联信息 boolean insertRs = studentDAO.insertRef(student) ; return delRs &amp;&amp; insertRs ; &#125;&#125; controller123456789101112131415161718192021222324252627@WebServlet(...&quot;/set-teacher.do&quot;&#125;)else if (&quot;/set-teacher.do&quot;.equals(requestURI))&#123; this.setTeacher(request,response) ;&#125;protected void setTeacher(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获得学生的id String sid = request.getParameter(&quot;sid&quot;); // 关联的教师工号 String[] tnoAy = request.getParameterValues(&quot;tno&quot;); //封装学生对象 Student student = new Student(); student.setSid(sid); List&lt;Teacher&gt; teacherList = new ArrayList&lt;&gt;() ; for (String tno : tnoAy) &#123; Teacher teacher = new Teacher(); teacher.setTno(tno); teacherList.add(teacher); &#125; //设置关联关系 student.setTeacherList(teacherList); boolean rs = studentService.setTeacher(student) ; //重新查询 response.sendRedirect(request.getContextPath()+&quot;/page-stu.do&quot;);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Vue指令学习","slug":"Vue指令学习","date":"2023-07-24T06:34:03.000Z","updated":"2023-07-25T11:25:24.993Z","comments":true,"path":"2023/07/24/Vue指令学习/","link":"","permalink":"http://example.com/2023/07/24/Vue%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Vue构成vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。之前接触到的 App.vue 文件本质上就是一个 vue 的组件。每个 .vue 组件都由 3 部分构成，分别是： 模板结构 功能 template 组件的模板结构 script 组件的 JavaScript 行为 style 组件的样式 其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。vue 规定：每个组件对应的模板结构，需要定义到 template 节点中。 在 template 中使用指令在组件的 template 节点中，支持使用前面所学的指令语法，来辅助开发者渲染当前组件的 DOM 结构。代码示例如下： 123456789&lt;template&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;!-- 使用&#123;&#123; &#125;&#125;插值表达式 --&gt;&lt;p&gt;生成一个随机数字: &#123;&#123; (Math. random() * 10). toFixed(2) &#125;&#125;&lt;/p&gt;&lt;!-- 使用v-bind属性绑定 --&gt;&lt;p :title=&quot;new Date().tolocaleTimeString()&quot;&gt;我在学习vue.js&lt;/p&gt;&lt;!-- 属性v-on事件绑定 --&gt;&lt;button @click=”showInfo&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt; 在 template 中定义根节点在 vue 2.x 的版本中，template 节点内的 DOM 结构仅支持单个根节点： 1234567&lt;template&gt; &lt;!-- vue 2.x中，template节点内的所有元素，最外层“必须有”唯一的根节点进行包裹，否则报错 --&gt;&lt;div&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;h2&gt;这是副标题&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt; 但是，在 vue 3.x 的版本中，&lt; template&gt; 中支持定义多个根节点： 12345&lt;template&gt;&lt;!-- 这是包含多个根节点的template结构，因为h1标签和h2标签外层没有包裹性质的根元素 --&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;h2&gt;这是副标题&lt;/h2&gt;&lt;/template&gt; 组件的 script 节点vue 规定：组件内的 &lt; script&gt; 节点是可选的，开发者可以在 &lt; script&gt; 节点中封装组件的 JavaScript 业务逻辑。&lt; script &gt; 节点的基本结构如下： 1234&lt;script&gt;//今后，组件相关的data数据、methods方法等，都需要定义到export default所导出的对象中。export default &#123;&#125;&lt;/script&gt; script 中的 name 节点可以通过 name 节点为当前组件定义一个名称，代码如下： 123456&lt;script&gt;export default &#123;// name属性指向的是当前组件的名称（建议：每个单词的首字母大写）name: &#x27;MyApp&#x27;&#125;&lt;/script&gt; 在使用 vue-devtools 进行项目调试的时候，自定义的组件名称可以清晰的区分每个组件。 script 中的 data 节点vue 组件渲染期间需要用到的数据，可以定义在 data 节点中： 123456789101112&lt;script&gt;export default &#123;// 组件的名称 name: &#x27;MyApp&#x27;,// 组件的数据（data方法中return出去的对象，就是当前组件渲染期间需要用到的数据对象） data() &#123; return &#123; username: &#x27;哇哈哈&#x27;, &#125; &#125;,&#125;&lt;/script&gt; 其中组件中的 data 必须是函数，vue 规定：组件中的 data 必须是一个函数，不能直接指向一个数据对象。因此在组件中定义 data 数据节点时，下面的方式是错误的： 123data: &#123; // 组件中，不能直接让 data 指向一个数据对象（会报错） count: 0&#125; script 中的 methods 节点组件中的事件处理函数，必须定义到 methods 节点中，示例代码如下： 12345678910111213export default &#123; name: &#x27;MyApp&#x27;, // 组件的名称 data() &#123; // 组件的数据 return &#123; count: 0, &#125; &#125;, methods: &#123; //处理函数 addCount() &#123; this.count++ &#125;, &#125;,&#125; 组件的 style 节点vue 规定：组件内的 &lt; style &gt; 节点是可选的，开发者可以在 &lt; style &gt; 节点中编写样式美化当前组件的 UI 结构。&lt; script &gt; 节点的基本结构如下： 12345&lt;style&gt;h1 &#123;font-weight: normal;&#125;&lt;/style&gt; 其中 &lt; style &gt; &lt;&#x3D;”” font&#x3D;””&gt; 标签上的 lang&#x3D;”css” 属性是可选的，它表示所使用的样式语言。默认只支持普通的 css 语法，可选值还有 less、scss 等。多学一招：让 style 中支持 less 语法：如果希望使用 less 语法编写组件的 style 样式，可以按照如下两个步骤进行配置：① 运行 npm install less -D 命令安装依赖包，从而提供 less 语法的编译支持；② 在 &lt; style &gt; &lt;&#x3D;”” font&#x3D;””&gt; 标签上添加 lang&#x3D;”less” 属性，即可使用 less 语法编写组件的样式。 123456789&lt;style&gt;h1 &#123;font-weight: normal;&#125;i &#123;color: red;font-style: normal;&#125;&lt;/style&gt; Vue指令插值表达式 目的: 在dom标签中, 直接插入内容 又叫: 声明式渲染&#x2F;文本插值 语法: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; person.age &gt; 100 ? `老头` : `小伙` &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // data 格式固定, 定义vue数据之处 data() &#123; // key相当于变量名 return &#123; msg: `hello vue!!!`, person: &#123; name: `张三丰`, age: 108, &#125;, &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 总结: dom中插值表达式赋值, vue的变量必须在data里声明注意点：1.在插值表达式中使用的数据 必须在data中进行了提供2.支持的是表达式，而非语句，比如：if for …3.不能在标签属性中使用插值（插值表达式只能在标签中间使用），比如：&lt;p title=&quot;&#123;&#123;username&#125;&#125;&quot;&gt;我是P标签&lt;/p&gt; v-bind 目标: 给标签属性设置vue变量的值 vue指令, 实质上就是特殊的 html 标签属性, 特点: v- 开头 每个指令, 都有独立的作用 语法：v-bind:属性名=&quot;vue变量&quot; 简写：:属性名=&quot;vue变量&quot; 123456789&lt;!-- vue指令-v-bind属性动态赋值 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;我是a标签&lt;/a&gt;&lt;img :src=&quot;imgSrc&quot;&gt;图片服务器:https://demo-video-oss.oss-cn-hangzhou.aliyuncs.com/images/mm.jpg或 指定尺寸 https://demo-video-oss.oss-cn-hangzhou.aliyuncs.com/images/mm.jpg?x-oss-process=image/resize,w_60,h_60 总结: 把vue变量的值, 赋予给dom属性上, 影响标签显示效果 v-on 目标: 给标签绑定事件 语法 v-on:事件名&#x3D;”要执行的 少量代码 “ v-on:事件名&#x3D;”methods中的函数” v-on:事件名&#x3D;”methods中的函数(实参)” 简写: @事件名&#x3D;”methods中的函数” 123456789101112131415161718192021222324&lt;!-- vue指令: v-on事件绑定--&gt;&lt;p&gt;你要买商品的数量: &#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count = count + 1&quot;&gt;增加1&lt;/button&gt;&lt;button v-on:click=&quot;addFn&quot;&gt;增加1个&lt;/button&gt;&lt;button v-on:click=&quot;addCountFn(5)&quot;&gt;一次加5件&lt;/button&gt;&lt;button @click=&quot;subFn&quot;&gt;减少&lt;/button&gt;&lt;script&gt; export default &#123; // ...其他省略 methods: &#123; addFn()&#123; // this代表export default后面的组件对象(下属有data里return出来的属性) this.count++ &#125;, addCountFn(num)&#123; this.count += num &#125;, subFn()&#123; this.count-- &#125; &#125; &#125;&lt;/script&gt; 总结: 常用@事件名, 给dom标签绑定事件, 以及&#x3D;右侧事件处理函数 v-on事件对象 目标: vue事件处理函数中, 拿到事件对象 语法: 无传参, 通过形参直接接收 传参, 通过$event指代事件对象传给事件处理函数 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止百度&lt;/a&gt; &lt;hr&gt; &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止去百度&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; one(e)&#123; e.preventDefault() &#125;, two(num, e)&#123; e.preventDefault() &#125; &#125;&#125;&lt;/script&gt; v-on修饰符 目的: 在事件后面.修饰符名 - 给事件带来更强大的功能 语法: @事件名.修饰符&#x3D;”methods里函数” .stop - 阻止事件冒泡 .prevent - 阻止默认行为 .once - 程序运行期间, 只触发一次事件处理函数 123456789101112131415161718192021&lt;template&gt; &lt;div @click=&quot;fatherFn&quot;&gt; &lt;!-- vue对事件进行了修饰符设置, 在事件后面.修饰符名即可使用更多的功能 --&gt; &lt;button @click.stop=&quot;btn&quot;&gt;.stop阻止事件冒泡&lt;/button&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;.prevent阻止默认行为&lt;/a&gt; &lt;button @click.once=&quot;btn&quot;&gt;.once程序运行期间, 只触发一次事件处理函数&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fatherFn()&#123; console.log(&quot;father被触发&quot;); &#125;, btn()&#123; console.log(1); &#125; &#125;&#125;&lt;/script&gt; 总结: 修饰符给事件扩展额外功能 v-on按键修饰符 目标: 给键盘事件, 添加修饰符, 增强能力 语法: @keyup.enter - 监测回车按键 @keyup.esc - 监测返回按键 更多修饰符 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; enterFn()&#123; console.log(&quot;enter回车按键了&quot;); &#125;, escFn()&#123; console.log(&quot;esc按键了&quot;); &#125; &#125;&#125;&lt;/script&gt; 总结: 多使用事件修饰符, 可以提高开发效率, 少去自己判断过程 例1：翻转字符串 目标: 点击按钮 - 把文字取反显示 - 再点击取反显示(回来了) 提示: 把字符串取反赋予回去 正确代码: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;反转字符串&lt;/h1&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;reverseStr&quot;&gt;反转字符串&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: `我是我爹的儿`, &#125; &#125;, methods: &#123; reverseStr() &#123; this.msg = this.msg.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 总结: 记住方法特点, 多做需求, vue是数据变化视图自动更新, 减少操作DOM时间, 提高开发效率 v-model 目标: 把value属性和vue数据变量, 双向绑定到一起 语法: v-model&#x3D;”vue数据变量” 双向数据绑定 数据变化 -&gt; 视图自动同步 视图变化 -&gt; 数据自动同步 演示: 用户名绑定 - vue内部是MVVM设计模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;!-- v-model:是实现vuejs变量和表单标签value属性, 双向绑定的指令 --&gt; &lt;div&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; v-model=&quot;pass&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;来自于: &lt;/span&gt; &lt;!-- 下拉菜单要绑定在select上 --&gt; &lt;select v-model=&quot;from&quot;&gt; &lt;option value=&quot;北京市&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;南京市&quot;&gt;南京&lt;/option&gt; &lt;option value=&quot;天津市&quot;&gt;天津&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- (重要) 遇到复选框, v-model的变量值 非数组 - 关联的是复选框的checked属性 数组 - 关联的是复选框的value属性 --&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;抽烟&quot;&gt;抽烟 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;喝酒&quot;&gt;喝酒 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;写代码&quot;&gt;写代码 &lt;/div&gt; &lt;div&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;男 &lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;女 &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍&lt;/span&gt; &lt;textarea v-model=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; username: &quot;&quot;, pass: &quot;&quot;, from: &quot;&quot;, hobby: [], sex: &quot;&quot;, intro: &quot;&quot;, &#125;; // 总结: // 特别注意: v-model, 在input[checkbox]的多选框状态 // 变量为非数组, 则绑定的是checked的属性(true/false) - 常用于: 单个绑定使用 // 变量为数组, 则绑定的是他们的value属性里的值 - 常用于: 收集勾选了哪些值 &#125;&#125;;&lt;/script&gt; 总结: 本阶段v-model只能用在表单元素上, 以后学组件后讲v-model高级用法 v-model修饰符 目标: 让v-model拥有更强大的功能 语法: v-model.修饰符&#x3D;”vue数据变量” .number 以parseFloat转成数字类型 .trim 去除首尾空白字符 （记下：去除字符串中间 空格 不是vue ） .lazy 在change事件时触发而非inupt触发 时 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;span&gt;年龄:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;人生格言:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;motto&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍:&lt;/span&gt; &lt;textarea v-model.lazy=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: &quot;&quot;, motto: &quot;&quot;, intro: &quot;&quot; &#125; &#125;&#125;&lt;/script&gt; 总结: v-model修饰符, 可以对值进行预处理, 非常高效好用 v-text和v-html 目的: 更新DOM对象的innerText&#x2F;innerHTML 语法: v-text&#x3D;”vue数据变量” v-html&#x3D;”vue数据变量” 注意: 会覆盖插值表达式 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; str: &quot;&lt;span&gt;我是一个span标签&lt;/span&gt;&quot; &#125; &#125;&#125;&lt;/script&gt; 总结: v-text把值当成普通字符串显示, v-html把值当做html解析 v-show和v-if 目标: 控制标签的隐藏或出现 语法: v-show&#x3D;”vue变量” v-if&#x3D;”vue变量” 原理 v-show 用的display:none隐藏 (频繁切换使用) v-if 直接从DOM树上移除 高级 v-else使用 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 v-show=&quot;isOk&quot;&gt;v-show的盒子&lt;/h1&gt; &lt;h1 v-if=&quot;isOk&quot;&gt;v-if的盒子&lt;/h1&gt; &lt;div&gt; &lt;p v-if=&quot;age &gt; 18&quot;&gt;我成年了&lt;/p&gt; &lt;p v-else&gt;还得多吃饭&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isOk: true, age: 15 &#125; &#125;&#125;&lt;/script&gt; 总结: 使用v-show和v-if以及v-else指令, 方便通过变量控制一套标签出现&#x2F;隐藏 例2：折叠面板 目标: 点击展开或收起时，把内容区域显示或者隐藏 此案例使用了less语法, 项目中下载模块 1yarn add less@3.0.4 less-loader@5.0.0 -D 只有标签和样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; &gt; 收起 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;body &#123; background-color: #ccc; #app &#123; width: 400px; margin: 20px auto; background-color: #fff; border: 4px solid blueviolet; border-radius: 1em; box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.5); padding: 1em 2em 2em; h3 &#123; text-align: center; &#125; .title &#123; display: flex; justify-content: space-between; align-items: center; border: 1px solid #ccc; padding: 0 1em; &#125; .title h4 &#123; line-height: 2; margin: 0; &#125; .container &#123; border: 1px solid #ccc; padding: 0 1em; &#125; .btn &#123; /* 鼠标改成手的形状 */ cursor: pointer; &#125; &#125;&#125;&lt;/style&gt; 参考答案: 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt; &#123;&#123; isShow ? &#x27;收起&#x27; : &#x27;展开&#x27; &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt; &lt;p&gt;寒雨连江夜入吴, &lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isShow: false &#125; &#125;&#125;&lt;/script&gt; v-for 目标: 列表渲染, 所在标签结构, 按照数据数量, 循环生成 语法 v-for&#x3D;”(值, 索引) in 目标结构” v-for&#x3D;”值 in 目标结构” 目标结构: 可以遍历数组 &#x2F; 对象 &#x2F; 数字 &#x2F; 字符串 (可遍历结构) 注意: v-for的临时变量名不能用到v-for范围外 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- v-for 把一组数据, 渲染成一组DOM --&gt; &lt;!-- 口诀: 让谁循环生成, v-for就写谁身上 --&gt; &lt;p&gt;学生姓名&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;item&quot;&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;学生详细信息&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;obj in stuArr&quot; :key=&quot;obj.id&quot;&gt; &lt;span&gt;&#123;&#123; obj.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.sex &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.hobby &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- v-for遍历对象(了解) --&gt; &lt;p&gt;老师信息&lt;/p&gt; &lt;div v-for=&quot;(value, key) in tObj&quot; :key=&quot;value&quot;&gt; &#123;&#123; key &#125;&#125; -- &#123;&#123; value &#125;&#125; &lt;/div&gt; &lt;!-- v-for遍历整数(了解) - 从1开始 --&gt; &lt;p&gt;序号&lt;/p&gt; &lt;div v-for=&quot;i in count&quot; :key=&quot;i&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; arr: [&quot;小明&quot;, &quot;小欢欢&quot;, &quot;大黄&quot;], stuArr: [ &#123; id: 1001, name: &quot;孙悟空&quot;, sex: &quot;男&quot;, hobby: &quot;吃桃子&quot;, &#125;, &#123; id: 1002, name: &quot;猪八戒&quot;, sex: &quot;男&quot;, hobby: &quot;背媳妇&quot;, &#125;, ], tObj: &#123; name: &quot;蜘蛛精&quot;, age: 18, class: &quot;昆虫&quot;, &#125;, count: 10, &#125;; &#125;,&#125;;&lt;/script&gt; 总结: vue最常用指令, 铺设页面利器, 快速把数据赋予到相同的dom结构上循环生成","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Java-常见异常","slug":"Java-常见异常","date":"2023-07-20T10:54:44.000Z","updated":"2023-08-03T01:27:16.127Z","comments":true,"path":"2023/07/20/Java-常见异常/","link":"","permalink":"http://example.com/2023/07/20/Java-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/","excerpt":"","text":"1.ClassCastException(类转换异常)数据类型转换错误，比如有个String temp&#x3D;”abc”; 如果设为(int)temp就会报错了，因为它们类型不一样，但是设为(object)temp就可以，因为object是它们的父类 2.IndexOutOfBoundsException(数组越界)这个异常我们在操作数组的时候会经常遇到，异常的解释是“数组下标越界”，现在程序中大多都有对数组的操作，因此在调用数组的时候一定要认真检查，看自己调用的下标是不是超出了数组的范围，一般来说，显示(即直接用常数当下标)调用不太容易出这样的错，但隐式(即用变量表示下标)调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。 3.NullPointerException(空指针)这个异常在编程时也经常遇到，异常的解释是 “程序遇上了空指针”，简单地说就是调用了未经初始化的对象或者是不存在的对象，这个错误经常出现在调用数组这些操作中，对数组操作中出现空指针，很多情况下是一些刚开始学习编程的人常犯的错误，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化(如果要调用的话)。 4.IllegalAccessException(安全权限异常)这个异常的解释是“没有访问权限“，当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常。 5. IOException(输入输出异常)一般读写文件会出现这个异常,比如你想从磁盘上读一个文件到你写的程序,如果硬盘上没有这文件,java虚拟机就会报这个异常","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-多表查询","slug":"Mysql-多表查询","date":"2023-07-18T16:27:20.000Z","updated":"2023-07-18T16:30:57.140Z","comments":true,"path":"2023/07/19/Mysql-多表查询/","link":"","permalink":"http://example.com/2023/07/19/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"1.DDLcreate 创建 alter 修改 drop 删除 truncate清空&#x2F;截断 【事务自动提交】 1.1 创建表常用创建 1234567表名 练习： t_emp tb_emp tbl_emp 项目： sys_ oa_ order_ product_create table 表名( 字段名 数据类型 [列级约束], 字段名 数据类型 [列级约束], [表级约束]) ; 1234CREATE TABLE t_emp01( id INT, NAME VARCHAR(20)) ; 查看表结构 1DESC t_emp01; 查看表创建语句 1SHOW CREATE TABLE t_emp01 ; CTAS语法创建表【没约束】 123CREATE TABLE emp10 AS SELECT * FROM emp WHERE deptno = 10;CREATE TABLE emp20 AS SELECT empno id,ename NAME,sal sal FROM emp WHERE deptno = 20;CREATE TABLE myemp AS SELECT * FROM emp WHERE 1=2 ; 1.2 约束主键 PK 非空+唯一 123456789101112131415CREATE TABLE t_emp02( id INT PRIMARY KEY, NAME VARCHAR(20)) ;或CREATE TABLE t_emp03( id INT , NAME VARCHAR(20), PRIMARY KEY (id)) ;INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;a&#x27;) ;INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) ;查询：INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) 错误代码： 1062Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27; 123456789CREATE TABLE t_emp04( id INT , NAME VARCHAR(20), PRIMARY KEY (id,NAME) -- 联合主键) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;a&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;2&#x27;,&#x27;b&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;2&#x27;,&#x27;a&#x27;) ; 查看表约束 123-- 查询数据字典：SELECT * FROM `information_schema`.`TABLE_CONSTRAINTS` WHERE TABLE_SCHEMA=&#x27;scott&#x27; AND table_name=&#x27;t_emp04&#x27;; 外键 FK 参考完整性 可以为 NULL 给值 只能关联 另一个主键 123456789101112131415161718192021222324CREATE TABLE mydept AS SELECT * FROM dept ;CREATE TABLE myemp02 ( id INT PRIMARY KEY, NAME VARCHAR(20), deptno INT REFERENCES mydept(deptno)) ;或CREATE TABLE myemp03 ( id INT PRIMARY KEY, NAME VARCHAR(20), deptno INT , CONSTRAINT fk_myemp03 FOREIGN KEY (deptno) REFERENCES mydept(deptno) -- 注意：PK) ;INSERT INTO myemp03(id,NAME,deptno) VALUES (3,&#x27;aaa&#x27;,NULL) ;INSERT INTO myemp03(id,NAME,deptno) VALUES (4,&#x27;aaa&#x27;,88) ; -- 88 部门表中没有该数据查询：INSERT INTO myemp03(id,NAME,deptno) VALUES (4,&#x27;aaa&#x27;,88) 错误代码： 1452Cannot add or update a child row: a foreign key constraint fails (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `mydept` (`DEPTNO`))DELETE FROM `mydept` WHERE deptno = 10 ; -- 10部门下 有关联的员工查询：delete from `mydept` where deptno = 10 错误代码： 1451Cannot delete or update a parent row: a foreign key constraint fails (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `mydept` (`DEPTNO`)) 非空 1234CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) NOT NULL -- 该列不能为空) ; 唯一 1234CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) UNIQUE -- 该列唯一 可以为 null 【只能一个null】) ; 默认值 12345CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) , age INT DEFAULT 18 ) ; 自增长 123456789-- 历史遗留问题：ID 使用雪花算法 【通过程序控制】CREATE TABLE t_emp08( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ) ;INSERT INTO t_emp08 (id,NAME) VALUES (NULL,&#x27;a&#x27;) ;INSERT INTO t_emp08 (id,NAME) VALUES (200,&#x27;b&#x27;) ;INSERT INTO t_emp08 (id,NAME) VALUES (NULL,&#x27;c&#x27;) ; 1.3 修改表注意： 权限问题 ？ 修改表名 1ALTER TABLE t_emp08 RENAME TO tbl_emp08 ; 修改字段名 1ALTER TABLE tbl_emp08 CHANGE NAME e_name VARCHAR(20); 修改字段类型 1ALTER TABLE tbl_emp08 MODIFY e_name VARCHAR(80); 添加字段 12ALTER TABLE tbl_emp08 ADD age INT ;ALTER TABLE tbl_emp08 ADD sex INT AFTER id ; 删除字段 1ALTER TABLE tbl_emp08 DROP COLUMN sex ; 1.4 删除表12-- 最新的备份 最新的简历DROP TABLE tbl_emp08 ; 1.5 清空表1234567891011-- 1. 清空表中数据 表结构保留 DDL事务自动提交 不可回滚 速度快 自增长从1开始-- 降低高水位TRUNCATE TABLE myemp03 ;TRUNCATE TABLE mydept; -- FK 外键引用查询：truncate table mydept错误代码： 1701Cannot truncate a table referenced in a foreign key constraint (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `scott`.`mydept` (`DEPTNO`))-- 2. delete where过滤条件 DML语句 事务不提交 可以回滚 速度慢delete from myemp03 where .... DDL练习12345678910111213141516171819202122232425262728293031323334351.创建一张表 student id int name varchar(10) age int(10) tel varchar（10） 给 id 字段添加主键约束 自增长 给 name 字段添加非空约束 给 age 字段 默认值 0 给 tel 添加唯一 非空 约束 2.创建一张学员兴趣爱好表 hobby id int(10) hobby_name varchar(10) sid int --学生 id 给 sid 字段添加外键约束 3.创建一个表emp1empno int(10)ename varchar(50)4.emp1 添加一个字段 sal int(4)5.emp1 修改字段 ename varchar(100) 6.emp1 删除字段 sal7.把表 emp1 改成 emp2 SQL面试题面试题一（厦门）12345678910111213141516Table: （员工emp1） id name 1 a 2 b 3 c 4 dTable:( 性别sext) id sex 1 男 4 女 5 男找出忘记填写性别的员工? create table emp1(id int,name varchar(20)) ; insert into emp1(id,name) values (1,&#x27;a&#x27;),(2,&#x27;b&#x27;),(3,&#x27;c&#x27;),(4,&#x27;d&#x27;) ; create table sext(id int,sex varchar(20)) ; insert into sext(id,sex) values (1,&#x27;男&#x27;),(4,&#x27;女&#x27;),(5,&#x27;男&#x27;) ; 12345-- 员工id 没有在 sext表出现过? -- inselect * from emp1 where id not in (select id from sext) ;-- existsselect * from emp1 e where not exists (select null from sext where id=e.id) ; 面试题二（上海）12345678910111213141516表一(AAA) 商品名称 mc 商品总量 sl A 100 B 120表二(BBB) 商品名称 mc 出库数量 sl A 10 A 20 B 10 B 20 B 30用一条 SQL 语句算出商品 A,B 目前还剩多少？ create table AAA(mc varchar(20),sl int) ; insert into AAA (mc,sl) values (&#x27;A&#x27;,100),(&#x27;B&#x27;,120) ; create table BBB(mc varchar(20),sl int) ; insert into BBB (mc,sl) values (&#x27;A&#x27;,10),(&#x27;A&#x27;,20),(&#x27;B&#x27;,10),(&#x27;B&#x27;,20),(&#x27;B&#x27;,30) ; 12345678910111213-- 期望结果： -- mc sl-- A 70 -- B 60 -- 方法1: 子查询 select mc, sl-(select sum(sl) from BBB where mc=a.mc) sy from AAA a ;-- 方法2: 多表-- 先分组select mc,sum(sl) from BBB group by mc ;-- 看做一张表select a.mc, a.sl-t.sum_sl from AAA a join (select mc,sum(sl) sum_sl from BBB group by mc) t on a.mc = t.mc ; 面试题三（上海）1234567891011121314151617181920212223242526272829人员情况表（employee）中字段包括，员工号（ID），姓名（name），年龄（age），文化程度（wh）：包括四种情况（本科以上，大专，高中，初中以下）,现在我要根据年龄字段查询统计出：表中文化程度为本科以上，大专，高中，初中以下，各有多少人，占总人数多少。结果如下A：学历 年龄 人数 百分比本科以上 20 34 14大专 20 33 13高中 20 33 13初中以下 20 100 40本科以上 21 50 20。。。。。。SQL 查询语句如何写？create table employee(id int primary key auto_increment, name varchar(20), age int(2), wh varchar(20) ) ;insert into employee(id,name,age,wh) values (null,&#x27;a&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;b&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;c&#x27;,21,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;d&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;大专&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,21,&#x27;大专&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,21,&#x27;高中&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;高中&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;初中以下&#x27;) ; 123456查询结果集B：-- [行列转换]学历 20岁 21岁本科以上 3 1大专 2 2高中 4 1SQL 查询语句如何写？ 面试题四（福州）1234567891011121314151617181920212223242526272829303132333435363738四张表-- 学生表 create table student(sid varchar(20),sname varchar(20));insert into student values(1,&#x27;小明&#x27;);insert into student values(2,&#x27;小花&#x27;);-- 教师表 create table teacher(tid varchar(20),tname varchar(20)) ;insert into teacher values(1,&#x27;陈红&#x27;);insert into teacher values(2,&#x27;陈白&#x27;);-- 课程表 create table course(cid varchar(20),cname varchar(20)，ctype varchar(20)) ;insert into course values(1,&#x27;语文&#x27;,&#x27;文科&#x27;);insert into course values(2,&#x27;数学&#x27;,&#x27;理科&#x27;);-- 选课表 create table choose_course(ccid varchar(20),sid varchar(20),tid varchar(20), cid varchar(20));-- 小明选了陈红老师的语文insert into choose_course values(1,1,1,1);-- 小明选了陈红老师的数学insert into choose_course values(2,1,1,2);-- 小花选了陈红老师的数学insert into choose_course values(3,2,1,2);-- 小明选了陈白老师的语文insert into choose_course values(1,1,2,1);-- 小花选了陈红老师的语文insert into choose_course values(4,2,1,1);-- 1. 查找陈红老师教的学生是那些？-- 2.找学生小明所有的文科老师？-- 3.找出没有选修陈红老师的学生？-- 4.教的学生最少的老师？ 面试题五（厦门）12345678910111213141516171819202122232425262728293031323334-- 8:00--12:00 为迟到, 12:00--18:00 为早退-- 打卡表 card create table card( cid int(10), ctime timestamp , cuser int(10) ); -- 人员表 personcreate table person( pid int(10), name varchar(10)) ;-- 插入人员表的数据insert into person values(1,&#x27;a&#x27;);insert into person values(2,&#x27;b&#x27;);-- 插入打卡的数据insert into card values(1,&#x27;2009-07-19 08:02:00&#x27;,1);insert into card values(2,&#x27;2009-07-19 18:02:00&#x27;,1);insert into card values(3,&#x27;2009-07-19 09:02:00&#x27;,2);insert into card values(4,&#x27;2009-07-19 17:02:00&#x27;,2);insert into card values(5,&#x27;2009-07-20 08:02:00&#x27;,1);insert into card values(6,&#x27;2009-07-20 16:02:00&#x27;,1);insert into card values(7,&#x27;2009-07-20 07:02:00&#x27;,2);insert into card values(8,&#x27;2009-07-20 20:02:00&#x27;,2);-- 查询 迟到 早退的员工姓名？查询结果如下:工号 姓名 打卡日期 上班打卡 下班打卡 迟到 早退1 a 2009-07-19 08:02:00 18:02:00 是 否1 a 2009-07-20 08:02:00 16:02:00 是 是2 b 2009-07-19 09:02:00 17:02:00 是 是 2. DML事务不自动提交 2.1 插入数据所有字段插入 123INSERT INTO dept(deptno,dname,loc) VALUES (11,&#x27;dev&#x27;,&#x27;NJ&#x27;) ;-- 所有列插入 可以省略列名 【不建议】 考虑兼容问题？INSERT INTO dept VALUES (12,&#x27;dev&#x27;,&#x27;NJ&#x27;) ; 插入多条 1INSERT INTO dept(deptno,dname,loc) VALUES (13,&#x27;dev&#x27;,&#x27;NJ&#x27;),(14,&#x27;test&#x27;,&#x27;BJ&#x27;) ; 查询结果集插入 1234-- CTAS 语法创建表 【同时拷贝数据 没有约束】CREATE TABLE myemp AS SELECT * FROM emp ;-- 查询结果集 插入 myemp表中INSERT INTO myemp SELECT * FROM emp ; 2.2 更新数据1UPDATE myemp SET sal=sal*1.5 ,comm=500 WHERE empno =7788 ; 2.3 删除数据1DELETE FROM myemp WHERE empno = 7788 ; DML练习：123456789-- 1.往 emp 表中插入 empno,ename,sal 数据（111,&#x27;1&#x27;,1000)(222,&#x27;2&#x27;,2000) insert into emp(empno,ename,sal) values (111,&#x27;1&#x27;,1000),(222,&#x27;2&#x27;,2000) ;-- 2.把 empno=111 的员工 comm 改成 100 update emp set comm = 100 where empno = 111 ;-- 3.往 dept 表中插入编号50 ，dname，loc 与10部门相同 的数据 insert into dept(deptno,dname,loc) select 55,dname,loc from dept where deptno=10 ;-- 4.删除 empno=111 的数据 delete from emp where empno=111 ; 3. 视图view &#x3D; 虚表 table &#x3D; 基表 【1.数据安全性 2.简化查询】 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 3.1 简单视图增删改查 &#x3D;&#x3D;&gt; 基表 增删改查 123456789-- 创建或替换视图CREATE OR REPLACE VIEW v_emp10ASSELECT empno,ename,sal FROM emp WHERE deptno = 10 ;-- 查询 基表SELECT * FROM v_emp10 ;-- 插入视图数据 基表数据插入INSERT INTO v_emp10 (empno,ename,sal) VALUES (333,&#x27;xxx&#x27;,800) ; 3.2 高级视图只能查询 无法新增 删除 修改 【统计函数 ，多表数据】 1234567CREATE OR REPLACE VIEW v_emp10ASSELECT deptno,COUNT(0) cut FROM emp GROUP BY deptno ;SELECT * FROM v_emp10 ;-- 无法插入数据 基表没有该列【cut 统计出来的】INSERT INTO v_emp10 (deptno,cut) VALUES (80,6) ; 视图练习1234-- 1.创建一个包含所有雇员的雇员编号、雇员名称、部门名称和薪金的视图 -- 2.创建一个包含各种工作的薪金总和的视图 4.索引 4.1 优缺点&#x2F;分类123456789101112优势1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。劣势1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。索引分类1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引2） 唯一索引 ：索引列的值必须唯一，但允许有空值3） 复合索引 ：即一个索引包含多个列 4.2 创建索引1234-- 创建索引CREATE INDEX idx_dept_dname ON dept(dname) ;-- 查看SQL执行计划EXPLAIN SELECT * FROM dept WHERE dname=&#x27;SALES&#x27;; 4.3 删除索引12-- 删除索引DROP INDEX idx_dept_dname ON dept ; 4.4 查看索引1SHOW INDEX FROM dept ; 4.5 索引设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I&#x2F;O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 12345678创建复合索引: CREATE INDEX idx_name_email_status ON tb_xx(NAME,email,STATUS);就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 索引练习:1-- 1. 在 emp 表的 ename 上创建一个索引 并查看执行计划？ 5. 存储过程 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 5.1 创建存储过程1234CREATE PROCEDURE procedure_name ([proc_parameter[,...]])begin -- SQL语句end ; 示例 ： 12345678delimiter $create procedure pro_test1()begin select &#x27;Hello Mysql&#x27; ;end$delimiter ; DELIMITER 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 5.2 调用存储过程1call procedure_name() ; 5.3 查看存储过程12345678910-- 查询db_name数据库中的所有的存储过程select name from mysql.proc where db=&#x27;db_name&#x27;;-- 查询存储过程的状态信息show procedure status;-- 查询某个存储过程的定义show create procedure test.pro_test1 \\G; 5.4 删除存储过程1DROP PROCEDURE [IF EXISTS] sp_name ； 5.5 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 1DECLARE var_name[,...] type [DEFAULT value] 示例 : 123456789delimiter $create procedure pro_test2() begin declare num int default 5; select num+ 10; end$delimiter ; SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： 1SET var_name = expr [, var_name = expr] ... 示例 : 12345678910DELIMITER $CREATE PROCEDURE pro_test3()BEGIN DECLARE NAME VARCHAR(20); SET NAME = &#x27;MYSQL&#x27;; SELECT NAME ;END$DELIMITER ; 也可以通过select … into 方式进行赋值操作 : 12345678910DELIMITER $CREATE PROCEDURE pro_test5()BEGIN declare countnum int; select count(*) into countnum from city; select countnum;END$DELIMITER ; if条件判断语法结构 : 1234567if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 需求： 1234567根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ----------&gt; 身材高挑 170 - 180 ---------&gt; 标准身材 170 以下 ----------&gt; 一般身材 示例 : 12345678910111213141516171819delimiter $create procedure pro_test6()begin declare height int default 175; declare description varchar(50); if height &gt;= 180 then set description = &#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description = &#x27;标准身材&#x27;; else set description = &#x27;一般身材&#x27;; end if; select description ;end$delimiter ; 调用结果为 : 传递参数语法格式 : 1234567create procedure procedure_name([in/out/inout] 参数名 参数类型)...IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认OUT: 该参数作为输出，也就是该参数可以作为返回值INOUT: 既可以作为输入参数，也可以作为输出参数 IN - 输入 需求 : 1根据定义的身高变量，判定当前身高的所属的身材类型 示例 : 12345678910111213141516delimiter $create procedure pro_test5(in height int)begin declare description varchar(50) default &#x27;&#x27;; if height &gt;= 180 then set description=&#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description=&#x27;标准身材&#x27;; else set description=&#x27;一般身材&#x27;; end if; select concat(&#x27;身高 &#x27;, height , &#x27;对应的身材类型为:&#x27;,description);end$delimiter ; OUT-输出 需求 : 1根据传入的身高变量，获取当前身高的所属的身材类型 示例: 12345678910create procedure pro_test5(in height int , out description varchar(100))begin if height &gt;= 180 then set description=&#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description=&#x27;标准身材&#x27;; else set description=&#x27;一般身材&#x27;; end if;end$ 调用: 123call pro_test5(168, @description)$select @description$ @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 case结构语法结构 : 12345678910111213141516171819202122232425方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE;方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 需求: 1给定一个月份, 然后计算出所在的季度 示例 : 1234567891011121314151617181920212223delimiter $create procedure pro_test9(month int)begin declare result varchar(20); case when month &gt;= 1 and month &lt;=3 then set result = &#x27;第一季度&#x27;; when month &gt;= 4 and month &lt;=6 then set result = &#x27;第二季度&#x27;; when month &gt;= 7 and month &lt;=9 then set result = &#x27;第三季度&#x27;; when month &gt;= 10 and month &lt;=12 then set result = &#x27;第四季度&#x27;; end case; select concat(&#x27;您输入的月份为 :&#x27;, month , &#x27; , 该月份为 : &#x27; , result) as content ; end$delimiter ; while循环语法结构: 12345while search_condition do statement_list end while; 需求: 1计算从1加到n的值 示例 : 1234567891011121314delimiter $create procedure pro_test8(n int)begin declare total int default 0; declare num int default 1; while num&lt;=n do set total = total + num; set num = num + 1; end while; select total;end$delimiter ; repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : 1234567REPEAT statement_list UNTIL search_conditionEND REPEAT; 需求: 1计算从1加到n的值 示例 : 123456789101112131415161718delimiter $create procedure pro_test10(n int)begin declare total int default 0; repeat set total = total + n; set n = n - 1; until n=0 end repeat; select total ; end$delimiter ; loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： 12345[begin_label:] LOOP statement_listEND LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 eave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： 123456789101112131415161718192021delimiter $CREATE PROCEDURE pro_test11(n int)BEGIN declare total int default 0; ins: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP ins; select total;END$delimiter ; 游标&#x2F;光标游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。 声明光标： 1DECLARE cursor_name CURSOR FOR select_statement ; OPEN 光标： 1OPEN cursor_name ; FETCH 光标： 1FETCH cursor_name INTO var_name [, var_name] ... CLOSE 光标： 1CLOSE cursor_name ; 示例 : 初始化脚本: 12345678910create table emp( id int(11) not null auto_increment , name varchar(50) not null comment &#x27;姓名&#x27;, age int(11) comment &#x27;年龄&#x27;, salary int(11) comment &#x27;薪水&#x27;, primary key(`id`))engine=innodb default charset=utf8 ;insert into emp(id,name,age,salary) values(null,&#x27;金毛狮王&#x27;,55,3800),(null,&#x27;白眉鹰王&#x27;,60,4000),(null,&#x27;青翼蝠王&#x27;,38,2800),(null,&#x27;紫衫龙王&#x27;,42,1800); 12345678910111213141516171819202122232425262728-- 查询emp表中数据, 并逐行获取进行展示create procedure pro_test11()begin declare e_id int(11); declare e_name varchar(50); declare e_age int(11); declare e_salary int(11); declare emp_result cursor for select * from emp; open emp_result; fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); close emp_result;end$ 通过循环结构 , 获取游标中的数据 : 12345678910111213141516171819202122232425DELIMITER $create procedure pro_test12()begin DECLARE id int(11); DECLARE name varchar(50); DECLARE age int(11); DECLARE salary int(11); DECLARE has_data int default 1; DECLARE emp_result CURSOR FOR select * from emp; DECLARE EXIT HANDLER FOR NOT FOUND set has_data = 0; open emp_result; repeat fetch emp_result into id , name , age , salary; select concat(&#x27;id为&#x27;,id, &#x27;, name 为&#x27; ,name , &#x27;, age为 &#x27; ,age , &#x27;, 薪水为: &#x27;, salary); until has_data = 0 end repeat; close emp_result;end$DELIMITER ; 6.函数语法结构: 12345CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ...END; 案例 : 定义一个存储过程, 请求满足条件的总记录数 ; 1234567891011121314delimiter $create function count_city(countryId int)returns intbegin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum;end$delimiter ; 调用: 12select count_city(1);select count_city(2); 7.触发器介绍触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 创建触发器语法结构 : 12345678910111213create trigger trigger_name before/after insert/update/deleteon tbl_name [ for each row ] -- 行级触发器begin trigger_stmt ;end; 示例 需求 1通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ; 首先创建一张日志表 : 12345678create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment &#x27;操作类型, insert/update/delete&#x27;, operate_time datetime not null comment &#x27;操作时间&#x27;, operate_id int(11) not null comment &#x27;操作表的ID&#x27;, operate_params varchar(500) comment &#x27;操作参数&#x27;, primary key(`id`))engine=innodb default charset=utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_insert_triggerafter insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;insert&#x27;,now(),new.id,concat(&#x27;插入后(id:&#x27;,new.id,&#x27;, name:&#x27;,new.name,&#x27;, age:&#x27;,new.age,&#x27;, salary:&#x27;,new.salary,&#x27;)&#x27;)); end $DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_update_triggerafter update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;update&#x27;,now(),new.id,concat(&#x27;修改前(id:&#x27;,old.id,&#x27;, name:&#x27;,old.name,&#x27;, age:&#x27;,old.age,&#x27;, salary:&#x27;,old.salary,&#x27;) , 修改后(id&#x27;,new.id, &#x27;name:&#x27;,new.name,&#x27;, age:&#x27;,new.age,&#x27;, salary:&#x27;,new.salary,&#x27;)&#x27;)); end $DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_delete_triggerafter delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;delete&#x27;,now(),old.id,concat(&#x27;删除前(id:&#x27;,old.id,&#x27;, name:&#x27;,old.name,&#x27;, age:&#x27;,old.age,&#x27;, salary:&#x27;,old.salary,&#x27;)&#x27;)); end $DELIMITER ; 测试： 123456insert into emp(id,name,age,salary) values(null, &#x27;光明左使&#x27;,30,3500);insert into emp(id,name,age,salary) values(null, &#x27;光明右使&#x27;,33,3200);update emp set age = 39 where id = 3;delete from emp where id = 5; 删除触发器语法结构 : 1drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 语法结构 ： 1show triggers ；","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Ajax学习","slug":"Ajax","date":"2023-07-13T10:33:25.000Z","updated":"2023-08-03T05:43:27.837Z","comments":true,"path":"2023/07/13/Ajax/","link":"","permalink":"http://example.com/2023/07/13/Ajax/","excerpt":"","text":"1.接口文档概念及说明 我们使用的 url，数据接口，或者简称为接口。 接口是服务器提供的一个url地址，通过这个url地址，我们可以操作服务器上的资源。 通过Ajax技术向一个接口发送请求，也叫做调用接口。 接口是谁设计的呢 后端设计的（学java的、学php的同学、…..） 后端设计完接口之后，会提供一个接口文档给前端开发工程师 一个好的接口文档，至少需要包含下面几项内容 接口说明（通过接口说明，大致了解到接口是干什么用的） 接口的url（发送ajax请求，必要的条件） 接口请求方式（发送ajax请求，必要的条件） 请求参数（参数名称、数据类型、是否必填、参数说明等） 响应格式 响应示例 请求的根路径 http://localhost:8080/day19-02-ajax 图书管理 1.1 图书列表 接口URL： &#x2F;api&#x2F;getbooks 调用方式： GET 参数格式： 参数名称 参数类型 是否必选 参数说明 id String 否 图书Id bookname String 否 图书名称 author String 否 作者 publisher String 否 出版社 响应格式： 数据名称 数据类型 说明 status Number 200 成功；500 失败； msg String 对 status 字段的详细说明 data Array 图书列表 +id String 图书Id +bookname String 图书名称 +author String 作者 +publisher String 出版社 返回示例： 123456789&#123; &quot;status&quot;: 200, &quot;msg&quot;: &quot;获取图书列表成功&quot;, &quot;data&quot;: [ &#123; &quot;id&quot;: &quot;B001&quot;, &quot;bookname&quot;: &quot;西游记&quot;, &quot;author&quot;: &quot;吴承恩&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125;, &#123; &quot;id&quot;: &quot;B002&quot;, &quot;bookname&quot;: &quot;红楼梦&quot;, &quot;author&quot;: &quot;曹雪芹&quot;, &quot;publisher&quot;: &quot;上海图书出版社&quot; &#125;, &#123; &quot;id&quot;: &quot;B003&quot;, &quot;bookname&quot;: &quot;三国演义&quot;, &quot;author&quot;: &quot;罗贯中&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125; ]&#125; 1.2 添加图书 接口URL： &#x2F;api&#x2F;addbook 调用方式： POST 参数格式： 参数名称 参数类型 是否必选 参数说明 bookname String 是 图书名称 author String 是 作者 publisher String 是 出版社 响应格式： 数据名称 数据类型 说明 status Number 201 添加成功；500 添加失败； msg String 对 status 字段的详细说明 返回示例： 1234&#123; &quot;status&quot;: 201, &quot;msg&quot;: &quot;添加图书成功&quot;&#125; 1.3 删除图书 接口URL： &#x2F;api&#x2F;delbook 调用方式： GET 参数格式： 参数名称 参数类型 是否必选 参数说明 id String 是 图书Id 响应格式： 数据名称 数据类型 说明 status Number 200 删除成功；500 未指定要删除的图书Id；502 要删除的图书不存在； msg String 对 status 字段的详细说明 返回示例： 1234&#123; &quot;status&quot;: 200, &quot;msg&quot;: &quot;删除图书成功！&quot;&#125; 2.服务器端开发2.1 vo封装返回结果123456789101112131415161718192021222324/** * 封装 ajax 响应结果 */public class AjaxResult &#123; /**响应状态码 */ private Integer status ; /**响应消息*/ private String msg ; /**响应数据 主要是查询接口返回的数据*/ private Object data ; public AjaxResult(Integer status, String msg) &#123; super(); this.status = status; this.msg = msg; &#125; public AjaxResult(Integer status, String msg, Object data) &#123; super(); this.status = status; this.msg = msg; this.data = data; &#125;&#125; 2.2 pojo1234567891011121314151617public class Book &#123; private String id ; private String bookname ; private String author ; private String publisher ; public Book() &#123; super(); // TODO Auto-generated constructor stub &#125; public Book(String id, String bookname, String author, String publisher) &#123; super(); this.id = id; this.bookname = bookname; this.author = author; this.publisher = publisher; &#125;&#125; 2.3 Service1234567891011121314151617181920212223242526272829public class BookService &#123; private static Map&lt;String,Book&gt; bookMap = Collections.synchronizedMap(new LinkedHashMap&lt;&gt;()) ; static &#123; bookMap.put(&quot;B001&quot;, new Book(&quot;B001&quot;,&quot;西游记&quot;,&quot;吴承恩&quot;,&quot;北京图书出版社&quot;)) ; bookMap.put(&quot;B002&quot;, new Book(&quot;B002&quot;,&quot;西红楼梦&quot;,&quot;曹雪芹&quot;,&quot;上海图书出版社&quot;)) ; bookMap.put(&quot;B003&quot;, new Book(&quot;B003&quot;,&quot;三国演义&quot;,&quot;罗贯中&quot;,&quot;北京图书出版社&quot;)) ; &#125; public AjaxResult save(Book book) &#123; //获得随机id String id = UUID.randomUUID().toString() ; //设置书籍id book.setId(id); bookMap.put(id, book); return new AjaxResult(201, &quot;添加图书成功&quot;) ; &#125; public AjaxResult remove(String id) &#123; if(!bookMap.containsKey(id)) &#123; return new AjaxResult(500, &quot;502 要删除的图书不存在&quot;) ; &#125; bookMap.remove(id) ; return new AjaxResult(200, &quot;删除图书成功！&quot;) ; &#125; public AjaxResult find(Book book) &#123; //此次忽略 条件 查询 return new AjaxResult(200, &quot;获取图书列表成功&quot;,bookMap.values()) ; &#125;&#125; 2.4 Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@WebServlet(&#123; &quot;/api/getbooks&quot;, &quot;/api/addbook&quot;, &quot;/api/delbook&quot; &#125;)public class BookController extends HttpServlet &#123; private static final long serialVersionUID = 1L; private BookService bookService = new BookService() ; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json;charset=UTF-8&quot;); String requestURI = request.getRequestURI() ; requestURI = requestURI.substring((request.getContextPath()+&quot;/api/&quot;).length()) ; try &#123; Method m = this.getClass().getDeclaredMethod(requestURI, HttpServletRequest.class,HttpServletResponse.class) ; AjaxResult ajaxResult = (AjaxResult)m.invoke(this, request,response) ; String json = JSON.toJSONString(ajaxResult) ; PrintWriter out = response.getWriter(); out.print(json); out.flush(); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; protected AjaxResult getbooks(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;POST&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; return bookService.find(null) ; &#125; protected AjaxResult addbook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;GET&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; String bookname = request.getParameter(&quot;bookname&quot;) ; String author = request.getParameter(&quot;author&quot;) ; String publisher = request.getParameter(&quot;publisher&quot;) ; Book book = new Book() ; book.setBookname(bookname); book.setAuthor(author); book.setPublisher(publisher); return bookService.save(book) ; &#125; protected AjaxResult delbook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;POST&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; String id = request.getParameter(&quot;id&quot;) ; if(id==null || id.equals(&quot;&quot;)) &#123; return new AjaxResult(500, &quot;未指定要删除的图书Id&quot;) ; &#125; return bookService.remove(id) ; &#125;&#125; 3. 接口测试准备工作： 121. tomcat先启动2. 安装 postman【默认安装】 3.1 图书列表 3.2 添加图书 3.3 删除图书 4. Ajax4.1 浏览器&#x2F;服务器交互模型 4.2 Ajax基本概念1234HTML是骨架CSS是颜值JS是行为数据是灵魂 AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用浏览器内置对象 XMLHttpRequest 与服务器通信。 Ajax是一种技术，通过浏览器内置对象和服务器进行数据交互的技术。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。 AJAX最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 你可以使用AJAX最主要的两个特性做下列事： 在不重新加载页面的情况下发送请求给服务器。 接受并使用从服务器发来的数据。 4.3 Ajax请求和浏览器请求1234567891011浏览器请求 是浏览器本能的请求 不需要执行任何JS代码 地址栏输入地址后，按下回车即可发送请求 接收到服务器的响应后，浏览器自动渲染响应结果到页面中Ajax请求 是通过浏览器内置对象（XHR）完成的 通过执行一段JS代码，才能实现的请求 响应结果由程序员自行处理，浏览器只负责接收响应结果。无论是浏览器请求，还是Ajax请求，道理都一样，都符合浏览器 – 服务器交互模型 123456789101112131415Ajax 优点： 可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 只更新页面的部分数据，节省带宽 用户体验好 异步，不阻塞 不阻塞，Ajax 代码之后的 其他 JS 代码无需等待 Ajax 代码执行完毕，即可执行。 多个Ajax请求可以同时进行。 Ajax 缺点: 1、增加了设计和开发时间 2、比构建经典Web应用程序更复杂 3、AJAX应用程序中的安全性较低，因为所有文件都是在客户端下载的。 4、可能出现网络延迟问题 5、禁用JavaScript的浏览器无法使用该应用程序。 6、由于安全限制，只能使用它来访问服务于初始页面的主机的信息。如果需要显示来自其他服务器的信息，则无法在AJAX中显示 4.4 JQuery封装的ajax方法$.get() 123jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求，从而将服务器上的资源请求到客户端来进行使用。 $.get() 函数的语法如下： $.get(url,[data],[success],[dataType]) 参数 是否必填 类型 说明 url 是 string 请求资源的接口地址，一般由后端开发工程师提供 data 否 string|array|object 请求参数，由后端提供 success 否 function 请求成功后触发的回调函数，函数的形参为响应结果 dataType 否 string 预期服务器端响应的数据的类型，一般不用设置 1234567891011121314//定义 请求接口地址 及 请求参数let url = &#x27;http://localhost:8080/day19-02-Ajax/api/getbooks&#x27;let obj = &#123; id: 1, bookname: &#x27;西游记&#x27;,&#125; ;//发送ajax get 请求$.get( url, obj, function (res) &#123; console.log(res) &#125;) $.post() 123jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，用于向服务器提交资源。 $.post() 函数的语法如下： $.post(url,[data],[success],[dataType]) 参数 是否必填 类型 说明 url 是 string 请求资源的接口地址，一般由后端开发工程师提供 data 否 string|array|object 请求参数，由后端提供 success 否 function 请求成功后触发的回调函数，函数的形参为响应结果 dataType 否 string 预期服务器端响应的数据的类型，一般不用设置 1234567891011// 定义路径和参数let url = &#x27;http://localhost:8080/day19-02-Ajax/api/addbook&#x27;;let obj = &#123; bookname: &#x27;三体之地球往&#x27;, author: &#x27;刘慈欣&#x27;, publisher: &#x27;中央人民出版社&#x27;&#125;;// 发送post类型的ajax$.post(url, obj, function (res) &#123; console.log(res);&#125;); $.ajax() 123456789$.ajax() - 一个综合的发送Ajax请求的方法，即可以发送GET方式的请求，也可以发送POST方式的请求，还可以根据需求配置更加复杂的Ajax请求，使用频率最高。$.ajax(&#123; method:&#x27;GET|POST&#x27;, // 请求方式 必填 url:&#x27;url接口地址&#x27;, //请求的接口地址 必填 data:&#x27;object|array|string&#x27;, // 请求参数 ，可选 success:function(res)&#123; //请求成功后的回调函数 res 表示响应结果 &#125;&#125;) 123456789101112// $.ajax(); 传递的参数是对象;// 四个关键参数都是一个属性形式存在！$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080/day19-02-Ajax/api/getbooks&#x27;, data: &#123; id: 1 &#125;, success: function (res) &#123; console.log(res); &#125;&#125;) 4.5 network工具使用 network工具使用 All – 查看所有请求 XHR – 查看Ajax请求 JS – 查看请求了哪些JS文件 CSS – 查看请求了哪些CSS文件 Img – 查看请求了哪些图片 Media – 查看请求了哪些音频、视频等 Font – 查看请求了哪些字体文件 Doc – document，查看请求了哪些html文件 4.6 综合案例效果图 素材12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!-- 套一个 .container 内容就有版心了 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;!-- bootstrap3 =&gt; 组件 =&gt; 面板 =&gt; 带标题的面版 =&gt; 情境效果 --&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;添加图书&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;!-- bootstrap3 =&gt; 全局CSS样式 =&gt; 表单 =&gt; 内联表单 --&gt; &lt;div class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;书名&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;书名&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpBookname&quot; placeholder=&quot;请输入书名&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;作者&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;作者&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpAuthor&quot; placeholder=&quot;请输入作者&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;出版社&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;出版社&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpPublisher&quot; placeholder=&quot;请输入出版社&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;btnAdd&quot; type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt; 添加 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注意: 第二部分是table标签，要写道 container 里面，panel下面 --&gt; &lt;!-- bootstrap3 =&gt; 全局CSS样式 =&gt; 表格 =&gt; 带边框的表格 --&gt; &lt;table class=&quot;table table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;西游记&lt;/td&gt; &lt;td&gt;吴承恩&lt;/td&gt; &lt;td&gt;北京图书出版社&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 5. CORS 错误跨源资源分享（CORS）是一种允许服务器放宽同源策略的标准。这用于明确允许一些跨源请求，同时拒绝其他请求。例如，如果站点提供外界嵌入的服务，则可能需要放宽同源策略。设置这样的 CORS 配置并不一定容易，并且可能存在一些挑战。在这些页面中，我们将研究一些常见的 CORS 错误消息以及如何解决它们。 如果未正确设置 CORS 配置，浏览器控制台将显示错误，例如 “Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite” 表示请求因违反 CORS 安全规则而被阻止。但这可能不一定是设置错误。因为用户的 Web 应用程序和远程外部服务可能故意禁止该请求。如果要使端点可用，则需要进行一些调试才能成功。 什么是跨域问题前端调用的后端接口不属于同一个域（域名或端口不同），就会产生跨域问题，也就是说你的应用访问了该应用域名或端口之外的域名或端口。 服务器端 开启跨域 12345678910111213141516171819202122232425262728/** * 功能描述：解决跨域过滤器 */@WebFilter(&quot;/api/*&quot;)public class CORSFilter implements Filter &#123; private final int time = 20*24*60*60; public void init(FilterConfig fConfig) throws ServletException &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse resp = (HttpServletResponse) response; // 添加参数，允许任意domain访问 resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 这个allow-headers要配为*，这样才能允许所有的请求头 resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;); resp.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); resp.setHeader(&quot;Access-Control-Max-Age&quot;, time+&quot;&quot;); chain.doFilter(request, resp); &#125; public void destroy() &#123; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"}]},{"title":"jQuery","slug":"jQuery","date":"2023-07-13T02:52:36.000Z","updated":"2023-07-13T02:58:04.316Z","comments":true,"path":"2023/07/13/jQuery/","link":"","permalink":"http://example.com/2023/07/13/jQuery/","excerpt":"","text":"1. JQ1.1 jQ概述jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。JavaScript库：是一个封装好的特定的集合包大量的方法。从封装函数的角度理解库，就是在JavaScrip库中，封装了很多预先定义好的函数在里面JQuery就是这样的一个js文件: 本质上就是对我们之前原生js代码封装后的一个js文件j 代表js Query 代表查询 优点： 轻量级。核心文件才几十kb，不会影响页面加载速度 跨浏览器兼容。基本兼容了现在主流的浏览器 链式编程、隐式迭代 对事件、样式、动画支持，大大简化了DOM操作 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等 免费、开源 初体验1234567891011121314151617181920212223242526272829303132&lt;!-- 使用 原生js 与 JQ PK 点击事件 --&gt; &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 隐式循环 2. 链式操作 3. $(dom对象) 转成 jq对象 调用 jq 的方法 $(&quot;li&quot;).mouseover(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;)).mouseout(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;&#x27;)) &lt;/script&gt; &lt;script&gt; //原生 let liCompAy = document.querySelectorAll(&#x27;li&#x27;) liCompAy.forEach((liComp) =&gt; &#123; liComp.addEventListener(&#x27;mouseover&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `pink` console.log(`鼠标覆盖`) &#125;) liComp.addEventListener(&#x27;mouseout&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `` console.log(`鼠标离开`) &#125;) &#125;) &lt;/script&gt; 入口函数12无需关心JS代码书写顺序 DOM中如果在HTML结构之前写JS代码,需要设置加载事件,获取HTML元素 【加载事件 window.onload】 123456789101112131415&lt;script&gt; //原生 window.addEventListener(&quot;load&quot;,()=&gt;&#123; let inputComp = document.querySelector(&quot;#name&quot;) console.log(`姓名 原生 :$&#123;inputComp.value&#125;`); &#125;) &lt;/script&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //JQ $(()=&gt;console.log(`姓名JQ: $&#123;$(&quot;#name&quot;).val()&#125;`)) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; DOM JQ转换12345678910DOM对象: 通过 document 方式获取到的元素都叫DOM对象jQuery对象 通过 $ 方式获取到的元素都叫 JQ对象将JQ对象转为DOM对象方式: JQ对象[索引] JQ对象.get(索引)将DOM对象转化为JQ对象: $(dom对象)注意： 只能由DOM对象 调用DOM的属性及方法，只能使用JQ对象调用 JQ的属性及方法 12345678910111213141516171819202122&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //dom对象 // let inputComp = document.querySelector(&quot;#name&quot;) // .val() jq的方法 必须 jq对象调用 .value dom的属性 必须 dom对象调用 // console.log(`姓名:$&#123;inputComp.value&#125;`); // jq对象 使用$开头 dom对象 // let $input = $(&quot;#name&quot;) // console.log(`姓名: $&#123;$input.val()&#125;`); //dom 转 jq let jq = $(dom) // let $input = $(inputComp) // console.log(`姓名: $&#123;$input.val()&#125;`); // jq 转 dom [0] .get(0) let $input = $(&quot;#name&quot;) // let input = $input[0] let input = $input.get(0) console.log(`姓名:$&#123;input.value&#125;`); &lt;/script&gt; 1.2 JQ 选择器基本选择器1234561. id选择器 #id值 $(&quot;#name&quot;)2. class选择器 .class值 $(&quot;.a&quot;)3. 标签选择器 标签名 $(&quot;li&quot;)4. 并集 OR , $(&quot;h1,#name,.a&quot;) 5. 交集 AND 直接写 $(&quot;li.c1&quot;)6. 适配 * $(&quot;*&quot;) 123456789101112131415161718192021&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li class=&quot;red&quot;&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data7&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`id选择器:$&#123;$(&#x27;#d5&#x27;).html()&#125;`) console.log(`class选择器:$&#123;$(&#x27;.red&#x27;).html()&#125;`) console.log(`标签选择器:$&#123;$(&#x27;ul&#x27;).html()&#125;`) console.log(`并集选择器===========`) $(&#x27;.red,#d5&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) $(&#x27;li.blue&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;) $(&#x27;*&#x27;).css(&#x27;fontSize&#x27;, &#x27;80px&#x27;)&lt;/script&gt; 层次选择器12345678910111. 儿子 &gt; $(&quot;tr&gt;td&quot;) $(&#x27;元素&#x27;).children([选择器]); 2. 后代 空格 $(&quot;table td&quot;) $(&#x27;元素&#x27;).find(选择器); 3. 下一个弟弟 + $(&quot;#data2+li&quot;) next() $(&quot;#data2&quot;).next(&quot;li&quot;)4. 所有的弟弟 ~ $(&quot;#data2~li&quot;) nextAll() $(&quot;#data2&quot;).nextAll(&quot;li&quot;)5. 上一个哥哥 prev() $(&quot;#data2&quot;).prev(&quot;li&quot;)6. 所有的哥哥 prevAll() $(&quot;#data2&quot;).prevAll(&quot;li&quot;)7. 同胞【哥哥弟弟们】 siblings() $(&quot;#data2&quot;).siblings(&quot;li&quot;) 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;ul&gt;li&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&quot;html li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5+li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).next(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5~li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).nextAll(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prev(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prevAll(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).siblings(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;)&lt;/script&gt; 属性选择器123451.拥有该属性 [attr] $(&quot;[name]&quot;)2.等于属性值 [attr=value] $(&quot;[name=&#x27;sid&#x27;]&quot;)3.使用属性值开头 [attr^=value] $(&quot;[name^=&#x27;s&#x27;]&quot;)4.使用属性值结尾 [attr$=value] $(&quot;[name$=&#x27;s&#x27;]&quot;)5.包含该属性值 [attr*=value] $(&quot;[name*=&#x27;s&#x27;]&quot;) 123456789101112131415&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;abc.html&quot;&gt;data1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;aaa.html&quot;&gt;data2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;ccc.html&quot;&gt;data3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;abcd.html&quot;&gt;data4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a&gt;data5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;[href]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href=&#x27;aaa.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href^=&#x27;a&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href$=&#x27;c.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href*=&#x27;c&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;)&lt;/script&gt; 过滤选择器基本过滤选择器12345671. 第一个 :first $(&quot;li:first&quot;)2. 最后一个 :last $(&quot;li:last&quot;)3. 偶数 :even $(&quot;li:even&quot;)4. 奇数 :odd $(&quot;li:odd&quot;)5. 等于索引 :eq(idx) 或 .eq(idx) $(&quot;li:eq(1)&quot;) 或 $(&quot;li&quot;).eq(1) 从0开始6. 小于索引 :lt(idx) $(&quot;li:lt(3)&quot;)7. 大于索引 :gt(idx) $(&quot;li:gt(3)&quot;) 123456789101112131415161718 &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li:first&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:last&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:even&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:odd&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:eq(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li&#x27;).eq(2).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:lt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:gt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;)&lt;/script&gt; 可见性过滤选择器121. 隐藏 :hidden2. 可见 :visible 1234567891011121314151617&lt;!-- 1. 隐藏 :hidden2. 可见 :visible--&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;显示&lt;/button&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).click(() =&gt; &#123; $(&#x27;img:visible&#x27;).hide(1000) &#125;) $(&#x27;button:eq(1)&#x27;).click(() =&gt; &#123; $(&#x27;img:hidden&#x27;).show(1000) &#125;)&lt;/script&gt; 表单过滤选择器12345678910111213141. input标签 :input $(&quot;input&quot;) &lt;input /&gt;2. type=&#x27;text&#x27; :text $(&quot;input[type=&#x27;text&#x27;]&quot;) &lt;input type=&#x27;text&#x27;/&gt;3. type=&#x27;password&#x27;:password $(&quot;input[type=&#x27;password&#x27;]&quot;) &lt;input type=&#x27;password&#x27;/&gt;4. type=&#x27;radio&#x27; :radio $(&quot;input[type=&#x27;radio&#x27;]&quot;) &lt;input type=&#x27;radio&#x27;/&gt;5. type=&#x27;checkbox&#x27;:checkbox $(&quot;input[type=&#x27;checkbox&#x27;]&quot;) &lt;input type=&#x27;checkbox&#x27;/&gt;6. type=&#x27;submit&#x27; :submit $(&quot;input[type=&#x27;submit&#x27;]&quot;) &lt;input type=&#x27;submit&#x27;/&gt;7. type=&#x27;image&#x27; :image $(&quot;input[type=&#x27;image&#x27;]&quot;) &lt;input type=&#x27;image&#x27;/&gt;8. type=&#x27;reset&#x27; :reset $(&quot;input[type=&#x27;reset&#x27;]&quot;) &lt;input type=&#x27;reset&#x27;/&gt;9. type=&#x27;button&#x27; :button $(&quot;input[type=&#x27;button&#x27;]&quot;) &lt;input type=&#x27;button&#x27;/&gt;10.type=&#x27;file&#x27; :file $(&quot;input[type=&#x27;file&#x27;]&quot;) &lt;input type=&#x27;file&#x27;/&gt;===========================布尔值属性==================11.被选中的单选/复选按钮 :checked $(&quot;:radio:checked&quot;)12.下拉框被选中 :selected $(&quot;:selected&quot;)13.被禁用 :disabled $(&quot;:disabled&quot;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;form action=&quot;xxController&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;admin1&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; value=&quot;admin2&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;hidden&quot; value=&quot;S1001&quot; /&gt; &lt;input type=&quot;text&quot; value=&quot;S1001&quot; disabled /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; value=&quot;123&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;CS&quot; /&gt;CS &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;LOL&quot; checked /&gt;LOL &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;DOTA&quot; checked /&gt;DOTA &lt;br /&gt; &lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt; &lt;br /&gt; &lt;select name=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;data1&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;data2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;data3&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;image&quot; src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`第一文本输入框:$&#123;$(&quot;input&quot;).val()&#125;`); console.log(`第一文本输入框:$&#123;$(&quot;:input&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;input[type=&#x27;text&#x27;]:eq(1)&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;:input:text:eq(1)&quot;).val()&#125;`); console.log(`密码输入框:$&#123;$(&quot;:password&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio:checked&quot;).val()&#125;`); $(&quot;:radio[value=&#x27;1&#x27;]&quot;)[0].checked = true $(&quot;:checkbox:checked&quot;).each((idx,e)=&gt;&#123; // console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); console.log(`索引:$&#123;idx&#125;========value:$&#123;$(e).val()&#125;`); &#125;) $.each($(&quot;:checkbox:checked&quot;),(idx,e)=&gt;&#123; console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); &#125;) $(&#x27;:submit&#x27;).val(&#x27;我是提交按钮&#x27;) $(&quot;:image&quot;).attr(&quot;src&quot;,&#x27;./images/html-css-js.png&#x27;) $(&quot;:reset&quot;).val(`回到解放前`) console.log(`file的name属性值:$&#123;$(&#x27;:file&#x27;).attr(&#x27;name&#x27;)&#125;`) console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).val()&#125;`); console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).text()&#125;`); console.log(`获得禁用的值:$&#123;$(&#x27;:disabled&#x27;).val()&#125;`) console.log(`获得隐藏的值:$&#123;$(&#x27;input:hidden&#x27;).val()&#125;`)&lt;/script&gt; 1.3 JQ注册事件鼠标事件121. 鼠标进入 mouseover = mouseenter2. 鼠标离开 mouseout = mouseleave 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* $(&#x27;li&#x27;) .mouseover(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) &#125;) .mouseout((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;)) */ $(&#x27;li&#x27;) .mouseenter((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;)) .mouseleave((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;))&lt;/script&gt; 123456789101112131415161718192021&lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;ul class=&quot;ul1&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;联系我们&lt;/a&gt; &lt;ul class=&quot;u2&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;邮件联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;电话联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;微信联系&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;.nav .ul1&gt;li:last&quot;).mouseenter(()=&gt;$(&quot;.u2&quot;).show()).mouseleave(()=&gt;$(&quot;.u2&quot;).hide()) &lt;/script&gt; 键盘事件121. 键盘按下 keydown2. 键盘释放 keyup 1234567&lt;input type=&quot;text&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;input&#x27;) .keydown((e) =&gt; console.log(e.keyCode)) .keyup(() =&gt; console.log(`释放`))&lt;/script&gt; 表单事件1234561.单击 click2.双击 dblclick3.值改变 change4.失去焦点 blur5.获得焦点 focus6.表单提交 submit 1234567891011121314151617181920212223242526272829&lt;form action=&quot;logcontroller&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;span id=&quot;accountError&quot;&gt;&lt;/span&gt;&lt;br /&gt; &lt;input type=&quot;password&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;:text&#x27;).focus((e) =&gt; $(e.target).css(&#x27;borderColor&#x27;, &#x27;red&#x27;)) $(&#x27;:text&#x27;).blur(() =&gt; &#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return &#125; console.log(`======用户名=====`) $(&#x27;#accountError&#x27;).html(``) &#125;) $(&quot;form&quot;).submit((e)=&gt;&#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return e.preventDefault() &#125; &#125;)&lt;/script&gt; 事件绑定1234561.绑定 bind(&quot;事件名&quot;,事件处理函数) = on (&quot;事件名&quot;,事件处理函数) 【结构固定,内容多变】 $(&quot;button:eq(0)&quot;).click(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;click&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).dblclick(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;dblclick&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).blur(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;blur&quot;,()=&gt;&#123;...&#125;)2.解绑 unbind(&quot;事件名&quot;) = off(&quot;事件名&quot;)3.只执行一次 one(&quot;事件名&quot;,事件处理函数) 1234567891011&lt;button&gt;绑定 click 按钮1&lt;/button&gt;&lt;button&gt;解除 click 按钮2&lt;/button&gt;&lt;button&gt;只绑定一次 click 按钮3&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).on(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).on(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).off(&#x27;click&#x27;)) $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).unbind(&#x27;click&#x27;)) $(&#x27;button:eq(2)&#x27;).one(&#x27;click&#x27;, () =&gt; console.log(`按钮3 被点击了..11.`))&lt;/script&gt; 复合事件12该事件由2个或2个以上的函数hover(fnOver,fnOut) 1234567891011121314151617&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li&#x27;).hover( (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;), (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) )&lt;/script&gt; 123456789101112131415161718 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;价格与包装&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;售后保障&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品评价&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;.box li&#x27;).hover( (e) =&gt; (e.target.className = &#x27;active&#x27;), (e) =&gt; (e.target.className = &#x27;&#x27;) )&lt;/script&gt; 事件冒泡1234触发子元素事件 级联 触发 父元素的事件【阻止事件冒泡:】1. event.stopPropagation()2. event.cancelBubble = true 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; #d1 &#123; width: 200px; height: 200px; background-color: pink; &#125; #d2 &#123; width: 100px; height: 100px; background-color: yellowgreen; &#125; #d3 &#123; width: 40px; height: 40px; background-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;d1&quot;&gt; &lt;div id=&quot;d2&quot;&gt; &lt;div id=&quot;d3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;#d1&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`爷爷被点击了`)) $(&#x27;#d2&#x27;).bind(&#x27;click&#x27;, function () &#123; console.log(`爸爸被点击了`) // event 内置对象 浏览器中 内置 对象 event.cancelBubble = true &#125;) $(&#x27;#d3&#x27;).bind(&#x27;click&#x27;, (e) =&gt; &#123; console.log(`你小子被点击了`) //e.stopPropagation() event.stopPropagation() &#125;)&lt;/script&gt; 事件默认行为1234默认事件行为： 比如 &lt;a href=&quot;addStu()&quot;&gt;...&lt;/a&gt; 默认链接到目标地址【阻止事件默认行为】1. javaScript:2. event.preventDefault() 12345678&lt;a href=&quot;http://www.baidu.com&quot;&gt;去百度 1 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:&quot;&gt;去百度 2 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:void(0)&quot;&gt;去百度 3 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;&quot;&gt;去百度 4 &lt;/a&gt; &lt;br /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;a&#x27;).bind(&#x27;click&#x27;, () =&gt; event.preventDefault())&lt;/script&gt; 表单序列化1234567序列化: 一次获取到表单中所有元素内容$(&#x27;form&#x27;).on(&#x27;submit&#x27;, function () &#123; // 通过 jQuery 对象的 serialize 方法，获取所有表单元素的数据 $(this).serialize(); // 阻止表单默认提交 return false;&#125;) 12345678910111213141516171819202122 &lt;form action=&quot;02-login-rs.html&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;account&quot; placeholder=&quot;请输入账号&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;pswd&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; placeholder=&quot;请输入年龄&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; location.href = `xxController?$&#123;$(&#x27;form&#x27;).serialize()&#125;` //阻止默认行为 event.preventDefault() &#125;) /* $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; let account = $(&quot;input[name=&#x27;account&#x27;]&quot;).val() let pswd = $(&quot;input[name=&#x27;pswd&#x27;]&quot;).val() location.href = `xxController?account=$&#123;account&#125;&amp;pswd=$&#123;pswd&#125;` //阻止默认行为 event.preventDefault() &#125;) */&lt;/script&gt; 1.4 JQ操作样式1234561.$(&#x27;元素&#x27;).css(&#x27;属性&#x27;, 值); 设置单个属性样式 $(&#x27;元素&#x27;).css(&#123;&#x27;属性&#x27;: &#x27;值&#x27;,&#x27;属性&#x27;: &#x27;值&#x27;&#125;) 设置多个属性样式2.$(&#x27;元素&#x27;).addClass(&#x27;类名 类名&#x27;); 3.$(&#x27;元素&#x27;).hasClass(&#x27;类名&#x27;);4.$(&#x27;元素&#x27;).removeClass(&#x27;类名&#x27;);5.$(&#x27;元素&#x27;).toggleClass(&#x27;类名&#x27;); 123456789101112131415161718192021222324&lt;style&gt; .pic &#123; width: 400px; height: 400px; border: 10px solid #000; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;/&gt;&lt;button&gt;添加样式1&lt;/button&gt;&lt;button&gt;添加样式2&lt;/button&gt;&lt;button&gt;添加样式3&lt;/button&gt;&lt;button&gt;删除样式4&lt;/button&gt;&lt;button&gt;切换样式5&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#x27;width&#x27;, &#x27;80px&#x27;)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#123; width: &#x27;80px&#x27; &#125;)) $(&#x27;button:eq(2)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).addClass(&#x27;pic&#x27;)) $(&#x27;button:eq(3)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).removeClass(&#x27;pic&#x27;)) $(&#x27;button:eq(4)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).toggleClass(&#x27;pic&#x27;)) console.log(`是否拥有pic样式: $&#123;$(&#x27;img&#x27;).hasClass(&#x27;pic&#x27;)&#125;`)&lt;/script&gt; 1.5 jQ操作属性12345678910111. 操作内置属性 获取: $(对象).prop(&#x27;属性名&#x27;); 设置: $(对象).prop(&#x27;属性名&#x27;, 值);2.操作自定义属性 获取: $(对象).attr(自定义属性名); 设置: $(对象).attr(自定义属性名, 值);3. 获取表单控件中的值 $(对象).val() $(对象).val(值);4. 操作普通标签中的值 $(对象).text(值); $(对象).html(值); 12345678910111213141516171819202122232425&lt;input type=&quot;text&quot; value=&quot;admin&quot; name=&quot;username&quot; data-user-id=&quot;S1001&quot; /&gt;&lt;span&gt;111111&lt;/span&gt;&lt;div&gt;&lt;h1&gt;2222&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`获得内置属性: $&#123;$(&#x27;input&#x27;).prop(&#x27;name&#x27;)&#125;`) $(&#x27;input&#x27;).prop(&#x27;name&#x27;, &#x27;uname&#x27;) console.log(`获得自定义属性: $&#123;$(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;)&#125;`) $(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;, &#x27;S6666&#x27;) console.log(`获得value属性: $&#123;$(&#x27;input&#x27;).val()&#125;`) $(&#x27;input&#x27;).val(&#x27;zhang3&#x27;) console.log(`获得innerText: $&#123;$(&#x27;span&#x27;).text()&#125;`) $(&#x27;span&#x27;).text(&#x27;span&#x27;) console.log(`获得innerHTML: $&#123;$(&#x27;div&#x27;).html()&#125;`) $(&#x27;div&#x27;).html(`&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt;&lt;/ul&gt;`)&lt;/script&gt; 1.6 jQ操作元素删除元素1231. $对象.remove(); 从页面中将当前标签删除2. $对象.empty(); 将标签中的所有内容清空3. $对象.html(&#x27;&#x27;); 将标签中的所有内容清空 创建元素121. $对象.html(&#x27;html标签名&#x27;); 直接在标签中添加新标签2. let res = $(&#x27;html标签&#x27;); 创建标签, 返回: JQ标签对象 添加元素1234567891. $父元素.append(元素); 将创建元素添加到父元素末尾2. $父元素.prepend(元素); 将创建元素添加到父元素开始1.尾部添加 父.append(子) 子.appendTo(父) 2.开始添加 父.prepend(子) 子.prependTo(父) 12345678910111213141516171819202122232425262728293031&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;p&gt;我的div中p&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.删除元素 $(&#x27;ul li:first&#x27;).remove() $(&#x27;ul li:last&#x27;).empty() $(&#x27;ul li:last&#x27;).html(``) //2.创建元素 $(&quot;ul li:first&quot;).html(`&lt;p&gt;aaaa&lt;/p&gt;`) let btn = $(`&lt;button&gt;按钮&lt;/button&gt;`) //3.添加元素 $(&#x27;div&#x27;).append(btn) btn.appendTo($(&#x27;div&#x27;)) $(&#x27;div&#x27;).prepend(btn) btn.prependTo($(&#x27;div&#x27;))&lt;/script&gt; 例：根据素材： 03-信息发布.html 实现元素添加&#x2F;删除功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; .msg &#123; width: 980px; padding-bottom: 10px; border: 1px solid #ccc; margin: 50px auto; &#125; textarea &#123; width: 880px; height: 100px; border: 0 none; border: 1px solid orange; resize: none; outline-style: none; border-radius: 10px; display: block; margin: 50px auto 0 auto; padding-left: 20px; padding-top: 20px; box-sizing: border-box; &#125; .btn &#123; width: 80px; height: 40px; display: block; float: right; margin-right: 50px; margin-top: 20px; background-color: blue; color: #fff; text-align: center; text-decoration: none; line-height: 40px; border-radius: 10px; clear: both; &#125; .content &#123; width: 880px; margin: 80px auto 0 auto; &#125; .item &#123; height: 50px; line-height: 50px; border-bottom: 1px dashed #ccc; padding-left: 20px; &#125; .item p &#123; float: left; &#125; .del &#123; float: right; text-decoration: none; color: #999; &#125; .del:hover &#123; color: orange; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;msg&quot;&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;btn&quot;&gt;发布&lt;/a&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;三天没吃肉啦&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //发布 $(`a.btn`).bind(`click`, () =&gt; &#123; //创建 元素 let divItemElt = $(`&lt;div class=&quot;item&quot;&gt; &lt;p&gt;$&#123;$(&#x27;textarea&#x27;).val()&#125;&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt;`) //添加元素 $(`div.content`).prepend(divItemElt) //清空输入框 $(&#x27;textarea&#x27;).val(``) console.log(`===发布=======`) &#125;) //删除 使用 事件委托 代理 $(`div.content`).on(`click`, `.del`, () =&gt; &#123; if (confirm(`确认删除吗?`)) &#123; $(event.target).parent().remove() &#125; console.log(`===删除=========`) &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"JDBC","slug":"JDBC","date":"2023-07-11T10:37:55.000Z","updated":"2023-07-11T16:45:26.895Z","comments":true,"path":"2023/07/11/JDBC/","link":"","permalink":"http://example.com/2023/07/11/JDBC/","excerpt":"","text":"JDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。 1. JDBC1.1 简介 1.2 工作原理 1.3 JDBC API 1.4 JDBC 驱动 1.5 Connection[会话] 1.6 Statement【执行SQL】Statement用于执行静态 SQL 语句 PreparedStatement表示预编译的 SQL 语句的对象。 CallableStatement用于执行 SQL 存储过程的接口。 存储过程定义1234567891011121314151617DELIMITER $$CREATE PROCEDURE p_save_dept(v_deptno INT,v_dname VARCHAR(20),v_loc VARCHAR(20) ,OUT v_rs INT ) BEGIN DECLARE cut INT(1) ; SELECT COUNT(0) INTO cut FROM dept WHERE deptno = v_deptno ; IF cut = 1 THEN SET v_rs = -1 ; END IF ; IF cut = 0 THEN SET v_rs = 1 ; INSERT INTO dept (deptno,dname,loc) VALUES (v_deptno,v_dname,v_loc) ; COMMIT ; END IF ;END $$DELIMITER ; 数据库直接调用12CALL p_save_dept(11,&#x27;aa&#x27;,&#x27;NJ&#x27;,@rs) ;SELECT @rs ; JDBC调用1234567891011Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;root&quot;);CallableStatement cs = conn.prepareCall(&quot;&#123;call p_save_dept(?,?,?,?)&#125;&quot;);cs.setInt(1,12);cs.setString(2,&quot;dev&quot;);cs.setString(3,&quot;NJ&quot;);cs.registerOutParameter(4, JDBCType.INTEGER);cs.execute() ;int out = cs.getInt(4);System.out.println(out);cs.close();conn.close(); 1.7 ResultSet 【查询结果集】 2. DAO2.1 什么是DAO 2.2 DAO作用 2.3 组成部分 2.4 示例 3.DbutilsDbutils：主要是封装了JDBC的代码，简化dao层的操作。作用：帮助java程序员，开发Dao层代码的简单框架。框架的作用：帮助程序员，提高程序的开发效率。 3.1 环境搭建jar包下载 https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils/1.7 3.2 官网地址https://commons.apache.org/proper/commons-dbutils/examples.html 3.3 Dbutils三个核心类介绍1：DbUtils：连接数据库对象—-jdbc辅助方法的集合类，线程安全构造方法：DbUtils()作用：控制连接，控制事务，控制驱动加载额一个类。 2：QueryRunner：SQL语句的操作对象，可以设置查询结果集的封装策略，线程安全。构造方法：（1）QueryRunner()：创建一个与数据库无关的QueryRunner对象，后期再操作数据库的会后，需要手动给一个Connection对象，它可以手动控制事务。Connection.setAutoCommit(false); 设置手动管理事务Connection.commit(); 提交事务 （2）QueryRunner(DataSource ds)：创建一个与数据库关联的queryRunner对象，后期再操作数据库的时候，不需要Connection对象，自动管理事务。DataSource：数据库连接池对象。 12345678 //构造函数与增删改查方法的组合：QueryRunner() update(Connection conn, String sql, Object... params) query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) QueryRunner(DataSource ds) update(String sql, Object... params) query(String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) 3：ResultSetHandle：封装数据的策略对象——将封装结果集中的数据，转换到另一个对象策略：封装数据到对象的方式（示例：将数据库保存在User、保存到数组、保存到集合）方法介绍：handle（ResultSet rs） 3.4 创建DBCP连接池1、创建DBCP链接池配置文件：名称为 dbcp.properties 内容如下： 12345driverClassName=com.mysql.jdbc.Driverusername=rootpassword=123456url=jdbc:mysql://127.0.0.1:3306/long1?characterEncoding=UTF8maxActive=2 2、读取配置文件，创建 DataSource 连接池实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.test.dbcp;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;public class DbcpDataSource &#123;/* * 重点：创建一个DataSource * 步骤为：1、用Properties类读取配置文件。 * 2、通过工厂类，读取这个Properties类获取的配置文件，创建出DataSource * DataSource作用： * 创建DataSource可以返回多个连接。可以实现dbutil简化操作数据库的流程。 *///1、创建一个静态的datasourceprivate static DataSource ds;//2、在静态代码块中，给ds赋值static&#123; //读取资源文件 try&#123; Properties p = new Properties(); p.load(DbcpDataSource.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;)); //在dbcp中有一个工厂类，读取一个资源文件,创建一个datasource ds = BasicDataSourceFactory.createDataSource(p); System.out.println(&quot;创建DataSource为&quot;+ds); &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125; &#125;//提供一个方法用于获取整个datasource对象public static DataSource getDataSource()&#123; return ds; &#125;//提供一个方法，获取connection连接public static Connection getConnection()&#123; Connection con = null; try&#123; con = ds.getConnection(); System.out.println(&quot;通过DataSource获取connection连接&quot;+con); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return con; &#125;&#125; 另外也可以不配置文件直接使用 1234567891011121314static &#123; //模拟初始化数据 Properties prop = new Properties(); prop.setProperty(&quot;driverClassName&quot;,&quot;com.mysql.jdbc.Driver&quot;); prop.setProperty(&quot;url&quot;,&quot;jdbc:mysql://localhost:3306/customer?useSSL=false&amp;characterEncoding=utf8&quot;); prop.setProperty(&quot;password&quot;,&quot;root&quot;); prop.setProperty(&quot;username&quot;,&quot;root&quot;); try&#123; dataSource = DruidDataSourceFactory.createDataSource(prop); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; //初始化 连接池&#125; 3.5 DBUtil 增删改查12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.test.ts;import java.sql.SQLException;import java.util.List;import javax.persistence.Version;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayHandler;import org.apache.commons.dbutils.handlers.ArrayListHandler;import org.junit.Test;import com.test.dbcp.DbcpDataSource;public class DbutilTests &#123;/* * dbutil向数据库新增数据 */@Testpublic void add() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run1 = new QueryRunner(DbcpDataSource.getDataSource()); //申明对象，获取DataSource链接池 //2、书写SQL字符串语句 String sq1 = &quot;INSERT INTO student(id,namee,sex,birth,department,address)&quot; + &quot;VALUES(3,&#x27;王思&#x27;,&#x27;男&#x27;,1995,&#x27;英文系&#x27;,&#x27;山东沧州&#x27;)&quot;; //3、执行sql语句 int result1 = run1.update(sq1); System.out.println(&quot;新增数据库结果，更新了数据有：&quot;+result1+&quot;条&quot;); &#125;/* * dbutil 修改数据库数据 * */@Testpublic void update() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run2 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句 String sq2 = &quot;UPDATE student SET sex=? WHERE id=?&quot;; //3、执行SQL语句 int result2 = run2.update(sq2, &quot;男&quot;,16); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result2+&quot;条&quot;); &#125;/* * dbutil 删除数据库数据 */@Testpublic void delete() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run3 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句（这个sql语句的作用是每次删除ID号最大的数据） String sq3 = &quot;DELETE FROM student WHERE id IN &quot; + &quot;(SELECT a.id FROM &quot; + &quot;(SELECT MAX(id) id FROM student a WHERE id IN&quot; + &quot;(SELECT id FROM student b WHERE a.id=b.id ORDER BY id DESC)) a)&quot;; //3、执行SQL语句 int result3 = run3.update(sq3); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result3+&quot;条&quot;); &#125;/* * dbutil 查询，将结果封装成Object对象，返回第一行数据 */@Testpublic void query() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource链接池 //2、查询 String sq4 = &quot;Select * from student&quot;; Object[] var = run.query(sq4, new ArrayHandler()); if(var !=null)&#123; System.out.print(&quot;输出学生表查询的信息&quot;+&quot;\\n&quot;); for(Object o :var)&#123; System.out.print(o+&quot;\\n&quot;); &#125; &#125; &#125;/* * dbutil 查询 ，将结果封装成Object对象，返回所有的数据 * */@Testpublic void query2() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run5 = new QueryRunner(DbcpDataSource.getDataSource()); //2、书写sql语句 String sq5 = &quot;select * from student&quot;; //3、查询sql List&lt;Object[]&gt; list = run5.query(sq5, new ArrayListHandler()); //4、遍历结果 if(list!=null)&#123; for(Object[] os:list)&#123; for(Object o :os)&#123; System.out.println(&quot;ArrayListHandler()显示查询到的所有数据：&quot;+o+&quot;\\t&quot;); &#125; System.out.println(&quot;\\n--------------------------------------------&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Tomcat-servlet","slug":"Tomcat-servlet","date":"2023-07-11T01:34:13.000Z","updated":"2023-07-11T02:13:21.920Z","comments":true,"path":"2023/07/11/Tomcat-servlet/","link":"","permalink":"http://example.com/2023/07/11/Tomcat-servlet/","excerpt":"","text":"Tomcat是web容器。在进行web项目开发的时候，经常需要http协议，也就是基于请求和响应，比如你在百度输入一行内容搜索，那么百度服务器如何处理这个请求呢？它需要创建servlet来处理，servlet其实就是java程序，只是在服务器端的java程序，servlet通过配置文件拦截你的请求，并进行相应处理，然后展示给你相应界面。那么servlet如何创建？这时候就要用到tomcat了。 1.网络编程1.1 图解 1.2 Server123456789101112131415161718192021222324252627282930313233343536public class ServerApp &#123; public static void main(String[] args) throws IOException &#123; //忠告 数组 final String[] ADVICE_AY = &#123;&quot;每天吃钙，到老我也健康膝盖!&quot;,&quot;听人劝，吃饱饭！&quot;,&quot;代码写的好，要饭要到老！&quot;&#125;; //随机数 final Random RAND = new Random(); //创建服务器端 套接字 ServerSocket serverSocket = new ServerSocket(8080); //服务器端 一直接受 客户端的请求 死循环 while (true)&#123; //获得 客户端套接字 Socket socket = serverSocket.accept(); new Thread(()-&gt;&#123; try &#123; // 获得输出流 OutputStream os = socket.getOutputStream(); //输出 随机字符串 字节流数组 os.write(ADVICE_AY[RAND.nextInt(ADVICE_AY.length)].getBytes(&quot;UTF-8&quot;)); //清空 缓存 os.flush(); InputStream is = socket.getInputStream(); byte[] ay = new byte[1024] ; is.read(ay) ; System.out.println(&quot;来着客户端的消息:&quot;+new String(ay)); //释放流 os.close(); is.close(); //关闭套接字 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 1.3 Client1234567891011121314151617181920public class ClientApp &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080); //获得输入流 InputStream is = socket.getInputStream(); byte[] ay = new byte[1024]; is.read(ay) ; //打印 服务器端消息 System.out.println(&quot;来着服务器端消息:&quot;+new String(ay)); //获得输出流 OutputStream os = socket.getOutputStream(); os.write((&quot;hello Server !!!&quot;+Math.random()).getBytes()); os.flush(); is.close(); os.close(); socket.close(); &#125;&#125; 2. CS&#x2F;BS架构2.1 图解 2.2 C&#x2F;S与B&#x2F;S区别123456789101112131415161718191．硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的，不必是专门的网络硬件环境，例如电话上网，租用设备. 信息自己管理. 有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。2．对安全要求不同：C/S 一般面向相对固定的用户群，对信息安全的控制能力很强。 一般高度机密的信息系统采用C/S 结构适宜。可以通过B/S发布部分可公开信息。B/S 建立在广域网之上， 对安全的控制能力相对弱， 可能面向不可知的用户。3．对程序架构不同：C/S 程序可以更加注重流程， 可以对权限多层次校验， 对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑，建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统。SUN 和IBM推JavaBean 构件技术等，使 B/S更加成熟.。4．软件重用不同：C/S 程序可以不可避免的整体性考虑， 构件的重用性不如在B/S要求下的构件的重用性好。B/S 的多重结构，要求构件相对独立的功能， 能够相对较好的重用，就如买来的餐桌可以再利用，而不是做在墙上的石头桌子。5．系统维护不同：C/S 程序由于整体性，必须整体考察，处理出现的问题以及系统升级、升级难、 可能是再做一个全新的系统。B/S 构件组成，方便构件个别的更换，实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级。 3. 手动部署3.0 创建web应用 3.1 静态html http://localhost/web01/hello.html 3.2 动态jsp http://localhost/web01/hello.jsp 3.3 Servlet1234567891011121314151617Servlet = Server applet 运行在服务器 tomcat上的小程序1.必须 规范：必须实现 Servlet 接口 //直接实现 Servlet 接口 A implements Servlet&#123; &#125; HttpServlet implments Servlet&#123; &#125; //间接实现 Servlet 接口 A extends HttpServlet&#123; ... &#125; 源码参考： 123456789101112131415161718192021import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class HelloWorld extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;Hello World!&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;Hello World Servlet ... !&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125;&#125; 编译 javac -cp D:\\java168_2\\server\\apache-tomcat-8.5.73\\lib\\servlet-api.jar .\\HelloWorld.java 部署 121. 桌面： aa文件下/HelloWorld.class 放在 classess文件夹下2. tomcat/lib/servlet-api.jar lib 空着 配置12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 访问http://localhost/web01/hello.do 4. IDE web开发4.1 创建项目 4.2 创建Servlet123456789public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //控制台输出 IDE console System.out.println(&quot;=====HelloServlet===doGet 该方法被执行啦=======&quot;); //通过 流 浏览器 输出 hello ... resp.getWriter().println(&quot;&lt;h1&gt; hello ...&lt;/h1&gt;&quot;); &#125;&#125; 4.3 配置Servlet123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;!-- 注册 servlet 类 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wanho.java171.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 映射 servlet 类访问路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.4 访问Servlethttp://localhost/day10-01-servlet/hello.do 基于请求驱动 地址栏直接怼 超链接 location.href form action&#x3D;“” 基于事件驱动 5.Servlet API5.1 HttpServletRequest12345678//获得请求参数的值方法1： String name = request.getParameter(&quot;name&quot;);&quot;name&quot; 参数名： 注意：如果参数名 不存在 String name 的值？ null 如果参数名 存在 没有值 String name 的值？ &quot;&quot; //1.针对 post 请求有效 中文乱码 req.setCharacterEncoding(&quot;UTF-8&quot;); 12345678910111213141516//兼容： get/postpublic class TestRequestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException &#123; //获得用户请求参数 使用 HttpServletRequest req 对象 String name = request.getParameter(&quot;name&quot;); String age = request.getParameter(&quot;age&quot;); System.out.println(&quot;姓名:&quot;+name+&quot;,年龄:&quot;+age); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 注意：doPost与doGet的区别GET调用用于获取服务器信息，并将其做为响应返回给客户端。当经由Web浏览器或通过HTML、JSP直接访问Servlet的URL时，一般用GET调用。 POST用于客户端把数据传送到服务器端，是可以隐藏传送给服务器的任何数据。Post适合发送大量的数据。 区别： 1、生成方式 get生成方式有四种：1）直接在URL地址栏中输入URL。2）网页中的超链接。3）form中method为get。4）form中method为空时，默认是get提交。 post生成方式：form中method属性为post。 2、数据传送方式 get方式：表单数据存放在URL地址后面。所有get方式提交时HTTP中没有消息体。 post方式：表单数据存放在HTTP协议的消息体中以实体的方式传送到服务器。 3、服务器获取数据方式 GET方式：服务器采用request.QueryString来获取变量的值。 POST方式：服务器采用request.Form来获取数据。 4、传送的数据量 GET方式：数据量长度有限制，一般不超过2kb。因为是参数传递，且在地址栏中，故数据量有限制。 POST方式：适合大规模的数据传送。因为是以实体的方式传送的。 5、安全性 GET方式：安全性差。因为是直接将数据显示在地址栏中，浏览器有缓冲，可记录用户信息。所以安全性低。 POST方式：安全性高。因为post方式提交数据时是采用的HTTP post机制，是将表单中的字段与值放置在HTTP HEADER内一起传送到ACTION所指的URL中，用户是看不见的。 6、在用户刷新时 GET方式：不会有任何提示、 POST方式：会弹出提示框，问用户是否重新提交 5.2 HttpServletResponse响应字符流12345// 1.响应 [html内容] 字符输出流resp.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter out = resp.getWriter();//通过 流 浏览器 输出 hello ... 类似： js ： document.write(&quot;html代码&quot;)out.println(&quot;&lt;h1&gt; hello . 该方法被执行啦..&lt;/h1&gt;&quot;); 响应URL12//2. 响应URL 浏览器 根据响应URL 再次发送新的请求resp.sendRedirect(&quot;./request.do&quot;) ;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"}]},{"title":"Java-捕获异常","slug":"Java-捕获异常","date":"2023-07-03T11:09:06.000Z","updated":"2023-07-03T11:35:12.222Z","comments":true,"path":"2023/07/03/Java-捕获异常/","link":"","permalink":"http://example.com/2023/07/03/Java-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/","excerpt":"","text":"捕获异常使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方。try&#x2F;catch代码块中的代码称为保护代码，使用 try&#x2F;catch 的语法如下： 1234567try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 实例:下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第四个元素的时候就会抛出一个异常。 1234567891011121314// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest&#123; public static void main(String args[])&#123; try&#123; int a[] = new int[2]; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; System.out.println(&quot;Out of the block&quot;); &#125;&#125; 以上代码编译运行输出结果如下 12Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block 多重捕获块一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。多重捕获块的语法如下所示： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;catch(异常类型3 异常的变量名3)&#123; // 程序代码&#125; 上面的代码段包含了 3 个 catch块。可以在 try 语句后面添加任意数量的 catch 块。如果保护代码中发生异常，异常被抛给第一个 catch 块。如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。如果不匹配，它会被传递给第二个 catch 块。如此，直到异常被捕获或者通过所有的 catch 块。 实例:该实例展示了怎么使用多重 try&#x2F;catch。 12345678910try &#123; file = new FileInputStream(fileName); x = (byte) file.read();&#125; catch(FileNotFoundException f) &#123; // Not valid! f.printStackTrace(); return -1;&#125; catch(IOException i) &#123; i.printStackTrace(); return -1;&#125; throws&#x2F;throw 关键字在Java中， throw 和 throws 关键字是用于处理异常的。throw 关键字用于在代码中抛出异常，而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。 throw 关键字throw 关键字用于在当前方法中抛出一个异常。通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 throw 关键字抛出异常，以告知调用者当前代码的执行状态。例如，下面的代码中，在方法中判断 num 是否小于 0，如果是，则抛出一个 IllegalArgumentException 异常。 12345public void checkNumber(int num) &#123; if (num &lt; 0) &#123; throw new IllegalArgumentException(&quot;Number must be positive&quot;); &#125;&#125; throws 关键字throws 关键字用于在方法声明中指定该方法可能抛出的异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常。例如，下面的代码中，当 readFile 方法内部发生 IOException 异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理 IOException 异常。 123456789public void readFile(String filePath) throws IOException &#123; BufferedReader reader = new BufferedReader(new FileReader(filePath)); String line = reader.readLine(); while (line != null) &#123; System.out.println(line); line = reader.readLine(); &#125; reader.close();&#125; 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException： 12345678910import java.io.*;public class className&#123; public void withdraw(double amount) throws RemoteException, InsufficientFundsException &#123; // Method implementation &#125; //Remainder of class definition&#125; finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; 实例:123456789101112131415public class ExcepTest&#123; public static void main(String args[])&#123; int a[] = new int[2]; try&#123; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; finally&#123; a[0] = 6; System.out.println(&quot;First element value: &quot; +a[0]); System.out.println(&quot;The finally statement is executed&quot;); &#125; &#125;&#125; 以上实例编译运行结果如下： 123Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed 注意下面事项： 1.catch 不能独立于 try 存在。2.在 try&#x2F;catch 后面添加 finally 块并非强制性要求的。3.try 代码后不能既没 catch 块也没 finally 块。4.try, catch, finally 块之间不能添加任何代码。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-查询基础","slug":"Mysql-查询基础","date":"2023-07-03T10:27:29.000Z","updated":"2023-07-11T01:36:23.486Z","comments":true,"path":"2023/07/03/Mysql-查询基础/","link":"","permalink":"http://example.com/2023/07/03/Mysql-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 查询基础1.0 基本概念12345678DDL:[数据定义语言] create , alter , drop , truncate 语句 【事务自动提交】DML:[数据操作语言] insert ,update, delete 语句DQL:[数据查询语言] selectDCL:[数据控制语言] grant[授权] ，revoke[撤销] ,commit , rollback , savepoint 表结构 初始化脚本scott.sql 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394drop database if exists scott;create database scott;use scott;DROP TABLE IF EXISTS BONUS;CREATE TABLE BONUS (ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,SAL DOUBLE NULL ,COMM DOUBLE NULL ) ;-- ------------------------------ Records for BONUS-- ------------------------------ ------------------------------ Table structure for DEPT-- ----------------------------DROP TABLE IF EXISTS DEPT;CREATE TABLE DEPT (DEPTNO INT(2) PRIMARY KEY,DNAME VARCHAR(14) NULL ,LOC VARCHAR(13) NULL );-- ------------------------------ Records for DEPT-- ----------------------------INSERT INTO DEPT VALUES (&#x27;10&#x27;, &#x27;ACCOUNTING&#x27;, &#x27;NEW YORK&#x27;);INSERT INTO DEPT VALUES (&#x27;20&#x27;, &#x27;RESEARCH&#x27;, &#x27;DALLAS&#x27;);INSERT INTO DEPT VALUES (&#x27;30&#x27;, &#x27;SALES&#x27;, &#x27;CHICAGO&#x27;);INSERT INTO DEPT VALUES (&#x27;40&#x27;, &#x27;OPERATIONS&#x27;, &#x27;BOSTON&#x27;);-- ------------------------------ Table structure for EMP-- ----------------------------DROP TABLE IF EXISTS EMP;CREATE TABLE EMP (EMPNO INT(4) PRIMARY KEY ,ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,MGR INT(4) NULL ,HIREDATE DATETIME NULL ,SAL DOUBLE(7,2) NULL ,COMM DOUBLE(7,2) NULL ,DEPTNO INT(2) NULL );-- ------------------------------ Records for EMP-- ----------------------------INSERT INTO EMP VALUES (&#x27;7369&#x27;, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, &#x27;7902&#x27;, &#x27;1980-12-17 00:00:00&#x27;, &#x27;800&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7499&#x27;, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-20 00:00:00&#x27;, &#x27;1600&#x27;, &#x27;300&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7521&#x27;, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-22 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;500&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7566&#x27;, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-04-02 00:00:00&#x27;, &#x27;2975&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7654&#x27;, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-28 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;1400&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7698&#x27;, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-05-01 00:00:00&#x27;, &#x27;2850&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7782&#x27;, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-06-09 00:00:00&#x27;, &#x27;2450&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7788&#x27;, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1987-04-19 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7839&#x27;, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, null, &#x27;1981-11-17 00:00:00&#x27;, &#x27;5000&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7844&#x27;, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-08 00:00:00&#x27;, &#x27;1500&#x27;, &#x27;0&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7876&#x27;, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, &#x27;7788&#x27;, &#x27;1987-05-23 00:00:00&#x27;, &#x27;1100&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7900&#x27;, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, &#x27;7698&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;950&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7902&#x27;, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7934&#x27;, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, &#x27;7782&#x27;, &#x27;1982-01-23 00:00:00&#x27;, &#x27;1300&#x27;, null, &#x27;10&#x27;);-- ------------------------------ Table structure for &quot;SALGRADE&quot;-- ----------------------------DROP TABLE IF EXISTS SALGRADE;CREATE TABLE SALGRADE (GRADE INT(2) NULL ,LOSAL DOUBLE NULL ,HISAL DOUBLE NULL ) ;-- ------------------------------ Records for SALGRADE-- ----------------------------INSERT INTO SALGRADE VALUES (&#x27;1&#x27;, &#x27;700&#x27;, &#x27;1200&#x27;);INSERT INTO SALGRADE VALUES (&#x27;2&#x27;, &#x27;1201&#x27;, &#x27;1400&#x27;);INSERT INTO SALGRADE VALUES (&#x27;3&#x27;, &#x27;1401&#x27;, &#x27;2000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;4&#x27;, &#x27;2001&#x27;, &#x27;3000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;5&#x27;, &#x27;3001&#x27;, &#x27;9999&#x27;);-- ------------------------------ Foreign Key structure for table EMP-- ----------------------------ALTER TABLE EMP ADD FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO); 1.1 简单select所有行所有列1SELECT * FROM emp ; 限制列1SELECT empno,ename,sal FROM emp ; 限制行1SELECT * FROM emp WHERE deptno = 10 ; 1.2 算术运算符 + - * &#x2F;注意： null 值不参与计算 【null 未知值 不确定值 x？】 1SELECT sal+comm FROM emp ; -- comm null 值 + 【运算】1234SELECT 3+4 ;SELECT &#x27;3&#x27;+4 ;SELECT &#x27;3&#x27;+&#x27;4&#x27; ;SELECT &#x27;3&#x27;+&#x27;ABC&#x27; ; -- 3 [不报错] &#x2F; 【除法】1SELECT 5/2 ; -- 2.5000 1.3 别名 AS标准： AS “dept.dname” 1SELECT ename AS &quot;from&quot; ,sal AS &quot;员工 工资&quot; FROM emp AS e 1.4 null 空值安全 等于&#x2F;全等于 ：&lt;&#x3D;&gt; 与 &#x3D; 区别：可以判断null值 is null123SELECT * FROM emp WHERE comm IS NULL ;SELECT * FROM emp WHERE comm &lt;=&gt; NULL ; is not null123SELECT * FROM emp WHERE comm IS NOT NULL ;SELECT * FROM emp WHERE NOT comm IS NULL ; 1.5 去重复行 distinct1SELECT DISTINCT deptno ,job FROM emp ; 1.6 排序 order by堆表：快速插入数据 【搬家公司 –&gt; 家具】 默认： 升序 ASC 降序 DESC 基本排序12SELECT * FROM emp ORDER BY sal ASC;SELECT * FROM emp ORDER BY sal DESC; 结果集列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC; 排序多列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC ,1 ASC ; nullOracle 数据库有专用关键字，mysql没有 12345-- null firstSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),99999,comm) DESC ;-- null lastSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),-1,comm) DESC ; 1.7 比较运算符 &lt;&#x3D;&gt; 安全等于【比较null值】 &#x3D; 等于【不能比较null值】 !&#x3D; &lt;&gt; &lt; &lt;&#x3D; &gt; &gt;&#x3D; between and 1234SELECT * FROM emp WHERE deptno != 10 ;SELECT * FROM emp WHERE deptno &lt;&gt; 10 ;SELECT * FROM emp WHERE sal BETWEEN 800 AND 3000 ;SELECT * FROM emp WHERE sal&gt;=800 AND sal&lt;=3000 ; 1.8 in not inin12SELECT * FROM emp WHERE deptno IN (10,20) ;SELECT * FROM emp WHERE deptno =10 OR deptno =20 ; not in12-- 注意： not in (去null值)SELECT * FROM emp WHERE deptno NOT IN (10,20,NULL) ; 1.9 模糊查询_ 一个字符 % N个字符 1SELECT * FROM emp WHERE ename LIKE &#x27;__A%&#x27;; 1234-- zhang_san _进行转义 _不是 like 匹配字符 而是数据SELECT * FROM emp WHERE ename LIKE &#x27;%\\_%&#x27;;SELECT * FROM emp WHERE ename LIKE &#x27;%\\%%&#x27;; 1.10 正则 REGEXP12345^ 匹配开头$ 匹配结尾. 任何一个字符[abc] 范围匹配一个 [a-z] [0-9]* 匹配任意次 12345678-- s开头的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;^S&#x27; ;-- T结尾的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;T$&#x27; ;-- 第二个字母 CSELECT * FROM emp WHERE ename REGEXP &#x27;.C&#x27; ;-- 包含字母 OSELECT * FROM emp WHERE ename REGEXP &#x27;.*O.*&#x27; ; 1.11 逻辑运算符not ! and &amp;&amp; or || 1SELECT NOT 1=1 , ! (1=1) ; 1.12 limitTOPN 1234567-- limit 位置偏移量, 行数 -- 第一页SELECT * FROM emp LIMIT 0,5 ;SELECT * FROM emp LIMIT 5 ;-- 第二页SELECT * FROM emp LIMIT 5,5 ; 例1：123456789101112131415161718-- 1.选择在部门 30 中员工的所有信息 select * from emp where deptno = &#x27;30&#x27; ;-- 2 列出职位为（MANAGER）的员工的编号，姓名 select empno,ename from emp where job = &#x27;MANAGER&#x27; ;-- 3 找出奖金高于工资的员工 select * from emp where comm&gt;sal ;-- 4 找出每个员工奖金和工资的总和 select sal+if(isnull(comm),0,comm) month_sal ,ename from emp order by month_sal desc ;-- 5 找出部门 10 中的经理(MANAGER)和部门 20 中的普通员工(CLERK)select * from emp where (deptno,job) in ((10,&#x27;MANAGER&#x27;),(20,&#x27;CLERK&#x27;)) ;-- 6 找出部门 10 中既不是经理MANAGER也不是普通员工CLERK，而且工资大于等于 2000 的员工select * from emp where deptno = 10 and job not in (&#x27;MANAGER&#x27;,&#x27;CLERK&#x27;) and sal&gt;=2000 ;-- 7 找出有奖金的员工的不同工作select distinct job from emp where comm is not null ;-- 8 找出没有奖金或者奖金低于 500 的员工select * from emp where comm is null or comm&lt;500 ;-- 9 显示雇员姓名，根据其服务年限，将最老的雇员排在最前面select ename from emp order by hiredate asc ; 2. 单行函数2.1 数值函数绝对值 1SELECT ABS(-11.5) ; 平方根 1SELECT SQRT(100) ; 求余 1SELECT MOD(5,2) ; 向上取整 1SELECT CEIL(3.001) ,CEIL(3.000) ; 向下取整 1SELECT FLOOR(3.999) ,CEIL(3.000) ; 随机数 1SELECT RAND() ; 四舍五入 1SELECT ROUND(11.5),ROUND(-11.5) ; 2.2 字符函数字符个数 123SELECT * FROM emp WHERE CHAR_LENGTH(ename) = 5 ;SELECT * FROM emp WHERE ename LIKE &#x27;_____&#x27; ; 字符串连接 12345-- concat() null 值 返回 nullSELECT CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;,NULL) ;-- concat_ws() null值不参与 【第一个参数 连接符 】SELECT CONCAT_WS(&#x27;,&#x27;,&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT_WS(&#x27;*&#x27;,&#x27;hello&#x27;,NULL,&#x27;word&#x27;,&#x27;java167&#x27;) 字符串替换 12-- db 索引从 1 开始SELECT INSERT(&#x27;hellojava167&#x27;,3,2,&#x27;**&#x27;) ; 大小写转换 1SELECT UPPER(&#x27;hello java&#x27;),LOWER(&#x27;JAVA hello&#x27;) ; 左右截取字符串 1SELECT LEFT(&#x27;helloworld&#x27;,5),RIGHT(&#x27;helloworld&#x27;,5) ; 左右填充字符串 1SELECT LPAD(&#x27;helloworld&#x27;,15,&#x27;-&#x27;),RPAD(&#x27;helloworld&#x27;,15,&#x27;*&#x27;) ; 首尾去空格 12SELECT TRIM(&#x27; abc ddd &#x27;) ;SELECT TRIM(&#x27;abc&#x27; FROM &#x27;abcxxxyyyabc&#x27;) ; 重复生成字符串 1SELECT REPEAT(&#x27;hello&#x27;,5) ; 字符串比较 12-- 1 0 -1SELECT STRCMP(&#x27;abc&#x27;,&#x27;def&#x27;) ,STRCMP(&#x27;abc&#x27;,&#x27;abc&#x27;),STRCMP(&#x27;zzz&#x27;,&#x27;abc&#x27;); 字符串截取 1234SELECT SUBSTRING(&#x27;helloworld&#x27;,1,5) ,SUBSTRING(&#x27;helloworld&#x27;,5),SUBSTRING(&#x27;helloworld&#x27;,-5);SELECT MID(&#x27;helloworld&#x27;,1,5) ,MID(&#x27;helloworld&#x27;,5),MID(&#x27;helloworld&#x27;,-5); 查找索引 1SELECT LOCATE(&#x27;o&#x27;,&#x27;helloworld&#x27;) ,POSITION(&#x27;o&#x27; IN &#x27;helloworld&#x27;),INSTR(&#x27;helloworld&#x27;,&#x27;o&#x27;) ; 2.3 日期函数当前日期 123456-- 年月日SELECT CURRENT_DATE , CURRENT_DATE() , CURDATE();-- 时分秒SELECT CURRENT_TIME ,CURRENT_TIME(), CURTIME();-- 年月日 时分秒SELECT CURRENT_TIMESTAMP,CURRENT_TIMESTAMP(),LOCALTIME(),NOW(),SYSDATE() ; 日期之间相差天数 1SELECT DATEDIFF(NOW(),hiredate) FROM emp ; 当前日期该月最后一天 1SELECT LAST_DAY(NOW()) ; 日期加减 123SELECT DATE_ADD(NOW(),INTERVAL 1 DAY) ;SELECT DATE_SUB(NOW(),INTERVAL 1 DAY) ; 周 年 月 小时 分 12345SELECT WEEK(NOW()),YEAR(NOW()),MONTH(NOW()),HOUR(NOW()),MINUTE(NOW()) ;SELECT DAYOFMONTH(NOW()),DAY(NOW()),DAYOFYEAR(NOW()) ;-- 提取日期中 部分字段SELECT EXTRACT(YEAR FROM NOW()),EXTRACT(MONTH FROM NOW()) ; 日期格式化 12SELECT DATE_FORMAT(NOW(),&#x27;%Y/%m/%d %h:%i&#x27;);SELECT * FROM emp WHERE DATE_FORMAT(hiredate,&#x27;%m&#x27;) = &#x27;02&#x27; ; 2.4 条件判断函数if 12SELECT IF(3&lt;2,&#x27;aaa&#x27;,&#x27;bbb&#x27;);SELECT IF(STRCMP(&#x27;xyz&#x27;,&#x27;abc&#x27;),&#x27;yes&#x27;,&#x27;no&#x27;); ifnull 1SELECT sal+IFNULL(comm,0) FROM emp ; case 12345678910111213-- 根据部门 10 dev 20 test 30 public others SELECT empno, ename, CASE deptno WHEN 10 THEN &#x27;dev&#x27; WHEN 20 THEN &#x27;test&#x27; WHEN 30 THEN &#x27;public&#x27; ELSE &#x27;others&#x27; END dnameFROM emp ; 例2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546-- 1 找出每个月倒数第三天受雇的员工（如：2009-5-29） -- date_add last_dayselect * from emp where date_add(hiredate,INTERVAL 2 day) = last_day(hiredate);-- 2 找出 25 年前雇的员工 -- datediffselect * from emp where datediff(now(),hiredate)/365&gt;25 ;-- 3 所有员工名字前加上 Dear ,并且名字首字母大写 -- concat concat_ws upper substring midselect concat(&#x27;Dear&#x27;,upper(mid(ename,1,1)),mid(ename,2)) from emp ;-- 4 找出姓名为 5 个字母的员工 -- char_length like _select * from emp where char_length(ename) = 5 ;-- 5 找出姓名中不带 R 这个字母的员工 -- not likeselect * from emp where ename not like &#x27;%R%&#x27; ;-- 6 显示所有员工的姓名的第一个字 -- substringselect substring(ename,1,1) from emp ;-- 7 显示所有员工，按名字降序排列，若相同，则按工资升序排序 select ename,sal from emp order by ename desc , sal asc ;-- 8 假设一个月为 30 天，找出所有员工的日薪，不计小数 -- floor isnull if ifnullselect floor((sal+ifnull(comm,0))/30) from emp ;-- 9 找到 2 月份受雇的员工 -- month date_formatselect * from emp where month(hiredate) = 2 ;-- 10 列出员工加入公司的天数(四舍五入） select datediff(now(),hiredate) from emp ;-- 11 分别用 case 列出员工所在的部门，-- deptno=10 显示&#x27;部门 10&#x27;, -- deptno=20 显示&#x27;部门 20&#x27; -- deptno=30 显示&#x27;部门 30&#x27; -- deptno=40 显示&#x27;部门 40&#x27; -- 否则为&#x27;其他部门&#x27; select empno,ename ,case when deptno between 10 and 30 then &#x27;重要部门&#x27; when deptno&gt;40 then &#x27;辅助部门&#x27; else &#x27;其他部门&#x27; end dname from emp ; 3. 分组函数统计函数 组函数 聚合函数 count sum min max avg 3.1 注意：null值不参与统计 123SELECT COUNT(comm) FROM emp ; -- 4 表中数据 16行SELECT COUNT(0) FROM emp ; 分组函数不能出现where子句 12-- 查询工资大于平均工资的员工SELECT * FROM emp WHERE sal &gt; AVG(sal) ; 3.2 group by注意： 只要有group by 子句： ​ select 子句要求：只能写 group by 出现的列名 + 5 个分组函数 12345678910SELECT deptno, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno ; 多个分组条件： 12345678910SELECT deptno,job, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno,job ; 3.3 having123456789-- 根据部门分组 查询部门人数大于 2人的部门编号 人数-- 根据部门分组 查询部门人数大于 2人的部门编号 人数SELECT deptno, COUNT(0) dept_countFROM empGROUP BY deptnoHAVING COUNT(0)&gt;2 ; 3.4 完整的SQL1234567891011121314select 列名1 ,列名2...列名Nfrom 表1,表2 .... 表Nwhere 限制行【分组前过滤】group by 分组列having 分组后过滤order by 排序limit 偏移量,行数 12345678910111213-- 查询工资大于500 按照部门分组 如果部门相同按照工种分组 人数大于等于1 按照人数排降序 第2~5条SELECT deptno, job, COUNT(0) dept_count FROM emp WHERE sal &gt; 500 GROUP BY deptno, job HAVING COUNT(0) &gt;= 1 ORDER BY 3 DESC LIMIT 2, 3 ; 3.5 行列转换12345678910CREATE TABLE stu( sname VARCHAR(20), sub VARCHAR(20), score VARCHAR(20));INSERT INTO stu (sname,sub,score) VALUES (&#x27;zs&#x27;,&#x27;chinese&#x27;,&#x27;100&#x27;),(&#x27;zs&#x27;,&#x27;math&#x27;,&#x27;99&#x27;),(&#x27;zs&#x27;,&#x27;english&#x27;,&#x27;98&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;li&#x27;,&#x27;chinese&#x27;,&#x27;80&#x27;),(&#x27;li&#x27;,&#x27;math&#x27;,&#x27;89&#x27;),(&#x27;li&#x27;,&#x27;english&#x27;,&#x27;88&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;ww&#x27;,&#x27;chinese&#x27;,&#x27;70&#x27;),(&#x27;ww&#x27;,&#x27;math&#x27;,&#x27;79&#x27;),(&#x27;ww&#x27;,&#x27;english&#x27;,&#x27;78&#x27;);COMMIT ; 1234567SELECT sname, CASE sub WHEN &#x27;chinese&#x27; THEN score END chinese , CASE sub WHEN &#x27;math&#x27; THEN score END math , CASE sub WHEN &#x27;english&#x27; THEN score END english FROM stu 12345678SELECT sname, SUM(CASE sub WHEN &#x27;chinese&#x27; THEN score END) chinese , SUM(CASE sub WHEN &#x27;math&#x27; THEN score END) math , SUM(CASE sub WHEN &#x27;english&#x27; THEN score END) english FROM stu GROUP BY sname 例3:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-- 1 分组统计各部门下工资&gt;500 的员工的平均工资-- group by deptno 分组统计各部门-- where sal &gt; 500 工资&gt;500 的员工-- select avg(sal) 平均工资-- from emp 员工select deptno,avg(sal) avg_sal from emp where sal&gt;500 group by deptno ;-- 2 统计各部门下平均工资大于 500 的部门 -- group by deptno 统计各部门-- select avg(sal)-- having avg(sal)&gt;500 工资大于 500 select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;500 ;-- 3 算出部门 30 中得到最多奖金的员工奖金 -- where deptno = 30 部门 30-- select max(comm) 最多奖金select max(comm) from emp where deptno = 30 ;-- 4 算出部门 30 中得到最多奖金的员工姓名 -- where deptno = 30 部门 30 得到最多奖金-- select ename 员工姓名-- select ename,comm from emp where deptno=30 order by comm desc limit 0,1;-- select ename,comm from emp where deptno=30 and comm=(select max(comm) from emp where deptno = 30 ) ;select ename,comm from emp where (deptno,comm)=(select deptno,max(comm) from emp where deptno = 30 ) ;-- 5 算出每个职位的员工数和最低工资 -- group by job 每个职位-- select count(0) , min(sal) 员工数和最低工资select job,count(0) , min(sal) from emp group by job ;-- 6 算出每个部门,每个职位的平均工资和平均奖金(平均值包括没有奖金)，-- 如果平均奖金大于 300，显示“奖金不错”，-- 如果平均奖金 100 到 300，显示“奖金一般”，-- 如果平均奖金小于 100，显示“基本没有奖金”，-- 按部门编号降序，平均工资降序排列-- group by deptno,job 每个部门,每个职位-- select avg(sal) ,avg(ifnull(comm,0)) 平均工资和平均奖金-- case when then end .. 显示转换-- order by deptno desc ,avg(sal) desc 按部门编号降序，平均工资降序排列select deptno,job,avg(sal) ,case when avg(ifnull(comm,0))&gt;300 then &#x27;奖金不错&#x27; when avg(ifnull(comm,0))&gt;=100 and avg(ifnull(comm,0))&lt;=300 then &#x27;奖金一般&#x27; when avg(ifnull(comm,0))&lt;100 then &#x27;基本没有奖金&#x27; end comm_msg from emp group by deptno,job order by deptno desc ,avg(sal) desc;-- 7 列出员工表中每个部门的员工数，和部门 no -- group by deptno 每个部门-- select count(0) , deptno 员工数，和部门 noselect count(0) , deptno from emp group by deptno ;-- 8 得到工资大于自己部门平均工资的员工信息 -- 注意： 别名select * from emp e where sal &gt; (select avg(sal) from emp where deptno=e.deptno) ;-- 9 分组统计每个部门下，每种职位的平均奖金（也要算没奖金的人）和总工资(包括奖金) -- group by deptno,job ; 每个部门下，每种职位-- select avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) 平均奖金（也要算没奖金的人）和总工资(包括奖金) select deptno,job,avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) from emp group by deptno,job; 4. 多表查询 4.1 笛卡尔集【积】 Cross join行相乘 列相加 【大结果集】 bug 【避免该查询】忘记写 where 条件 ，或条件无效 1234-- 忘记写 where 条件SELECT * FROM emp,dept,salgrade ;-- 条件无效 SELECT * FROM emp,dept,salgrade WHERE emp.deptno=emp.deptno; 4.2 等值连接 Equi join&#x2F;Natural join两张表的数据 必须相关 【外键值 &#x3D; 另一张表的主键值】 等值连接 12-- 查询姓名 部门名称SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e , dept d WHERE e.deptno = d.deptno 自然连接【两表中同名的列】 12-- EMP deptno [emp 的 FK] Dept deptno [dept 的 PK]SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e NATURAL JOIN dept d ; 4.3 非等值连接 Non-Equijoin参考值 【emp表 sal 3000 salgrade表 3000 ？1201~4000】 1234567891011-- 查询工号，姓名 ，工资，工资等级SELECT e.empno, e.ename, e.sal, s.grade FROM emp e, salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal ; 4.4 自连接 Self join树型表 无限级分类表 【表的FK 指向自己表的主键】 必须使用别名 123456SELECT COUNT(0) FROM emp e,emp m ; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.empno = e.empno; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.mgr = m.empno; -- 自连接-- 查询员工姓名 工资 直接领导姓名 工资 SELECT e.ename emp_name,e.sal emp_sal,m.ename mgr_name,m.sal mgr_sal FROM emp e, emp m WHERE e.mgr = m.empno ; 4.5 左外连接 Left Outer Join123456789-- 查询所有员工姓名 部门名称 包括没有部门的员工SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno ; 4.6 右外连接 Right Outer Join123456789-- 查询所有部门名称 包括没有员工的 部门select e.ename, d.deptno, d.dname from emp e right outer join dept d on e.deptno = d.deptno ; 4.7 满外连接 Full Outer Joinmysql 不支持 Full join 【通过集合操作 union 合集】 12345678910111213141516171819-- 查询所有部门名称 包括没有员工的 部门 -- + 所有员工姓名 部门名称 包括没有部门的员工(SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno) UNION(SELECT e.ename, d.deptno, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno = d.deptno) 4.8 内连接 Inner Join12-- 查询 员工姓名 部门名SELECT e.ename,d.deptno,dname FROM emp e INNER JOIN dept d ON e.deptno = d.deptno ; 4.9 集合操作并集【UNION ，UNION ALL】 UNION 自动去重复 速度慢 UNION ALL 保留重复 速度快 注意： 列的个数相同 列的数据类型一致 无序 123456SELECT* FROM((SELECT * FROM emp WHERE deptno = 10 ORDER BY sal DESC )UNION(SELECT * FROM emp WHERE deptno = 20 ORDER BY sal DESC ))t ORDER BY t.sal DESC ; 5. 子查询子查询：where 子句 ，from子句，select 子句 , having 子句 123456789101112131415161718-- select 子句 [标量子查询]SELECT ename,(SELECT dname FROM dept WHERE deptno=e.deptno) dname FROM emp e;-- having 子句SELECT MIN(sal), deptno FROM emp GROUP BY deptno HAVING MIN(sal) = (SELECT MIN(min_sal) FROM (SELECT MIN(sal) min_sal FROM emp GROUP BY deptno) t) ; 子查询不返回 主查询不返回 12-- 查询工资比 工号8888 的员工还高员工姓名SELECT * FROM emp WHERE sal&gt;(SELECT sal FROM emp WHERE empno = 8888) ; 单列 对 多列 1SELECT * FROM emp WHERE sal&gt;(SELECT ename,sal FROM emp WHERE empno = 7788) ; 单行 对 多行 12-- Subquery returns more than 1 rowSELECT * FROM emp WHERE sal = (SELECT MIN(sal) FROM emp GROUP BY deptno) ; 5.1 单行子查询子查询结果【单行】 比较运算符 &#x3D; !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 12345678910111213-- 查询大于平均工资的员工SELECT * FROM emp WHERE sal &gt; (SELECT AVG(sal) FROM emp) ; -- 查询 7788 相同部门 工种的员工SELECT * FROM emp WHERE (deptno,job)=(SELECT deptno,job FROM emp WHERE empno = 7788) 注意：返回多行 【一行 对多行&#x2F;多值 ，一列对多列 ，NULL&#x2F;空值】 5.2 多行子查询返回 多行 【包含单行 –&gt; NULL值】 in 【 &#x3D; any ，&#x3D; some】 ，not in ， &gt; all &gt;&#x3D; all &lt; &lt;&#x3D; all ,&gt;any in ，not in 【无法使用索引查询，查询全表扫描】 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename,e.sal FROM emp e ,(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) tWHERE e.deptno = t.deptno AND e.sal = t.dept_min_sal ;-- 子查询SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) IN(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =ANY(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =SOME(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) exists ，not exists 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename, e.sal FROM emp e WHERE EXISTS (SELECT NULL FROM emp GROUP BY deptno HAVING deptno = e.deptno AND MIN(sal) = e.sal) ; in VS exists 1234in : 无法使用索引，全表扫描 not in 【注意去 null值】 主查询 3KW 子查询 1Kexists : 使用索引，不使用全表扫描 not exists 主查询 1k 子查询 3kw","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Mysql安装过程详解","slug":"Mysql安装过程详解","date":"2023-07-03T03:48:58.000Z","updated":"2023-07-11T01:36:53.605Z","comments":true,"path":"2023/07/03/Mysql安装过程详解/","link":"","permalink":"http://example.com/2023/07/03/Mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Mysql安装&#x2F;卸载1 卸载 2 安装下载https://downloads.mysql.com/archives/installer/ 安装 卸载不干净，无法安装 【解决方案】 https://blog.csdn.net/weixin_43147354/article/details/117241786 MicrosoftProgram_Install_and_Uninstall.meta.diagcab","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java-IO流","slug":"Java-IO流","date":"2023-07-01T12:15:14.000Z","updated":"2023-07-01T14:36:24.329Z","comments":true,"path":"2023/07/01/Java-IO流/","link":"","permalink":"http://example.com/2023/07/01/Java-IO%E6%B5%81/","excerpt":"","text":"1. File1.1 File与流 1.2 File练习例11234567891011121314151617181920/*使用File对象，在C盘创建aaa/bbb/ccc的文件夹，在此文件夹下创建1.txt【C:/aaa/bbb/ccc/1.txt】 如果该文件存在，删除1.txt 如果该文件不存在，创建1.txt*/import java.io.File;import java.io.IOException;public class FileTest01 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\aaa\\\\bbb\\\\ccc\\\\1.txt&quot;); if (file.exists())&#123; file.delete(); &#125;else&#123; //创建文件夹 file.getParentFile().mkdirs(); //创建 文件 file.createNewFile(); &#125; &#125;&#125; 例21234567891011121314151617/*使用File对象 listFiles() 方法自定义类 implements FilenameFilterC:\\Program Files\\Java\\jdk1.8.0_321\\bin目录下，所有的 .exe结尾的文件打印出来。*/import java.io.File;import java.io.FilenameFilter;import java.io.IOException;import java.util.stream.Stream;public class FileTest02 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_361\\\\bin&quot;); String[] ay = file.list((dir, name) -&gt; name.endsWith(&quot;.exe&quot;)); Stream.of(ay).forEach(System.out::println); &#125;&#125; 2. 节点流2.1 字节流 2.2 节点流练习例312345678910111213141516171819202122232425/*使用FileOutputStream 向1.txt文件写入： A~Z 字符在 文件 结尾：a~z字符*/import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class FileOutputStreamTest03 &#123; public static void main(String[] args) throws IOException &#123; //输出流 自动创建文件 OutputStream os = new FileOutputStream(&quot;1.txt&quot;,true) ; //写 byte 比如：A for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125; /*for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125;*/ //建议： 可选 //os.flush(); os.close(); &#125;&#125; 例412345678910111213141516171819202122232425262728293031/*使用FileInputStream IDEA具体的JAVA文件 比如： Test1.java打印该Java文件中所有的内容*/import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class FileInputStreamTest04 &#123; public static void main(String[] args) throws IOException &#123; //输入流 注意：目标数据源 一定存在的 InputStream is = new FileInputStream(&quot;Test1.java&quot;) ; //读 /*while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; System.out.print((char)data); &#125;*/ int data = 0 ; while((data = is.read())!=-1)&#123; System.out.print((char)data); &#125; is.close(); &#125;&#125; 2.3 字符流 2.4 节点流 输入流 输出流 例51234567891011121314151617181920212223/*使用流 实现把图片从C盘拷贝D盘。*/import java.io.*;public class PicCopyTest05 &#123; public static void main(String[] args) throws IOException &#123; //1.输入流 怼到 目标数据源 InputStream is = new FileInputStream(&quot;D:\\\\Java180_2\\\\doc\\\\day01-html基础\\\\res\\\\mm.jpg&quot;) ; //2.输出流 项目下 OutputStream os = new FileOutputStream(&quot;meimei.jpg&quot;) ; //3. 读 while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; //4.写 os.write(data); &#125; System.out.println(&quot;====图片拷贝结束=========&quot;); &#125;&#125; 3. 处理流3.1 流嵌套 3.2 处理流 3.3 调包侠https://commons.apache.org/proper/commons-io/description.html 4. 对象流 例61234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用对象流 实现对对象实现读写功能*///写入import java.io.*;public class ObjectOutputStreamTest11 &#123; public static void main(String[] args) throws IOException &#123; //1.对象 创建商品对象 【A.瞬时状态 -- JVM 内存】 Goods goods = new Goods(&quot;G1001&quot;, &quot;苹果&quot;, 4.5D); //2. 写入 4.txt 文件 节点文件流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;4.txt&quot;)) ; /*OutputStream os = new FileOutputStream(&quot;4.txt&quot;) ; ObjectOutputStream oos = new ObjectOutputStream(os) ;*/ //【B.持久状态 -- 文件系统】 //goods.setName(&quot;香蕉&quot;); //对象流 写入 oos.writeObject(goods); oos.flush(); oos.close(); //【C.脱管状态 -- 脱离管理】 //goods.setName(&quot;菠萝&quot;); &#125;&#125;//读取import java.io.*;public class ObjectInputStreamTest12 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.读取 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;4.txt&quot;)) ; Object o = ois.readObject(); ois.close(); System.out.println(o); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-集合","slug":"Java-集合","date":"2023-06-29T14:07:43.000Z","updated":"2023-07-29T14:15:39.712Z","comments":true,"path":"2023/06/29/Java-集合/","link":"","permalink":"http://example.com/2023/06/29/Java-%E9%9B%86%E5%90%88/","excerpt":"","text":"1. Map集合框架类图 HashMap常用方法键值对（“key &#x3D; value”），顾名思义，每一个键会对应一个值。 APIAPI 是用于构建应用程序软件的一组子程序定义，协议和工具。一般来说，这是一套明确定义的各种软件组件之间的通信方法。 例1：1234567891011121314151617181920212223242526272829/*1.遍历集合，并将序号与对应人名打印。2.向该map插入一个编码为5姓名为李晓红3.移除该map中的编号为1的信息4.将map集合中编号为2的姓名信息修改为&quot;周琳&quot;*/import java.util.HashMap;import java.util.Map;public class Ex01 &#123; public static void main(String[] args) &#123; Map map =new HashMap();//多态 map.put(1,&quot;张三丰&quot;); map.put(2,&quot;周芷若&quot;); map.put(3,&quot;汪峰&quot;); map.put(4,&quot;灭绝师太&quot;); //1.循环遍历 map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); //2.插入 map.put(5,&quot;李晓红&quot;); //3.移除 map.remove(1); //4.修改 //map.put(2,&quot;周琳&quot;); map.replace(2,&quot;周琳&quot;); System.out.println(&quot;==============================&quot;); map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); &#125;&#125; java8 参考循环输出： 123456Map map = new HashMap() ;map.put(1,&quot;张三1&quot;) ;map.put(2,&quot;张三2&quot;) ;map.put(3,&quot;张三3&quot;) ;// java lambda表达式 类似 ES6 的箭头函数 【可推导即可省略】map.forEach((k,v)-&gt; System.out.println(&quot;序号:&quot;+k+&quot;,姓名:&quot;+v)); 例2：1234567891011121314151617181920212223242526/*有2个数组，第一个省份数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，第二个省会数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为key，第二个数组元素作为value存储到Map集合中。如&#123;黑龙江省=哈尔滨, 浙江省=杭州, …&#125;。*/import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class Ex02 &#123; public static void main(String[] args) &#123; String[] proAy = &#123;&quot;黑龙江省&quot;,&quot;浙江省&quot;,&quot;江西省&quot;,&quot;广东省&quot;,&quot;福建省&quot;&#125; ; String[] cityAy = &#123;&quot;哈尔滨&quot;,&quot;杭州&quot;,&quot;南昌&quot;,&quot;广州&quot;,&quot;福州&quot;&#125; ; Map map = new LinkedHashMap(); // 把 数组中的元素 存放在 map的 条目中 for (int i=0;i&lt;proAy.length;i++)&#123; map.put(proAy[i],cityAy[i]); &#125; //打印map 无需循环 &#123;key=value,key=value&#125; System.out.println(map); &#125;&#125; 例3：1234567891011/*定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。 List list = new ArrayList() ;例如：集合中有”abc”、”bcd”两个元素， list.add(“abc”) ; list.add(“bcd”) ;程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。 Map map = ... String 类 1. length() 字母个数 2. charAt() 根据索引 获得 字母*/ Hashtable1null值问题? 对比： 2. Iterator基本使用 例41234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用ArrayList存储多个学生信息1. 删除年龄&gt;18岁的学生2. 使用Iterator进行遍历 */import java.util.ArrayList;import java.util.Iterator;import java.util.function.Predicate;/** * 使用ArrayList存储多个学生信息 * 1. 删除年龄&gt;18岁的学生 * 2. 使用Iterator进行遍历 */public class Ex04 &#123; public static void main(String[] args) &#123; ArrayList&lt;Stu&gt; stuList = new ArrayList(); stuList.add(new Stu(19)) ; stuList.add(new Stu(39)) ; stuList.add(new Stu(14)) ; stuList.add(new Stu(16)) ; stuList.add(new Stu(26)) ; stuList.add(new Stu(12)) ; //推荐 java8的语法 removeIf(e-&gt;e.getAge()&gt;18) forEach(System.out::println) //stuList.removeIf( o -&gt; ((Stu)o).getAge()&gt;18 ) ; //stuList.removeIf( o -&gt; o.getAge()&gt;18 ) ; //stuList.forEach(System.out::println); //Iterator 判断有没有下一个元素 hasNext() 取出下一个元素 next() 删除当前元素 remove() Iterator&lt;Stu&gt; iterator = stuList.iterator(); while (iterator.hasNext()) &#123; //腐烂味道代码 坏味道代码 Stu stu = iterator.next(); if (stu.getAge()&gt;18)&#123; iterator.remove(); &#125; &#125; System.out.println(stuList); &#125;&#125; 参考java8 List 删除元素： 12345678List list = new ArrayList() ;list.add(new Stu(1,&quot;aaa&quot;,19)) ;list.add(new Stu(2,&quot;bbb&quot;,16)) ;list.add(new Stu(3,&quot;ccc&quot;,14)) ;//如果满足条件 进行删除list.removeIf(ele-&gt;((Stu)ele).getAge()&gt;18) ;//循环输出list.forEach(System.out::println); 3. 泛型为什么 怎么用 4. Set4.1 HashSet 例512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.HashSet;import java.util.Random;import java.util.Set;/** * 双色球规则： * 双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。 * 红色球号码从1—33中选择； * 蓝色球号码从1—16中选择； * 请随机生成一注双色球号码。 * （要求同色号码不重复） */public class Ex05 &#123; public static void main(String[] args) &#123; Random random = new Random(); // 蓝色球号码 int blueBall = random.nextInt(16)+1 ; HashSet&lt;Ball&gt; ballSet = new LinkedHashSet&lt;&gt;() ; // 一个 蓝色球 ballSet.add(new Ball(&quot;蓝球&quot;,blueBall)) ; while (ballSet.size() != 7) &#123; //红色球号码 int redBall = random.nextInt(33)+1 ; ballSet.add(new Ball(&quot;红球&quot;,redBall)) ; &#125; System.out.println(ballSet); &#125;&#125;class Ball&#123; private String color ; private Integer num ; public Ball(String color, Integer num) &#123; this.color = color; this.num = num; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Ball ball = (Ball) o; return Objects.equals(color, ball.color) &amp;&amp; Objects.equals(num, ball.num); &#125; @Override public int hashCode() &#123; return Objects.hash(color, num); &#125; @Override public String toString() &#123; return &quot;Ball&#123;&quot; + &quot;color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &quot;, num=&quot; + num + &#x27;&#125;&#x27;; &#125;&#125; 5. Map练习5.1 Map练习例61234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162一、利用Map，完成下面的功能：/*从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。如果该年没有举办世界杯，则输出：没有举办世界杯。*/import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Ex06 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //map.put(2023,null); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入年份:&quot;); //怼死 死去活来法 int year = scanner.nextInt(); String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg); scanner.close(); /*String team = map.get(year); if (team!=null)&#123; System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /*if (map.containsKey(year)) &#123; String team = map.get(year); System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /* String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg);*/ &#125;&#125; 例712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Scanner;/** * 二、在原有世界杯Map 的基础上， * 增加如下功能： * 读入一支球队的名字，输出该球队夺冠的年份列表。 * 例如， * 读入“巴西”，应当输出 1958 1962 1970 1994 2002 * 读入“荷兰”，应当输出 没有获得过世界杯 */public class Ex07 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //逆向思维 Map&lt;String, StringBuilder&gt; teamMap = new HashMap&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; //当前 队伍 map集合中 是否包含当前 队伍 if (teamMap.containsKey(name)) &#123; // 字符串 缓存中 添加新的年份 StringBuilder sb = teamMap.get(name); sb.append(year).append(&quot;\\t&quot;) ; &#125;else &#123; //如果不包含 直接存放当前年份 teamMap.put(name, new StringBuilder(year + &quot;\\t&quot;)); &#125; &#125;); // System.out.println(teamMap); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一支球队的名字:&quot;); //怼死 死去活来法 String year = scanner.next(); String msg = teamMap.getOrDefault(year, new StringBuilder(&quot;没有获得过世界杯&quot;)).toString(); System.out.println(msg); &#125;&#125; 123456789101112131415//另一种方法 String inputTeamName = scanner.next(); AtomicBoolean isPrint = new AtomicBoolean(true); map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; System.out.println(year); //System.exit(-1); isPrint.set(false); &#125; &#125;); if (isPrint.get()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; 123456789101112131415161718//第三种方法 String inputTeamName = scanner.next(); //存放 获得世界杯的年份集合 List&lt;Integer&gt; yearList = new ArrayList&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; yearList.add(year) ; &#125; &#125;); //集合为空 条件没有满足 if (yearList.isEmpty()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; yearList.forEach(System.out::println); 5.2 Map.Entry 5.3 Map综合案例1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * * 将以上对应关系的数据存储到map集合中，key：表示站编号，value：表示站名，并遍历打印(可以不按顺序打印)： * 例如： * 第10站: 森林公园南门 * 第6站: 育新 * 第12站: 奥体中心 * 第13站: 北土城 */public class EX &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); &#125;&#125; 例81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * *计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； */public class Ex08 &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); //站之间的数量 int money = caclMoney(13) ; System.out.println(&quot;共:&quot; + money); &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; Map&lt;Integer,Integer&gt; moneyMap = new HashMap&lt;&gt;() ; moneyMap.put(0,3) ; moneyMap.put(1,3) ; moneyMap.put(2,3) ; moneyMap.put(3,3) ; moneyMap.put(4,4) ; moneyMap.put(5,4) ; // .... moneyMap.put(0,3) ; moneyMap.put(0,3) ; return count ; /*if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ;*/ &#125;&#125; 例9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*计算地铁票价规则： 总行程 3站内（包含3站）收费3元， 3站以上但不超过5站（包含5站）的收费4元， 5站以上的，在4元的基础上，每多1站增加2元， 10元封顶；*/import java.util.ArrayList;import java.util.HashMap;import java.util.Map;public class Test09 &#123; public static void main(String[] args) &#123; ArrayList&lt;Num&gt; numList = new ArrayList(); Map map = new HashMap(); map.put(1,&quot;朱辛庄&quot;); map.put(2,&quot;育知路&quot;); map.put(3,&quot;平西府&quot;); map.put(4,&quot;回龙观东大街&quot;); map.put(5,&quot;霍营&quot;); map.put(6,&quot;育新&quot;); map.put(7,&quot;西小口&quot;); map.put(8,&quot;永泰庄&quot;); map.put(9,&quot;林萃桥&quot;); map.put(10,&quot;森林公园南门&quot;); map.put(11,&quot;奥林匹克公园&quot;); map.put(12,&quot;奥体中心&quot;); map.put(13,&quot;北土城&quot;); for (Object j : map.keySet())&#123; System.out.println(&quot;第&quot; +j +&quot;站: &quot; +map.get(j)); &#125; int i=1; numList.add(new Num(1,3)) ; numList.add(new Num(2,3)) ; numList.add(new Num(3,3)) ; numList.add(new Num(4,4)) ; numList.add(new Num(5,4)) ; numList.add(new Num(5+i,4+2*i)) ; /*numList.forEach((k,v)-&gt;&#123; if(k.equals()&lt;=3)&#123; System.out.println(k + &quot; &quot;); &#125; &#125;);*/ &#125;&#125;class Num&#123; int number ; int money; public int getMoney() &#123; return money; &#125; public int getNumber() &#123; return number; &#125; public Num(int number,int money) &#123; this.number = number; this.money = money; &#125; @Override public String toString() &#123; return &quot;homework.Num&#123;&quot; + &quot;number=&quot; + number + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 例1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * 打印格式（需要对键盘录入的上车站和到达站进行判断，如果没有该站，提示重新输入，直到站名存在为止）： 注意：每站需要2分钟 请输入上车站： 朱辛庄 请输入到达站： 西小口 从朱辛庄到西小口共经过6站收费6元，大约需要 12分钟； */public class Ex09 &#123; private static String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ; private static Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; public static void main(String[] args) &#123;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); String beginName = &quot;林萃桥&quot; ; String endName = &quot;平西府&quot;; int count = caclCount(beginName, endName); int time = count*2 ; //站之间的数量 int money = caclMoney(count) ; System.out.println(&quot;从&quot;+beginName+&quot;到&quot;+endName+&quot;共经过&quot;+count+&quot;站收费&quot;+money+&quot;元，大约需要 &quot;+time+&quot;分钟&quot;); &#125; /** * 根据 两站 站名 计算 之间 站之间的数量 * @param beginName * @param endName * @return */ private static int caclCount(String beginName,String endName)&#123; //map的 key站名 value 站序号 反转 Map&lt;String,Integer&gt; name2IndxMap = new HashMap&lt;&gt;() ; //站序号 站名 map.forEach((idx,name)-&gt; name2IndxMap.put(name,idx)); Integer beginIdx = name2IndxMap.get(beginName); Integer endIdx = name2IndxMap.get(endName); return Math.abs(beginIdx-endIdx) ; &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ; &#125;&#125; 6.Set扩展6.1 TreeSet 6.2 例11123456789101112131415161718192021222324252627/*学生类 姓名 分数 double 存放 TreeSet中 实现 根据 分数 从大到小 内部排序Comparable 外部排序 ComparatorSet&lt;Stu&gt; set = new TreeSet&lt;&gt;() ;set.add(new Stu(“aa”,98.5)) ;set.add(new Stu(“bb”,88.5)) ;*/package set;import java.util.*;public class Ex11 &#123; public static void main(String[] args) &#123; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; (int) (c1.getScore()-c2.getScore())) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; c1.getScore().compareTo(c2.getScore())) ;// Set&lt;Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparing(Customer::getScore)) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(set.Customer::getScore)) ; Set&lt;Customer&gt; set = new TreeSet&lt;&gt;() ; set.add(new Customer(&quot;小丽&quot;,500D)) ; set.add(new Customer(&quot;小红&quot;,400.8)) ; set.add(new Customer(&quot;小夏&quot;,400.3)) ; set.add(new Customer(&quot;小花&quot;,700D)) ; set.forEach(System.out::println); &#125;&#125; java8 外部排序写法： 1Set&lt;Stu&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(Stu::getAge)) ; 7. Collections7.1 辅助类 7.2 例1212345678910111213141516171819202122232425262728/* 1. List&lt;Stu&gt; Collections.sort(stuList) Comparable Collections.sort(stuList,...) Comparator 分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序， 如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。*/package collections;import set.Customer;import java.util.Arrays;import java.util.Collections;import java.util.List;public class Ex12 &#123; public static void main(String[] args) &#123; //集合中 存放 Customer List&lt;Customer&gt; customerList = Arrays.asList(new Customer(&quot;aaa&quot;,100D),new Customer(&quot;bbb&quot;,80.5D),new Customer(&quot;ccc&quot;,90D)) ; //jdk1.8 新特性 不使用辅助类 Collections //customerList.sort((c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); //使用 辅助类 Collections //Collections.sort(customerList); Collections.sort(customerList,(c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); customerList.forEach(System.out::println); &#125;&#125; 8. Map扩展8.1 LinkedHashSet 8.2 LinkedHashMap 8.3 ConcurrentHashMap 8.4 Properties 9.泛型扩展9.1 什么是泛型 9.2 泛型好处 9.3 使用前后对比 9.4 类型参数 9.5 方法参数 9.6 泛型不是协变的 9.7 类型通配符 9.8 泛型局限性","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java开发利器--idea安装过程详解","slug":"Java开发利器-idea安装过程详解","date":"2023-06-29T13:46:51.000Z","updated":"2023-07-03T05:31:41.850Z","comments":true,"path":"2023/06/29/Java开发利器-idea安装过程详解/","link":"","permalink":"http://example.com/2023/06/29/Java%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-idea%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"0. IDEA0.1 安装 0.2 配置破解11. 打开 readme.txt 安装步骤进行破解 JDK 字体 编码 0.3 运行创建项目 创建Java类 编写&#x2F;运行源代码 0.4 debug 0.5 卸载 删除安装目录：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"ES6及之后新特性一览","slug":"ES6及之后新特性一览","date":"2023-06-25T04:40:11.000Z","updated":"2023-07-01T08:40:14.329Z","comments":true,"path":"2023/06/25/ES6及之后新特性一览/","link":"","permalink":"http://example.com/2023/06/25/ES6%E5%8F%8A%E4%B9%8B%E5%90%8E%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/","excerpt":"","text":"let声明变量let 声明变量1.let 不允许重复声明变量 var 可以重复声明2.let 不支持变量的声明提升，var可以3.let声明的变量会被所有代码块（{}内的范围）限制作用范围 var只会受到函数影响4.let 声明的变量不和顶层变量挂钩 const 声明常量const 声明常量1.const 不可以重复声明2.不支持声明提升3.作用范围受{}影响4.不和最上层对象window挂钩const num &#x3D; 10;const num &#x3D; 20;&#x2F;&#x2F;Cannot redeclare block-scoped variable ‘num’if(true){ const a &#x3D; 20;}console.log(a); let和const区别1.let声明的变量可以被修改，const声明的是常量 不可以改变2.let声明时可以不赋值，const声明时必须赋值 变量的解构赋值解构赋值；就是快速的从对象或者数组中取出成员的一个语法方式 解构对象12345678const obj = &#123; name:&quot;zs&quot;, age:18, genders:&quot;男&quot;&#125;let name = obj.name;let age = obj.age;let genders = obj.genders; 123456789101112131415const obj2 = &#123; name:&quot;ls&quot;, age:18, genders:&quot;女&quot;&#125;//解构对象//前面的必须是&#123;&#125;表示要从obj2这个对象中获取对象成员//name age genders 都是obj2的现有成员//obj2必须是对象let&#123;name,age,genders&#125; = obj2;console.log(name,age,genders);let&#123;name:a,age:b,genders:c&#125; = obj2;console.log(a,b,c);let&#123;max,min,ceil,floor,random&#125;=Math;console.log(max(10,20,30)); 解构数组12345678//使用解构赋值的方式从数组中提取成员const arr2 = [&quot;一&quot;,&quot;二&quot;,&quot;三&quot;];//解构数组//a b c 分别对应这个数组中的索引下标0 1 2//arr2 必须是数组//如果解构失败，返回结果就是undefinedlet [a,b,c,d] = arr2;console.log(a,b,c,d); 模板字符串ES5中 表示字符串的时候使用’’或者””ES6中 还有一种可以表示字符串的方法 就是&#96;&#96;ES5 字符串 需要同行书写，换行后需要拼接字符串 12const str2 = &#x27;hello&#x27; +&#x27;world&#x27; ES6 可以直接换行使用 12const str3 = `hello world` &#96;&#96;的拼接方式与””不同 12console.log(&quot;我要&quot;+a+&quot;块钱&quot;)console.log(`我要$&#123;a&#125;块钱`) 字符串与数值拓展字符串12345678910111213let &#123;log&#125; = console;let str = &quot;Tom&quot;;//判断字符串中是否存在指定字符 返回true或者falselet res = str.includes(&quot;opm&quot;);//判断字符串中以指定字符开头 返回true或者falseres = str.startsWith(&quot;p&quot;)//判断字符串中以指定字符结尾 返回true或者falseres = str.endsWith(&quot;m&quot;)//repeat() 将字符串重复N次，返回一个新的字符串res = str.repeat(3)//TomTomTomres = str.repeat(2.5)//TomTomres = str.repeat(0)//&quot;&quot;log(res); 数值12345678910111213141516171819202122232425262728let&#123;log&#125; = console;//Number.isFinite() 判断被传入的内容是否为有限数值let res = Number.isFinite(100);//trueres = Number.isFinite(100/0);//falseres = Number.isFinite(Infinity);//falseres = Number.isFinite(NaN);//falseres = Number.isFinite(&quot;100&quot;)//false//Number.isInteger() 判断被传入的内容是否为整数res = Number.isInteger(100);//trueres = Number.isInteger(100.0);//trueres = Number.isInteger(100.1);//falseres = Number.isInteger(&quot;Tom&quot;);//falseres = Number.isInteger(&quot;100&quot;)//false//Math.trunc() 将括号内的参数转化为数字再去掉小数点res = Math.trunc(1.2);//1res = Math.trunc(1.8);//1res = Math.trunc(-1.8);//-1res = Math.trunc(&quot;Tom&quot;);//NaNres = Math.trunc(&quot;10.2&quot;);//10//Math.sign() 判断括号内的数是正数负数还是0res = Math.sign(200);//1res = Math.sign(-200);//-1res = Math.sign(0);//0res = Math.sign(-0);//-0res = Math.sign(&quot;asld&quot;);//NaN 数组拓展12345678910111213//...扩展运算符: let arr = [1,2,3]; let arr2 = [4,5,6]; let res =[...arr,...arr2]; console.log(res);//1，2，3，4，5，6function test()&#123; //arguments 是函数参数的集合 是个伪数组 console.log(arguments); //Array.from() 将 伪数组 转换为 真实数组 res = Array.from(arguments); console.log(res);&#125;test(1,2,3) document.querySelectorAll() 通过选择器获取所有相关元素 返回的是NodeList 伪数组document.querySelector() 通过选择器获取首个相关元素 直接返回元素对象find() 主要用于查找一个符合条件的数组元素findIndex() 主要用于查找一个符合条件的数组元素的下标它的参数是一个回调函数 在回调函数中可以制定寻找元素的条件当条件成立为true时间。返回该元素，如果没有符合的条件，返回undefined 123456let arr3 = [11,22,33,44,55]res = arr3.find(function(item)&#123;//item 表示数组内的每一个成员 return item&gt;20; console.log(item);&#125;)console.log(lis); fill() 使用括号内的参数，直接在数组内填充数据（替换和添加）第一个参数 是替换的新value值第二个参数 是替换的起始坐标第三个参数 是替换的结束坐标 123let arr5 = [1,&quot;纯爱&quot;,&quot;纯爱&quot;];arr5.fill(&quot;牛头人&quot;,1,2);console.log(arr5); 对象拓展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; let name = &quot;张三&quot; let obj = &#123; name:name, fn:function()&#123;&#125; &#125; console.log(obj) //如果对象的属性和value的变量相同，就可以只写一个属性名 let obj2 = &#123; name, //name:name getMessage()&#123;&#125;, getList()&#123;&#125; &#125; console.log(obj2) let msg = &quot;class&quot;; //对象的属性名可以使用表达式 需要用到符号 [表达式] let obj3 = &#123; [msg+&quot;one&quot;]:&quot;Tom&quot;, [`$&#123;msg&#125;xxx`]()&#123;&#125; &#125; console.log(obj3) let obj4 = &#123; name:&quot;jerry&quot;, age:14 &#125; //对象内可以使用拓展运算符 let obj5 = &#123; ...obj4//相当于通过for in遍历，属于深拷贝 &#125; console.log(obj5) //Object.assign() 将需要操作的元素复制到目标对象中 //第一个参数 目标参数 //第二个参数及后面所有额参数都是 需要操作的对象 //如果复制的数据是 值类型数据 实现的是深拷贝 //如果复制的数据是 引用类型数据 使用的任然是该数据的指针(引用地址)，实现的是浅拷贝(重点) let obj6 = &#123;&#125;; let obj7 = &#123; name:&quot;ggBANG&quot;,//值类型深拷贝 friends:[&quot;小A&quot;]//引用类型浅拷贝 &#125; Object.assign(obj6,obj7); obj6.age = 20; obj6.friends = &quot;小王&quot;; console.log(obj6) console.log(obj7)&lt;/script&gt; 函数拓展1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; function fn()&#123;&#125; let fn2 = function()&#123;&#125; // =&gt; const fn3 = (a,b) =&gt;&#123; console.log(a+b) &#125; fn3(1,2) // xxx.onclick = ()=&gt;&#123;&#125; // setInterval(()=&gt;&#123;&#125;) //传入一个参数a, 并且a为函数的返回值 //只有一个参数的情况下 小括号可以省略 //函数内 只有一行需要执行的代码的时候 花括号可以省略 const fn4 = a =&gt;a; fn4(10) //箭头函数制定参数默认值 const fn5 = (a=20,b=50) =&gt;&#123; console.log(a,b); &#125; fn5() let div = document.querySelector(&#x27;div&#x27;); //函数区别 //1.箭头函数的this指向 函数的声明处 //2.箭头函数中无法使用arguments //3.箭头函数不可以作为构造函数 使用 div.onclick= () =&gt;&#123; console.log(this); &#125; // const fn6 = () =&gt;&#123; // console.log(arguments); // &#125; // fn6(1,2,3) const Tom = () =&gt;&#123; console.log(&quot;123&quot;); &#125; new Tom() &lt;/script&gt; SymbolSymbol：表示独一无二的值 1234567891011121314151617var names = Symbol();console.log(names);//使用symbol 当作对象名var obj = &#123; [names]:&quot;Tom&quot;&#125;console.log(obj);//Symbol 函数可以接收一个字符串作为字符串，表示堆Symbol实例的描述//主要是为了在控制台上显示，比较容易区分const ages = Symbol(&quot;age&quot;)console.log(ages)var obj2 = &#123; [ages]:18, [names]:&quot;Tom&quot;&#125;//获取带有Symbol格式的属性console.log(obj2[ages]);//不要加.了 Reflect 是一个内置对象的反射机制，用来提供方法 拦截js的操作Reflect.ownKeys(obj)返回一个数组forEach（）实现遍历的方法 123Reflect.ownKeys(obj).forEach(function(item)&#123; console.log(item);&#125;) Iterator接口Iterator接口的作用为各种数据结构，提供一个统一的，简单的访问接口使数组格式的成员能够按照某种次序排列es6创造了一种新的遍历命令 for of 循环， Iterator接口主要供for…of循环Iterator接口遍历的过程创建一个指针对象，指向当前数据结构的起始位置,第一次调用指针对象的next方法，可以将指针指向该数据结构的第一个成员第二次调用指针对象的next方法，指针就指向该数据结构的第二个成员不断调用指针对象的next方法，直到他指向数据结构的结束位置 1234let item = arr[Symbol.iterator]();console.log(item);console.log(item.next());console.log(item.next()); ES6规定，默认的Iterator接口部署在数据结构[Symbol.iterator]属性或者说 只要有 数据结构 具备Symbol.iterator属性 就认为是可遍历的Symbol.iterator属性本身就是一个函数，就是当前数据结构默认的遍历器生成函数执行这个函数就会返回一个遍历器原生默认具备 iterator 接口的数据结构如下:Array Set Map String arguments NodeList Set数据结构Set类似于数组，成员的值是唯一的，没有重复的值Set.size() 返回Set实例的成员总数Set.add() 添加Set成员Set.delete()删除Set成员Set.has() 查看括号内的成员是否在Set中存在 返回布尔类型 1234567let s1 = new Set([1,2,3,4]);console.log(s1);let s2 = new Set();s2.add(&#x27;hello&#x27;);s2.add(&#x27;world&#x27;);s2.delete(&quot;world&quot;);s2.clear(); Set遍历Set.keys() 返回键名的遍历器Set.values() 返回键值的遍历器Set.entries() 返回键值对的遍历器 123456789let result =s2.keys();console.log(result); result =s2.values();console.log(result); result =s2.entries(); console.log(result); s1.forEach(function(item)&#123; console.log(item);&#125;) 数组去重方法一： 123456let arr = [19,20,19,19,20,21,30,90];let s1 = new Set(arr);console.log(s1);//输出的是一个对象//需要转换为数组的话s1 = Array.from(s1);//使用Array.from() 转换成数组console.log(s1); 方法二： 12let s2 = [...new Set(arr)];//...扩展运算符console.log(s2); Map12345678910111213141516171819202122232425&lt;script&gt; //Map 类型对象 键值对的集合，但是Map中的key不限于字符串，可以是各种类型的值 let M1 = new Map(); M1.set(&#x27;name&#x27;,&#x27;tom&#x27;); M1.set(&#123;a:1&#125;,&#x27;tom&#x27;); M1.set(&#x27;big&#x27;,&#x27;small&#x27;); //操作方法 //Map.set(key.value); 在Map对象中添加key和对应的value //Map.get(key); 在Map对象中获取key对象的value //Map.delete(key); 删除指定的key //Map.has(key); 查看key是否在map中存在 返回布尔类型 //Map.clear(); 清空 console.log(M1); console.log(M1.get(&quot;name&quot;)); M1.delete(&quot;name&quot;); console.log(M1); let res = M1.has(&#x27;big&#x27;); console.log(res); //Map遍历方法 与 Set相同 res = M1.keys() res = M1.values() res = M1.entries() console.log(M1); console.log(res);&lt;/script&gt; ProxyObject.defineProperty() 拦截并处理数据第一个参数 需要拦截处理的对象第二个对象 对象内的属性第三个对象 {}配置项，格式是个对象 1234567891011121314151617181920let obj = &#123; data: 111, name:&quot;zs&quot;, age:20 &#125;let box = document.getElementById(&quot;box&quot;)Object.defineProperty(obj, &quot;data&quot;, &#123; get() &#123;// 当使用对象内的指定属性时调用 console.log(&quot;get函数调用&quot;); &#125;, set(value)&#123; console.log(&quot;set函数接收到了:&quot;,value); if(value&gt;=1000)&#123; box.innerHTML =`数据较大,请重新输入`; &#125; else&#123; box.innerHTML = `数据合理放心使用`; &#125; &#125;&#125;) Proxy代理: 123456789101112131415let proxy = new Proxy(obj,&#123; get(target,key)&#123; //target 表示 需要代理的对象 //key 表示的是访问的属性 console.log(target,key); return target[key]; &#125;, set(target,key,value)&#123; //target 表示 需要代理的对象 //key 表示的是设置的属性 //value 设置的新值 console.log(&quot;set:&quot;,target,key,value); target[key] = value//确认操作 &#125;&#125;) ReflectReflect 主要用来获取目标对象的行为,它与Object类似，但更容易读 Promise对象回调地狱当一个回调函数嵌套另一个回调函数的时候就会出现嵌套结构当嵌套结构多的时候，就会出现回调地狱的情况回调地狱 其实就是由多个回调函数互相嵌套导致的，代码维护性非常差 同步异步异步 当一行代码还没有执行结束，就可以去执行另一行代码的顺序 叫做异步同步 当代码逐行执行过程就是同步的过程异步的操作：定时器 callbackpromise 是异步编程的一种统一的解决方案，比传统回调函数，更合理更强大 1234567891011121314151617const api = new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; if(true)&#123; resolve()//resolve 表示成功的回调函数 &#125; else&#123; reject()//reject 表示失败的回调函数 &#125; &#125;,1000)&#125;)api.then(()=&gt;&#123; console.log(&quot;yyyyy&quot;);//.then() 成功&#125;).catch(()=&gt;&#123; console.log(&quot;nnnnn&quot;);//.catch() 失败&#125;) Promise 对象通过自身的状态，来控制异步操作。Promise实例具有三种状态异步操作未完成(pending)异步操作完成(fulfilled)异步操作失败(rejected) 链式调用为什么promise可以实现链式调用因为当promise方法执行结束后仍然会返回一个promise对象 123456789101112131415const a = promise.then((res) =&gt; &#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 2000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 3000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 5000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;);&#125;).catch((err)=&gt;&#123; console.log(&quot;失败啦&quot;,err);&#125;)console.log(a) all方法Promise.all() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态都是fulfilled pAll的状态才是 fulfilled此时P1,P2,P3的返回值组成一个数组，传递给pAll中 race方法Promise.race() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态只要有一个fulfilled pRace的状态才是 fulfilled此时返回值是首次达到fulfilled状态的值除非全部reject否则不会触发.catch Generator函数ES6 提供的一种异步编程解决方案 123456789101112function *gen()&#123; console.log(1); yield;//yield 表示暂停执行标记，通过next方法恢复执行 console.log(2); yield; console.log(3);&#125;let g = gen()//next() 驱动下一步的执行g.next()g.next()g.next()console.log(g); Class语法与继承123456789101112131415class Person&#123;//创建一个Person类 也叫做 构造函数 //类中的属性需要使用constructor 构造器创建 constructor(name,age,height)&#123; this.name = name; this.age = age; this.height = height; &#125; // 在类中创造方法 say()&#123; console.log(&quot;这是Person类&quot;); &#125;&#125;let obj = new Person(&quot;zhangsan&quot;,19,&quot;180cm&quot;);console.log(obj);obj.say() class继承 123456789101112131415161718192021222324class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(&quot;这是&quot;,this.name,this.age,&quot;岁&quot;); &#125;&#125;const one = new Person(&quot;张飞&quot;,100);one.say();class Student extends Person&#123;//extends 表示StudentPerson类中继承 constructor(name,age,height)&#123; super(name,age);//super() 表示从父类中继承的属性内容 必须写在 construtor中 this.height = height; &#125; say()&#123; super.say(); console.log(&quot;是学生&quot;) &#125;&#125;let obj = new Student(&#x27;xz&#x27;,12,&#x27;120&#x27;);console.log(obj);obj.say();","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"Javascript 基础知识","slug":"Javascript-基础知识","date":"2023-06-12T05:11:08.000Z","updated":"2023-07-01T08:40:11.753Z","comments":true,"path":"2023/06/12/Javascript-基础知识/","link":"","permalink":"http://example.com/2023/06/12/Javascript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 JavaScrip简介JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。JavaScript 很容易学习。 ECMAScript 语法标准(es)JavaScript 输出JavaScript 可以通过不同的方式来输出数据：使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 外部的 JavaScript也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。 外部 JavaScript 文件的文件扩展名是 .js。 1&lt;script src=&quot;./01.js&quot;&gt;&lt;/script&gt; 变量1var a = 20; var 申明变量名a 变量名 用来存储变量20 变量&#x3D; 赋值符号 从右向左赋值 变量命名规则：1.可以是字母或者下划线_或者$开头2.长度不可超过255个字符3.名中不能含有空格，首字头不能是数字4.严格区分大小5.不能使用关键字或保留字6.汉字可使用不推荐当使用空的变量名时，得到的结果就是未定义 undefined使用不存在的变量名时，报错，d is not defined变量的声明提升:先使用变量再创建变量 得到的结果会是 undefined 只能提升变量名，不提升变量 12console.log(e);var e = 30; 相当于 123var e;console.log(e);var e = 30; 数据类型与转换基本数据类型:number 数字string 字符串 只要有引号包裹就是字符串boolean 布尔 true&#x2F;false将数据类型转化为number类型强制类型转换:Number（） 将数据类型转换成number转换字母等非数字内容的话会显示NaN (No a Number)parseFloat() 浮点型 将数据保留小数 并且转换为数字类型转换带数字的字符串时，必须开头为数字才能识别parseInt() 整型 将数据保留整数，并转换成数字类型isNaN()：判断内容是否是 非数字 如果是非数字 返回 true 反之为 false只查看数据内容，不查看数据类型数据类型转换为字符串强制类型转换String() 将数据类型转换为字符串xxx.toString() 将数据类型转换为字符串 需要转化的变量名写在前面将数据类型转换为布尔Boolean()0为false，其他为true值类型:number 数字string 字符串boolean 布尔null 空undefined未定义symbol 独一无二的引用数据类型：object 对象function函数array 数组tpyeof(undefined)&#x3D; undefined;tpyeof(null)&#x3D; object;tpyeof(error)&#x3D; object; 算数运算符+ 加法当符号两边都是数字的时候，会自动相加求和当符号两边有字符串时，会起到拼接字符串的作用（结果时字符串类型–隐式类型转换）当符号两边有布尔类型时，true为1，false为0 参与求和计算++ 自增加1++在后面 表示后加，处于正在加1的过程，还没加上，当再次使用变量时，才算自增结束++在前面 表示先加，直接自增结束，得到就是自增+1的结果- 减法当符号两边都是数字的时候，会自动相减求差当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算– 自减1，同自增* 乘法当符号两边都是数字的时候，会自动相乘求积当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算&#x2F; 除法当符号两边都是数字的时候，会自动相除求商当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算除数如果是0 得到的是 Infinity 无穷&#x2F;无限% 除余()优先运算符 比较运算符注意：&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D; 的不同&#x3D;&#x3D; 等号(只比较值，不比较数据类型)&#x3D;&#x3D;&#x3D; 全等号（值和数据类型都相同）&gt; 大于号&gt;&#x3D; 大于等于&lt; 小于&lt;&#x3D; 小于等于!&#x3D; 不等于!&#x3D;&#x3D; 不全等于 逻辑运算符&amp;&amp; 与 符号两边的表达都为true整个表达式的结果就是true 有一方为false，整个表达式的结果就是false|| 或 有一方为true，整个表达式的结果就是true！ 非 对象与事件实例化对象：var obj&#x3D;new Object();键值对（属性：属性值）obj.name&#x3D;”zs”;&#x2F;&#x2F;键值对就是XX&#x3D;XX字面量的方式创建对象: 12345var obj2 = &#123; name:&quot;1s&quot;, age:20, height:172&#125; 日期对象var&#x3D; new Date();date.getFullYear();获取当前年份getMonth 获取当前月份getDate日期getDay星期getHours小时getMinutes分钟getSeconds当前秒getMilliseconds 当前毫秒getTime从1970.1.1至今的毫秒数Math对象Math.max 返回最大数Math.min 返回最小数Math.ceil 天花板函数，有小数部分向上取整Math.floor 地板函数 舍掉小数部分Math.round(b) 四舍五入Math.random() 随机数字0-1 取不到1事件on绑定事件的关键字 click 点击事件box.onclick&#x3D;function(){}onblur 失去焦点 if else略 switchswitch 用来监视链路，捕获数据某种情况下需要执行的代码块switch 具有数据穿透性 需要break中断余下代码的执行default 相当于else 123456789101112switch(n)&#123; case 10: XXXX; break; case 20: XXXX; break; default: XXXX; break;&#125; 第二种情况：switch(true) 12345switch(true)&#123; case n&lt;10&amp;&amp;n&gt;=0: console.log(&quot;switch范围监测&quot;) break;&#125; 三目运算符表达式？ 结果1(true):结果2(false) 1a&gt;b ? console.log(&quot;a大&quot;):console.log(&quot;b大&quot;); for循环for循环执行顺序：for 首次执行 先创造变量 再判断条件 不走增量 直接执行代码块剩下的执行次数都是 先增量再判断 最后走代码块如果 变量不满足判断条件 循环结束for(初始化变量;判断条件；增量){重复执行代码块}break： 终止循环 终止整个循环体 余下代码不执行continue： 终止循环 终止当前次数的循环，余下代码不执行 while循环与do while循环1234while(i&lt;10)&#123; console.log(i); i++;&#125; 1234do &#123; i++; console.log(i); &#125; while (i &lt; 10) while 和 do while的区别while循环是 先判断再执行do while 循环 是先执行再判断 数组和数组api123456789101112131415161718192021222324252627282930313233var arr = new Array();//实例化数组// 数组内数据的序号 我们叫做下标（索引号）arr[0]=&quot;李白&quot;;arr[1]=&quot;白居易&quot;;console.log(arr);// 字面量的方式创建数组var arr2 = [&quot;ls&quot;,&quot;zs&quot;,123,false];console.log(arr2);// 数组的使用方式 数组名[下标]console.log(arr2[2]);// 数组名.length 数组内成员的个数console.log(arr2.length);//二维数组var arr4 = [1,3,4,[1,2,3]];console.log(arr4[3][1]);//多维数组var arr5 =[&#123; name:&quot;zs&quot;, age:18, friends:[&#x27;ls&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;ls&quot;, age:20, friends:[&#x27;zs&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;wr&quot;, age:22, friends:[&#x27;ls&#x27;,&#x27;zs&#x27;]&#125;] 数组的操作方法1.数组.includes() 查看数组内是否包含指定成员，如果是就返回true,如果不包含就返回false 2.Array.isArray() 判断是否是一个数组格式 返回 true 或 false 3.数组.indexOf() 查看数组内的成员，如果存在就返回首次出现的下标，如果不存在就返回-14.数组.lastIndexOf() 查看数组内的成员，如果存在就返回最后一次出现的下标，如果不存在就返回-15.数组.join() 在数组各元素之间插入相同的字符串拼接，将数组转换成字符串6.数组.push() 在原数组末尾添加新成员，返回新数组长度，原数组被改变7.数组.unshift() 在数组开头添加新成员，返回新数组长度，原数组被改变8.数组.pop() 删除数组最后一名成员，返回被删除内容，原数组被改变9.数组.shift() 删除数组开头的成员，返回被删除内容，原数组被改变 10.数组.reverse() 反转数据11.数组.splice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组改变当括号内有两个参数的时候，表示从当前下标开始一直截取到几个，返回被截取的内容，原数组改变当括号内有三个参数的时候，第三个参数表示在截取位置添加的新内容，返回被截取的内容，原数组改变12.数组.slice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组不改变当括号内有两个参数的时候，表示从当前下标开始到第二个参数下标结束，返回被截取的内容，原数组不改变var res &#x3D;arr.includes(“奥斯”); 字符串API字符串.length 获取字符串的长度字符串.split() 字符串转换成数组，根据括号的内容进行字符分割字符串.charAt() 返回指定下标处的字符字符串.indexOf() 返回查找首次出现字符的下标，如果不存在返回-1字符串.lastIndexOf() 返回查找最后一次出现字符的下标，如果不存在返回-1字符串.substr() 截取字符串 如果有一个参数 表示从当前下标开始截取到末尾 返回截取的内容如果有两个参数，表示从当前下标开始截取几个 返回截取的内容 函数匿名函数： 自调用 通过事件绑定在一起触发具名函数： function . 函数名()函数特性：不调用，不执行函数的使用叫做调用函数具有 预加载(函数的位置在定义先后不影响执行)具名函数的调用 函数名()return 返回值（余下代码不执行）function 函数名（形式参数）{}var a &#x3D; 函数名（实际参数）；封装函数 全局变量与局部变量变量是存在作用域的 分为 全局变量和局部变量局部变量： 在函数内部用var声明的变量就是局部变量（只在函数内部生效）全局变量：在函数外部用var声明的变量就是全局变量，可以在整个JS中生效不用var声明的，变量也是全局变量（不推荐使用）闭包：闭包的形式：多个函数互相嵌套闭包的目的：将内部函数的局部变量提到全局中去使用闭包的实现方式：不断地设置return 返回值闭包的缺点：会消耗电脑内存 影响性能 DOMdocument object model 文档对象模型 定时器1234567891011// setInterval(callback) 多次执行的定时器 callback参数 表示 回调函数start.onclick = function () &#123; timer = setInterval( function () &#123; console.log(1); &#125;, 1000) &#125; stop.onclick = function () &#123;// clearInterval(定时器的名字) 清除定时器 clearInterval(timer);&#125; thisthis 表示 这个this 在函数中 代指函数的调用者this在函数外 指向的是window对象，最大的对象 12345678910111213141516var lis = document.getElementsByTagName(&quot;li&quot;)console.log(this);for (var i = 0; i &lt; lis.length; i++)&#123; //属性绑定 写在循环的内部，事件的外部 // index 一般表示为下标 lis[i].index = i; lis[i].onclick = function() &#123; //先让所有颜色都变成蓝色 再让当前的这个变成红色 //这就是排他思想 for (var j = 0; j &lt; lis.length; j++)&#123; lis[j].style.background = &quot;skyblue&quot;; &#125; this.style.background = &quot;red&quot;; console.log(this.index);//获取到下标 &#125;&#125; 轮播图参考https://swiper.com.cn/ Node节点操作1.xx.parentNode 当前节点的父节点2.xx.childNodes 当前节点的所有子节点,包含文本节点(本次返回的text为回车造成的空格) 返回nodeList 伪数组3.xx.children 当前节点的所有子元素节点 返回HTMLCollection 伪数组4.xx.firstChild 当前节点的第一个子节点,包含文本节点5.xx.firstElementChild 当前节点的第一个子元素节点6.xx.lastChild 当前节点的最后一个子节点,包含文本节点7.xx.lastElementChild 当前节点的最后一个子元素节点8.xx.previousSibling 当前节点的前一个兄弟节点,包含文本节点9.xx.previousElementSibling 当前节点的前一个兄弟元素节点10.xx.nextSibling 当前节点的前一个兄弟节点,包含文本节点11.xx.nextElementSibling 当前节点的前一个兄弟元素节点节点的操作1.document.createElement() 创建节点2.xx.innerHTML 往节点内添加或替换内容(文本或标签)2.xx.innerText 往节点内添加或替换内容(文本)4.xx.appendChild() 往父节点的末尾添加新节点5.xx.insertBefore(新节点,目标节点) 将新节点添加到目标节点之前6.xx.cloneNode() 克隆节点,true的时候,将该节点及其子节点全部复制；flase的时候只复制节点本身。7.父节点.removeChild() 删除父节点的子节点 偏移量offsetWidth 元素自身的宽度 width+border+paddingoffsetHeight 元素自身的高度 同上offsetLeft 元素自身的位置offsetTop 元素自身的位置onscroll 滚动事件scroll卷曲的距离clientWidth可视区域的宽 width paddingclientWidth可视区域的宽 height padding document.body;&#x2F;&#x2F;获取body 标签document.documentElement&#x2F;&#x2F;获取html标签 事件对象event 事件对象 通过事件触发的时候调用函数内的参数该对象内包含了事件触发时的信息事件对象的兼容写法： 1var e = event || window.event;//兼容低版本ie浏览器 pageX 光标相对于网页的水平位置（ie无）*pageY 光标相对于网页的垂直位置（ie无）*screenX 光标相对于屏幕的水平位置screenY 光标相对于屏幕的垂直位置clientX 光标相对于可视区域的水平位置*clientY 光标相对于可视区域的垂直位置（重要且相同）xx.onkeypress 键盘按键 按下并且弹起xx.keyCode 表示键盘上对应按键的编码xx.onmouseenter 鼠标进入xx.onmouseleave 鼠标离开 事件冒泡和事件句柄事件冒泡：当一个元素的事件被触发的时候,比如鼠标点击了一个元素，同样的事件就会在这个元素的所有祖先元素上被触发这个过程就叫做事件冒泡,这个事件是从原始事件一直冒泡到dom树的最上层.不支持事件冒泡的事件: focus,blur,mouseenter,mouseleave,load,resize 12//阻止事件冒泡的兼容写法e.stopPropagation ? e.stopPropagation() :e.cancelBubble = true; 事件句柄:addEventLister 添加事件句柄第一个参数 事件的名称第二个参数 callback 回调函数第三个参数 false 触发的顺序是由内到外，叫做冒泡的顺序（默认）； true 触发的顺序是由外到内，叫做捕获的顺序同一个元素可以绑定多个相同事件，不会覆盖，挨个执行 123box.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;222&quot;); &#125;,true) 缓存注意：cookie localStorage sessionStorage的区别cookie 默认浏览器关闭时消失，存在于web服务器中，存储大小为4KBlocalStorage 本地储存 永久有效，除非手动删除，存储大小为5MBsessionStorage 会话存储 关闭浏览器或窗口事就消失，存储大小为5MBcookie缓存： 123456document.cookie=&quot;username = 李白&quot;//创建cookie缓存document.cookie=&quot;age = 30; expires = Tue, 20 Jun 2023 12:00:00 GMT&quot;//设置过期事件var res =document.cookie;var n = res.indexOf(&quot;=&quot;) +1 ;res = res.substr(n);console.log(res); localStorage缓存： 123456localStorage.setItem(&quot;NAME&quot;,&quot;TOM&quot;);//创建缓存 localStorage.setItem（key,value） localStorage.setItem(&quot;AGE&quot;,&quot;18&quot;);localStorage.removeItem(&quot;AGE&quot;);//删除指定缓存 localStorage.removeItem(key)var res = localStorage.getItem(&quot;NAME&quot;);//获取缓存 localStorage.getItem(key) var age = localStorage.getItem(&quot;AGE&quot;);localStorage.clear();//清空缓存 localStorage.clear() BOMbrowser object model 浏览器对象模型 Window对象window.open(“https://www.baidu.com&quot;//在当前窗口跳转window.close();&#x2F;&#x2F;关闭窗口 locationlocation.hostname web主机域名location.pathname 当前页面的路径location.port 端口号(0-65535)location.herf 整个URLlocation.protocol web协议常见的协议:http 和 https 的区别*http 免费 相对不安全，端口号默认80https 收费 比较安全，端口号默认443 secureftpfile history两种后退功能：history.back(); history.go(-1);两种前进功能：history.go(); history.go(1); navigatornavigator 设备信息对象navigator.appCodeName 浏览器代号navigator.appName 浏览器名称navigator.appVersion 浏览器版本navigator.vender 浏览器供应商navigator.cookieEnabled 浏览器是否启用了缓存navigator.platform 硬件平台navigator.userAgent 用户代理语言navigator.language 用户代理语言 正则表达式 实例化创建正则对象 1var reg = new RegExp(); &#x2F;&#x2F;字面量方式创造正则对象reg &#x3D; &#x2F;@&#x2F;; 含有@reg &#x3D; &#x2F;\\d&#x2F; 含有数字reg &#x3D; &#x2F;\\D&#x2F; 含有非数字reg &#x3D; &#x2F;\\s&#x2F; 含有不可见字符(空格，回车等)reg &#x3D; &#x2F;\\S&#x2F; 含有可见字符reg &#x3D; &#x2F;\\w&#x2F; 含有单词字符 字母 数字reg &#x3D; &#x2F;\\W&#x2F; 含有非单词字符 简单类reg &#x3D; &#x2F;[23]&#x2F; 含有2或者3负向类reg &#x3D; &#x2F;[^23]&#x2F; 含有非2或者3范围类reg.onblur &#x3D; &#x2F;[0-9]&#x2F; 含有0-9中的任意一个组合类reg &#x3D; &#x2F;[0-9a-z]&#x2F; 含有数字或者字母中的一个边界reg &#x3D; &#x2F;^12&#x2F; 必须以12开头reg &#x3D; &#x2F;23$&#x2F; 必须以23结束reg &#x3D; &#x2F;^123$&#x2F; 必须是123&#x2F;&#x2F;量词reg&#x3D; &#x2F;^123*$&#x2F; ‘3’的重复次数&gt;&#x3D;0次reg&#x3D; &#x2F;^123+$&#x2F; ‘3’的重复次数&gt;&#x3D;1次reg&#x3D; &#x2F;^123?$&#x2F; ‘3’的重复次数只能是0或1次reg&#x3D; &#x2F;^12{4}3$&#x2F; ‘2’的重复次数4次reg&#x3D; &#x2F;^12{4,}3$&#x2F; ‘2’的重复次数&gt;&#x3D;4次reg&#x3D; &#x2F;^12{4,10}3$&#x2F; ‘2’的重复次数4到10次 正则.test(需要校验的内容) 返回布尔类型 1var res = reg.test(inp.value); 高级JS(面向对象)值类型与引导类型值类型 ：number string boolean null undef symbol引用数据类型： array function object 值类型与引用数据类型的区别值类型 ：存储在栈中，内存空间固定当数据复制的时候，可以直接复制互不影响typeof 判断数据类型引用数据类型：存储在堆中，内存空间不固定浅拷贝：当数据复制的时候，只能复制数据的引用地址深拷贝：将数据复制并在堆中重新申请一片空间进行存储深拷贝实现的两种方式： 12var obj2 = JSON.stringify(obj);//对象 =&gt; string 将对象转换成json字符串var obj2 = JSON.parse(obj2);//string =&gt; 对象 将json字符串转换成对象 通过instanceof() 判断数据是哪一种引用类型（返回true&#x2F;false） 1var res = arr instanceof(Arry); 工厂模式和构造函数面向对象编程的基本特征封装： 将客观事物封装成抽象的类继承： 子类具有父类的公有属性多态： 对象的多功能，多方法，一个方法可以有多种表现形式字面量创建对象 创建量如果比较多就比较繁琐，并且对象之间没有关系 12345678var personOne = &#123; name:&quot;zs&quot;, age:20&#125;var personTwo = &#123; name:&quot;ls&quot;, age:24&#125; 通过封装的方式创建对象，解决代码重复的问题 123456function createPerson(name,age)&#123; return&#123; name:name, age:age &#125; &#125; 工厂模式 12345678function createPerson(name,age)&#123; var obj =new Object();//准备工厂环境 obj.name = name;//将属性进行加工 obj.age = age;//将属性进行加工 return obj;//将加工好的对象进行输出&#125;personOne = createPerson(&quot;王二&quot;,10);personTwo = createPerson(&quot;zy&quot;,30); 构造函数 12345678function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;var personOne = new CreatePerson(&quot;张三丰&quot;,&quot;108&quot;)var personTwo = new CreatePerson(&quot;孙悟空&quot;,&quot;正无穷&quot;)console.log(personOne);console.log(personTwo); 构造函数需要注意的事情：1.CreatePerson 称之为 构造函数 也叫做 类，构造函数就是类2.personOne 就是 CreatePerson 的实例对象3.构造函数中的this指向的是通过new实例化出来的4.必须使用new关键字 将函数实例化5.构造函数的开头必须大写6.构造函数会自动创造出来一个 constructor(构造器)属性，这是属性就是指向CreatePerson prototype原型属性，存在于每个构造函数之中通过prototype原型创建的方法可以在构造函数生成的实例中公用，有利于提升效率prototype 的顶端 是 object 123456789 function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;CreatePerson.prototype.say = function()&#123; console.log(&quot;yyy&quot;); return 0;&#125;var one = new CreatePerson(&quot;zs&quot;,20); 对象继承12345678910111213141516171819202122232425function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.run=function()&#123; console.log(&quot;啊啊啊啊啊&quot;);&#125;Person.prototype.findWork=function()&#123; console.log(&quot;working&quot;);&#125;function Man()&#123; console.log(&quot;nnnnn&quot;);&#125;//看似赋值的过程 =&gt; 实际上实现的是浅拷贝// Man.prototype = Person.prototype; //for in 循环（用来遍历对象）for(var k in Person.prototype)&#123; console.log(k);//k是对象的属性 Man.prototype[k] = Person.prototype[k]&#125;Man.prototype.jump = function()&#123; console.log(&quot;hhhhhhhhhhh&quot;); &#125;console.log(Man.prototype);console.log(Person.prototype); 多态多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态的实现方式：覆盖指子类重新定义父类方法，基于prototype继承就是。 call和apply和bind12345678910111213141516171819 //thiswindow.color = &quot;red&quot;;document.color = &quot;green&quot;;// console.log(window);var obj = &#123; color:&quot;white&quot;&#125;function changeColor(a,b)&#123; console.log(a+&quot;和&quot;+b+&quot;喜欢&quot;+this.color)&#125;//函数.call(this需要指向的对象，参数必须使用逗号分隔)changeColor(&quot;小王&quot;,&quot;小明&quot;);changeColor.call(document,&quot;小王&quot;,&quot;小明&quot;);changeColor.call(obj,&quot;小王&quot;,&quot;小明&quot;);//函数.apply(this需要指向的对象，参数必须使用数组)changeColor.apply(document,[&quot;小王&quot;,&quot;小明&quot;]);changeColor.apply(obj,[&quot;小王&quot;,&quot;小明&quot;]);//函数名.bind(this需要指向的对象，参数可以是任意形式)() 返回的是函数需要再次调用changeColor.bind(obj,[&quot;小李&quot;],[&quot;zs&quot;])()","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"MarkDown学习(一)","slug":"MarkDown学习-一","date":"2022-06-22T13:39:30.000Z","updated":"2023-07-02T17:10:54.433Z","comments":true,"path":"2022/06/22/MarkDown学习-一/","link":"","permalink":"http://example.com/2022/06/22/MarkDown%E5%AD%A6%E4%B9%A0-%E4%B8%80/","excerpt":"","text":"MarkDOwn初识标题要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 () (例如：### My Header)。 1234567# 1级标题## 2级标题### 3级标题#### 四级标题 ##### 五级标题 ###### 六级标题 字体1*斜体文本* 斜体文本 1**加粗文本** 加粗文本 1***加粗和斜体文本*** 加粗和斜体文本 1~~删除文本~~ 删除文本 1&gt; 引用文本 引用文本 列表有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 一： First item Second item Third item Fourth item 二： 12341. First item1. Second item2. Third item3. Fourth item First item Second item Third item Fourth item 三： 12341. First item8. Second item7. Third item3. Fourth item First item Second item Third item Fourth item 无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 123456- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 复选框列表（CheckBoxList） 123- [ ] List Item 1 unchecked- [x] List Item 2 checked- [X] List Item 3 checked List Item 1 unchecked List Item 2 checked List Item 3 checked 代码12345678910111213141516#[derive(Debug)]pub enum State &#123; Start, Transient, Closed,&#125;impl From&lt;&amp;&#x27;a str&gt; for State &#123; fn from(s: &amp;&#x27;a str) -&gt; Self &#123; match s &#123; &quot;start&quot; =&gt; State::Start, &quot;closed&quot; =&gt; State::Closed, _ =&gt; unreachable!(), &#125; &#125;&#125; 123456789101112[ &#123; &quot;title&quot;: &quot;apples&quot;, &quot;count&quot;: [12000, 20000], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;, &#123; &quot;title&quot;: &quot;oranges&quot;, &quot;count&quot;: [17500, null], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;] 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Gre\\&#x27;ater&#x27; return (param2 - param1 + 1 + 0b10l) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; 12345678910111213&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt; function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt; 123456789101112131415161718192021function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=&quot;$&#123;cls&#125;&quot;`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log(&#x27;undefined&#x27;); &#125; return ( &lt;div&gt; &lt;web-component&gt;&#123;block&#125;&lt;/web-component&gt; &lt;/div&gt; )&#125;export $initHighlight; 1234567891011121314#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125; 123456789101112CREATE TABLE &quot;topic&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;forum_id&quot; integer NOT NULL, &quot;subject&quot; varchar(255) NOT NULL);ALTER TABLE &quot;topic&quot;ADD CONSTRAINT forum_id FOREIGN KEY (&quot;forum_id&quot;)REFERENCES &quot;forum&quot; (&quot;id&quot;);-- Initialsinsert into &quot;topic&quot; (&quot;forum_id&quot;, &quot;subject&quot;)values (2, &#x27;D&#x27;&#x27;artagnian&#x27;); 12345678910111213#import &lt;UIKit/UIKit.h&gt;#import &quot;Dependency.h&quot;@protocol WorldDataSource@optional- (NSString*)worldName;@required- (BOOL)allowsToLive;@end@property (nonatomic, readonly) NSString *title;- (IBAction) show;@end 12345678910111213141516/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123; public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; 123456789101112131415import Foundation@objc class Person: Entity &#123; var name: String! var age: Int! init(name: String, age: Int) &#123; /* /* ... */ */ &#125; // Return a descriptive string for this person func description(offset: Int = 0) -&gt; String &#123; return &quot;\\(name) is \\(age + offset) years old&quot; &#125;&#125; 123456789101112131415@font-face &#123; font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123; color: #F0F0F0; background: #600; font-family: Chunkfive, sans;&#125;@import url(print.css);@media print &#123; a[href^=http]::after &#123; content: attr(href) &#125;&#125; 12345678910111213# The Greeter classclass Greeter def initialize(name) @name = name.capitalize end def salute puts &quot;Hello #&#123;@name&#125;!&quot; endendg = Greeter.new(&quot;world&quot;)g.salute 12345678910111213# MakefileBUILDDIR = _buildEXTRAS ?= $(BUILDDIR)/extras.PHONY: main cleanmain: @echo &quot;Building main facility...&quot; build_main $(BUILDDIR)clean: rm -rf $(BUILDDIR)/* 123456789101112package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan float64) ch &lt;- 1.0e10 // magic number x, ok := &lt;- ch defer fmt.Println(`exitting now\\`) go println(len(&quot;hello world!&quot;)) return&#125; 123456789101112131415#!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then echo &quot;Superuser rights required&quot; exit 2figenApacheConf()&#123; echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125; 123456789101112; boilerplate[package]name = &quot;some_name&quot;authors = [&quot;Author&quot;]description = &quot;This is \\a description&quot;[[lib]]name = $&#123;NAME&#125;default = Trueauto = nocounter = 1_000 超链接1这是一个链接 [百度](https://baidu.com)。 这是一个链接 百度。 图片1![图片alt](图片链接 &quot;图片title&quot;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2022-06-03T11:42:34.000Z","updated":"2023-07-02T17:10:41.054Z","comments":true,"path":"2022/06/03/我的第一篇博客文章/","link":"","permalink":"http://example.com/2022/06/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"一年前，就试着搭建了这个Hexo框架的微博，但是只是部署到了Github上，并没有打理自己的博客，也没有写一些内容，这和当初搭建博客的目的有点南辕北辙了。这段时间确实是让人比较疲惫且受挫，但还是得打起精神，继续前进。","categories":[],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"},{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"},{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]}