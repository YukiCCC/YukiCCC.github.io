{"meta":{"title":"YukiCCC的博客","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-10-03T09:02:31.086Z","updated":"2023-07-18T17:09:14.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"自己想做的XXX件事： 干一份自己值得为之倾尽全力的工作 邂逅真爱 自驾游环游中国 考取研究生 研究生顺利毕业 学会射箭 学会写一手花体英文字 去日本旅行一次 学会骑马 去内蒙古玩一次 去舟山群岛到普陀山登顶 学会开车 拥有一台旗舰级顶级配置的电脑 让父母放心为他们分一次忧 开一次大排量摩托车 坐一次倒悬式的过山车 作为长辈给晚辈精心准备一次礼物 给家里坏掉的房门装锁 自己自驾游一座城市 写好中国字练一手好字"},{"title":"所有分类","date":"2024-10-03T09:02:31.104Z","updated":"2023-07-01T08:25:42.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-10-03T09:02:31.110Z","updated":"2023-07-01T08:54:37.000Z","comments":true,"path":"data/friends.json","permalink":"http://example.com/data/friends.json","excerpt":"","text":"[{\"group\":\"分组1# 分组标题\",\"description\":\"友情链接\",\"items\":[{\"title\":\"Google\",\"avatar\":\"https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png\",\"url\":\"https://www.google.com/\",\"screenshot\":null,\"keywords\":null,\"description\":null},{\"title\":null,\"avatar\":null,\"url\":null,\"screenshot\":null,\"keywords\":null,\"description\":null}]}]"},{"title":"所有标签","date":"2024-10-03T09:02:31.129Z","updated":"2023-07-01T08:26:59.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-10-03T09:02:31.114Z","updated":"2023-07-01T08:26:42.000Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"不同任务的线程池设置","slug":"不同任务的线程池设置","date":"2025-07-03T16:58:52.000Z","updated":"2025-07-03T17:00:57.196Z","comments":true,"path":"2025/07/04/不同任务的线程池设置/","link":"","permalink":"http://example.com/2025/07/04/%E4%B8%8D%E5%90%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"主要特性对比 特性 CPU密集型任务 IO密集型任务 主要瓶颈 CPU计算能力 外部I&#x2F;O资源速度限制 线程配置建议 核心线程数 ≈ CPU核心数 + 1 核心线程数 ≈ CPU核心数 * 2 或更多 任务特征 高计算量、长时间占用CPU 高I&#x2F;O操作、长时间等待外部资源 性能优化 限制线程数，避免频繁上下文切换 增加线程数，优化I&#x2F;O操作，减少等待时间 适用场景 数据计算、图像处理、机器学习、科学计算 文件操作、数据库查询、网络请求、分布式通信","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"菜单权限控制模块(RBAC)","slug":"菜单权限控制模块-RBAC","date":"2025-07-03T14:06:11.000Z","updated":"2025-07-03T15:24:10.332Z","comments":true,"path":"2025/07/03/菜单权限控制模块-RBAC/","link":"","permalink":"http://example.com/2025/07/03/%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97-RBAC/","excerpt":"","text":"一、权限系统框架 如图所示，权限系统主要解决两个问题： 前端渲染：接入系统用户登录后，获取自己有权限的菜单，也就是前端sdk请求权限系统获取有权限的菜单并进行自动渲染。 后端鉴权：用户请求接入系统后端，拒绝没有权限的接口访问，防止无权限用户获取后端接口地址后直接访问无权限的接口。为了解决这两个问题，必然需要引入一些配套内容，其中重要的功能点如下： 用户管理：统一登录系统，支撑权限系统识别登录用户。 权限管理：系统管理、角色管理、菜单管理、数据管理、角色人员绑定等功能，方便为用户绑定相应的权限。 后端鉴权：访问接入系统接口调用时使用。后面会一一介绍用户管理、权限管理、后端鉴权sdk的实现。 首先让我们思考一个问题，为什么首先前端渲染，另外既然前端已经获得了用户可点击的菜单按钮，为什么还要经过后端校验？ 1.1 安全性考虑前端权限控制不可信任 ： 前端代码运行在用户浏览器中，用户可以通过开发者工具、浏览器插件等方式修改前端代码 恶意用户可以绕过前端的权限检查，直接调用后端API接口 前端权限控制只是为了提升用户体验，不能作为安全防护的最后一道防线API接口直接访问风险 ： 即使前端隐藏了某些菜单，用户仍可能通过抓包、查看网络请求等方式获取API地址 恶意用户可以使用Postman、curl等工具直接调用后端接口 没有后端鉴权的话，系统存在严重的安全漏洞 1.2 双重防护机制权限系统需要解决两个核心问题： 前端渲染 ：提供良好的用户体验，只显示用户有权限的菜单 后端鉴权 ：确保安全性，拒绝无权限的接口访问这是一个”前端控制体验，后端保证安全”的设计原则。前端权限控制让用户界面更友好，后端鉴权确保数据和业务逻辑的安全性。 二、用户管理本文通过转转权限控制举例： 权限系统支持转转、转转精神、发条爱客、自注册四种来源的用户数据，支持用户在一个系统登录在其他系统保持登录状态功能（统一登录），支持员工入职自动加入权限系统（员工同步），这里重点介绍统一登录。 2.1、统一登录先从接入权限的域名都是*.zhuanspirit.com说起，统一登录利用浏览器携带Cookie特点：不同二级域名可以携带一级域名的Cookie。统一登录系统为接入系统种植一级域名Cookie，例如OA系统oa.zhuanspirit.com，权限系统自身id.zhuanspirit.com统一种植域名为*.zhuanspirit.com的Cookie，这样OA、权限系统等接入统一登录系统的系统就可以做到一处登录处处访问。现在抛出两个问题： 接入系统并未引入统一登录系统的任何代码，未登录用户是怎样跳转到统一登录页的？ 如何校验Cookie是否合法的？ 从以OA系统为例的图中可以看出问题答案： ngix会对*.zhuanspirit.com域名的请求做Cookie合法校验，校验不通过跳转到登录页，同时携带原url信息。 校验合法性是通过Cookie&lt;sso_uid,sso_code&gt;的值是否和Redis中一致，不一致就需要重新登录。 三、权限管理转转权限管理系统是一个基于经典RBAC权限管理模型的实现，上图为转转权限系统的主要功能，本身实现复杂度并不高。但是由于历史原因，转转权限系统在实现的时候需要考虑兼容原有权限系统的数据，这是一个比较琐碎复杂的事情，在这里不做过多介绍。对于简单的管理系统来说，灵魂在数据。对应到转转权限系统，血肉就是管理UI，它的使命就是方便为数据表填充数据，具体一点就是为用户表、系统表、菜单表、数据表、角色表以及中间关系表填充数据。下面我就展现转转权限系统的灵魂–数据库表关系。 从上图中可以看到转转权限系统和RBAC一些差异：用户直接可以与菜单或者数据绑定，增加灵活性。 用户直接可以与菜单或者数据绑定，增加灵活性。 3.1 核心实体表 用户表（User） ：存储用户基本信息 角色表（Role） ：定义系统中的各种角色 菜单表（Menu） ：存储系统菜单和功能点 数据表（Data） ：存储数据权限相关信息 系统表（System） ：管理接入的各个系统 3.2 关系表（多对多关联） 用户-角色关系表 ：用户可以拥有多个角色 角色-菜单关系表 ：角色可以访问多个菜单 角色-数据关系表 ：角色可以访问多种数据 用户-菜单关系表 ：用户可以直接绑定菜单（增加灵活性） 用户-数据关系表 ：用户可以直接绑定数据权限（增加灵活性） 3.3 表关联逻辑标准RBAC模型流程： 1用户 → 角色 → 权限（菜单/数据） 转转权限系统的增强模型： 123用户 → 角色 → 权限（菜单/数据）用户 → 直接绑定 → 权限（菜单/数据） // 增加灵活性 3.4 用户登录后获取权限信息的逻辑 根据用户ID查询用户-角色关系表，获取用户的所有角色 根据角色ID查询角色-菜单关系表，获取角色对应的菜单权限 根据用户ID查询用户-菜单关系表，获取用户直接绑定的菜单权限 合并角色权限和直接权限，去重后返回最终权限列表 将权限信息缓存到Redis中，提升后续访问性能 四、后端鉴权4.1、工作原理 如上图所示，后端鉴权sdk通过切面编程的思想，对请求url或者code进行拦截鉴权，如果登录用户没有权限，则返回错误。 4.2、核心方法1AuthResult res = authentication.check(new AppCodeAuthParmBuilder(APP_CODE, CODE, request)); 上面是sdk面向用户的接口很容易可以看出来，进入非常简单，仅仅需要三个参数： APP_CODE：系统的系统编号 CODE：权限编码（可为空，为空时根据url鉴权） request：HttpServletRequest（从中获取Cookie信息解析出登录用户，以及url信息判断用户是否有此url权限） 4.3、使用demo利用Spring Interceptor切面技术，下面是架构管理平台关于ZZLock后台操作的一个例子 123456789101112131415161718192021222324@Componentpublic class ZZLockInterceptor implements HandlerInterceptor &#123; @Resource private Authentication authentication; private static final String APP_CODE = &quot;arch_ipms&quot;; private static final String CODE = &quot;ro_zzlock&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; AuthResult res = authentication.check(new AppCodeAuthParmBuilder(APP_CODE, CODE, request)); if (res.isSuccess() &amp;&amp; res.getCode() == ResultCodeEnum.SUCCESS.getCode()) &#123; return true; &#125; else &#123; UserDTO user = authentication.parseUser(request); logger.info(&quot;菜单 zzlock_get user &#123;&#125; 鉴权结果 code &#123;&#125; msg &#123;&#125;&quot;, user.getLoginName(), res.getCode(), res.getMsg()); response.getWriter().write(&quot;user: &quot; + user.getLoginName() + &quot; no auth&quot;); response.getWriter().close(); &#125; return false; &#125;&#125; 五、总结从使用方的视角出发，也就是前端渲染和接口鉴权，引出转转权限系统如何识别用户（统一登录），如何存储权限数据（权限管理），如何实现后端鉴权。 简而言之，权限系统的主要功能：权限系统UI编辑权限数据，用户登录后，获取配置好的菜单和数据，并且校验用户访问的后端接口。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Redis在spring项目中的运用","slug":"Redis在spring项目中的运用","date":"2025-03-06T11:28:20.000Z","updated":"2025-07-05T13:03:15.089Z","comments":true,"path":"2025/03/06/Redis在spring项目中的运用/","link":"","permalink":"http://example.com/2025/03/06/Redis%E5%9C%A8spring%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"Redis 是一种高性能的键值存储数据库，而 Spring Boot 是一个简化了开发过程的 Java 框架。将两者结合，可以轻松地在 Spring Boot 项目中使用 Redis 来实现数据缓存、会话管理和分布式锁等功能。 一、添加 Redis 依赖在 pom.xml 文件中添加 Redis 相关依赖 1234567&lt;dependencies&gt; &lt;!-- Spring Data Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 二、配置 Redis 连接信息在 application.properties 或 application.yml 配置文件中添加 Redis 连接信息 12spring.redis.host=127.0.0.1spring.redis.port=6379 根据自己 Redis 服务器配置，修改主机和端口信息 三、使用 RedisTemplate 进行操作1. 创建 RedisTemplate Bean在配置类中创建 RedisTemplate Bean，用于进行 Redis 操作 1234567891011@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); return template; &#125; 上述示例中使用了 JSON 序列化器来对值进行序列化和反序列化，你也可以根据需要选择其他序列化器。 2. 注入 RedisTemplate在服务类或控制器中注入 RedisTemplate 12@Autowiredprivate RedisTemplate&lt;String, Object&gt; redisTemplate; 3. 执行 Redis 操作使用注入的 RedisTemplate 来进行 Redis 操作，设置键值对、获取值等 12345// 设置键值对redisTemplate.opsForValue().set(&quot;key&quot;, &quot;value&quot;);// 获取值String value = (String) redisTemplate.opsForValue().get(&quot;key&quot;); 四、使用 Spring Cache 简化缓存操作1. 添加 Spring Cache 依赖123456789101112131415在 pom.xml 文件中添加 Spring Cache 相关依赖&lt;dependencies&gt; &lt;!-- Spring Data Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cache --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 启用缓存支持在启动类上添加 @EnableCaching 注解，启用缓存支持 12345@SpringBootApplication@EnableCachingpublic class Application &#123; // ...&#125; 3. 使用缓存注解在服务类或方法上使用 Spring Cache 提供的缓存注解，如 @Cacheable、@CachePut、@CacheEvict 1234567891011121314151617181920@Servicepublic class demoService &#123; @Cacheable(value = &quot;cacheName&quot;, key = &quot;#id&quot;) public Object getData(String id) &#123; // 从数据库或其他数据源获取数据 return data; &#125; @CachePut(value = &quot;cacheName&quot;, key = &quot;#id&quot;) public Object updateData(String id, Object newData) &#123; // 更新数据库或其他数据源的数据 return newData; &#125; @CacheEvict(value = &quot;cacheName&quot;, key = &quot;#id&quot;) public void deleteData(String id) &#123; // 删除数据库或其他数据源的数据 &#125;&#125; 五、使用 Redisson 实现分布式锁1. 添加 Redisson 依赖在 pom.xml 文件中添加 Redisson 相关依赖 1234567891011121314&lt;dependencies&gt; &lt;!-- Spring Data Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Redisson --&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.16.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 配置 Redisson在配置文件中添加 Redisson 配置，例如 application.properties 12# 单节点 Redisson 配置spring.redis.redisson.config=classpath:redisson-single-node.yml 在 redisson-single-node.yml 配置文件中配置 Redisson 的连接信息 3. 使用 Redisson 获取锁：在你的代码中使用 Redisson 获取分布式锁： 123456789101112@Autowiredprivate RedissonClient redissonClient;public void doSomething() &#123; RLock lock = redissonClient.getLock(&quot;lockName&quot;); try &#123; lock.lock(); // 执行需要加锁的操作 &#125; finally &#123; lock.unlock(); &#125;&#125; 六、完善 Redis 的其他配置除了基本配置，还可以根据实际需求完善 Redis 的其他配置，例如连接池配置、超时设置等。 一、连接池配置Redis 使用连接池来管理和复用与 Redis 服务器的连接，以提高连接的效率和性能。 在 配置文件中配置连接池相关参数打开 Redis 配置文件 redis.conf，找到以下配置项并进行修改1234567891011121314151617# 最大连接数maxclients 10000# TCP 连接的队列长度tcp-backlog 511# 连接池中的最大空闲连接数maxidle 100# 连接池中的最小空闲连接数minidle 10# 连接超时时间（毫秒）timeout 3000# 是否开启 TCP 连接的保活机制tcp-keepalive 0 通过客户端连接池配置对象进行配置在 Spring Boot 项目中，可以通过 Redis 连接池配置对象 JedisPoolConfig 进行配置12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class RedisConfig &#123; @Bean public JedisPoolConfig jedisPoolConfig() &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(10000); poolConfig.setMaxIdle(100); poolConfig.setMinIdle(10); poolConfig.setMaxWaitMillis(3000); // 其他配置项设置 return poolConfig; &#125; @Bean public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig poolConfig) &#123; RedisStandaloneConfiguration config = new RedisStandaloneConfiguration(); config.setHostName(&quot;127.0.0.1&quot;); config.setPort(6379); // 其他 Redis 配置项设置 JedisClientConfiguration clientConfig = JedisClientConfiguration.builder() .usePooling().poolConfig(poolConfig) .build(); return new JedisConnectionFactory(config, clientConfig); &#125; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(JedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); return template; &#125;&#125; 二、超时设置超时设置用于控制 Redis 操作的超时时间，以防止长时间的阻塞或无响应操作 配置 Redis 连接超时时间在 Redis 配置文件中设置 timeout 参数，单位为毫秒，如下设置连接超时时间为 5000 毫秒1timeout 5000 通过 Redis 客户端配置对象进行配置通过 JedisClientConfiguration 进行配置，将读取操作的超时时间设置为 5秒1234567891011121314@Beanpublic JedisClientConfiguration jedisClientConfiguration() &#123; Duration timeout = Duration.ofSeconds(5); return JedisClientConfiguration.builder() .readTimeout(timeout) .build();&#125;@Beanpublic JedisConnectionFactory jedisConnectionFactory(JedisClientConfiguration clientConfig) &#123; // 其他配置项设置 return new JedisConnectionFactory(config, clientConfig);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"代码审查sonar报告问题修改","slug":"代码审查sonar报告问题修改","date":"2025-03-04T06:17:03.000Z","updated":"2025-03-06T12:04:03.000Z","comments":true,"path":"2025/03/04/代码审查sonar报告问题修改/","link":"","permalink":"http://example.com/2025/03/04/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5sonar%E6%8A%A5%E5%91%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E6%94%B9/","excerpt":"","text":"项目引入了sonar做代码质量管理，以下为代码审查修改中反馈的相关问题： Make the enclosing method &quot;static&quot; or remove this set.内容：从非静态方法正确更新静态字段很难做到正确，如果有多个类实例和&#x2F;或多个线程在运行，很容易导致错误。 理想情况下，静态字段仅从同步静态方法中更新。解决方法：将静态字段改为非静态。 Remove this annotation and use constructor injection instead.内容：移除@Autowired注解使用构造器注入方式替代。解决方法：IntelliJ IDEA也会提示Field injection is not recommended，翻译成中文即：不推荐使用字段注入可以是使用@Resource注释替换，具体区别：1.提供方不同@Autowired 是Spring提供的，@Resource 是J2EE提供的。2.装配时默认类型不同@Autowired只按type装配,@Resource默认是按name装配。3、使用区别（1）@Autowired与@Resource都可以用来装配bean，都可以写在字段或setter方法上（2）@Autowired默认按类型装配，默认情况下必须要求依赖对象存在，如果要允许null值，可以设置它的required属性为false。如果想使用名称装配可以结合@Qualifier注解进行使用。（3）@Resource，默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。@Resource有两个重要的属性：name和type Replace this call to &quot;replaceAll()&quot; by a call to the &quot;replace&quot; method 这句话的意思是将“replaceAll()”方法的调用替换为”replace”方法的调用。这是因为replaceAll方法是Java字符串类中的一个高级方法，它可以用正则表达式来替换字符串中的所有匹配项。然而，如果你只是想简单地替换字符串中的一个子串，那么使用 “replace” 方法会更加简洁和高效。 Invoke method(s) only conditionally在编写代码时，有时需要根据特定条件来调用方法，以避免不必要的性能开销或错误。这种做法在代码质量工具如SonarLint中被称为“有条件地调用方法”（Invoke method(s) only conditionally）。这种方法可以提高代码的效率和可读性。 Use the built-in formatting to construct this argument将连接字符串传递给日志记录方法也可能导致不必要的性能损失，因为每次调用该方法时都会执行连接，无论日志级别是否低到足以显示消息。应该使用内置的字符串格式而不是字符串连接，如果消息是方法调用的结果，则应该完全跳过前置条件，而应该有条件地抛出相关异常。反例 12String message = &quot;Hellow World!&quot;;logger.info(&quot;Test Info message：&quot;+message); 正确 1234String message = &quot;Hellow World!&quot;;String format = String.format(&quot;Test Info message：%s&quot;, message);logger.info(format); Reorder the modifiers to comply with the Java Language Specification 调整修饰符次序，反例：private final static String DD &#x3D; “测试”; 改成private static final String DD &#x3D; “测试”; 以下是修饰符的顺序： Annotations public protected private abstract static final transient volatile synchronized native strictfp","categories":[],"tags":[{"name":"代码审查","slug":"代码审查","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"}]},{"title":"SpringBootApplication和ComponentScan注释","slug":"SpringBootApplication和ComponentScan注释","date":"2025-02-27T12:05:25.000Z","updated":"2025-02-27T12:06:42.000Z","comments":true,"path":"2025/02/27/SpringBootApplication和ComponentScan注释/","link":"","permalink":"http://example.com/2025/02/27/SpringBootApplication%E5%92%8CComponentScan%E6%B3%A8%E9%87%8A/","excerpt":"","text":"在 Spring Boot 中，@SpringBootApplication 和 @ComponentScan 一般不会直接冲突，但如果配置不当可能会出现问题。下面详细分析可能出现的冲突情况及解决办法。 冲突原因分析 @SpringBootApplication 注解原理：@SpringBootApplication 是一个组合注解，它包含了 @SpringBootConfiguration、@EnableAutoConfiguration 和 @ComponentScan 这三个注解。默认情况下，@SpringBootApplication 会扫描主应用类所在包及其子包下的组件。 冲突情况：当你在 @SpringBootApplication 中使用 scanBasePackages 属性指定扫描包路径，同时又使用 @ComponentScan 注解指定不同的扫描包路径时，就可能会出现冲突。这可能导致组件重复扫描或者某些组件未被扫描到。 解决办法1. 只使用 @SpringBootApplication 的 scanBasePackages 属性如果你只需要指定一个扫描包路径，那么可以直接在 @SpringBootApplication 中使用 scanBasePackages 属性，避免使用 @ComponentScan 注解。 示例代码： 123456789import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication(scanBasePackages = &quot;com.example.demo.service&quot;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 在这个例子中，Spring Boot 会扫描 com.example.demo.service 包及其子包下的组件。 2. 合并扫描包路径如果你需要指定多个扫描包路径，可以将这些路径合并到 @SpringBootApplication 的 scanBasePackages 属性中。 示例代码： 123456789import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication(scanBasePackages = &#123;&quot;com.example.demo.service&quot;, &quot;com.example.demo.repository&quot;&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 这样，Spring Boot 会同时扫描 com.example.demo.service 和 com.example.demo.repository 包及其子包下的组件。 3. 移除 @SpringBootApplication 中的 scanBasePackages 属性，使用 @ComponentScan如果你更倾向于使用 @ComponentScan 注解来指定扫描包路径，可以移除 @SpringBootApplication 中的 scanBasePackages 属性。 示例代码： 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.example.demo.service&quot;, &quot;com.example.demo.repository&quot;&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 在这个例子中，@ComponentScan 注解会覆盖 @SpringBootApplication 中默认的扫描包路径，Spring Boot 会扫描 com.example.demo.service 和 com.example.demo.repository 包及其子包下的组件。 通过以上方法，你可以避免 @SpringBootApplication 和 @ComponentScan 之间的冲突，确保组件能够被正确扫描。","categories":[],"tags":[]},{"title":"自动部署","slug":"自动部署","date":"2025-02-22T14:09:33.000Z","updated":"2025-02-22T14:46:14.000Z","comments":true,"path":"2025/02/22/自动部署/","link":"","permalink":"http://example.com/2025/02/22/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","excerpt":"","text":"CI&#x2F;CD的概念CI&#x2F;CD是持续集成（Continuous Integration）和持续交付（Continuous Delivery）的缩写，它旨在通过自动化的流程和工具，提高软件开发的效率、质量和交付速度。 持续集成在现在的开发模式中，一般的项目，协同开发是离不开的，这就涉及到多个开发人员编写处理自己负责的功能模块或者某些开发人员共同负责一个模块。于是，通过版本控制系统可以将各个开发人员的代码集成在该共享存储库里，在存储库里，每个开发人员根据需求的不同来创建对应的分支，在完成需求后，每个人都需要提交合并将开发分支代码集成在一起，这就需要解决代码冲突，并且如何除了code review之外如何确保这些更改对应用没有产生影响，一旦提交请求合并到主分支，自动化构建工具就会根据流程自动编译构建安装应用，并执行单元测试框架的自动化测试来校验提交的修改。以下是一些用于构建有效CI流程的关键组件：版本控制系统（Version Control System，VCS）：例如Git，用于跟踪代码变更，协作开发，并确保团队成员之间的代码同步。自动化构建工具：如Jenkins、Travis CI、CircleCI等，用于在每次代码提交时自动触发构建过程。单元测试框架：例如JUnit（Java）、pytest（Python），用于确保代码的基本功能在集成后仍然有效。 持续交付持续交付后的代码已经在主分支上了，这处于某个版本的待发布的状态，随时可以将开发环境的功能部署到生产环境中（部署到生成环境前还需要在测试环境性能测试、回归测试、自动化测试、人工测试等），运行脚本构建打包应用，通过自动化部署工具部署到生产环境运行应用，监控生产环境指标，如出现问题和错误，可以触发手动或自动回滚，如系统正常，则定期回顾，收集反馈，优化，并持续改进。以下是一些用于实现持续交付的关键组件：自动化部署工具：例如Docker、Ansible、Kubernetes等，用于自动化地部署应用程序和其依赖。环境配置管理：工具如Terraform，确保不同环境（开发、测试、生产）的一致性。持续监控和反馈：使用工具如Prometheus、Grafana，确保在部署后能够监控应用程序的性能和稳定性。 本人目前负责的项目就是使用了Jenkins自动化构筑+K8S自动化部署 Jenkins+K8S实现自动化部署的全流程提交项目代码并打上git tag，上传代码及tag至gitlabgitlab通过webhook自动触发jenkins执行任务jenkins获取代码，执行代码编译、构建docker镜像、上传docker镜像至harbor镜像仓库、执行kubectl命令部署至k8s","categories":[],"tags":[]},{"title":"统计网站UVPV","slug":"统计网站UVPV","date":"2025-02-20T10:49:15.000Z","updated":"2025-02-20T12:09:51.000Z","comments":true,"path":"2025/02/20/统计网站UVPV/","link":"","permalink":"http://example.com/2025/02/20/%E7%BB%9F%E8%AE%A1%E7%BD%91%E7%AB%99UVPV/","excerpt":"","text":"系统活跃度指标描述系统活跃度的名词：PV、UV、VV、IPPV(Page View) 页面浏览量。每当一个页面被打卡或被刷新，都会产生一次PV。UV(Unique Visitor) 独立访客。一天内相同访客多次访问网站，只计算为1个独立访客。VV(VIsit View) 访客访问的次数。IP 独立IP访问数 为什么选择HyperLogLog统计UV、PV在说明 HyperLogLog 之前，我们需要先了解一个概念：基数统计。维基百科中的解释是： cardinality of a set is a measure of the “number of elements“ of the set它的意思是：一个集合（注意：这里集合的含义是 Object 的聚合，可以包含重复元素）中不重复元素的个数。例如集合 {1,2,3,1,2}，它有5个元素，但它的基数&#x2F;Distinct 数为3。 Redis 最常用的数据结构有字符串、列表、字典、集合和有序集合。后来，由于 Redis 的广泛应用，Redis 自身也做了很多补充，其中就有 HyperLogLog（2.8.9 版本添加）结构。HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定的、并且是很小的。 Redis HyperLogLog 命令Redis 为 HyperLogLog提供了三个命令：PFADD、PFCOUNT、PFMERGE。我们依次来看看这三个命令的解释和作用。 PFADD将任意数量的元素添加到指定的 HyperLogLog 里面。时间复杂度： 每添加一个元素的复杂度为 O(1) 。如果 HyperLogLog 估计的近似基数（approximated cardinality）在命令执行之后出现了变化， 那么命令返回 1 ， 否则返回 0 。 如果命令执行时给定的键不存在， 那么程序将先创建一个空的 HyperLogLog 结构， 然后再执行命令。命令行示例 12345678910# 命令格式：PFADD key element [element …]# 如果给定的键不存在，那么命令会创建一个空的 HyperLogLog，并向客户端返回 1127.0.0.1:6379&gt; PFADD ip_20190301 &quot;192.168.0.1&quot; &quot;192.168.0.2&quot; &quot;192.168.0.3&quot;(integer) 1# 元素估计数量没有变化，返回 0（因为 192.168.0.1 已经存在）127.0.0.1:6379&gt; PFADD ip_20190301 &quot;192.168.0.1&quot;(integer) 0# 添加一个不存在的元素，返回 1。注意，此时 HyperLogLog 内部存储会被更新，因为要记录新元素127.0.0.1:6379&gt; PFADD ip_20190301 &quot;192.168.0.4&quot;(integer) 1 PFCOUNT当 PFCOUNT key [key …] 命令作用于单个键时，返回储存在给定键的 HyperLogLog 的近似基数，如果键不存在，那么返回 0，复杂度为 O(1)，并且具有非常低的平均常数时间；当 PFCOUNT key [key …] 命令作用于多个键时，返回所有给定 HyperLogLog 的并集的近似基数，这个近似基数是通过将所有给定 HyperLogLog 合并至一个临时 HyperLogLog 来计算得出的，复杂度为 O(N)，常数时间也比处理单个 HyperLogLog 时要大得多。命令行示例 123456789101112# 返回 ip_20190301 包含的唯一元素的近似数量127.0.0.1:6379&gt; PFCOUNT ip_20190301(integer) 4127.0.0.1:6379&gt; PFADD ip_20190301 &quot;192.168.0.5&quot;(integer) 1127.0.0.1:6379&gt; PFCOUNT ip_20190301(integer) 5127.0.0.1:6379&gt; PFADD ip_20190302 &quot;192.168.0.1&quot; &quot;192.168.0.6&quot; &quot;192.168.0.7&quot;(integer) 1# 返回 ip_20190301 和 ip_20190302 包含的唯一元素的近似数量127.0.0.1:6379&gt; PFCOUNT ip_20190301 ip_20190302(integer) 7 PFMERGE将多个 HyperLogLog 合并（merge）为一个 HyperLogLog，合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。时间复杂度是 O(N)，其中 N 为被合并的 HyperLogLog 数量，不过这个命令的常数复杂度比较高。命令格式：PFMERGE destkey sourcekey [sourcekey …]，合并得出的 HyperLogLog 会被储存在 destkey 键里面，如果该键并不存在，那么命令在执行之前，会先为该键创建一个空的 HyperLogLog。命令行示例 12345# ip_2019030102 是 ip_20190301 与 ip_20190302 并集127.0.0.1:6379&gt; PFMERGE ip_2019030102 ip_20190301 ip_20190302OK127.0.0.1:6379&gt; PFCOUNT ip_2019030102(integer) 7 SpringBoot 中使用 Redis HyperLogLog由于 Redis HyperLogLog 只有三个命令，思想和操作也非常简单，这里直接给出代码示例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.imooc.ad.Application;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.HyperLogLogOperations;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.test.context.junit4.SpringRunner;/** * &lt;h1&gt;Redis HyperLogLog 测试用例&lt;/h1&gt; * Created by Qinyi. */@RunWith(SpringRunner.class)@SpringBootTest(classes = &#123;Application.class&#125;, webEnvironment = SpringBootTest.WebEnvironment.NONE)public class RedisHyperLogLogTest &#123; /** 注入 StringRedisTemplate, 使用默认配置 */ @Autowired private StringRedisTemplate stringRedisTemplate; @Test @SuppressWarnings(&quot;all&quot;) public void testHyperLogLog() &#123; HyperLogLogOperations operations = stringRedisTemplate.opsForHyperLogLog(); // add 方法对应 PFADD 命令 operations.add(&quot;ip_20190301&quot;, &quot;192.168.0.1&quot;, &quot;192.168.0.2&quot;, &quot;192.168.0.3&quot;); // size 方法对应 PFCOUNT 命令 System.out.println(operations.size(&quot;ip_20190301&quot;)); // 3 operations.add(&quot;ip_20190301&quot;, &quot;192.168.0.1&quot;, &quot;192.168.0.4&quot;); System.out.println(operations.size(&quot;ip_20190301&quot;)); // 4 operations.add(&quot;ip_20190302&quot;, &quot;192.168.0.1&quot;, &quot;192.168.0.5&quot;); System.out.println(operations.size(&quot;ip_20190302&quot;)); // 2 // union 方法对应 PFMERGE 命令 operations.union(&quot;ip_201903&quot;, &quot;ip_20190301&quot;, &quot;ip_20190302&quot;); System.out.println(operations.size(&quot;ip_201903&quot;)); // 5 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"短信验证功能","slug":"短信验证功能","date":"2025-02-19T07:51:46.000Z","updated":"2025-02-19T09:29:12.000Z","comments":true,"path":"2025/02/19/短信验证功能/","link":"","permalink":"http://example.com/2025/02/19/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/","excerpt":"","text":"短信验证功能业务流程 用户点击“发送验证码”按钮，前端向后端发送请求，包含手机号信息。 后端生成一个随机验证码（如 6 位数字）和唯一标识（UUID），并将验证码和 UUID 存储到 Redis 中并设置过期时间，以手机号作为唯一 Key。 短信服务商将验证码发送到用户的手机号，同时后端通过 Redis 限制发送频率（如每分钟最多发送一次，每天最多发送 5 次）。 后端将 UUID 返回给前端，前端将 UUID 存储在本地（如 localStorage 或 sessionStorage，sessionStorage存储安全性更高）。 用户收到短信后，输入验证码，前端将手机号、验证码和 UUID 一起提交给后端。 后端使用手机号从 Redis 获取验证码记录，并校验提交的 UUID 和验证码是否匹配： - 如果匹配，则验证成功，并立即删除 Redis 中的验证码记录，执行登录流程（如生成 Token）。 - 如果不匹配，记录错误次数，超过最大错误次数后锁定手机号的验证功能一段时间。 验证成功后，返回登录成功的 Token 或其他相关信息。 解决的问题 更细化的 key 设计是这样的：verification:&#123;类型&#125;:&#123;场景&#125;:&#123;目标&#125;。&#123;类型&#125;：如 sms（短信）、email（邮箱），&#123;场景&#125;：如 login（登录）、register（注册）。&#123;目标&#125;：手机号或邮箱。 除了手机号限制外，还建议对单个 IP 的请求频率进行限制，防止攻击者使用不同的手机号进行短信轰炸。 在后端对验证码发送频率做了限制，不会出现因为网络波动等原因导致用户同时收到多个验证码。UUID 的作用：防止验证码泄露被滥用。如果攻击者通过某种方式窃取了验证码（例如短信被拦截或用户截图泄露），那么直接用手机号+验证码可以绕过验证。使用 UUID 作为额外的校验参数，可以增加破解难度，因为攻击者需要同时知道验证码和 UUID 才能通过验证 前端的一些验证工作 按钮置灰：防止用户重复点击，减少无效请求。 验证码前置：填写验证码之后才可以发送短信。 手机号合法性校验：提前校验手机号格式，避免无效请求浪费后端资源。 HTTPS 加密传输：通过 HTTPS 加密传输，避免验证码和 UUID 泄露。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"DynamicDataSource多数据","slug":"DynamicDataSource多数据","date":"2024-09-30T14:43:00.000Z","updated":"2024-09-30T15:03:05.000Z","comments":true,"path":"2024/09/30/DynamicDataSource多数据/","link":"","permalink":"http://example.com/2024/09/30/DynamicDataSource%E5%A4%9A%E6%95%B0%E6%8D%AE/","excerpt":"","text":"DynamicDataSource多数据多数据源的典型使用场景1、业务复杂应用没有拆，数据库拆分了2、读写分离解决数据库的读性能瓶颈（读比写性能更高，写锁会影响阻塞，影响性能） 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 配置多数据源通过yaml配置主数据源，这里就只配置了一个主数据源，后续通过代码来自由的切换数据源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344spring: datasource: dynamic: hikari: connection-timeout: 5000 idle-timeout: 30000 # 经过idle-timeout时间如果连接还处于空闲状态, 该连接会被回收 min-idle: 5 # 池中维护的最小空闲连接数, 默认为 10 个 max-pool-size: 16 # 池中最大连接数, 包括闲置和使用中的连接, 默认为 10 个 max-lifetime: 60000 # 如果一个连接超过了时长，且没有被使用, 连接会被回收 is-auto-commit: true primary: master #设置默认的数据源或者数据源组,默认值即为master strict: true #严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源 datasource: master: # 数据源名称 url: username: password: driver-class-name: com.mysql.cj.jdbc.Driver # 如下，如果你是确定的几个数据源，可以直接都在yaml配置写死即可# slave_1:# url: # username: # password: # driver-class-name: com.mysql.cj.jdbc.Driver 其中数据库连接池，所有的数据库统一配置，也可以单独配置，例如：datasource: master: # 数据源名称 url: username: password: driver-class-name: com.mysql.cj.jdbc.Driver hikari: connection-timeout: 5000 idle-timeout: 30000 # 经过idle-timeout时间如果连接还处于空闲状态, 该连接会被回收 min-idle: 5 # 池中维护的最小空闲连接数, 默认为 10 个 max-pool-size: 16 # 池中最大连接数, 包括闲置和使用中的连接, 默认为 10 个 max-lifetime: 60000 # 如果一个连接超过了时长，且没有被使用, 连接会被回收 is-auto-commit: true 切换数据源DS注解123456789101112@Service@DS(&quot;common&quot;)public class BookService extends ServiceImpl&lt;BookMapper, Book&gt; &#123; @Resource private BookMapper bookMapper; @Transactional(propagation = Propagation.REQUIRES_NEW) public void save(ReqDto reqDto) &#123; bookMapper.save(reqDto); &#125;","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Mybatis-Plus日志","slug":"Mybatis-Plus日志","date":"2024-09-13T13:23:46.000Z","updated":"2024-09-13T13:42:14.000Z","comments":true,"path":"2024/09/13/Mybatis-Plus日志/","link":"","permalink":"http://example.com/2024/09/13/Mybatis-Plus%E6%97%A5%E5%BF%97/","excerpt":"","text":"Mybatis-Plus日志在项目中日志中经常会出现如下日志： 12345678Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@42607e80] was not registered for synchronization because synchronization is not activeJDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@56ebc6bb] will not be managed by Spring==&gt; Preparing: SELECT app_id, app_code, app_name FROM t_sys_application ==&gt; Parameters: &lt;== Columns: app_id, app_code, app_name&lt;== Total: 2Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@42607e80] 在程序中并无代码体现，那么为什么会打印这些日志呢？是因为Mybatis-plus自带的SQL日志，首先我们学习一下更基础更通用的mybatis示例。开启的方法是是由org.apache.ibatis.logging.stdout.StdOutImpl控制的根据StdOutImpl.java可看出日志都是System.out.println(s);的控制台输出，配置及源码如下 123456mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 控制台输出日志logging: level: com.XXX.dao: debug 将使用mybatis的类的level配置为debug，因为mybatis内部仅打印debug级别的SQL日志。而本项目使用的Mybatis-plus配置起来更复杂一些 1234567891011121314151617181920212223# mybatis-plus 配置内容mybatis-plus: configuration: ### 开启驼峰配置 map-underscore-to-camel-case: true # 虽然默认为 true ，但是还是显示去指定下。 global-config: db-config: id-type: auto # ID 主键自增 logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) # xml扫描，多个目录用逗号或者分号分隔（告诉 Mapper 所对应的 XML 文件位置） mapper-locations: classpath*:mapper/*.xmllogging: level: com.XXX.dao: debug cn: iocoder: springboot: lab12: mybatis: mapper:info# 将Mapper 层设置日志级别为 info，这将记录较为简要的重要信息，通常包括 SQL 执行过程和结果 config:classpath:log/logback-spring.xml file.path 这样配置为 MyBatis-Plus 的 SQL 执行提供更细粒度的日志输出，帮助开发者在开发和调试过程中看到详细的 SQL 语句和执行过程，同时在生产环境中记录必要的日志信息用于运维分析。","categories":[],"tags":[{"name":"Mybatis-plus","slug":"Mybatis-plus","permalink":"http://example.com/tags/Mybatis-plus/"}]},{"title":"基于AOP的日志系统","slug":"基于AOP的日志系统","date":"2024-09-06T17:08:25.000Z","updated":"2024-09-06T17:29:59.000Z","comments":true,"path":"2024/09/07/基于AOP的日志系统/","link":"","permalink":"http://example.com/2024/09/07/%E5%9F%BA%E4%BA%8EAOP%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"基于AOP的日志模块本文旨在分析参与项目中的日志，如何基于AOP面向切面原理实现controller请求及响应信息打印。本项目将日志记录的逻辑封装成一个切面，然后通过切入点和通知来指定在哪些方法需要执行日志记录的操作。 AOP中注解的含义@Aspect：切面。表示一个横切进业务的一个对象。它里面包含切入点(Pointcut)和Advice（通知）。@Pointcut：切入点。表示需要切入的位置，比如某些类或者某些方法，也就是先定一个范围。@Before：Advice（通知）的一种，切入点的方法体执行之前执行。@Around：Advice（通知）的一种，环绕切入点执行也就是把切入点包裹起来执行。@After：Advice（通知）的一种，在切入点正常运行结束后执行。@AfterReturning：Advice（通知）的一种，在切入点正常运行结束后执行，异常则不执行@AfterThrowing：Advice（通知）的一种，在切入点运行异常时执行。 以下是一个类似案例： 日志注释12345678910111213141516// 日志注解@Target(&#123;ElementType.PARAMETER,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Log &#123; /** * 描述 */ String description() default &quot;&quot;; /** * 方法类型 INSERT DELETE UPDATE OTHER */ MethodType methodType() default MethodType.OTHER;&#125; 其中@Target用于指定自定义注解可以应用到哪些Java元素上。它的值是一个或多个 ElementType 枚举常量。你提到的 {ElementType.PARAMETER, ElementType.METHOD} 表示该注解可以应用到方法参数（PARAMETER）和方法（METHOD）上。 ElementType.PARAMETER: 该注解可以应用于方法参数上。ElementType.METHOD: 该注解可以应用于方法上。 @Retention 指定了注解的生命周期，也就是注解信息在什么阶段可以被保留。它的值是一个 RetentionPolicy 枚举常量。 RetentionPolicy.RUNTIME: 表示该注解不仅会被编译到字节码中，还会在运行时保留，因此可以通过反射机制获取到该注解信息。这在AOP中非常常见，因为AOP需要在运行时根据注解来执行相应的逻辑。 日志切面12345678// 日志切面@Component@Aspectpublic class LogAspect &#123; // 切入点，所有被 Log 注解标注的方法 @Pointcut(&quot;@annotation(cn.javaguide.annotation.Log)&quot;) public void webLog() &#123; &#125; 其中@Aspect 是 Spring AOP（Aspect-Oriented Programming，面向切面编程）中的一个注解，用于定义一个类为“切面”（Aspect）。在 Spring AOP 中，切面是用来实现横切关注点的模块化，它将横切关注点（如日志记录、事务管理、安全性检查等）从业务逻辑中分离出来，以提高代码的可维护性和可重用性。 @Aspect 注解的作用定义切面：@Aspect 标识一个类为切面类，这个类包含了与横切关注点相关的代码逻辑，如方法拦截、日志记录等。包含切入点和通知：一个切面类通常包含一个或多个切入点（Pointcut）和通知（Advice）。切入点定义了在哪些地方应用横切关注点，而通知则定义了在切入点执行的具体动作。 环绕通知12345678910 /** * 环绕通知 */ @Around(&quot;webLog()&quot;) public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable &#123; // 省略具体的处理逻辑 &#125; // 省略其他代码&#125; 其中@Around：Advice（通知）的一种，环绕切入点执行也就是把切入点包裹起来执行。 两套日志系统本项目使用的是@Pointcut()注释，对项目controller目录下的controller接口进行扫描，以进行控制","categories":[],"tags":[]},{"title":"滑动窗口","slug":"滑动窗口","date":"2024-09-02T15:47:10.000Z","updated":"2024-09-02T15:48:47.000Z","comments":true,"path":"2024/09/02/滑动窗口/","link":"","permalink":"http://example.com/2024/09/02/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口算法今天刷力扣题目，刷到了一个滑动窗口算法问题，这类算法问题之前没有遇到过，特此记录下来 解题思路1.首先确定窗口的定义（比如子串的每个字符存在个数&#x2F;子数组的和）2.开始创建变量2.1.window(HashMap&#x2F;int)用来定义窗口。2.2.left right指针[left, right)区间就是我们的窗口。2.3结果res，需根据题意3.window更新窗口值后,right++。到达窗口收缩条件，更新结果（如果满足题)，window更新窗口值，left– 例题给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 1234输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题办法如下： 12345678910111213141516171819202122//窗口状态：窗口内字符的数量//收缩条件：窗口内有字符数量大于1class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int left = 0, right = 0; int res = 0; while(right &lt; s.length())&#123; char c1 = s.charAt(right); window.put(c1, window.getOrDefault(c1, 0) + 1); right++; //窗口收缩不满足题意时收缩，也就是含有重读字符时 while(window.get(c1) &gt; 1)&#123; char c2 = s.charAt(left); window.put(c2, window.getOrDefault(c2, 0) - 1); left++; &#125; res = Math.max(res, right - left); &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"线程安全","slug":"线程安全","date":"2024-08-31T16:28:18.000Z","updated":"2024-08-31T16:54:36.000Z","comments":true,"path":"2024/09/01/线程安全/","link":"","permalink":"http://example.com/2024/09/01/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","excerpt":"","text":"问题描述在最近的项目中，因为需要多次对某个中台接口进行反复调用，以获取分页数据的全量数据以便在后台进行去重，我写了一个多线程功能代码如下： 123456789101112pageList.forEach(obj -&gt; &#123; pool.execute(() -&gt; &#123; request.setCurrent(obj); log.info(JSON.toJSONString(threadRequest)); JSONObject threadJsonObject = JcommonFeign.querylightninglnfluencelnfo(JSON.parseObject(JSON.toJSONString(threadRequest))); log.info(&quot;查询结束&quot;); MiddleGroundResponse threadResponse = SON.parseObject(SON.toJSONString(threadJsonObject), MiddleGroundResponse.class); threadList.add(JSON.toJSONString(threadResponse.getResult().getRecords())); latch.countDown(); &#125;);&#125;);latch.await(); 但是调用之后，经常发生重复调用后一页数据的情况，例如调用了2、3次第一页，导致获取的总数一致，但数据内容存在差异，前端展示内容不断变化。 问题原因每个线程都从同一个 request 对象开始工作，最后将结果存储到 threadList 中。经过排查是由以下两个因素引起的： 共享的 request 对象：多线程中共享了同一个 request 对象，而没有为每个线程创建一个独立的副本。这可能导致每个线程在执行 commonFeign.querylightninglnfluencelnfo 方法时，使用的都是相同的输入数据。如果 request 的内容在某个线程中被修改，那么其他线程可能会看到这种修改，导致调用时使用了相同或错误的数据。 线程安全问题：request 对象在多个线程之间共享，而没有进行任何同步操作来确保线程安全。如果 request 对象是可变的，并且多个线程同时修改它的内容，可能会导致未定义的行为，从而出现重复或错误的调用。 解决方案为每个线程创建独立的 request 副本：在 forEach 循环中，为每个线程创建一个新的 request 对象的副本，而不是共享同一个对象。这样可以确保每个线程都使用独立的数据。 方法一12345678910111213pageList.forEach(obj -&gt; &#123; RequestObject threadRequest = new RequestObject(request); // 创建request副本 pool.execute(() -&gt; &#123; request.setCurrent(objJ); log.info(JSON.toJSONString(threadRequest)); JSONObject threadJsonObject = commonFeign.querylightninglnfluencelnfo(JSON.parseObject(JSON.toJSONString(threadRequest))); log.info(&quot;查询结束&quot;); MiddleGroundResponse threadResponse = SON.parseObject(SON.toJSONString(threadJsonObject), MiddleGroundResponse.class); threadList.add(JSON.toJSONString(threadResponse.getResult().getRecords())); latch.countDown(); &#125;);&#125;);latch.await(); 而我使用的是Clone方法，通过使用 clone 方法，可以为每个线程创建独立的 request 副本，从而避免在多线程环境下出现重复调用相同数据的情况。 方法二12345678910111213pageList.forEach(obj -&gt; &#123; pool.execute(() -&gt; &#123; RequestObject threadRequest = (RequestObject) request.clone();// 创建request副本 request.setCurrent(objJ); log.info(JSON.toJSONString(threadRequest)); JSONObject threadJsonObject = commonFeign.querylightninglnfluencelnfo(JSON.parseObject(JSON.toJSONString(threadRequest))); log.info(&quot;查询结束&quot;); MiddleGroundResponse threadResponse = SON.parseObject(SON.toJSONString(threadJsonObject), MiddleGroundResponse.class); threadList.add(JSON.toJSONString(threadResponse.getResult().getRecords())); latch.countDown(); &#125;);&#125;);latch.await(); 经过验证同样可行。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"等待异步线程池跑完再执行后续代码的方法","slug":"等待异步线程池跑完再执行后续代码的方法","date":"2024-08-27T14:34:04.000Z","updated":"2024-08-27T14:36:13.000Z","comments":true,"path":"2024/08/27/等待异步线程池跑完再执行后续代码的方法/","link":"","permalink":"http://example.com/2024/08/27/%E7%AD%89%E5%BE%85%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B7%91%E5%AE%8C%E5%86%8D%E6%89%A7%E8%A1%8C%E5%90%8E%E7%BB%AD%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"等待异步线程池跑完再执行后续代码的方法等待异步线程池跑完再执行指定方法的三种方式(condition、CountDownLatch、CyclicBarrier)，最近本人使用的CountDownLatch CountDownLatch应用场景 某个线程需要在其他n个线程执行完毕后再向下执行 多个线程并行执行同一个任务，提高响应速度 12345678910111213141516171819202122232425262728293031323334353637383940414243public class CountDownLaunchTest &#123; public static void main(String[] args) throws InterruptedException &#123; List list = new ArrayList(); for(int i = 1; i&lt;=100; i++)&#123; list.add(i); &#125; Long start = System.currentTimeMillis(); for(int i = 0; i&lt;list.size(); i++)&#123; Thread.sleep(100); &#125; System.out.println(&quot;=====同步执行：耗时&quot;+(System.currentTimeMillis()-start)+&quot;毫秒======&quot;); Long start1 = System.currentTimeMillis(); CountDownLatch latch = new CountDownLatch(10); for(int i = 0; i&lt;latch.getCount(); i++)&#123; new Thread(new Test(latch, i, list)).start(); &#125; latch.await(); System.out.println(&quot;=====异步执行：耗时&quot;+(System.currentTimeMillis()-start1)+&quot;毫秒======&quot;); &#125; static class Test implements Runnable&#123; private CountDownLatch latch; private int i; private List list; Test(CountDownLatch latch, int i, List list)&#123; this.latch = latch; this.i = i; this.list = list; &#125; @SneakyThrows @Override public void run() &#123; for(int a = i*10; a&lt;(i+1)*10; a++)&#123; // 执行任务逻辑 Thread.sleep(100); &#125; latch.countDown(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"动态可改变时间间隔的定时任务","slug":"动态可改变时间间隔的定时任务","date":"2024-02-29T13:48:34.000Z","updated":"2024-02-29T14:22:41.000Z","comments":true,"path":"2024/02/29/动态可改变时间间隔的定时任务/","link":"","permalink":"http://example.com/2024/02/29/%E5%8A%A8%E6%80%81%E5%8F%AF%E6%94%B9%E5%8F%98%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"@Scheduled 和SchedulingConfigurer接口的区别@Schedule注解的一个缺点就是其定时时间不能动态更改，它适用于具有固定任务周期的任务，若要修改任务执行周期，只能走“停服务→修改任务执行周期→重启服务”这条路。 而基于 SchedulingConfigurer 接口方式可以做。 SchedulingConfigurer 接口可以实现在@Configuration 类上，同时不要忘了，还需要@EnableScheduling 注解的支持。 使用方法1、创建数据库 12345678910CREATE TABLE `trip_job_lock` ( `job_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#x27;定时任务名称&#x27;, `is_lock` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#x27;是否开启任务 1-开启，0-关闭&#x27;, `job_cron` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#x27;定时任务执行时间间隔&#x27;, `job_desc` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#x27;定时任务中午描述&#x27;, PRIMARY KEY (`job_name`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#x27;定时任务配置表&#x27; ROW_FORMAT = Dynamic;INSERT INTO `trip_job_lock` VALUES (&#x27;1&#x27;, NULL, &#x27;0/5 * * * * ?&#x27;, NULL); 2、后端实现方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//(1)Mapper接口public interface JobMapper &#123; @Select(&quot;&lt;script&gt;SELECT is_lock FROM trip_job_lock WHERE job_name = #&#123;jobName&#125;&lt;/script&gt;&quot;) public String getIsLock(String jobName); @Select(&quot;&lt;script&gt;SELECT job_cron FROM trip_job_lock WHERE job_name = #&#123;jobName&#125;&lt;/script&gt;&quot;) public String getCron(String jobName);&#125;//(2)定时任务实现SchedulingConfigurer接口@Component@SuppressWarnings(&quot;all&quot;)@Slf4j@EnableScheduling@Configurationpublic class AirTicketSettlementScheduler implements SchedulingConfigurer &#123; @Resource private AirTicketSettlementTaskService airTicketSettlementTaskService; @Resource CtripUtil ctripUtil; @Autowired SnowFlake snowFlake; @Autowired ScheduledByRedisIP scheduledByRedisIP; @Autowired LogRecordService logRecordService; //飞机结算的url @Value(&quot;$&#123;FlightSettlementURL&#125;&quot;) private String FlightSettlementURL; @Resource JobMapper jobMapper; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.addTriggerTask( //1.添加任务内容(Runnable) () -&gt; //System.out.println(&quot;执行定时任务2: &quot; + LocalDateTime.now().toLocalTime()), isScheduler(), //2.设置执行周期(Trigger) triggerContext -&gt; &#123; //2.1 从数据库获取执行周期 String cron = jobMapper.getCron(&quot;AirTicketSettlementScheduler&quot;); //2.2 合法性校验. if (StringUtils.isEmpty(cron)) &#123; // Omitted Code .. &#125; //2.3 返回执行周期(Date) return new CronTrigger(cron).nextExecutionTime(triggerContext); &#125; ); &#125; //判断定时任务是否已关闭 public void isScheduler()&#123; String isLock = jobMapper.getIsLock(&quot;AirTicketSettlementScheduler&quot;); if(&quot;1&quot;.equals(isLock)) &#123; updateAirSettlementTask(); &#125;else&#123; log.info(&quot;机票结算数据入库定时任务已关闭！&quot;); &#125; &#125; private void updateAirSettlementTask() &#123; //定时任务需要执行的任务 //.............. &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"线程池","slug":"线程池","date":"2023-11-01T06:56:08.000Z","updated":"2023-11-01T07:00:28.000Z","comments":true,"path":"2023/11/01/线程池/","link":"","permalink":"http://example.com/2023/11/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"参数说明：1.corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，才会根据是否存在空闲线程，来决定是否需要创建新的线程。除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。2.maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。3.keepAliveTime（线程存活保持时间）：默认情况下，当线程池的线程个数多于corePoolSize时，线程的空闲时间超过keepAliveTime则会终止。但只要keepAliveTime大于0，allowCoreThreadTimeOut(boolean) 方法也可将此超时策略应用于核心线程。另外，也可以使用setKeepAliveTime()动态地更改参数。4.unit（存活时间的单位）：时间单位，分为7类，从细到粗顺序：NANOSECONDS（纳秒），MICROSECONDS（微妙），MILLISECONDS（毫秒），SECONDS（秒），MINUTES（分），HOURS（小时），DAYS（天）；5.workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。可以使用此队列与线程池进行交互：如果运行的线程数少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。如果运行的线程数等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。6.threadFactory（线程工厂）：用于创建新线程。由同一个threadFactory创建的线程，属于同一个ThreadGroup，创建的线程优先级都为Thread.NORM_PRIORITY，以及是非守护进程状态。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）;7.handler（线程饱和策略）：当线程池和队列都满了，则表明该线程池已达饱和状态。ThreadPoolExecutor.AbortPolicy：处理程序遭到拒绝，则直接抛出运行时异常 RejectedExecutionException。(默认策略)ThreadPoolExecutor.CallerRunsPolicy：调用者所在线程来运行该任务，此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。ThreadPoolExecutor.DiscardPolicy：无法执行的任务将被删除。ThreadPoolExecutor.DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重新尝试执行任务（如果再次失败，则重复此过程）。","categories":[],"tags":[]},{"title":"数据库事务","slug":"数据库事务","date":"2023-10-25T06:38:15.000Z","updated":"2023-10-25T06:47:04.000Z","comments":true,"path":"2023/10/25/数据库事务/","link":"","permalink":"http://example.com/2023/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"什么是事务 事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。可以通俗理解为：就是把多件事情当做一件事情来处理，好比大家同在一条船上，要活一起活，要完一起完 。 事物的四个特性（ACID）● 原子性（Atomicity）：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。 eg：拿转账来说，假设用户A和用户B两者的钱加起来一共是20000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是20000，这就是事务的一致性。 ● 一致性（Consistency）：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。● 隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 ● 持久性（Durability）：当事务正确完成后，它对于数据的改变是永久性的。 eg： 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 并发事务导致的问题 在许多事务处理同一个数据时，如果没有采取有效的隔离机制，那么并发处理数据时，会带来一些的问题。 ● 第一类丢失更新：撤销一个事务时，把其他事务已提交的更新数据覆盖。 eg：小明去银行柜台存钱，他的账户里原来的余额为100元，现在打算存入100元。在他存钱的过程中，银行年费扣了5元，余额只剩95元。突然他又想着这100元要用来请女朋友看电影吃饭，不打算存了。在他撤回存钱操作后，余额依然为他存钱之前的100元。所以那5块钱到底扣了谁的？ ● 脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 eg：小明的银行卡余额里有100元。现在他打算用手机点一个外卖饮料，需要付款10元。但是这个时候，他的女朋友看中了一件衣服95元，她正在使用小明的银行卡付款。于是小明在付款的时候，程序后台读取到他的余额只有5块钱了，根本不够10元，所以系统拒绝了他的交易，告诉余额不足。但是小明的女朋友最后因为密码错误，无法进行交易。小明非常郁闷，明明银行卡里还有100元，怎么会余额不足呢？（他女朋友更郁闷。。。） ● 幻读也叫虚读：一个事务执行两次查询，第二次结果集包含第一次中没有或某些行已经被删除的数据，造成两次结果不一致，只是另一个事务在这两次查询中间插入或删除了数据造成的。幻读是事务非独立执行时发生的一种现象。 eg：例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 ● 不可重复读：一个事务两次读取同一行的数据，结果得到不同状态的结果，中间正好另一个事务更新了该数据，两次结果相异，不可被信任。 eg：例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 Tips：不可重复读和脏读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 Tips：幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 ● 第二类丢失更新：是不可重复读的特殊情况。如果两个事物都读取同一行，然后两个都进行写操作，并提交，第一个事物所做的改变就会丢失。 eg：小明和女朋友一起去逛街。女朋友看中了一支口红，（对，女朋友就是用来表现买买买的）小明大方的掏出了自己的银行卡，告诉女朋友：亲爱的，随便刷，随便买，我坐着等你。然后小明就坐在商城座椅上玩手机，等着女朋友。这个时候，程序员的聊天群里有人推荐了一本书，小明一看，哎呀，真是本好书，还是限量发行呢，我一定更要买到。于是小明赶紧找到购买渠道，进行付款操作。而同时，小明的女朋友也在不亦乐乎的买买买，他们同时进行了一笔交易操作，但是这个时候银行系统出了问题，当他们都付款成功后，却发现，银行只扣了小明的买书钱，却没有扣去女朋友此时交易的钱。哈哈哈，小明真是太开心了！ 数据库事务的隔离级别 事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。 Read uncommitted（最低级别，任何情况都无法保证。）读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。 eg：老板要给程序员发工资，程序员的工资是3.6万&#x2F;月。但是发工资时老板不小心按错了数字，按成3.9万&#x2F;月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。 Analyse：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。 那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。 Read committed（可避免脏读的发生。）读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 eg：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的… Analyse：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。 那怎么解决可能的不可重复读问题？Repeatable read ！ Repeatable read（可避免脏读、不可重复读的发生。）重复读，就是在开始读取数据（事务开启）时，不再允许修改操作 eg：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。 Analyse：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。 什么时候会出现幻读？ eg：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。 那怎么解决幻读问题？Serializable！ Serializable（可避免脏读、不可重复读、幻读的发生。） 序列化Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。 Tips：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。 Mysql的默认隔离级别是Repeatable read。 Tips：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 Tips：设置数据库的隔离级别一定要是在开启事务之前。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"CORS跨域","slug":"CORS跨域","date":"2023-10-22T04:51:57.000Z","updated":"2023-10-23T16:14:25.000Z","comments":true,"path":"2023/10/22/CORS跨域/","link":"","permalink":"http://example.com/2023/10/22/CORS%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"为什么会有跨域的问题？为了保证用户信息的安全，所有的浏览器都遵循同源策略，那什么情况下算同源呢？同源策略又是什么呢？ 记住：协议、域名、端口号完全相同时，才是同源 可以参考 Web安全 - 浏览器的同源策略 在同源策略下，会有以下限制： 无法获取非同源的 Cookie、LocalStorage、SessionStorage 等无法获取非同源的 dom无法向非同源的服务器发送 ajax 请求但是我们又经常会遇到前后端分离，不在同一个域名下，需要ajax请求数据的情况。那我们就要规避这种限制。 可以在网上搜到很多解决跨域的方法，有些方法比较古老了，现在项目中用的比较多的是 jsonp 和 CORS（跨域资源共享），这篇主要讲 CORS 的原理和具体实践。 CORS 跨域原理CORS 跨域的原理实际上是浏览器与服务器通过一些 HTTP 协议头来做一些约定和限制。可以查看 HTTP-访问控制（CORS） 与跨域相关的协议头 请求头 说明 Origin 表明预检请求或实际请求的源站URL，不管是否跨域ORIGIN字段总是被发送 Access-Control-Request-Method 将实际请求所使用的HTTP方法告诉服务器 Access-Control-Request-Headers 将实际请求所携带的首部字段告诉服务器 响应头 说明 Access-Control-Allow-Origin 指定允许访问该资源的外域URI，对于携带身份凭证的请求不可使用通配符 Access-Control-Expose-Headers 指定XMLHttpRequest的getResponseHeader可以访问的响应头 Access-Control-Max-Age 指定preflight请求的结果能够被缓存多久 Access-Control-Allow-Credentials 是否允许浏览器读取response的内容；当 Access-Control-Allow-Methods 指定实际请求所允许使用的HTTP方法 Access-Control-Allow-Headers 指定实际请求中允许携带的首部字段 代码实例这里写了个 demo，一步步来分析。目录如下： 12345678910111213141516171819202122232425262728293031.├── README.md├── client│ ├── index.html│ └── request.js└── server ├── pom.xml ├── server-web │ ├── pom.xml │ ├── server-web.iml │ └── src │ └── main │ ├── java │ │ └── com │ │ └── example │ │ └── cors │ │ ├── constant │ │ │ └── Constants.java │ │ ├── controller │ │ │ └── CorsController.java │ │ └── filter │ │ └── CrossDomainFilter.java │ ├── resources │ │ └── config │ │ └── applicationContext-core.xml │ └── webapp │ ├── WEB-INF │ │ ├── dispatcher-servlet.xml │ │ └── web.xml │ └── index.jsp └── server.iml Client：前端，简单的ajax请求在client文件夹下，启动静态服务器，前端页面通过http://localhost:8000/index.html访问： 1anywhere -h localhost -p 8000 Server： java项目，SpringMVC在 IntelliJ IDEA 中本地启动 tomcat，设置host: http://localhost:8080/，服务端数据通过http://localhost:8080/server/cors请求。 这里前端和后端因为端口号不同，存在跨域限制，下面通过 CORS 来解决因为跨域无法通过ajax请求数据的问题。 没有允许跨域的情况这种情况就是前端什么都不做，服务端也什么都不做。 Client: 请求成功后，将数据显示在页面上 12345new Request().send(&#x27;http://localhost:8080/server/cors&#x27;,&#123; success: function(data)&#123; document.write(data) &#125;&#125;); Server: 123456789@Controller@RequestMapping(&quot;/server&quot;)public class CorsController &#123; @RequestMapping(value=&quot;/cors&quot;, method= RequestMethod.GET) @ResponseBody public String ajaxCors(HttpServletRequest request) throws Exception&#123; return &quot;SUCCESS&quot;; &#125;&#125; 在浏览器地址栏输入http://localhost:8080/server/cors直接请求服务端，可以看到返回结果： ‘SUCCESS’ 在浏览器地址栏输入http://localhost:8000/index.html，从不同域的网页中向 Server 发送 ajax 请求。可以看到几个方面： 从 network 可以看到，请求返回正常。 但 Response 中没有内容，显示 Failed to load response data。 并且控制台报错： 总结： 浏览器请求是发出去了的，服务端也会正确返回，但是我们拿不到response的内容 浏览器控制台会报错提示可以怎么做，而且提示的很明白： xhr不能请求http://localhost:8080/server/cors，请求资源的响应头中没有设置Access-Control-Allow-Origin，Origin：http://localhost:8000是不允许跨域请求的。 那下一步，我们要在服务端响应跨域请求时，设置响应头: Access-Control-Allow-Origin 设置 Access-Control-Allow-Origin 允许跨域先说明为什么要设置 Access-Control-Allow-Origin，可以把 Access-Control-Allow-Origin 当作一个指令，服务端设置 Access-Control-Allow-Origin 就是告诉浏览器允许向服务端请求资源的域名，浏览器通过 Response 中的 Access-Control-Allow-Origin 就可以知道能不能把数据吐出来。 官方解释是这样的： Access-Control-Allow-Origin 响应头指定了该响应的资源是否被允许与给定的 origin 共享。 Access-Control-Allow-Origin可以设置的值有： 12Access-Control-Allow-Origin: *Access-Control-Allow-Origin: 那在java服务端给响应头设置 Access-Control-Allow-Origin 可以这么做： 1、添加一个过滤器 123456789public class CrossDomainFilter implements Filter&#123; public void init(FilterConfig filterConfig) throws ServletException &#123;&#125; public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse resp = (HttpServletResponse)servletResponse; resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8000&quot;); filterChain.doFilter(servletRequest,servletResponse); &#125; public void destroy() &#123;&#125;&#125; 2、然后在web.xml文件中添加过滤器配置： 12345678&lt;filter&gt; &lt;filter-name&gt;crossDomainFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.example.cors.filter.CrossDomainFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;crossDomainFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、然后重新启动tomcat，client重新发送请求http://localhost:8000/index.html 可以看到我们能够拿到返回结果了，响应头中有我们在服务端设置的Access-Control-Allow-Origin: http://localhost:8000，这个应该跟请求头中的origin一致，或者设置Access-Control-Allow-Origin:*也是可以的，这就允许任何网站来访问资源了（前提是不带凭证信息，这个后面讲） 以上就是允许一个简单的跨域请求的做法，只需要服务端设置响应头Access-Control-Allow-Origin。 简单请求与预检请求上面讲述了一个简单请求通过在服务端设置响应头 Access-Control-Allow-Origin 就可以完成跨域请求。 那怎样的请求算是一个简单请求？与简单请求相对应的是什么样的请求呢？解决跨域的方式又有什么不一样呢？ 符合以下条件的可视为简单请求： 1、使用下列 HTTP 方法之一 123456- GET- HEAD- POST，并且Content-Type的值在下列之一： - text/plain - multipart/form-data - application/x-www-form-urlencoded 2、并且请求头中只有下面这些 123456789- Accept- Accept-Language- Content-Language- Content-Type （需要注意额外的限制）- DPR- Downlink- Save-Data- Viewport-Width- Width 不满足上述要求的在发送正式请求前都要先发送一个预检请求，预检请求以 OPTIONS 方法发送，浏览器通过请求方法和请求头能够判断是否发送预检请求。 比如 Client 发送如下请求： 123456789new Request().send(&#x27;http://localhost:8080/server/options&#x27;,&#123; method: &#x27;POST&#x27;, header: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; //告诉服务器实际发送的数据类型 &#125;, success: function(data)&#123; document.write(data) &#125;&#125;); Server 端处理请求的 controller: 123456789@Controller@RequestMapping(&quot;/server&quot;)public class CorsController &#123; @RequestMapping(value=&quot;/options&quot;, method= RequestMethod.POST) @ResponseBody public String options(HttpServletRequest request) throws Exception&#123; return &quot;SUCCESS&quot;; &#125;&#125; 因为请求时，请求头中塞入了 header，’Content-Type’: ‘application&#x2F;json’。根据前面讲述的可以知道，浏览器会以 OPTIONS 方法发出一个预检请求，浏览器会在请求头中加入： 12Access-Control-Request-Headers:content-typeAccess-Control-Request-Method:POST 这个预检请求的作用在这里就是告诉服务器：我会在后面请求的请求头中以 POST 方法发送数据类型是application&#x2F;json 的请求，询问服务器是否允许。 在这里服务器还没有做任何允许这种请求的设置，所以浏览器控制台报错： 也清楚的说明了出错的原因： 服务端在预检请求的响应中没有告诉浏览器允许协议头 Content-Type，即服务端需要设置响应头 Access-Control-Allow-Headers，允许浏览器发送带 Content-Type 的请求。 Server端过滤器中添加Access-Control-Allow-Headers： 12345678910public class CrossDomainFilter implements Filter&#123; public void init(FilterConfig filterConfig) throws ServletException &#123;&#125; public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse resp = (HttpServletResponse)servletResponse; resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8000&quot;); resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;); filterChain.doFilter(servletRequest,servletResponse); &#125; public void destroy() &#123;&#125;&#125; 可以看到请求成功 再来看请求的具体信息，第一次以 OPTIONS 方法发送预检请求，浏览器设置请求头： 12Access-Control-Request-Headers:content-type //请求中加入的请求头Access-Control-Request-Method:POST //跨域请求的方法 服务端设置响应头： 12Access-Control-Allow-Headers:Content-Type //允许的headerAccess-Control-Allow-Origin:http://localhost:8000 //允许跨域的源 也可以设置 Access-Control-Allow-Methods 来限制客户端的的请求方法。 这样预检请求成功了，浏览器会发出第二个请求，这是真正请求数据的请求： 可以看到 POST 请求成功了，第二次请求头中没有设置 Access-Control-Request-Headers 和 Access-Control-Request-Method。 但是这里有个问题，需要预检请求时，浏览器会发出两次请求，一次 OPTIONS，一次 POST。两次都返回了数据。这样服务端如果逻辑复杂一些，比如去数据库查找数据，从 web 层、 service 到数据库这段逻辑就会走两遍，浏览器会两次拿到相同的数据，所以服务端的 filter 可以改一下，如果是 OPTIONS 请求，在设置完跨域请求响应头后就不走后面的逻辑直接返回。 1234567891011121314151617public class CrossDomainFilter implements Filter&#123; public void init(FilterConfig filterConfig) throws ServletException &#123;&#125; public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse resp = (HttpServletResponse)servletResponse; resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8000&quot;); resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;); //OPTION请求就直接返回 HttpServletRequest req = (HttpServletRequest) servletRequest; if (req.getMethod().equals(&quot;OPTIONS&quot;)) &#123; resp.setStatus(200); resp.flushBuffer(); &#125;else &#123; filterChain.doFilter(servletRequest,servletResponse); &#125; &#125; public void destroy() &#123;&#125;&#125; 总结： ** 对于POST请求设置响应头Content-Type为某些值、自定义请求头等情况，浏览器会先以OPTIONS方法发送一个预检请求，并设置相应的请求头。 服务端还是正常返回，但如果预检请求响应头中不设置相应的响应头，预检请求不通过，不会再发出第二次请求来获取数据。 服务端设置相应的响应头，浏览器会发出第二个请求，并将服务端返回的数据吐出，我们可以获得response的内容 带凭证信息的请求还有一种情况我们经常遇到。浏览器在发送请求时需要给服务端发送 cookie，服务端根据 cookie 中的信息做一些身份验证等。 默认情况下，浏览器向不同域的发送 ajax 请求，不会携带发送 cookie 信息。 Client: 123456var containerElem = document.getElementById(&#x27;container&#x27;)new Request().send(&#x27;http://localhost:8080/server/testCookie&#x27;,&#123; success: function(data)&#123; containerElem.innerHTML = data &#125;&#125;); Server: 1234567891011@RequestMapping(value=&quot;/testCookie&quot;, method= RequestMethod.GET)@ResponseBodypublic String testCookie(HttpServletRequest request,HttpServletResponse response) throws Exception&#123; String str = &quot;SUCCESS&quot;; Cookie[] cookies = request.getCookies(); String school = getSchool(cookies); if(school == null || school.length() == 0)&#123; addCookie(response); &#125; return str + buildText(cookies);&#125; 服务端收到请求，判断 cookie 中有没有 school，没有就添加 cookie. 可以看到响应头中有 Set-Cookie，再次请求时，如果是同源请求，浏览器会将 Set-Cookie 中的值放在请求头中，但是对于跨域请求，默认是不发送这个 Cookie 的。 如果要让浏览器发送 cookie，需要在 Client 设置 XMLHttpRequest 的 withCredentials 属性为 true。 Client: 1234567var containerElem = document.getElementById(&#x27;container&#x27;)new Request().send(&#x27;http://localhost:8080/server/testCookie&#x27;,&#123; withCredentials: true, success: function(data)&#123; containerElem.innerHTML = data &#125;&#125;); 现在浏览器在请求头中加入了 cookie 信息 但是服务端返回的数据没有在页面中展示，并且报错： 报错信息很明白： 当请求中包含凭证信息时，需要设置响应头 Access-Control-Allow-Credentials，是否带凭证信息是由 XMLHttpRequest的withCredentials 属性控制的。 ** 所以我们在 Server 端 filter 中加入这个响应头： 123456789101112public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse resp = (HttpServletResponse)servletResponse; resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8000&quot;); resp.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;); HttpServletRequest req = (HttpServletRequest) servletRequest; if (req.getMethod().equals(&quot;OPTIONS&quot;)) &#123; resp.setStatus(200); resp.flushBuffer(); &#125;else &#123; filterChain.doFilter(servletRequest,servletResponse); &#125; &#125; 现在浏览器知道响应头中 Access-Control-Allow-Credentials 为 true，就会把数据给吐出来了，我们能够从response 中拿到内容了。 那如果附带凭证信息并且有预检请求呢？如果有预检请求，并附带凭证信息（ XMLHttpRequest 的withCredentials 设置为 true）， 服务端需要设置 Access-Control-Allow-Credentials: true，否则浏览器不会发出第二次请求，并报错。 总结： 跨域请求时，浏览器默认不会发送cookie，需要设置XMLHttpRequest的withCredentials属性为true 浏览器设置XMLHttpRequest的withCredentials属性为true，表明要向服务端发送凭证信息(这里是cookie)。那么服务端就需要在响应头中添加Access-Control-Allow-Credentials为true。否则浏览器上有两种情况： 如果是简单请求，服务端结果吐出了，浏览器拿到了但就是不给吐出来，并报错。 如果是预检请求，同样我们拿不到返回结果，并报错提示预检请求不通过，不会再发第二次请求。 其他cookie 的同源策略另外就是设置了 XMLHttpRequest 的 withCredentials 属性为 true，浏览器发出去了，服务端还是拿不到 cookie的问题。 cookie 也遵循同源策略的，在设置 cookie 的时候可以发现除了键值对，还可以设置 cookie 的这些值： 如果获取不到 cookie，可以检查下 cookie 的 domain 和 path. IE 上跨域访问没有权限在跨域发送 ajax 请求时提示没有权限。 因为IE浏览器默认对跨域访问有限制。需要在浏览器设置中去除限制。 方法： 设置 &gt; Internet 选项 &gt; 安全 &gt; 自定义级别 &gt; 在设置中找到其他 - 在【其他】中将【通过域访问数据源】启用。 Demo 源码CORS Demo 源码","categories":[],"tags":[{"name":"CORS","slug":"CORS","permalink":"http://example.com/tags/CORS/"}]},{"title":"RabbitMQ详细学习笔记","slug":"RabbitMQ详细学习笔记","date":"2023-10-18T10:36:55.000Z","updated":"2023-10-18T14:48:05.000Z","comments":true,"path":"2023/10/18/RabbitMQ详细学习笔记/","link":"","permalink":"http://example.com/2023/10/18/RabbitMQ%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、MQ相关的概念1.1、MQ的基本概念什么是MQMQ(message queue)，从字面意思上看就个 FIFO 先入先出的队列，只不过队列中存放的内容是 message 而已，它是一种具有接收数据、存储数据、发送数据等功能的技术服务在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务，用于上下游传递消息。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务 为什么用MQ常见的MQ消息中间件有很多，例如ActiveMQ、RabbitMQ、Kafka、RocketMQ等等。那么为什么我们要使用它呢？因为它能很好的帮我解决一些复杂特殊的场景： 1. 高并发的流量削峰假设某订单系统每秒最多能处理一万次订单，也就是最多承受的10000qps，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。 2.应用解耦以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性 3.异步处理有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息队列，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。 4.分布式事务以订单服务为例，传统的方式为单体应用，支付、修改订单状态、创建物流订单三个步骤集成在一个服务中，因此这三个步骤可以放在一个jdbc事务中，要么全成功，要么全失败。而在微服务的环境下，会将三个步骤拆分成三个服务，例如：支付服务，订单服务，物流服务。三者各司其职，相互之间进行服务间调用，但这会带来分布式事务的问题，因为三个步骤操作的不是同一个数据库，导致无法使用jdbc事务管理以达到一致性。而 MQ 能够很好的帮我们解决分布式事务的问题，有一个比较容易理解的方案，就是二次提交。基于MQ的特点，MQ作为二次提交的中间节点，负责存储请求数据，在失败的情况可以进行多次尝试，或者基于MQ中的队列数据进行回滚操作，是一个既能保证性能，又能保证业务一致性的方案。 5.数据分发MQ 具有发布订阅机制，不仅仅是简单的上游和下游一对一的关系，还有支持一对多或者广播的模式，并且都可以根据规则选择分发的对象。这样一份上游数据，众多下游系统中，可以根据规则选择是否接收这些数据，能达到很高的拓展性。 RabbitMQ简介2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。 优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备、健壮、稳定、易用、跨平台、支持多种语言如Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。 缺点：商业版需要收费，学习成本较高。 选用场景：结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。 1.2、消息队列协议什么是协议协议：是在TCP&#x2F;IP协议基础之上构建的种约定成的规范和机制，目的是让客户端进行沟通和通讯。并且这种协议下规范必须具有持久性，高可用，高可靠的性能。 为什么不直接采用TCP&#x2F;IP协议去传递消息？因为TCP&#x2F;IP协议太过于简单，并不能承载消息的内容和载体，因此在此之上增加一些内容，给消息的传递分发高可用提供基础。 我们知道消息中间件负责数据的传递，存储，和分发消费三个部分，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，是采用底层的TCP&#x2F;IP，UDP协议还是在这基础上自己构建等，而这些约定成俗的规范就称之为：协议。 12345所谓协议是指：1.计算机底层操作系统和应用程序通讯时共同遵守的组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。2.和一般的网络应用程序的不同，它主要负责数据的接受和传递，所以性能比较的高。3.协议对数据格式和计算机之间交换数据都必须严格遵守规范。 网络协议的三要素 语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。 语义：语义是解控制信息每个部分的意义。它规定了需要发出何种控制信息以及完成的动作与做出什么样的响应。 时序：时序是对事件发生顺序的详细说明。1234# 类比http请求协议1. 语法：htp规定了请求报文和响应报文的格式2. 语义：客户端主动发起请求称之为请求。（这是一种定义，同时你发起的是post/get请求）3. 时序：一个请求对应个响应。（定先有请求在有响应，这个是时序） 而消息中间件采用的并不是http协议，而常见的消息中间件协议有：OpenWire、AMQP、MQTT、Kafka、OpenMessage协议 1234面试题：为什么消息中间件不直接使用http协议呢？因为http请求报文头和响应报文头是比较复杂的，包含了cookie、数据的加密解密、状态码、晌应码等附加的功能，但是对于个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就够，要追求的是高性能。尽量简洁，快速。大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。 常用消息中间件协议1. AMQP协议（Advanced Message Queuing Protocol—高级消息队列协议）12它由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。 特性： 分布式事务支、消息的持久化支持、高性能和高可靠的消息处理优势 AMQP典型的实现者是RabbitMQ、ACTIVEMQ等，其中RabbitMQ由Erlang开发 2.MQTT协议（Message Queueing Telemetry Transport—消息队列遥测传输协议）1它是一种基于发布/订阅（publish/subscribe）模式的&quot;轻量级&quot;通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。 特点：轻量、结构简单、传输快、不支持事务、没有持久化设计 应用场景：适用于计算能力有限、低带宽、网络不稳定的场景 支持者：RabbitMQ、ACTIVEMQ（默认情况下关闭，需要打开） 3.OpenMessage协议是近几年由阿里、雅虎和滴滴出行、 Stremalio等公司共同参与创立的分布式消息中间件、流处理等领域的应用开发标准。特点： 结构简单、解析速度快、支持事务和持久化设计 4.Kafka协议基于TCP&#x2F;IP的二进制协议。消息内部是通过长度来分割，由些基本数据类型组成。特点： 结构简单、解析速度快、无事务支持、有持久化设计 1.3、消息队列持久化持久化简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。 1.4、消息的分发策略MQ消息队列有如下几个角色： Producer：消息生产者。负责产生和发送消息到 Broker Broker：消息处理中心。负责消息存储、确认、重试等，一般其中会包含多个 queue Consumer：消息消费者。负责从 Broker 中获取消息，并进行相应处理生产者产生消息后，MQ进行存储，消费者如何获得消息呢？ 一般的获取方式无外乎外推（push）或者（pull）两种方式，典型的git就有推拉机制，我们发送的http请求就是一种典型的拉取数据库数据返回的过程。而消息队列MQ是一种推送过程，而这些推机制会适用到很多的业务场景，也有很多对应的推机制策略 RabbitMQ消息分发策略的机制支持：发布订阅、轮询分发、公平分发、重发、消息拉取 1.5、消息队列的高可用和高可靠123所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力。当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU、内存、磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。 主要方法有：Master-slave主从共享数据的部署方式、Master-slave主从同步部署方式、多主集群同步部署模式、多主集群转发部署模式、Master-slave与Breoker-cluster组合的方案这些集群模式最终目的都是为保证：消息服务器不会挂掉，出现了故障依然可以抱着消息服务继续使用。反正终归三句话： 要么消息共享要么消息同步要么元数据兴享 二、RabbitMQ快速入门2.1、RabbitMQ的概念RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于：它不处理快件而是接收，存储和转发消息数据。 2.2 AMQP协议RabbitMQ是一种遵循AMQP协议的分布式消息中间件。AMQP 全称 “Advanced Message Queuing Protocol”，高级消息队列协议。它是应用层协议的一个开发标准，为面向消息的中间件设计 2.3 RabbitMQ架构组成 Broker：就是 RabbitMQ 服务，用于接收和分发消息，接受客户端的连接，实现 AMQP 实体服务。 Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange 或 queue 等。 Connection：连接，生产者&#x2F;消费者与 Broker 之间的 TCP 网络连接。Channel：网络信道，如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立连接的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销。 Message：消息，服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。 Virtual Host：虚拟节点，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若干个Exhange和Queue，同一个虚拟主机里面不能有相同名字的Exchange Exchange：交换机，是 message 到达 broker 的第一站，用于根据分发规则、匹配查询表中的 routing key，分发消息到 queue 中去，不具备消息存储的功能。常用的类型有：direct、topic、fanout。 Bindings：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。 Routing key：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息 Queue：消息队列，保存消息并将它们转发给消费者进行消费。 2.4四大核心概念 生产者：产生数据发送消息的程序是生产者。 交换机：交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个是由交换机类型决定的。 队列：队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。 消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。 2.5、RabbitMQ角色分类 none：不能访问 management plugin management：查看自己相关节点信息 列出自己可以通过AMQP登入的虚拟机 查看自己的虚拟机节点virtual hosts的queues，exchanges和bindings信息 查看和关闭自己的channels和connections 查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息 Policymaker 包含management所有权跟 查看和创建和删除自己的virtual hosts所属的policies和parameters信息 Monitoring 包含management所有权限 罗列出所有的virtual hosts，包括不能登录的virtual hosts 查看其他用户的connections和channels信息 查看节点级别的数据如clustering和memory使用情况 查看所有的virtual hosts的全局统计信息。 Administrator 最高权限 可以创建和删除 virtual hosts 可以查看，创建和删除users 查看创建permissions 关闭所有用户的connections 2.6、RabbitMQ消息模式RabbitMQ提供6种模式，分别是 Hello World、Work Queues、Publish&#x2F;Subscribe、Routing、Topics、RPC。其中 Publish&#x2F;Subscribe、Routing、Topics 三种模式可以统一归为 Exchange 模式，只是创建时交换机的类型不一样，分别是 fanout、direct、topic 三种交换机类型。 简单模式一个生产者，一个消费者，一个队列，采用默认交换机。可以理解为生产者P发送消息到队列Q，一个消费者C接收。 工作模式一个生产者，多个消费者，一个队列，采用默认交换机。可以理解为生产者P发送消息到队列Q，可以由多个消费者C1、C2进行接收。 发布&#x2F;订阅模式（fanout）功能：一个生产者、一个 fanout 类型的交换机、多个队列、多个消费者。一个生产者发送的消息会被多个消费者获取。其中 fanout 类型就是发布订阅模式，只有订阅该生产者的消费者会收到消息。 路由模式（direct）功能：一个生产者，一个 direct 类型的交换机，多个队列，交换机与队列之间通过 routing-key 进行关联绑定，多个消费者。生产者发送消息到交换机并且要指定routing-key，然后消息根据这交换机与队列之间的 routing-key 绑定规则进行路由被指定消费者消费。 主题模式（topic）一个生产者，一个 topic 类型的交换机，多个队列，交换机与队列之间通过 routing-key 进行关联绑定，多个消费者。生产者发送消息到交换机并且要指定 routing-key，然后消息根据这交换机与队列之间的 routing-key 绑定规则进行路由被指定消费者消费。与路由模式不同是 routing-key 有指定的队则，可以更加的通用，满足更过的场景。routing-key 的规则如下： #：匹配一个或者多个词，例如lazy.# 可以匹配 lazy.xxx 或者 lazy.xxx.xxx ：只能匹配一个词，例如lazy. 只能匹配 lazy.xxx 参数模式作用：可以携带参数，根据参数进行过滤 三、简单模式四、工作模式五、RabbitMQ交换机Exchanges简介RabbitMQ 消息传递模型的核心思想是：生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。 相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。Exchanges 的类型总共有四种：直接(direct)、主题(topic)、标题(headers)、扇出(fanout)","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://example.com/tags/RabbitMQ/"}]},{"title":"Redis-锁机制","slug":"Redis-锁机制","date":"2023-10-17T11:30:45.000Z","updated":"2023-10-19T11:03:30.000Z","comments":true,"path":"2023/10/17/Redis-锁机制/","link":"","permalink":"http://example.com/2023/10/17/Redis-%E9%94%81%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、实现原理1.1基本原理JDK 原生的锁可以让不同线程之间以互斥的方式来访问共享资源，但如果想要在不同进程之间以互斥的方式来访问共享资源，JDK 原生的锁就无能为力了。此时可以使用 Redis 来实现分布式锁。 Redis 实现分布式锁的核心命令如下： 1SETNX key value SETNX 命令的作用是：如果指定的 key 不存在，则创建并为其设置值，然后返回状态码 1；如果指定的 key 存在，则直接返回 0。如果返回值为 1，代表获得该锁；此时其他进程再次尝试创建时，由于 key 已经存在，则都会返回 0 ，代表锁已经被占用。 当获得锁的进程处理完成业务后，再通过 del 命令将该 key 删除，其他进程就可以再次竞争性地进行创建，获得该锁。 通常为了避免死锁，我们会为锁设置一个超时时间，在 Redis 中可以通过 expire 命令来进行实现： 1EXPIRE key seconds 这里我们将两者结合起来，并使用 Jedis 客户端来进行实现，其代码如下： 12345Long result = jedis.setnx(&quot;lockKey&quot;, &quot;lockValue&quot;);if (result == 1) &#123; // 如果此处程序被异常终止（如直接kill -9进程），则设置超时的操作就无法进行，该锁就会出现死锁 jedis.expire(&quot;lockKey&quot;, 3);&#125; 上面的代码存在原子性问题，即 setnx + expire 操作是非原子性的，如果在设置超时时间前，程序被异常终止，则程序就会出现死锁。此时可以将 SETNX 和 EXPIRE 两个命令写在同一个 Lua 脚本中，然后通过调用 Jedis 的 eval() 方法来执行，并由 Redis 来保证整个 Lua 脚本操作的原子性。这种方式实现比较繁琐，因此官方文档中推荐了另外一种更加优雅的实现方法： 1.2 官方推荐[官方文档]( Distributed locks with Redis) 中推荐直接使用 set 命令来进行实现： 1SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL] 这里我们主要关注以下四个参数： EX ：设置超时时间，单位是秒； PX ：设置超时时间，单位是毫秒； NX ：当且仅当对应的 Key 不存在时才进行设置； XX：当且仅当对应的 Key 存在时才进行设置。这四个参数从 Redis 2.6.12 版本开始支持，因为当前大多数在用的 Redis 都已经高于这个版本，所以推荐直接使用该命令来实现分布式锁。对应的 Jedis 代码如下：1jedis.set(&quot;lockKey&quot;, &quot;lockValue&quot;, SetParams.setParams().nx().ex(3)); 此时一条命令就可以完成值和超时时间的设置，并且因为只有一条命令，因此其原子性也得到了保证。但因为引入了超时时间来避免死锁，也带来一些问题。可以估计业务的最大处理时间，然后保证设置的过期时间大于最大处理时间。但是由于业务会面临各种复杂的情况，因此可能无法保证业务每一次都能在规定的过期时间内处理完成，此时可以使用延长锁时效的策略。 1.3 延长锁时效延长锁时效的方案如下：假设锁超时时间是 30 秒，此时程序需要每隔一段时间去扫描一下该锁是否还存在，扫描时间需要小于超时时间，通常可以设置为超时时间的 1&#x2F;3，在这里也就是 10 秒扫描一次。如果锁还存在，则重置其超时时间恢复到 30 秒。通过这种方案，只要业务还没有处理完成，锁就会一直有效；而当业务一旦处理完成，程序也会马上删除该锁。 Redis 的 Java 客户端 Redisson 提供的分布式锁就支持类似的延长锁时效的策略，称为 WatchDog，直译过来就是 “看门狗” 机制。 以上讨论的都是单机环境下的 Redis 分布式锁，而想要保证 Redis 分布式锁是高可用，首先 Redis 得是高可用的，Redis 的高可用模式主要有两种：哨兵模式和集群模式。以下分别进行讨论： 二、哨兵模式与分布式锁哨兵模式是主从模式的升级版，能够在故障发生时自动进行故障切换，选举出新的主节点。但由于 Redis 的复制机制是异步的，因此在哨兵模式下实现的分布式锁是不可靠的，原因如下： 由于主从之间的复制操作是异步的，当主节点上创建好锁后，此时从节点上的锁可能尚未创建。而如果此时主节点发生了宕机，从节点上将不会创建该分布式锁； 从节点晋升为主节点后，其他进程（或线程）仍然可以在该新主节点创建分布式锁，此时就存在多个进程（或线程）同时进入了临界区，分布式锁就失效了。因此在哨兵模式下，无法避免锁失效的问题。因此想要实现高可用的分布式锁，可以采取 Redis 的另一个高可用方案 —— Redis 集群模式。 三、集群模式与分布式锁3.1 RedLock 方案想要在集群模式下实现分布式锁，Redis 提供了一种称为 RedLock 的方案，假设我们有 N 个 Redis 实例，此时客户端的执行过程如下： 以毫秒为单位记录当前的时间，作为开始时间； 接着采用和单机版相同的方式，依次尝试在每个实例上创建锁。为了避免客户端长时间与某个故障的 Redis 节点通讯而导致阻塞，这里采用快速轮询的方式：假设创建锁时设置的超时时间为 10 秒，则访问每个 Redis 实例的超时时间可能在 5 到 50 毫秒之间，如果在这个时间内还没有建立通信，则尝试连接下一个实例； 如果在至少 N&#x2F;2+1 个实例上都成功创建了锁。并且 当前时间 - 开始时间 &lt; 锁的超时时间 ，则认为已经获取了锁，锁的有效时间等于 超时时间 - 花费时间（如果考虑不同 Redis 实例所在服务器的时钟漂移，则还需要减去时钟漂移）； 如果少于 N&#x2F;2+1 个实例，则认为创建分布式锁失败，此时需要删除这些实例上已创建的锁，以便其他客户端进行创建。 该客户端在失败后，可以等待一个随机的时间后，再次进行重试。以上就是 RedLock 的实现方案，可以看到主要是由客户端来实现的，并不真正涉及到 Redis 集群相关的功能。因此这里的 N 个 Redis 实例并不要求是一个真正的 Redis 集群，它们彼此之间可以是完全独立的，但由于只需要半数节点获得锁就能真正获得锁，因此其仍然具备容错性和高可用性。后面使用 Redisson 来演示 RedLock 时会再次验证这一点。 3.2 低延迟通讯另外实现 RedLock 方案的客户端与所有 Redis 实例进行通讯时，必须要保证低延迟，而且最好能使用多路复用技术来保证一次性将 SET 命令发送到所有 Redis 节点上，并获取到对应的执行结果。如果网络延迟较高，假设客户端 A 和 B 都在尝试创建锁： 12SET key 随机数A EX 3 NX #A客户端SET key 随机数B EX 3 NX #B客户端 此时可能客户端 A 在一半节点上创建了锁，而客户端 B 在另外一半节点上创建了锁，那么两个客户端都将无法获取到锁。如果并发很高，则可能存在多个客户端分别在部分节点上创建了锁，而没有一个客户端的数量超过 N&#x2F;2+1。这也就是上面过程的最后一步中，强调一旦客户端失败后，需要等待一个随机时间后再进行重试的原因，如果是一个固定时间，则所有失败的客户端又同时发起重试，情况就还是一样。 因此最佳的实现就是客户端的 SET 命令能几乎同时到达所有节点，并几乎同时接受到所有执行结果。 想要保证这一点，低延迟的网络通信极为关键，下文介绍的 Redisson 就采用 Netty 框架来保证这一功能的实现 3.3 持久化与高可用为了保证高可用，所有 Redis 节点还需要开启持久化。假设不开启持久化，假设进程 A 获得锁后正在处理业务逻辑，此时节点宕机重启，因为锁数据丢失了，其他进程便可以再次创建该锁，因此所有 Redis 节点都需要开启 AOF 的持久化方式。 AOF 默认的同步机制为 everysec，即每秒进程一次持久化，此时能够兼顾性能与数据安全，发生意外宕机的时，最多会丢失一秒的数据。但如果碰巧就是在这一秒的时间内进程 A 创建了锁，并由于宕机而导致数据丢失。此时其他进程还可以创建该锁，锁的互斥性也就失效了。想要解决这个问题有两种方式： 方式一：修改 Redis.conf 中 appendfsync 的值为 always，即每次命令后都进行持久化，此时会降低 Redis 性能，进而也会降低分布式锁的性能，但锁的互斥性得到了绝对的保证； 方式二：一旦节点宕机了，需要等到锁的超时时间过了之后才进行重启，此时相当于原有锁自然失效（但你首先需要保证业务能在设定的超时时间内完成），这种方案也称为延时重启。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"Redis淘汰策略","slug":"Redis淘汰策略","date":"2023-10-17T10:48:26.000Z","updated":"2023-10-17T11:09:46.000Z","comments":true,"path":"2023/10/17/Redis淘汰策略/","link":"","permalink":"http://example.com/2023/10/17/Redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/","excerpt":"","text":"volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。 volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。 volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。 allkeys-lru：从数据集中挑选最近最少使用的数据淘汰 allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。 淘汰策略的意义MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"Mybatis-plus","slug":"mybatisplus","date":"2023-10-16T01:46:48.000Z","updated":"2024-09-13T13:42:42.000Z","comments":true,"path":"2023/10/16/mybatisplus/","link":"","permalink":"http://example.com/2023/10/16/mybatisplus/","excerpt":"","text":"Mybatis-plus1. 什么是MyBatis-PlusMyBatis-Plus 是一个 Mybatis 增强版工具，在 MyBatis 上扩充了其他功能没有改变其基本功能，为了简化开发提交效率而存在。 官网文档地址： https://mp.baomidou.com/guide/ 2. springboot中快速使用Mybatis-plus使用插件使用 IDEA 安装一个 mybatis-plus 插件 增加依赖12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.24&lt;/version&gt;&lt;/dependency&gt; 配置application.yml12345678910111213141516server: port: 8080spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/java160?serverTimezone=Asia/Shanghai&amp;useSSL=false username: root password: root type: com.alibaba.druid.pool.DruidDataSource initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000mybatis: type-aliases-package: com.hyy.entity 增加Config类12345678@Configurationpublic class MyConfig &#123; @Bean(&quot;dataSource&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druid() &#123; return new DruidDataSource(); &#125;&#125; 增加实体类12345678910@Datapublic class Teacher &#123; String tno; String tname; String tsex; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date tbirthday; String prof; String depart;&#125; 编写Mapper类12public interface TeacherMapper extends BaseMapper&lt;Teacher&gt; &#123;&#125; 修改启动类增加@MapperScan注解 123456789@SpringBootApplication@MapperScan(basePackages = &quot;com.hyy.dao&quot;)public class Base04MybatisplusApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base04MybatisplusApplication.class, args); &#125;&#125; 编写测试控制器此控制器跳开service，直接调用了Mapper 123456789@RestControllerpublic class TeacherController &#123; @Autowired TeacherMapper teacherMapper; @RequestMapping(&quot;/getall&quot;) public List&lt;Teacher&gt; selectAll()&#123; return teacherMapper.selectList(null); &#125;&#125; 配置日志123mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 常用注解@TableName：用于表名，放在entity上面，value值是数据库表名（主要用于pojo和数据库表名不一致的情况下） @TableId：用于定义表的主键，其value是表的主键column名，type是指主键类型 @TableField：用于定义表的非主键字段。 ​ value：指定数据库表中的cloumn名 ​ exist：用于表明当前的field是否是数据库表的一个属性，会影响sql语句 ​ fill：用于指定数据的自动填充策略，一般用于修改时间或者创建时间，默认不填充 @TableLogic：用于定义表的逻辑删除字段。 ​ value：用于定义未删除状态的值 ​ delval：用于定义删除状态的值 ​ 代码生成器新版（3.5.1之后）依赖12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 配置1234567891011121314151617181920212223242526272829303132@Test void mybatisGenerator() &#123; String url = &quot;jdbc:mysql://localhost:3306/authc?serverTimezone=UTC&amp;useSSL=false&quot;; //总体配置 FastAutoGenerator fastAutoGenerator = FastAutoGenerator.create(url, &quot;root&quot;, &quot;root&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;mamp&quot;) // 设置作者 //.commentDate(LocalDateTime.now().toString()) //.enableSwagger() // 开启 swagger 模式 .fileOverride() .outputDir(&quot;D://&quot;); // 指定输出目录 &#125;); //包配置 fastAutoGenerator.packageConfig(builder -&gt; &#123; builder.parent(&quot;net&quot;) .moduleName(&quot;system&quot;) .controller(&quot;controller&quot;) .service(&quot;service&quot;) .entity(&quot;domain&quot;) .mapper(&quot;mapper&quot;) .serviceImpl(&quot;impl&quot;); &#125;); //实体策略 fastAutoGenerator.strategyConfig(builder -&gt; &#123; builder.entityBuilder() .naming(NamingStrategy.underline_to_camel) .columnNaming(NamingStrategy.underline_to_camel); builder.controllerBuilder().enableRestStyle(); &#125;); //执行 fastAutoGenerator.execute(); &#125; 模板定义模板定义模板并放在resources&#x2F;templates目录下，以下为controller.java.vm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package $&#123;package.Controller&#125;;import org.springframework.web.bind.annotation.RequestMapping;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import $&#123;package.Entity&#125;.$&#123;entity&#125;;import $&#123;package.Service&#125;.$&#123;table.serviceName&#125;;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.List;#if($&#123;restControllerStyle&#125;)import org.springframework.web.bind.annotation.RestController;#elseimport org.springframework.stereotype.Controller;#end#if($&#123;superControllerClassPackage&#125;)import $&#123;superControllerClassPackage&#125;;#end/** * &lt;p&gt; * $!&#123;table.comment&#125; 前端控制器 * &lt;/p&gt; * * @author $&#123;author&#125; * @since $&#123;date&#125; */#if($&#123;restControllerStyle&#125;)@RestController#else@Controller#end@RequestMapping(&quot;#if($&#123;package.ModuleName&#125;)/$&#123;package.ModuleName&#125;#end/#if($&#123;controllerMappingHyphenStyle&#125;)$&#123;controllerMappingHyphen&#125;#else$&#123;table.entityPath&#125;#end&quot;)#if($&#123;kotlin&#125;)class $&#123;table.controllerName&#125;#if($&#123;superControllerClass&#125;) : $&#123;superControllerClass&#125;()#end#else#if($&#123;superControllerClass&#125;)public class $&#123;table.controllerName&#125; extends $&#123;superControllerClass&#125; &#123;#elsepublic class $&#123;table.controllerName&#125; &#123; &#125;#end @Resource $&#123;table.serviceName&#125; #serviceName(); @GetMapping(&quot;list&quot;) public List&lt;$&#123;entity&#125;&gt; doList()&#123; QueryWrapper&lt;$&#123;entity&#125;&gt; query = new QueryWrapper&lt;&gt;(); query.likeLeft(&quot;phone&quot;,&quot;23&quot;) .like(&quot;email&quot;,&quot;2189&quot;); List&lt;$&#123;entity&#125;&gt; list = #serviceName().list(query); return list; &#125; @GetMapping(&quot;findOne/&#123;id&#125;&quot;) public $&#123;entity&#125; findOne(@PathVariable(&quot;id&quot;) Long id)&#123; return #serviceName().getById(id); &#125; @DeleteMapping(&quot;delete/&#123;id&#125;&quot;) public void deleteOne(@PathVariable(&quot;id&quot;) Long id)&#123; $&#123;table.serviceName.substring(0,1).toLowerCase()&#125;$&#123;table.serviceName.substring(1)&#125;.removeById(id); &#125;&#125;#end#macro(serviceName) $&#123;table.serviceName.substring(0,1).toLowerCase()&#125;$&#123;table.serviceName.substring(1)&#125;#end 修改生成代码12345678910@Test void mybatisGenerator() &#123; ... //resourceLoader使用的是ClasspathResourceLoader，所以只需要写classpath下的目录即可，不需要classpath前缀 String controllerTemplate=&quot;templates/controller.java&quot;; fastAutoGenerator.templateConfig(builder -&gt; &#123; builder.controller(controllerTemplate); &#125;); fastAutoGenerator.execute(); &#125; 旧版（3.4.x)使用代码生成器能够方便的生成所需要的代码 注意在主类中需要增加@EnableAutoConfiguration或者给@SpringBootApplication注解添加属性exclude &#x3D; {DataSourceAutoConfiguration.class} 123456@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)public class GeneratorApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GeneratorApplication.class, args); &#125;&#125; 增加依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 默认的引擎模板--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt; 创建代码生成器1AutoGenerator mpg = new AutoGenerator(); 全局配置123456789101112131415161718192021// Step2：全局配置GlobalConfig gc = new GlobalConfig();// 填写代码生成的目录(需要修改)String projectPath = &quot;D:\\\\springbootProject\\\\springbootsample\\\\base05-mybatisplus-generator&quot;;// 拼接出代码最终输出的目录gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);// 配置开发者信息（可选）（需要修改）gc.setAuthor(&quot;mamp&quot;);// 配置是否打开目录，false 为不打开（可选）gc.setOpen(false);// 实体属性 Swagger2 注解，添加 Swagger 依赖，开启 Swagger2 模式（可选）//gc.setSwagger2(true);// 重新生成文件时是否覆盖，false 表示不覆盖（可选）gc.setFileOverride(false);// 配置主键生成策略，此处为 ASSIGN_ID（可选）gc.setIdType(IdType.ASSIGN_ID);// 配置日期类型，此处为 ONLY_DATE（可选）gc.setDateType(DateType.ONLY_DATE);// 默认生成的 service 会有 I 前缀gc.setServiceName(&quot;%sService&quot;);mpg.setGlobalConfig(gc); 设置数据源1234567891011121314// Step3：数据源配置（需要修改）DataSourceConfig dsc = new DataSourceConfig();// 配置数据库 url 地址String url=&quot;jdbc:mysql://localhost:3306/java160?&quot; +&quot;serverTimezone=Asia/Shanghai&amp;useSSL=false&quot;;System.out.println(url);dsc.setUrl(url);// 配置数据库驱动dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);// 配置数据库连接用户名dsc.setUsername(&quot;root&quot;);// 配置数据库连接密码dsc.setPassword(&quot;root&quot;);mpg.setDataSource(dsc); 设置包123456789101112131415// Step:4：包配置PackageConfig pc = new PackageConfig();// 配置父包名（需要修改）pc.setParent(&quot;com.hyy&quot;);// 配置模块名（需要修改）pc.setModuleName(&quot;system&quot;);// 配置 entity 包名pc.setEntity(&quot;entity&quot;);// 配置 mapper 包名pc.setMapper(&quot;mapper&quot;);// 配置 service 包名pc.setService(&quot;service&quot;);// 配置 controller 包名pc.setController(&quot;controller&quot;);mpg.setPackageInfo(pc); 设置生成策略123456789101112131415161718// Step5：策略配置（数据库表配置）StrategyConfig strategy = new StrategyConfig();// 指定表名（可以同时操作多个表，使用 , 隔开）（需要修改）strategy.setInclude(&quot;teacher&quot;);// 配置数据表与实体类名之间映射的策略strategy.setNaming(NamingStrategy.underline_to_camel);// 配置数据表的字段与实体类的属性名之间映射的策略strategy.setColumnNaming(NamingStrategy.underline_to_camel);// 配置 lombok 模式strategy.setEntityLombokModel(true);// 配置 rest 风格的控制器（@RestController）strategy.setRestControllerStyle(true);// 配置驼峰转连字符strategy.setControllerMappingHyphenStyle(true);// 配置表前缀，生成实体时去除表前缀// 此处的表名为 test_mybatis_plus_user，模块名为 test_mybatis_plus，去除前缀后剩下为 user。// strategy.setTablePrefix(pc.getModuleName() + &quot;_&quot;);mpg.setStrategy(strategy); 执行代码生成操作1mpg.execute(); 其他功能自动填充数据给POJO的属性@TableField上增加fill属性 定义一个实现MetaObjectHandler 接口的组件（需要能够扫描到） POJO属性 12345678910111213141516@Data@EqualsAndHashCode(callSuper = false)public class Teacher implements Serializable &#123; private static final long serialVersionUID = 1L; //.....其他属性 @TableField(value = &quot;createTime&quot;,fill = FieldFill.INSERT) private Date createtime; @TableField(value = &quot;updateTime&quot;,fill = FieldFill.INSERT_UPDATE) private Date updatetime;&#125; MetaObjectHandler 的实现类，定义自动填充规则 12345678910111213@Componentpublic class BaseObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.strictInsertFill(metaObject, &quot;createtime&quot;, Date.class, new Date()); this.strictInsertFill(metaObject, &quot;updatetime&quot;, Date.class, new Date()); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.strictInsertFill(metaObject, &quot;updatetime&quot;, Date.class, new Date()); &#125;&#125; 逻辑删除支持的数据类型为Integer，Boolean以及Date类型。 操作方法：给实体类的对象增加@TableLogic(value&#x3D;”0”,delval &#x3D; “1”)注解 value：正常有效数据值 delval：删除时的值 使用 mybatis-plus 封装好的方法时，会自动添加逻辑删除的功能。若是自定义的 sql 语句，需要手动添加逻辑。 全局设置（3.5.1以后版本）在application.yml文件中增加以下配置，并在entity的指定属性上增加@TableLogic注解 1234567mybatis-plus global-config: db-config: logic-delete-field: del_flag # 全局逻辑删除的实体字段名 logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) entity 12345678@Data@TableName(value=&quot;sample&quot;)public class Sample implements Serializable &#123; ... @TableLogic private Integer delFlag;&#125; 单个设置使用@TableLogic的value和delValue来设置 1234567891011121314@Data@EqualsAndHashCode(callSuper = false)public class Teacher implements Serializable &#123; private static final long serialVersionUID = 1L; 。。。 @TableLogic(value=&quot;0&quot;,delval = &quot;1&quot;) //增加此字段和注解 @TableField(&quot;deleteFlag&quot;) private Integer deleteflag;&#125; 分页插件注入mybatisplus分页插件123456789@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 使用mybatis提供的方法mybatis提供了一系列分页的方法，例如page 12345678@GetMapping(&quot;page&quot;)public Page&lt;Sample&gt; findPage()&#123; Page&lt;Sample&gt; page = new Page&lt;&gt;(); page.setCurrent(1); page.setSize(2); Page&lt;Sample&gt; page1 = sampleService.page(page); return page1;&#125; 使用自定义方法 修改mapper 12345678910111213@Mapperpublic interface SampleMapper extends BaseMapper&lt;Sample&gt; &#123; IPage&lt;Sample&gt; selectPageVo(IPage&lt;?&gt; page, Sample sample);&#125;//mapper.xml&lt;select id=&quot;selectPageVo&quot; resultType=&quot;net.wanho.base01.entity.Sample&quot;&gt; select * from sample where name like concat(&#x27;%&#x27;,#&#123;sample.name&#125;,&#x27;%&#x27;) &lt;/select&gt; 修改service 1234567891011121314public interface ISampleService extends IService&lt;Sample&gt; &#123; IPage&lt;Sample&gt; selectPageVo(IPage&lt;?&gt; page, Sample sample);&#125;@Servicepublic class SampleServiceImpl extends ServiceImpl&lt;SampleMapper, Sample&gt; implements ISampleService &#123; @Override public IPage&lt;Sample&gt; selectPageVo(IPage&lt;?&gt; page, Sample sample) &#123; SampleMapper baseMapper = this.getBaseMapper(); return baseMapper.selectPageVo(page,sample); &#125;&#125; 测试处理器 1234567891011@GetMapping(&quot;mypage&quot;) public Page&lt;Sample&gt; findMyPage()&#123; Page&lt;Sample&gt; page = new Page&lt;&gt;(); page.setCurrent(1); page.setSize(2); Sample sample = new Sample(); sample.setName(&quot;test&quot;); IPage&lt;Sample&gt; page1 = sampleService.selectPageVo(page,sample); return (Page&lt;Sample&gt;)page1; &#125; 乐观锁（3.5.1）条件构造器QueryWrapper：查询条件构造器 12345678QueryWrapper&lt;Teacher&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper .select(&quot;tno&quot;, &quot;tname&quot;, &quot;tbirthday&quot;) .eq(&quot;tno&quot;, &#x27;702&#x27;) .like(&quot;tname&quot;, &quot;j&quot;); teacherService .list(queryWrapper) .forEach(System.out::println);","categories":[],"tags":[{"name":"Mybatis-plus","slug":"Mybatis-plus","permalink":"http://example.com/tags/Mybatis-plus/"}]},{"title":"rabbitMQ","slug":"rabbitMQ","date":"2023-10-16T01:45:37.000Z","updated":"2023-10-16T01:50:59.000Z","comments":true,"path":"2023/10/16/rabbitMQ/","link":"","permalink":"http://example.com/2023/10/16/rabbitMQ/","excerpt":"","text":"一、消息队列1. 什么是消息队列 消息Message 网络中的两台计算机或者两个通讯设备之间传递的数据。例如：文本、音乐、视频等内容。 队列 Queue 一种特殊的线性表。只允许在首部删除元素和在尾部增加元素（FIFO) 消息队列（Message Queue） 保存消息的队列。消息传输过程中的容器，具有存储消息的能力，提供生产、消费接口供外部调用做数据的存储和获取。 同步调动的问题耦合度高：每次加入新的需求，都要修改原来的代码 性能下降：调用者需要等待服务提供者响应，如果调用链过长，则响应时间等于每次调用的事件之和 资源浪费：调用链中的每条服务在等待响应中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源 级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，迅速导致整个微服务群故障。 2. 使用消息队列的好处 解耦（类似Spring的IOC）允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。 可恢复性系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。 缓冲有助于控制和优化数据流经过系统的速度， 解决生产消息和消费消息的处理速度不一致的情况。 灵活性 &amp; 峰值处理能力（削峰）在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。 异步通信很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。 3. 消息队列的两种模式3.1 点对点的消息系统一对一，消费者主动拉取数据，消息收到后消息清除。 消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后， queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。最典型的例子就是订单处理系统，多个订单处理器可以同时工作，但是对于一个特定的订单，只有其中一个订单处理器可以拿到该订单进行处理。 3.2 发布-订阅消息系统一对多，消费者消费数据之后不会清除消息。消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。有两种方式，一种是队列主动推送模式、一种是消费者主动拉取模式。 主动推送方式：生产者一生产消息，就发送给消费者。问题：1：要维护订阅的消费者 2：消费者消费能力问题。 消费者拉取方式：维持长轮询，不停地访问是否有新的数据。问题：维持长轮询，即使没有数据，也要不停地询问。 4. 常见的消息系统 RabbitMQ 支持多协议AMQP、XMPP、SMTP、STOMP。支持负载均衡，数据持久化。同时支持Peer-to-Peer和发布&#x2F;订阅。可靠性和稳定性 Redis基于key-value对的NoSQL数据库，通知支持MQ功能，可做轻量级队列服务使用。就入队而言，Redis对短消息（小于10kb）的性能比RabbitMQ好，长消息性能比RabblitMQ差。 Zoom 轻量级，不需要单独的消息服务器或中间件，应用本身扮演该角色，Peer-to-Peer。它本质上是一个库，需要开发人员自己组合多种技术，使用复杂度高。 ActiveMQ JMS实现，Peer-to-Peer，支持持久化、XA（分布式）事务 Kafka 高性能跨语言的分布式发布&#x2F;订阅信息系统，数据持久化、全分布式，同时支持在线和离线处理。 MetaQ&#x2F;RocketMQ 纯java实现，发布&#x2F;订阅信息系统，支持本地事务和XA分布式事务。 5. 常见使用场景 任务异步处理 将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高应用程序的响应时间。 应用程序解耦合 MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。 二、RabbitMQ基础1. 什么是AMQP AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。 AMQP是一套公开的消息队列协议，最早在2003年提出，它旨在从协议层定义消息通信数据的标准格式，为的就是解决MQ市场上协议不同意的问题。RabbitMQ就是遵循AMQP标准协议开发的MQ服务。 2. 什么是RabbitMQRabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。 为什么使用RabbitMQ呢？ 使用简单，功能强大。 基于AMQP协议 社区活跃，文档完善。 高并发性能好，这主要得益于Erlang语言。 Spring Boot默认已集成RabbitMQ 3. RabbitMQ安装docker安装查看仓库1docker search rabbitmq 拉取镜像1docker pull rabbitmq 创建并启动容器指定用户名&#x2F;密码启动1234567docker run -d --name rabbitmq \\ -p 5672:5672 -p 15672:15672 \\ -v `pwd`/data:/var/lib/rabbitmq \\ --hostname myRabbit \\ -e RABBITMQ_DEFAULT_VHOST=my_vhost \\ -e RABBITMQ_DEFAULT_USER=admin -e \\ RABBITMQ_DEFAULT_PASS=admin rabbitmq -d 后台运行容器； –name 指定容器名； -p 指定服务运行的端口（5672：应用访问端口；15672：控制台Web端口号）； -v 映射目录或文件； –hostname 主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）； -e 指定环境变量； （RABBITMQ_DEFAULT_VHOST：默认虚拟机名； RABBITMQ_DEFAULT_USER：默认的用户名； RABBITMQ_DEFAULT_PASS：默认用户名的密码） 不指定用户名密码启动默认用户名和密码都是guest 12docker run -d --name rabbitmq \\ -p 5672:5672 -p 15672:15672 rabbitmq 安装插件12docker exec -it rabbitmq bashrabbitmq-plugins enable rabbitmq_management 客户端访问1http://192.168.33.10:15672 普通安装创建配置文件 创建&#x2F;etc&#x2F;yum.repos.d&#x2F;rabbitmq.repo文件，内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[rabbitmq_erlang]name=rabbitmq_erlangbaseurl=https://packagecloud.io/rabbitmq/erlang/el/7/$basearchrepo_gpgcheck=1gpgcheck=1enabled=1# PackageCloud&#x27;s repository key and RabbitMQ package signing keygpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.ascsslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300#### RabbitMQ server##[rabbitmq_server]name=rabbitmq_serverbaseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/7/$basearchrepo_gpgcheck=1gpgcheck=1enabled=1# PackageCloud&#x27;s repository key and RabbitMQ package signing keygpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.ascsslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300[rabbitmq_erlang-source]name=rabbitmq_erlang-sourcebaseurl=https://packagecloud.io/rabbitmq/erlang/el/7/SRPMSrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300[rabbitmq_server-source]name=rabbitmq_server-sourcebaseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/7/SRPMSrepo_gpgcheck=1gpgcheck=0enabled=1gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkeysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtmetadata_expire=300 更新yum package （可以不执行）1yum update -y 安装12345yum install socat logrotate -yyum -y install erlangyum install erlang rabbitmq-server -y 服务启动停止123456#启动服务/sbin/service rabbitmq-server start#查看状态/sbin/service rabbitmq-server status#停止服务/sbin/service rabbitmq-server stop 安装插件1rabbitmq-plugins enable rabbitmq_management 修改配置如果linux上安装了浏览器，可以通过guest&#x2F;guest登录（只能本机） 在&#x2F;etc&#x2F;rabbitmq下创建rabbitmq.conf &#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.conf 12loopback_users = none#如果无效，则使用下面增加用户的方式 增加用户，并设置管理员权限（不要执行） 123456#增加用户rabbitmqctl add_user admin admin#设置权限rabbitmqctl set_permissions -p / admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;#设置管理员rabbitmqctl set_user_tags admin administrator 输入测试输入可以访问，如果不行，则可能是插件没有安装，尝试运行一下命令后再访问 用户名：密码 guest&#x2F;guest 1http://192.168.33.10:15672 三、RabbitMQ的工作原理1.RabbitMQ基本结构 组成部分说明如下： Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。 Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。 Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。 Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。 Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。 队列，交换机和绑定（队列和交换机）统称为AMQP实体（AMQP entities）。 消息发布接收流程1、生产者和Broker建立TCP连接。2、生产者和Broker建立通道。3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。4、Exchange将消息转发到指定的Queue（队列） 接收消息1、消费者和Broker建立TCP连接2、消费者和Broker建立通道3、消费者监听指定的Queue（队列）4、当有消息到达Queue时Broker默认将消息推送给消费者。5、消费者接收到消息。 HelloWorld基本案例生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class Producer &#123; //队列 private static final String QUEUE = &quot;helloworld&quot;; public static void main(String[] args) throws Exception &#123; //通过连接工厂创建新的连接和mq建立连接 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.33.10&quot;); connectionFactory.setPort(5672);//端口 connectionFactory.setUsername(&quot;admin&quot;); connectionFactory.setPassword(&quot;admin&quot;); //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = null; Channel channel = null; //建立新连接 connection = connectionFactory.newConnection(); //创建会话通道,生产者和mq服务所有通信都在channel通道中完成 channel = connection.createChannel(); //声明队列，如果队列在mq 中没有则要创建 //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments /** * 参数明细 * 1、queue 队列名称 * 2、durable 是否持久化，如果持久化，mq重启后队列还在 * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建 * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除） * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间 */ channel.queueDeclare(QUEUE, true, false, false, null); //发送消息 //参数：String exchange, String routingKey, BasicProperties props, byte[] body /** * 参数明细： * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为&quot;&quot;） * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称 * 3、props，消息的属性 * 4、body，消息内容 */ //消息内容 String message = &quot;hello world&quot;; channel.basicPublish(&quot;&quot;, QUEUE, null, message.getBytes()); System.out.println(&quot;send to mq &quot; + message); //关闭连接，//先关闭通道 channel.close(); connection.close(); &#125;&#125; 消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer &#123; //队列 private static final String QUEUE = &quot;helloworld&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; //通过连接工厂创建新的连接和mq建立连接 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.33.10&quot;); connectionFactory.setPort(5672);//端口 connectionFactory.setUsername(&quot;guest&quot;); connectionFactory.setPassword(&quot;guest&quot;); //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq connectionFactory.setVirtualHost(&quot;/&quot;); //建立新连接 Connection connection = connectionFactory.newConnection(); //创建会话通道,生产者和mq服务所有通信都在channel通道中完成 Channel channel = connection.createChannel(); //监听队列 //声明队列，如果队列在mq 中没有则要创建 //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments /** * 参数明细 * 1、queue 队列名称 * 2、durable 是否持久化，如果持久化，mq重启后队列还在 * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建 * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除） * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间 */ channel.queueDeclare(QUEUE,true,false,false,null); //实现消费方法 DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123; /** * 当接收到消息后此方法将被调用 * @param consumerTag 消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume * @param envelope 信封，通过envelope * @param properties 消息属性 * @param body 消息内容 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //交换机 String exchange = envelope.getExchange(); //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收 long deliveryTag = envelope.getDeliveryTag(); //消息内容 String message= new String(body,&quot;utf-8&quot;); System.out.println(&quot;receive message:&quot;+message); &#125; &#125;; //监听队列 //参数：String queue, boolean autoAck, Consumer callback /** * 参数明细： * 1、queue 队列名称 * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复 * 3、callback，消费方法，当消费者接收到消息要执行的方法 */ channel.basicConsume(QUEUE,true,defaultConsumer); &#125;&#125; SpringAMQP基本概念​ AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等。 ​ Spring AMQP是基于AMQP协议定义的一套API规范，提供了模板来放和接收消息。包含两个部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。 特征 侦听器容器，用于异步处理入栈消息。 用于发送和接收消息的RabbitTemplate RabbitAdmin用于自动声明队列，交换和绑定 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 配置RabbitMQ1 编写Producer12345678910111213@RestControllerpublic class Producer &#123; @Autowired RabbitTemplate rabbitTemplate; @RequestMapping(&quot;/simpleQueue&quot;) public String testSimpleQueue()&#123; String queueName =&quot;helloworld&quot;; String message = &quot;hello,simple&quot;; rabbitTemplate.convertAndSend(queueName,message); return &quot;success&quot;; &#125;&#125; 编写Consumer1234567@Componentpublic class Consumer &#123; @RabbitListener(queues = &quot;helloworld&quot;) public void listenSimpleQueue(String msg) throws InterruptedException &#123; System.out.println(&quot;接收的消息：&quot; + msg); &#125;&#125; 2. 工作模式和交换机rabbitmq支持以下集中工作模式： ​ workqueue：工作队列，不需要交换机，消息发送指定的某个队列当中去的，队列的消费者共同消费队列中的数据。 ​ pub&#x2F;sub ：发布订阅：扇形交换机 ​ routing: 路由模式：直连交换机 ​ topic:主题模式：主题交换机 ​ rpc: rpc模式 交换机类型 ​ Direct exchange（直连交换机） ​ Fanout exchange（扇型交换机） ​ Topic exchange（主题交换机） ​ Headers exchange（头交换机） Work queues 消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2,同时监听同一个队列,消息被消费?C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患,高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize,与同步锁的性能不一样) 保证一条消息只能被一个消费者使用)。队列中的数据过多时会被丢弃。提高消息处理的速度，避免消息的队列 应用场景:红包;大项目中的资源调度(任务分配系统不需知道哪一个任务执行系统在空闲,直接将任务扔到消息队列中,空闲的系统自动争抢) 生产者 1234567891011@RequestMapping(&quot;/workQueue&quot;)public String testWorkQueue() throws InterruptedException &#123; String queueName =&quot;helloworld&quot;; String message = &quot;hello,simple&quot;; for (int i=1;i&lt;50;i++)&#123; rabbitTemplate.convertAndSend(queueName,message + &quot;,index:&quot; + i); Thread.sleep(20); &#125; return &quot;success&quot;;&#125; 消费者 1234567891011@RabbitListener(queues = &quot;helloworld&quot;)public void listenWorkQueue1(String msg) throws InterruptedException &#123; System.out.println(&quot;消费者1接收消息：&quot; + msg); Thread.sleep(20);&#125;@RabbitListener(queues = &quot;helloworld&quot;)public void listenWorkQueue2(String msg) throws InterruptedException &#123; System.out.println(&quot;消费者2接收消息：&quot; + msg); Thread.sleep(50);&#125; 消息预取机制：当消息到达的时候，rabbitmq内部会预先取得消息，再后续再处理。preFetch消息预取限制，可以控制消息的上限。 12345678910spring: rabbitmq: host: 192.168.33.10 port: 5672 virtual-host: / username: guest password: guest listener: simple: prefetch: 1 Publish&#x2F;Subscribe交换机是用来发送消息的AMQP实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和被称作绑定（bindings）的规则所决定的。 发布订阅模式交换机模型： Direct exchange（直连交换机） Fanout exchange（扇型交换机） Topic exchange（主题交换机） Headers exchange（头交换机） X代表交换机rabbitMQ内部组件，erlang 消息产生者是代码完成，代码的执行效率不高，消息产生者将消息放入交换机,交换机发布订阅把消息发送到所有消息队列中,对应消息队列的消费者拿到消息进行消费。 应用场景：:邮件群发,群聊天,广播(广告) Fanout Exchange生产者发送的消息，交换机会将消息路由到所有的队列中。 在消费者当中创建交换机，队列，并绑定交换机和队列。 定义消费者方法 定义生产者方法 创建交换机，队列以及绑定代码 1234567891011121314151617181920212223242526272829303132@Configurationpublic class FanoutConfig &#123; //声明交换机 @Bean(name=&quot;fanoutExchange&quot;) public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(&quot;fanout.exchange&quot;); &#125; //声明队列 @Bean(name=&quot;fanoutQueue1&quot;) public Queue fanoutQueue1()&#123; return new Queue(&quot;fanout.queue1&quot;); &#125; @Bean public Binding bindingQueue1(@Qualifier(&quot;fanoutQueue1&quot;) Queue queue ,@Qualifier(&quot;fanoutExchange&quot;) FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(queue).to(fanoutExchange); &#125; //声明队列 @Bean(name=&quot;fanoutQueue2&quot;) public Queue fanoutQueue2()&#123; return new Queue(&quot;fanout.queue2&quot;); &#125; @Bean public Binding bindingQueue2(@Qualifier(&quot;fanoutQueue2&quot;) Queue queue ,@Qualifier(&quot;fanoutExchange&quot;) FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(queue).to(fanoutExchange); &#125;&#125; 消费者代码 1234567891011@RabbitListener(queues = &quot;fanout.queue1&quot;)public void listenFanoutQueue1(String msg) throws InterruptedException &#123; System.out.println(&quot;消费者1接收消息：&quot; + msg); Thread.sleep(20);&#125;@RabbitListener(queues = &quot;fanout.queue2&quot;)public void listenFanoutQueue2(String msg) throws InterruptedException &#123; System.out.println(&quot;消费者2接收消息：&quot; + msg); Thread.sleep(50);&#125; 生产者代码 1234567891011@RequestMapping(&quot;/fanoutQueue&quot;)public String testFanoutQueue() throws InterruptedException &#123; String exchange = &quot;fanout.exchange&quot;; String message = &quot;hello,simple&quot;; for (int i=1;i&lt;20;i++)&#123; //交换机，路由名，信息 rabbitTemplate.convertAndSend(exchange,&quot;&quot;,message); Thread.sleep(20); &#125; return &quot;fanoutQueue success&quot;;&#125; Routing （路由）Direct Exchange：会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式。 Routing模式要求队列在绑定交换机时要指定routingkey，消息会转发到符合routingkey的队列。 每一个Queue都与Exchange设置一个BindingKey发布者发布消息时，指定消息的RoutingKeyExchange将消息路由到BindingKey与消息RountingKey一致的队列。 消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息; 业务场景：从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误; &#x2F;&#x2F;科技 tec ，艺术 art 消费者代码 12345678910111213141516171819@RabbitListener(bindings = @QueueBinding( value=@Queue(name = &quot;direct.queue1&quot;), exchange = @Exchange(name=&quot;direct.exchange&quot;,type = ExchangeTypes.DIRECT), key=&#123;&quot;eat&quot;,&quot;jump&quot;&#125; )) public void listenRouteQueue1(String msg) throws InterruptedException &#123; System.out.println(&quot;消费者1--Direct接收消息--eat：&quot; + msg); Thread.sleep(20); &#125; @RabbitListener(bindings = @QueueBinding( value=@Queue(name = &quot;direct.queue2&quot;), exchange = @Exchange(name=&quot;direct.exchange&quot;,type = ExchangeTypes.DIRECT), key=&#123;&quot;jump&quot;&#125; )) public void listenRouteQueue2(String msg) throws InterruptedException &#123; System.out.println(&quot;消费者1--Direct接收消息--jump：&quot; + msg); Thread.sleep(20); &#125; 生产者代码 123456789@RequestMapping(&quot;/routeQueue&quot;)public String testRouteQueue() throws InterruptedException &#123; String exchange = &quot;direct.exchange&quot;; //交换机，路由名，信息 rabbitTemplate.convertAndSend(exchange,&quot;eat&quot;,&quot;...eat.....&quot;); rabbitTemplate.convertAndSend(exchange,&quot;jump&quot;,&quot;...jump.....&quot;); return &quot;routeQueue success&quot;;&#125; TopicsTopicExchange与DirectExchange类似，区别在于routingKey必须是多个单词的列表，并且以.分隔。 Queue与exchange指定的BindingKey时，可以使用通配符： *：代指一个单词 ‘#’：代指零个或者多个单词 a.#.b &#x3D;&#x3D;&gt;a.x.b ,a.x.y.z.b 消费者代码 123456789101112131415161718@RabbitListener(bindings = @QueueBinding( value=@Queue(name = &quot;topic.queue1&quot;), exchange = @Exchange(name=&quot;topic.exchange&quot;,type = ExchangeTypes.TOPIC), key=&#123;&quot;wanho.*&quot;&#125; )) public void listenTopicQueue1(String msg) throws InterruptedException &#123; System.out.println(&quot;消费者1--topic接收消息--wanho：&quot; + msg); Thread.sleep(20); &#125; @RabbitListener(bindings = @QueueBinding( value=@Queue(name = &quot;topic.queue2&quot;), exchange = @Exchange(name=&quot;topic.exchange&quot;,type = ExchangeTypes.TOPIC), key=&#123;&quot;*.news&quot;&#125; )) public void listenTopicQueue2(String msg) throws InterruptedException &#123; System.out.println(&quot;消费者2--topic接收消息--news：&quot; + msg); Thread.sleep(20); &#125; 生产者代码 123456789@RequestMapping(&quot;/topicQueue&quot;)public String testTopicQueue() throws InterruptedException &#123; String exchange = &quot;topic.exchange&quot;; //交换机，路由名，信息 rabbitTemplate.convertAndSend(exchange,&quot;wanho.news&quot;,&quot;wanho,hahaha&quot;); rabbitTemplate.convertAndSend(exchange,&quot;weather.news&quot;,&quot;sunny&quot;); return &quot;routeQueue success&quot;;&#125; Headerheader模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key&#x2F;value（键值对）匹配队列。 接收方 123456789@RabbitListener(bindings = @QueueBinding( value=@Queue(name = &quot;head.query1&quot;), exchange = @Exchange(name=&quot;header.exchange&quot;,type = ExchangeTypes.HEADERS), key = &#123;&quot;sms&quot;&#125; )) public void listenHeadQueue1(byte[] bytes) throws InterruptedException &#123; System.out.println(&quot;消费者1--header接收消息--sms：&quot; + new String(bytes)); Thread.sleep(20); &#125; 发送方 1234567891011@RequestMapping(&quot;/headerQueue&quot;) public String testHeaderQueue() throws InterruptedException &#123; String exchange = &quot;header.exchange&quot;; MessageProperties messageProperties = new MessageProperties(); messageProperties.setHeader(&quot;query&quot;,&quot;query1&quot;); //交换机，路由名，信息 Message message = new Message(&quot;info&quot;.getBytes(),messageProperties); rabbitTemplate.convertAndSend(exchange,&quot;&quot;,message); return &quot;routeQueue success&quot;; &#125; RPC消息转换器Spring对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的，默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。如果要修改只需要定义一个MessageConverter类型的Bean即可。推荐用JSON方式序列化。 发送方​ 在publisher服务声明MessageConverter 1234@Beanpublic MessageConverter messageConverter()&#123; return new Jackson2JsonMessageConverter();&#125; 发送代码 123456789@RequestMapping(&quot;/objectQueue&quot;) public String testObjectQueue()&#123; String queueName =&quot;object.queue&quot;; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;dola&quot;); map.put(&quot;age&quot;,&quot;5&quot;); rabbitTemplate.convertAndSend(queueName,map); return &quot;success&quot;; &#125; 接收方引入依赖和声明MessageConverter参考发送方 接收方代码：需要用和发送消息一致的类型接收。 123456@RabbitListener(queues = &quot;helloworld&quot;)public void listenWorkQueue2(Map&lt;String,String&gt; map) throws InterruptedException &#123; System.out.println(&quot;name：&quot; + map.get(&quot;name&quot;)); System.out.println(&quot;age：&quot; + map.get(&quot;age&quot;)); Thread.sleep(50);&#125; 非存储型交换机和队列存储型交换机和队列：RabbitMQ会将消息保存在磁盘，如果服务器再次启动，会从磁盘将数据读入内存。 非存储型交换机和队列：数据仅仅放在内存当中，当服务重启或者发生宕机之后，数据就会不存在。 持久化队列和交换机，是要牺牲一部分性能。 设置超时时间以及长度在创建队列时，使用map参数进行设置 x-message-ttl：超时参数，时间单位是毫秒 x-max-length: 队列中最多能存储的数量 &#x3D;&#x3D;》死信 死信队列死信：这些信息没有被处理，直接被丢掉了。 ​ 消息过期 ​ 队列达到最大的长度 ​ 消息被拒绝（basicReject&#x2F;basicNack），并且requeue&#x3D;false 死信队列：用来处理死信的队列 用来处理死信的交换机称为死信交换机，用来处理死信的队列，称之为死信队列 创建一个普通队列 normalqueue（消费者罢工），队列设置过期时间以及长度， ​ 当出现死信的时候，配置死信交换机以及队列 配置属性x-dead-letter-exchange： 配置死信交换机x-dead-letter-routing-key：死信路由key 使用案例123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configurationpublic class DeathConfig &#123; @Bean(&quot;normal.exchange&quot;) public FanoutExchange normalExchange()&#123; return new FanoutExchange(&quot;normal&quot;); &#125; @Bean(&quot;normal.queue&quot;) public Queue normalQueue()&#123; Map&lt;String,Object&gt; args = new HashMap&lt;&gt;(); //超时 args.put(&quot;x-message-ttl&quot;,3000); //最大长度 args.put(&quot;x-max-length&quot;,5); //死信交换机(用死信交换机的名字--rabbitmq当中的名字) args.put(&quot;x-dead-letter-exchange&quot;,&quot;death&quot;); //设置死信队列的路由key //args.put(&quot;x-dead-letter-routing-key&quot;,&quot;tec&quot;); return new Queue(&quot;normal&quot;,true,false,false,args); &#125; @Bean public Binding normalBinding(@Qualifier(&quot;normal.exchange&quot;)FanoutExchange fanoutExchange ,@Qualifier(&quot;normal.queue&quot;)Queue queue)&#123; return BindingBuilder.bind(queue).to(fanoutExchange); &#125; //死信相关 @Bean(&quot;death.exchange&quot;) public FanoutExchange deathExchange()&#123; return new FanoutExchange(&quot;death&quot;); &#125; @Bean(&quot;death.queue&quot;) public Queue DeathQueue()&#123; return new Queue(&quot;death&quot;); &#125; @Bean public Binding deathBinding(@Qualifier(&quot;death.exchange&quot;)FanoutExchange fanoutExchange ,@Qualifier(&quot;death.queue&quot;)Queue queue)&#123; return BindingBuilder.bind(queue).to(fanoutExchange); &#125; 消息确认默认情况下，都是自动确认，需要手工确认的情况下，需要配置 生产者消息确认配置1234567891011spring: rabbitmq: host: 192.168.33.10 port: 5672 virtual-host: / username: guest password: guest listener: direct: acknowledge-mode: manual #配置确认模式为手动确认 publisher-confirm-type: correlated #生产者需要手工确认 生产者代码修改12345678910111213141516171819//定义一个特殊的属性对象 RabbitTemplate.ConfirmCallback confirmCallback = new RabbitTemplate.ConfirmCallback() &#123; @Override public void confirm(CorrelationData correlationData, boolean b, String s) &#123; System.out.println(&quot;消息发送id：&quot; + correlationData.getId() + &quot;，发送状态：&quot; + b ); &#125; &#125;; @RequestMapping(&quot;/cfm&quot;) public String testCfm()&#123; String message = &quot;hello,死信消息&quot;; rabbitTemplate.setConfirmCallback(confirmCallback); CorrelationData correlationData = new CorrelationData(); System.out.println(&quot;发送的id:&quot; + correlationData.getId()); rabbitTemplate.convertAndSend(&quot;normal&quot;,&quot;&quot;,message ,correlationData); return &quot;cfg success&quot;; &#125; 消费者的消息确认进行配置12345678910111213spring: rabbitmq: host: 192.168.33.10 port: 5672 virtual-host: / username: guest password: guest listener: simple: prefetch: 2 #消息的预取限制 acknowledge-mode: manual #手工确认 direct: acknowledge-mode: manual #手工确认 确认和拒绝12345678910111213@RabbitListener(queues = &quot;normal&quot;) public void normalConsumer(Channel channel, Message message) throws IOException &#123; System.out.println(&quot;正常消费者：&quot; +message); long deliveryTag = message.getMessageProperties().getDeliveryTag(); System.out.println(&quot;deliveryTag: &quot; + deliveryTag); //消费者确认消息 channel.basicAck(deliveryTag ,true); //拒绝消息,requeue为false，则变成死信 //channel.basicReject(deliveryTag,false); //channel.basicReject(deliveryTag,true); //未确认消息重新入队 //channel.basicRecover(true); &#125; 常见问题RabbitMQ有哪几种交换机Direct exchange（直连交换机） Fanout exchange（扇型交换机） Topic exchange（主题交换机） Headers exchange（头交换机） RabbitMQ有几种工作模式Work queues Publish&#x2F;Subscribe Routing Topics Header RPC 惰性队列默认情况下，生产者将消息发送到队列后，默认是存储在内存当中，这样可以将消息发送给消费者。即使是持久化队列，也会在内存当中留一个备份。当需要释放内存的时候，将内存中的数据写入磁盘。 在某些特殊的情况，消息的生产和消费不是同一时间的场合下，可以设置惰性队列，无论队列是否是持久化，默认将数据写入磁盘，目的主要是为了减少内存的消耗。当需要消费消息的时候，再从磁盘读入内如。 拿时间换空间，可以部分解决消息堆积问题。 1map.put(&quot;x-queue-mode&quot;,&quot;lazy&quot;) 作业业务：注册用户，给用户发送邮件，用户在邮件中点击链接，确认登录（修改状态位），如果超过24小时不确认，则删除此用户。 ​ 解决方案： ​ 注册时，发送一条消息（用来发送邮件），邮件确认后，修改状态 ​ 超时24未确认： ​ 采用消息队列，使用扇形交换机，同时发送两个队列，一个用来处理邮件，一个作为延时队列（设置消息的有效时间），此队列没有消费者，指定另外的死信交换机，死信交换机的消费者，根据状态，确定是否要删除用户（未确认，则删除）。使用直连交换机，两条消息，一条用来发送邮件，一个用来处理过期。 ​ 定时任务：查询数据库，到目前位置，注册时间已经到24小时，但是用户状态依旧是未确认的，将这些数据直接删除掉。 ​ 解决方案2：注册完（写入数据库） –直接发送邮件，通过rabbitmq发送一条消息（用来确认用户是否注册），此消息没有消费者，而是在超时之后，直接转入死信队列，由死信消费者来进行处理。 ​ 美团，饿了么订单，用户生成订单后(未付款)，付款后状态发生变化，超过15分钟未付款，则删除订单。 ​ 解决：生成订单时，直接通过消息队列发送一条消息（15分钟），消息没有对应的消费，转入死信队列，消费者（死信）获取到信息，判断数据状态位，如果为未付款，则删除此订单。 目的：练习rabbitmq收发消息，同时要查阅官网，学习如何发送邮件 1：编写一个注册页面 ​ 用户名，密码，电话，邮件地址 （存入数据库，默认状态为0–未确认） 注册处理： ​ 写入数据库 ​ 并且将用户的信息，通过rabbitmq发送到指定的队列当中 2：rabbitmq的消费者 ​ 从队列当中拿到用户信息（用户名，邮箱） ​ 向指定邮箱发送邮件，邮件中带有用户信息，当用户点击连接的时候，要将数据库当中的状态从0（未确认状态）–1(已确认) 3：超时删除 ​ 如果用户注册后超过24小时未确认，则删除表中的用户信息","categories":[],"tags":[]},{"title":"Nginx","slug":"Nginx","date":"2023-10-16T01:22:27.000Z","updated":"2023-10-16T01:28:28.000Z","comments":true,"path":"2023/10/16/Nginx/","link":"","permalink":"http://example.com/2023/10/16/Nginx/","excerpt":"","text":"1. 域名解析一个域名一定会被解析为一个或多个ip，一般包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果找到就返回IP，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts Linux下的hosts文件所在路径： &#x2F;etc&#x2F;hosts 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和IP映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 2. Nginx简介是一个WEB服务器，是一个高性能的反向代理的服务器、还是一个负载均衡服务器，同时还可以实现动静分离。 特点：在高并发和处理静态资源上相对于tomcat有更多优势. 什么是反向代理 正向代理：客户端先进行代理服务器的设置，客户端发送请求到代理服务器，代理服务器将请求转发至原始服务器。代理服务器所代理的对象是很多个客户端。 反向代理：对于客户而言反向代理就像原始服务器,客户不需要作任何设置，客户端发送请求，直接发送到代理服务器，代理服务器判断向何处转发请求,并将获得的内容返回给客户端。反向代理是对多个服务器进行代理 什么是负载均衡 可以按照调度规则实现动态、静态页面分离，可以按照轮询、ip哈希、权重等多种方式实现将请求平均分配到后端服务器上 3. docker安装3.1 拉取镜像docker pull nginx 3.2 启动容器 docker run -d –name mynginx1 -p 80:80 nginx bash 配置文件在&#x2F;etc&#x2F;nginx&#x2F;nginx.conf,默认没有vi命令 拷贝nginx目录到宿主机： docker cp mynginx1:&#x2F;etc&#x2F;nginx &#x2F;opt&#x2F;nginx docker cp mynginx1:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 删除容器：docker stop mynginx1–》docker rm mynginx1 启动容器并添加数据卷： docker run -v &#x2F;opt&#x2F;data&#x2F;nginx:&#x2F;etc&#x2F;nginx -di –name mynginx -p 80:80 nginx ​ yum安装 安装yum仓库 yum-utils 12#可以不执行，当出现版本问题时，再进行更新sudo yum install yum-utils -y 创建&#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo文件， 1vi /etc/yum.repos.d/nginx.repo 内容如下 123456789101112131415[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true#[nginx-mainline]#name=nginx mainline repo#baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/#gpgcheck=1#enabled=0#gpgkey=https://nginx.org/keys/nginx_signing.key#module_hotfixes=true nginx-stable:稳定版的信息。一般情况下使用此版本 nginx-mainline：主力版本（或开发版本），如果想要安装此版本，可以先使用如下命令，再安装 使用stable版本，下面这句话不要执行 12#使用stable版本，下面这句话不要执行sudo yum-config-manager --enable nginx-mainline 安装 1sudo yum install nginx -y 启动测试 1nginx 在windows主机上输入 http://192.168.33.10 其它命令 1234567891011121314#停止nginx -s stop#重启nginx -s reopen#检查是否有语法错误nginx -t#重新加载nginx -s reload#查看版本nginx -V 或nginx -v#查看80端口的程序netstat –ano | grep 80#卸载Nginxyum remove nginx 关闭防火墙 (需要重启)：chkconfig iptables off 卸载步骤： 12345卸载时1：先停止nginx服务 nginx -s stop2：查找nginx目录文件：find / -name nginx3: 依次删除找到的目录：rm -rf /usr/sbin/nginx4：使用yum清除 yum remove nginx 其它Linux版本的安装请参考以下文档： http://nginx.org/en/linux_packages.html#RHEL-CentOS 配置文件位置&#x2F;etc&#x2F;nginx 主配置文件 ngixn.conf 每个服务器配置的conf.d目录下 主启动页：&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 四、nginx信号量1. 工作模式​ nginx是一个多进程&#x2F;多线程高性能web服务器，在linux系统中，nginx启动后会以后台守护进程（daemon）的方式去运行，后台进程包含一个master进程和多个worker进程（可以通过在nginx.conf配置文件中配置worker_processes参数设置），可以充分利用多核架构。 nginx默认的工作模式是以多进程的方式来工作的，nginx也是支持多线程的方式的，只是我们主流的方式还是多进程的方式。nginx在启动之后会有一个master进程和多个worker进程（默认是一个），多个worker子进程将监听同一个端口，并行处理请求。worker 进程数应该设置为等于 CPU 的核数，高流量并发场合也可以考虑将进程数提高至 CPU 核数 * 2。 ​ master主进程主要用来管理worker进程，主要作用是：读取并验正配置信息，管理真正提供服务的worker进程，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。master进程不会对用户请求提供服务，而用户的请求则是worker进程来响应的。 ​ nginx是通过信号来控制，比如关闭，重启等去控制nginx进程。nginx信号是属于nginx进程间的通信的一种机制，比如master主进程控制多个worker子进程，也是通过信号控制的，如下图。 2. 信号量信号控制语法 ​ kill -信号选项 nginx的主进程号 TERM，INT：快速关闭 QUIT ：从容关闭（优雅的关闭进程,即等请求结束后再关闭） HUP ：平滑重启，重新加载配置文件 （平滑重启，修改配置文件之后不用重启服务器。直接kill -PUT 进程号即可） USR1 ：重新读取日志文件，在切割日志时用途较大（停止写入老日志文件，打开新日志文件，之所以这样是因为老日志文件就算修改的文件名，由于inode的原因，nginx还会一直往老的日志文件写入数据） USR2 ：平滑升级可执行程序 ，nginx升级时候用 WINCH ：优雅的关闭旧的进程(配合上USR2来进行升级) 1234567#查找nginx.pidfind / -name nginx.pid#查看nginx.pid的进程id ==》结果为4851cat /var/run/nginx.pid#关闭nginx进程 （id号为4851，每次都不一样，会变化，需要查找）#关闭后无法访问，需要重新启动kill -QUIT 4851 五、nginx的配置 1. main 全局配置nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。 1234567891011121314151617## 指定nginx进程使用什么用户启动，默认是nobodyuser www www; #指定启动多少进程来处理请求，一般情况下设置成CPU的核数。默认为1worker_processes 4; #在高并发情况下，通过设置将CPU和具体的进程绑定来降低由于多核CPU切换造成的寄存器等现场重建带来的性能损耗。#位数和进程数相关。#两个cpu内核开启两个进程#worker_processes 2; #worker_processes 01 10；分别对应第一个CPU内核，第二个CPU内核 worker_cpu_affinity 0001 0010 0100 1000; #分别对应第一个CPU内核……第四个CPU内核 #error_log是个主模块指令，用来定义全局错误日志文件。#日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。error_log logs/error.log crit;#指定进程pid文件的位置。pid logs/nginx.pid;#用于指定一个nginx进程可以打开的最多文件描述符数目，需要使用命令“ulimit -n 8192”来设置。worker_rlimit_nofile 8192; 2. events模块123456789101112events &#123; #每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。 #默认是1024 #进程的最大连接数受Linux系统进程的最大打开文件数限制，最大不能超过worker_rlimit_nofile的值 worker_connections 4096; #use是个事件模块指令，用来指定Nginx的工作模式。 #Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。 #其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式， #不同的是epoll用在Linux平台上，而kqueue用在BSD系统中。对于Linux系统，epoll工作模式是首选。 #use [ kqueue | rtsig | epoll | /dev/poll | select | poll ] ; use epoll;&#125; 3. http服务器12345678910#include是个主模块指令，实现对配置文件所包含的文件的设定，可以减少主配置文件的复杂度。#类似于Apache中的include方法。include conf/mime.types;include /etc/nginx/proxy.conf;include /etc/nginx/fastcgi.conf;#定义路径下默认访问的文件名index index.html index.htm index.php;#default_type属于HTTP核心模块指令，这里设定默认类型为二进制流，也就是当文件类型未定义时使用这种方式。#例如在没有配置PHP环境时，Nginx是不予解析的，此时，用浏览器访问PHP文件就会出现下载窗口。default_type application/octet-stream; 3.1 客户端head缓存1234567891011121314151617181920212223#服务器名字的hash表大小server_names_hash_bucket_size 128;#用来指定来自客户端请求头的header buffer 大小。client_header_buffer_size 32k; #用来指定客户端请求中较大的消息头的缓存最大数量和大小，4为个数，128k为大小，最大缓存为4个128KB。large_client_header_buffers 4 128k; #允许户端请求的最大单个文件字节数。如果有上传较大文件，请设置它的限制值。client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数。client_body_buffer_size 128k; #高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，#减少用户空间到内核空间的上下文切换。对于普通应用设为 on，# 如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。# 开启 tcp_nopush on; 和tcp_nodelay on; 防止网络阻塞。sendfile on ; tcp_nopush on;tcp_nodelay on;#长连接超时时间，单位是秒，65s内没上传完成会导致失败。keepalive_timeout 65 : #用于设置客户端请求主体读取超时时间，默认是60s。client_body_timeout 60s;#用于指定响应客户端的超时时间。send_timeout 60s; 3.2 FastCGI参数FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。 1234567891011121314151617181920212223242526#指定连接到后端FastCGI的超时时间。fastcgi_connect_timeout 300; #指定向FastCGI传送请求的超时时间，此值是已经完成两次握手后向FastCGI传送请求的超时时间。fastcgi_send_timeout 300; #指定接收FastCGI应答的超时时间，此值是已经完成两次握手后接收FastCGI应答的超时时间。fastcgi_read_timeout 300; #用于指定读取FastCGI应答第一部分需要多大的缓冲区。# 此值表示将使用1个64KB的缓冲区读取应答的第一部分（应答头）fastcgi_buffer_size 64k; # 指定本地需要用多少和多大的缓冲区来缓冲FastCGI的应答请求。fastcgi_buffers 4 64k; #默认值是fastcgi_buffers的两倍。fastcgi_busy_buffers_size 128k; #表示在写入缓存文件时使用多大的数据块，默认值是fastcgi_buffers的两倍。fastcgi_temp_file_write_size 128k;#表示开启FastCGI缓存并为其指定一个名称。开启缓存非常有用，可以有效降低CPU的负载，并且防止502错误的发生。fastcgi_cache TEST; #FastCGI缓存指定一个文件路径、目录结构等级、关键字区域存储时间和非活动删除时间。fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10m inactive=5m; #用来指定应答代码的缓存时间。#实例中的值表示将200和302应答缓存一个小时。fastcgi_cache_valid 200 302 1h; #将301应答缓存1天，其他应答均缓存1分钟。fastcgi_cache_valid 301 1d;#fastcgi_cache_valid any 1m; 3.3 gzip模块设置123456789101112131415161718192021#开启gzip压缩输出gzip on;#最小压缩文件大小，页面字节数从header头的Content-Length中获取。默认值为0，不管多大页面都压缩，建议设置成大于1K的字节数，小于1K可能会越压越大。gzip_min_length 1k;#压缩缓冲区，表示申请四个8K的内存作为压缩结果流缓存#默认是申请与原始数据大小相同的内存空间来存储gzip压缩结果。gzip_buffers 4 8k;#用于设置识别HTTP协议版本，默认是1.1#（默认1.1，前端如果是squid2.5请使用1.0）gzip_http_version 1.1;#压缩等级，1压缩比最小，处理速度最快，9压缩比最大，传输速度快，但是消耗CPU资源。#范围1~9gzip_comp_level 5;#压缩类型，默认已包含text/html。gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;#和http头有关系，会在响应头加个 Vary: Accept-Encoding ，# 可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。gzip_vary on;#Nginx作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，# 匹配的前提是后端服务器必须要返回包含”Via”的 header头。#gzip_proxied any; 4. nginx 配置虚拟主机4.1 配置虚拟主机流程1：拷贝一段完整的server段，并放入http标签内 2：更改server_name以及对应网页的root根目录 3：创建server_name 对应网页的根目录，如果没有index首页会出现404错误。 4：对客户端server_name 的主机做host 解析或DNS配置。 5：浏览器访问，或者在Linux客户端做host解析，用wget或curl 访问。 1234567891011121314server &#123; listen 80; server_name localhost; index index.html index.htm; location /emp &#123; #在/opt/project目录下存放各种html文件 root /opt/project; #默认的首页 index index.html index.htm; &#125; &#125;#浏览器中使用localhost/emp来访问对应的资源 如果出现502,503错误，尝试临时关闭SELinux后再测试。 123456#临时关闭SELinuxsetenforce 0永久关闭：#输入命令（需要重启服务器）vim /etc/selinux/config#设置config文件中的SELINUX=enforcing改为SELINUX=disabled，然后退出保存。 如果出现403错误，用以下方式解决 看log，查看路径是否正确 如果路径正确，则确认配置文件中用户是什么，修改和当前用户匹配（如果当前用户为root，请也将用户改成root）。 4.2 location模块语法规则location的语法规则有两种：前缀字符串（路径名）和正则表达式 前缀字符串 12#匹配以/some/path/开头的路径，如：/some/path/domt.htmllocation /some/path/ &#123; &#125; 正则表达式 正则表达式前加上“”表示区分大小写，加上”*”表示不区分大小写 ※当使用插入符时“^~”则表示只匹配前缀字符串，不匹配正则表达式 location [&#x3D;|||^~] &#x2F;uri&#x2F; { … }* &#x3D; 精确匹配，如果找到匹配&#x3D;号的内容，立即停止搜索，并立即处理请求(优先级最高) ~ 区分大小写 ~* 不区分大小写 ^~ 只匹配字符串，不匹配正则表达式 &#x2F; 通用匹配，任何请求都会匹配到 123456789101112131415#匹配跟目录location =/ &#123; &#125;#各种图片格式结尾的（正则匹配）# ~ 区分大小写# . 匹配除换行符之外的任何字符# * 匹配0或多次#\\ 转义字符 \\. 匹配点好（.)location ~ .*\\.(gif|jpg|jpeg|png|bmp|icon)$ &#123;&#125;#将所有请求都交给location / &#123;&#125; 六、nginx动静分离1. 什么是动静分离在Web开发中，通常来说，动态资源其实就是指那些后台资源，而静态资源就是指HTML、JavaScript、CSS、img等文件。 动静分离就是将动态资源和静态资源分开，将静态资源部署在Nginx上。当一个请求来的时候，如果是静态资源的请求，就直接到nginx配置的静态资源目录下面获取资源，如果是动态资源的请求，nginx利用反向代理的原理，把请求转发给后台应用去处理，从而实现动静分离。 优点： 可以很大程度的提升静态资源的访问速度。 前后端可以并行开发、有效地提高开发效率。 2. nginx结合tomcat实现动静分离项目准备编写一个带图片的index.html,放置在&#x2F;opt&#x2F;project&#x2F;emp目录中。 图片fruit01.jpg放入&#x2F;opt&#x2F;project&#x2F;static&#x2F;img目录中 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot;&gt; 用户：&lt;input name=&quot;user&quot;&gt;&lt;br&gt; 密码：&lt;input name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;取消&quot;&gt; &lt;/form&gt; &lt;img src=&quot;/static/img/fruit01.jpg&quot; style=&quot;width:200px;height:200px&quot;/&gt;&lt;/body&gt;&lt;/html&gt; nginx配置思路：动、静态的文件，请求时匹配不同的目录 当访问gif,jpeg时 直接访问&#x2F;opt&#x2F;project&#x2F;static&#x2F;目录下内容,正则自行配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344user root;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; # include /etc/nginx/conf.d/*.conf; server &#123; listen 8100; server_name localhost; location / &#123; root /opt/project/emp; index index.html index.htm; &#125; # 所有静态图片请求都放到static目录下 location ~ .*\\.(jpg|jpeg|png)$ &#123; alias /opt/project/static/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root e:wwwroot; &#125; &#125;&#125; 测试图片能够正常加载 通过以下语句测试图片的正常加载 1curl -I http://localhost/static/img/fruit01.jpg 七、nginx反向代理、负载均衡1. 什么是反向代理 代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理 反向代理：用一台服务器，代理真实服务器，用户访问时，不是访问真实的服务器，而是访问代理服务器。 Nginx可以当作反向代理服务来使用时，我们需要提前在Nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理。当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能。 安装在主机上 安装在虚拟机上 2. Nginx反向代理Tocat拷贝配置文件将&#x2F;etc&#x2F;nginx&#x2F;conf.d目录下的default.conf拷贝一份，并命名成my.conf 123456#进入配置server的目录cd /etc/nginx/conf.d#拷贝文件（保留模板文件，防止被破坏）cp default.conf my.conf#打开my.conf进行编辑vi my.conf my.conf的修改使用proxy_pass来设置反向代理的服务器 1234567891011121314151617 1 server &#123; 2 listen 80; 3 server_name localhost; 4 5 #access_log /var/log/nginx/host.access.log main; 6 7 location / &#123; #修改内容，注释掉8，9行，增加第10行数据 8 #root /usr/share/nginx/html; 9 #index index.html index.htm;10 proxy_pass http://192.168.40.251:8080;11 &#125;12 .... 修改nginx.conf&#x2F;etc&#x2F;nginx&#x2F;nginx.conf中的http节点中修改以下内容 1234#修改内容 #include /etc/nginx/conf.d/*.conf; include /etc/nginx/conf.d/my.conf; 3. 负载均衡upstream模块nginx 的负载均衡功能依赖于 ngx_http_upstream_module模块，所支持的代理方式有 proxy_pass(一般用于反向代理).fastcgi_pass(一般用于和动态程序交互），memcached_pass,proxy_next_upstream,fastcig_next_pass 以及memcached_next_pass 。 upstream 模块应该放于http{}标签内。 12345678910111213141516171819202122upstream dynamic &#123; zone upstream_dynamic 64k; server backend1.example.com weight=5; server backend2.example.com:8080 fail_timeout=5s slow_start=30s; server 192.0.2.1 max_fails=3; server backend3.example.com resolve; server backup1.example.com:8080 backup; server backup2.example.com:8080 backup; #通过该指令配置了每个worker进程与上游服务器可缓存的空闲连接的最大数量。 #当超出这个数量时，最近最少使用的连接将被关闭。keepalive指令不限制worker进程与上游服务器的总连接。 keepalive 100;&#125;//案例upstream tc&#123; #ip_hash; server 192.168.4.91:80 weight=1 backup; server 192.168.4.91:8080 weight=3; &#125; my.conf1proxy_pass http://tc; 负载均衡策略轮询(rr)：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器故障，故障系统自动清除，使用户访问不受影响。适用于多个服务器的性能相当的情况下，适用此策略。 轮询权值(weight),weight值越大，分配到的访问几率越高，主要用于后端每个服务器性能不均的情况。 ip_hash，每个请求按访问IP的hash结果分配(IP地址的前三段)，这样来自同一个IP的固定访问一个后端服务器，主要解决动态网站session共享的问题。 192.168.40.xxx url_hash，按照访问的URL的hash结果来分配请求，是每个URL定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率，nginx本身不支持，如果想使用需要安装nginx的hash软件包。 server模块的写法server IP 调度状态 server指令指定后端服务器IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。 down 表示当前的server暂时不参与负载均衡。 backup 预留的备份服务器，当其他所有的非backup服务器出现故障或者忙的时候，才会请求backup机器，因为这台集群的压力最小。 max_fails 允许请求失败的次数，默认是1，当超过最大次数时，返回proxy_next_upstream模块定义的错误。0表示禁止失败尝试，企业场景：2-3.京东1次，蓝汛10次，根据业务需求去配置。 fail_timeout，在经历了max_fails次失败后，暂停服务的时间。京东是3s，蓝汛是3s，根据业务需求配置。常规业务2-3秒合理。 vue项目的发布开发或者测试环境的确认执行打包命令 npm run build:prod把dist文件夹放入centos 的 &#x2F;opt&#x2F;dist目录​ 放入vagrant共享目录， vagrant reload读取文件，通过cp命令copy到opt目录下 修改nginx的配置（server段）123456789101112131415161718192021#nginx.confhttp &#123; ..... upstream tc &#123; server 192.168.66.182:8080; &#125; include /etc/nginx/conf.d/my.conf&#125;#my.confserver &#123; .... location /&#123; root /opt/dist; index index.html index.htm; &#125; location /core &#123; proxy_pass http://tc; &#125;&#125; 八、session共享1.ip_hash缺点： 分配不均匀。 如果后端还作了其他负载均衡，就不能共享session 2.tomcat会话复制会话数据会存储在每个服务器上的堆内存中 2.1 实现步骤 在每一个tomcat中添加集群缓存配置 在tomcat的conf中找到server.xml，在这一行下面添加下面内容： 12345678910111213141516171819202122&lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot; channelSendOptions=&quot;8&quot;&gt; &lt;Manager className=&quot;org.apache.catalina.ha.session.DeltaManager&quot; expireSessionsOnShutdown=&quot;false&quot; notifyListenersOnReplication=&quot;true&quot;/&gt; &lt;Channel className=&quot;org.apache.catalina.tribes.group.GroupChannel&quot;&gt; &lt;Membership className=&quot;org.apache.catalina.tribes.membership.McastService&quot; address=&quot;228.0.0.4&quot; port=&quot;45564&quot; frequency=&quot;500&quot; dropTime=&quot;3000&quot;/&gt; &lt;Receiver className=&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot; address=&quot;auto&quot; port=&quot;4000&quot; autoBind=&quot;100&quot; selectorTimeout=&quot;5000&quot; maxThreads=&quot;6&quot;/&gt; &lt;Sender className=&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;&gt; &lt;Transport className=&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;/&gt; &lt;/Sender&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;/&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor&quot;/&gt; &lt;/Channel&gt; &lt;Valve className=&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot; filter=&quot;&quot;/&gt; &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot;/&gt; &lt;Deployer className=&quot;org.apache.catalina.ha.deploy.FarmWarDeployer&quot; tempDir=&quot;/tmp/war-temp/&quot; deployDir=&quot;/tmp/war-deploy/&quot; watchDir=&quot;/tmp/war-listen/&quot; watchEnabled=&quot;false&quot;/&gt; &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;/&gt;&lt;/Cluster&gt; 在每个项目的web.xml中添加下面标签 1&lt;distributable/&gt; 2.2 缺点 因为每个服务器都存储一份session，所以数据冗余 如果某个服务器内存很小，可能无法存储。 3.会话共享推荐使用Spring Session方案，主流, 会话存储在远程的redis缓存中. 3.1 实现原理 客户端第一次发请求时，没有携带sessionID，nginx将请求分发给服务器1 ，然后服务器1 产生session0，spring 对sesion0封装成sesion1，并根据session0计算并更新session1的id,然后 放入redis中，并把session0的原始ID回写到浏览器，这样服务器1 和redis中都会有一个相同的session1 当客户端发送第二次请求的时候，nginx将请求分发给服务器2 （无session），因为请求中携带了一个sessionID，那么服务器2 就根据sessionID得出session1的id，用这个id去redis中获取session。 3.2 实现步骤建两个springboot项目，内容如下，除了端口号不同 两个项目的pom依赖 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; templates目录添加login.html 1234&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; templates目录添加success.html 123&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;h1&gt;this is session1&lt;/h1&gt;&lt;span th:text=&quot;$&#123;session.username&#125;&quot;&gt;&lt;/span&gt; yml内容如下,注意：另一项目端口为8080 123456789server: port: 80spring: redis: host: 127.0.0.1 port: 6379 jedis: pool: max-idle: 8 config包下添加类 1234567@Configurationpublic class MyConfig implements WebMvcConfigurer &#123; public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/showSuc&quot;).setViewName(&quot;success&quot;); registry.addViewController(&quot;/showLogin&quot;).setViewName(&quot;login&quot;); &#125;&#125; controller包中添加类 @Controller public class UserCtl &#123; @RequestMapping(&quot;/login&quot;) public String hello(HttpSession session, String username)&#123; session.setAttribute(&quot;username&quot;,username); //注意：这里的session已不是传统session,被重构成新的session，存储在redis中 System.out.println(&quot;name:&quot;+username+&quot;,sessionID：&quot;+session.getId()); return &quot;success&quot;; &#125; &#125; 主类添加注解 //使用该注解，会重构session,参数为session存活时间 @EnableRedisHttpSession(maxInactiveIntervalInSeconds = 10000*30) @SpringBootApplication public class SessionApp &#123; public static void main(String[] args) &#123; SpringApplication.run(SessionApp.class,args); &#125; &#125; nginx中 修改配置 123456789 location / &#123; root /opt/project/emp; index index.html index.htm; proxy_pass http://tc; &#125;upstream tc&#123; server 192.168.1.144:80; server 192.168.1.144:8080; &#125; 重启nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload 启动redis: redis-server redis.conf 启动80和8080两个端口的项目 测试 浏览器输入http://192.168.184.100/login.html,输入用户名 http://192.168.184.100/showSuc，反复刷新观看","categories":[],"tags":[]},{"title":"Spring Cloud","slug":"Spring-Cloud","date":"2023-10-11T11:35:51.000Z","updated":"2023-10-11T11:46:58.000Z","comments":true,"path":"2023/10/11/Spring-Cloud/","link":"","permalink":"http://example.com/2023/10/11/Spring-Cloud/","excerpt":"","text":"springcloud和springboot的区别springboot专注于开发单个服务 springcloud用来开发多个服务，关注全局的服务的协调和治理工作，将springboot开发的单个微服务整合起来，给各个服务之间提供配置管理，服务发现，断路器，路由，事件总线，配置等继承服务。 springboot是springcloud的基础。 什么是springcloudSpring Cloud是一个基于Spring boot实现的微服务架构开发工具,微服务架构是SOA架构的发展。它为微服务架构中提供配置管理、服务治理、智能路由、断路器以及集群状态管理等等。Spring cloud是基于HTTP协议的架构。 Springboot只用来开发单个服务 Springcloud可以开发多个服务 核心组件： ​ 注册中心：Eureka ，Nacos，Consul ​ 负载均衡：Ribbon，sentinel， loadbalancer ​ 容错保护：Hystrix，resilience4j，sentinel ​ 服务调用：feign，openfeign ​ 网关：Zuul，Gateway ​ 配置中心：config，Nacos 入门案例有一个服务（提供者），提供图书的检索功能。 有另外一个服务（消费者），需要买书时，按照编号查看书的信息。 公共模块创建普通maven工程base00-common，并编写实体类 123456789@Data@NoArgsConstructor@AllArgsConstructorpublic class Book &#123; String isbn; String name; String author; double price;&#125; 服务提供者创建一个spring boot的web工程，并增加base00-common的依赖 依赖文件123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.wanho&lt;/groupId&gt; &lt;artifactId&gt;base00-common&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; service12345678910111213141516@Servicepublic class BookService &#123; static Map&lt;String,Book&gt; map = new HashMap&lt;&gt;(); static &#123; map.put(&quot;SB1001&quot;,new Book(&quot;SB1001&quot;,&quot;随便&quot;,&quot;佚名&quot;,50)); map.put(&quot;SB1002&quot;,new Book(&quot;SB1002&quot;,&quot;浮士德&quot;,&quot;歌德&quot;,60)); map.put(&quot;SB1003&quot;,new Book(&quot;SB1003&quot;,&quot;我们仨&quot;,&quot;杨绛&quot;,25)); &#125; public Book findByIsbn(String isbn) &#123; //查询数据库 return map.get(isbn); &#125;&#125; controller1234567@ResourceBookService bookService;@GetMapping(&quot;book/&#123;isbn&#125;&quot;)public Book findBookByIsbn(@PathVariable(&quot;isbn&quot;) String isbn)&#123; return bookService.findByIsbn(isbn);&#125; 服务的调用者创建一个普通springboot的web工程，并增加base00-common的依赖 用户服务 依赖文件123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.wanho&lt;/groupId&gt; &lt;artifactId&gt;base00-common&lt;/artifactId&gt;c &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;c 注册RestTemplate1234@Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; 编写Service，调用别人提供的服务12345678910111213141516@Servicepublic class UserService &#123; //服务提供者的服务URL //String host = &quot;http://localhost:8080&quot;; @Resource RestTemplate restTemplate; public Book searchBook(String isbn)&#123; System.out.println(&quot;用户查找图书&quot;); String url = host + &quot;/book/&quot; + isbn; Book book = restTemplate.getForObject(url, Book.class); return book; &#125;&#125; 编写控制器测试1234567891011@RestControllerpublic class UserController &#123; @Resource UserService userService; @GetMapping(&quot;borrow/&#123;isbn&#125;&quot;) public Book searchBook(@PathVariable(&quot;isbn&quot;) String isbn) &#123; return userService.searchBook(isbn); &#125;&#125; Eureka（注册中心）是Spring cloud中的一个服务治理模块。 NetFlix公司一系列开源产品中的其中之一，它的主要作用是服务的注册和发现。 服务器端：也称为服务注册中心，提供服务的注册和发现。Eureka支持高可用的配置，当集群当中有节点（分片）出现故障时，Eureka会自动进入自我保护模式，它允许故障期间提供服务的发现和注册，当故障分片（节点）恢复后，集群的其他节点（分片）会把数据同步过来。 客户端：主要包含服务的生产者和服务消费者。服务的提供者要和服务器端维持心跳，来更新它的服务租约。可以将服务器端的注册信息缓存到本地，并周期性的更新服务状态。 服务端创建一个普通springboot工程base01-eureka，注意不要选择web依赖，增加Eureka服务端依赖 依赖1234567891011121314151617181920212223242526272829303132333435363738&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;net.wanho&lt;/groupId&gt; &lt;artifactId&gt;base01-eureka&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;base01-eureka&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;2021.0.6&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 配置文件123456789101112131415server: port: 7100spring: application: name: eureka-servereureka: client: service-url: defaultZone: http://localhost:7100/eureka #是否从注册中心拉取信息，本身就是注册中心，不需要拉取信息 fetch-registry: false #当前工程是否要到注册中心去注册， 本身就是注册中心，所以不需要 register-with-eureka: false instance: hostname: localhost 启动类增加@EnableEurekaServer注解 12345678910@SpringBootApplication@EnableEurekaServer //启用Eureka的服务器端public class Base01EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01EurekaApplication.class, args); &#125;&#125; 服务提供者在原来的base01-provider上进行修改 增加依赖在各自的节点内，增加以下相关内容，注意不要覆盖 12345678910111213141516171819202122232425&lt;properties&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 配置文件1234567891011server: port: 8090spring: application: name: bookappeureka: client: service-url: defaultZone: http://localhost:7100/eureka register-with-eureka: true fetch-registry: true 修改主启动类增加@EnableEurekaClient注解或者@EnableDiscoveryClient 1234567891011@SpringBootApplication@EnableEurekaClient //启用Eureka的客户端//@EnableDiscoveryClient //使用于Eureka以及其他非Eureka的卡护短public class Base01ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01ProviderApplication.class, args); &#125;&#125; 服务消费者在原来的base01-consumer上进行修改 增加依赖参考服务提供者 配置文件1234567891011server: port: 8081spring: application: name: userappeureka: client: service-url: defaultZone: http://localhost:7100/eureka register-with-eureka: true fetch-registry: true 修改主启动类增加@EnableEurekaClient注解 123456789101112131415@SpringBootApplication@EnableEurekaClientpublic class Base01ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01ConsumerApplication.class, args); &#125; @Bean @LoadBalanced //启用ribbon的负载均衡 public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改RestTemplate增加负载均衡 12345@Bean@LoadBalanced //启用ribbon的负载均衡public RestTemplate restTemplate()&#123; return new RestTemplate();&#125; 修改调用host用服务名替换原来的具体节点URL 123456789101112131415161718@Servicepublic class UserService &#123; //服务提供者的服务URL //String host = &quot;http://localhost:8080&quot;; //用服务名替换具体的服务器的URL String host = &quot;http://BOOKAPP&quot;; @Resource RestTemplate restTemplate; public Book searchBook(String isbn)&#123; System.out.println(&quot;用户查找图书&quot;); String url = host + &quot;/book/&quot; + isbn; Book book = restTemplate.getForObject(url, Book.class); return book; &#125;&#125; 指定服务的IP地址使用eureka.instance.prefer-ip-address&#x3D;true显示ip eureka.instance.ip-address&#x3D;127.0.0.1来指定ip地址 1234567891011121314server: port: 8070spring: application: name: bookappeureka: client: service-url: defaultZone: http://localhost:7100/eureka register-with-eureka: true fetch-registry: true instance: prefer-ip-address: true ip-address: 127.0.0.1 服务端添加用户验证整合spring security，要求客户端注册时，提供服务端需要的用户名和密码 服务器端引入依赖引入spring-boot-starter-security依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 修改配置配置文件当中指定用户名和密码，并且修改defaultZone配置 1234567891011121314151617server: port: 7100spring: application: name: eureka-server security: user: name: admin password: 123456eureka: client: service-url: defaultZone: http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@localhost:$&#123;server.port&#125;/eureka #是否要到注册中心拉取服务 fetch-registry: false #当前的服务是否要注册到指定的注册中心，由于现在时server自身，不需要注册 register-with-eureka: false 增加springsecurity的配置项12345678910111213@Configuration@EnableWebSecuritypublic class SecurityConfig &#123; @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123; http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); http.csrf().disable(); http.authorizeRequests().anyRequest().authenticated().and().httpBasic(); return http.build(); &#125;&#125; 客户端在注册配置时，提供用户名和密码 1234567891011121314server: port: 8090spring: application: name: GOODSeureka: client: service-url: defaultZone: http://admin:123456@localhost:7100/eureka register-with-eureka: true fetch-registry: true instance: prefer-ip-address: true ip-address: 192.168.40.251 取消刷新默认情况下，Eureka client是可以刷新的。当刷新客户端时，客户端暂时从服务器中取消注册，可能在短暂的时间内不提供给定的服务实例。设置配置：eureka.client.refresh.enable&#x3D;false ，则不刷新客户端 自我保护默认情况下，Eureka服务器端在一定的时间内如没有接收某个服务端实例的心跳，EurekaServer将会注销该实例。当网络发生故障的时候，微服务就可能无法正常通信。Eureka通过自我保护来解决这个，在短时间内失去过多的客户端的时候，进入自我保护模式，一但进入该模式，就会保护服务列表，不再删除服务注册列表中的数据。当故障恢复以后，退出自我保护模式。 负载均衡器LoadBalancer客户端的负载均衡器，进程内部的负载均衡器。默认的策略是轮询，还有一个是随机。可以自定义策略。 使用方式，在RestTemplate对象上加入@LoadBalanced 随机策略定义一个类（不能使用@Configuration注解），在此类当中增加一个@Bean注解的方法。返回RactorLoadbalancer接口的对象。 在配置类或者主启动类上使用@@LoadBalancerClients或者@LoadBalancerClient，指定上述定义的类为配置类 定义配置注意：千万不要增加@Configuration注解 1234567891011public class LoadBalancerConfig &#123; @Bean ReactorLoadBalancer&lt;ServiceInstance&gt; randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory) &#123; String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new RandomLoadBalancer(loadBalancerClientFactory .getLazyProvider(name, ServiceInstanceListSupplier.class), name); &#125;&#125; 启动类修改1234567891011121314151617181920212223@SpringBootApplication@EnableEurekaClient//配置单个服务的负载均衡策略//@LoadBalancerClient(value = &quot;GOODS&quot;,configuration = LoadBalancerConfig.class)//多个服务，采用同一个策略@LoadBalancerClients(defaultConfiguration = LoadBalancerConfig.class)//@LoadBalancerClients(value = &#123;@LoadBalancerClient(value = &quot;GOODS&quot;,configuration =LoadBalancerConfig.class )&#125;// , defaultConfiguration = LoadBalancerConfig.class)public class Base01OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01OrderApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 自定义负载均衡策略需求：使用轮询方式访问服务器，每个服务器访问三次之后换下一个服务器 需要两个属性：1）用来记录当前的服务器被调用了几次 ​ 2）记录当前服务器是第几台服务器 如果当前的服务器已经被调用三次，换下一台服务器（i ） 编写负载均衡策略类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MyRRLoadBalancer implements ReactorServiceInstanceLoadBalancer &#123; private static final Log log = LogFactory.getLog(RoundRobinLoadBalancer.class); final AtomicInteger position; final String serviceId; ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider; int count=0; int MAX=3; public MyRRLoadBalancer(String serviceId, ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider) &#123; this((new Random()).nextInt(1000),serviceId,serviceInstanceListSupplierProvider); &#125; public MyRRLoadBalancer(int position, String serviceId, ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider) &#123; this.position = new AtomicInteger(position);; this.serviceId = serviceId; this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider; &#125; public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123; ServiceInstanceListSupplier supplier = (ServiceInstanceListSupplier)this.serviceInstanceListSupplierProvider.getIfAvailable(NoopServiceInstanceListSupplier::new); return supplier.get(request).next().map((serviceInstances) -&gt; &#123; return this.processInstanceResponse(supplier, serviceInstances); &#125;); &#125; private Response&lt;ServiceInstance&gt; processInstanceResponse(ServiceInstanceListSupplier supplier, List&lt;ServiceInstance&gt; serviceInstances) &#123; Response&lt;ServiceInstance&gt; serviceInstanceResponse = this.getInstanceResponse(serviceInstances); if (supplier instanceof SelectedInstanceCallback &amp;&amp; serviceInstanceResponse.hasServer()) &#123; ((SelectedInstanceCallback)supplier).selectedServiceInstance((ServiceInstance)serviceInstanceResponse.getServer()); &#125; return serviceInstanceResponse; &#125; private Response&lt;ServiceInstance&gt; getInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123; if (instances.isEmpty()) &#123; if (log.isWarnEnabled()) &#123; log.warn(&quot;No servers available for service: &quot; + this.serviceId); &#125; return new EmptyResponse(); &#125; else if (instances.size() == 1) &#123; return new DefaultResponse((ServiceInstance)instances.get(0)); &#125; else &#123; int pos; if(count&lt;MAX) &#123; pos = this.position.get(); &#125; else &#123; pos = this.position.incrementAndGet() &amp; 2147483647; count=0; &#125; ServiceInstance instance = (ServiceInstance)instances.get(pos % instances.size()); count++; return new DefaultResponse(instance); &#125; &#125;&#125; 配置类修改1234567891011121314151617181920public class LoadBalancerConfig &#123; //@Bean //ReactorLoadBalancer&lt;ServiceInstance&gt; randomLoadBalancer(Environment environment, // LoadBalancerClientFactory loadBalancerClientFactory) &#123; // String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); // return new RandomLoadBalancer(loadBalancerClientFactory // .getLazyProvider(name, ServiceInstanceListSupplier.class), // name); //&#125; @Bean ReactorLoadBalancer&lt;ServiceInstance&gt; randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory) &#123; String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new MyRRLoadBalancer(name,loadBalancerClientFactory .getLazyProvider(name, ServiceInstanceListSupplier.class) ); &#125;&#125; Ribbon（旧）Ribbon是NetFlix发布的客户端负载均衡器，主要是用来控制HTTP和TCP客户端的行为。为Ribbon配置了服务提供者的地址列表后，Ribbon就可以基于某种负载均衡算法，自动地帮助服务消费者去请求对应的服务实例。Ribbon提供很多的负载均衡策略：轮询，随机，最少使用等。 Nginx和Ribbon的区别： Nginx：是集中式的负载均衡设备（软件），Ribbon是进程内的负载均衡器，只是一个类库，集成在消费方的进程当中，消费方通过它来获取服务提供者的位置。 Nignx是服务器端负载均衡器，客户端的请求都是交给Nginx，然后由Nginx进行转发。 Ribbon：在调用微服务接口的时候，会在注册中心上获取注册的服务列表，缓存到本地。 如何负载均衡策略123456789@Configurationpublic class AppConfig &#123; @Bean public IRule iRule()&#123; return new RandomRule(); &#125;&#125; 自带的负载均衡策略RoundRobinRule：轮询，尝试超过10次以后，直接不提供服务。 RandomRule: 随机策略 Retry：先按照轮询的策略获取服务，如果服务失败，则在指定的时间内进行重试，获取可用的服务 WeightedResponseTimeRule：是对轮询策略的扩展，每30秒钟计算一次服务器的响应时间，以响应时间作为权重，响应时间越短，响应速度越快的服务器被选中的概率越大。 BestAvailableRule：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，在可用列表中选择一个并发量最小的服务实例。 AvailabilityFilteringRule：：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，再选择一个相对并发量较小的实例。 ZoneAvoidanceRule：根据服务提供者实例的所在区域以及响应的可用性选择服务器。 自定义负载均衡策略需求：使用轮询方式访问服务器，每个服务器访问三次之后换下一个服务器 需要两个属性：1）用来记录当前的服务器被调用了几次 ​ 2）记录当前服务器是第几台服务器 如果当前的服务器已经被调用三次，换下一台服务器（i ） 定义策略12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CustomizeRule extends AbstractLoadBalancerRule &#123; //当前服务器索引的访问次数 private int total=0; //当前的服务器索引 private int currentIndex = 0; @Override public void initWithNiwsConfig(IClientConfig iClientConfig) &#123; &#125; @Override public Server choose(Object o) &#123; return choose(getLoadBalancer(),o); &#125; public Server choose(ILoadBalancer lb,Object key) &#123; if(lb == null) &#123; return null; &#125; Server server = null; //隐形风险：如果一直找不到可用的服务器实例，导致死循环 while (server==null)&#123; //获取可用的服务器列表 List&lt;Server&gt; reachableServers = lb.getReachableServers(); //获取所有的服务器列表 List&lt;Server&gt; allServers = lb.getAllServers(); int upCount = reachableServers.size(); int serverCount = allServers.size(); //没有可用的服务器实例，直接返回 if (upCount==0) &#123; return null; &#125; if(total &lt; 3) &#123; server=reachableServers.get(currentIndex); if (server==null) &#123; Thread.yield(); continue; &#125; total++; &#125; else &#123; currentIndex = (currentIndex + 1) % upCount; //currentIndex++; //if (currentIndex== upCount) &#123; // currentIndex=0; //&#125; server = reachableServers.get(currentIndex); if (server==null) &#123; Thread.yield(); continue; &#125; total =1; &#125; &#125; return server; &#125;&#125; 配置123456789@Configurationpublic class AppConfig &#123; @Bean public IRule iRule()&#123; //return new RandomRule(); return new CustomizeRule(); &#125;&#125; OpenFeign（Http服务调用）OpenFeign是NetFlix开发的声明式、模板化的HTTP客户端，用于HTTP请求调用的轻量级的框架，以Java接口注解的方式调用HTTP请求。OpenFeign支持SpringMVC注解，可以和Eureka，nacos等整合一起使用。 使用方法比较简单，主要是创建一个接口。接口上增加openfeign注解，并通过启动类进行注解的启用。通过注解，将请求模板化，根据参数对应到请求上。 使用步骤 导入依赖 在消费者端编写Openfeign的客户端（接口） 导入依赖增加以下依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 编写接口使用@FeignClient注解 123456789@Service//name指定要调用的服务名@FeignClient(name=&quot;bookapp&quot;)public interface UserServiceFeign &#123; @RequestMapping(value = &quot;book/&#123;isbn&#125;&quot;) Book findByIsbn(@PathVariable(&quot;isbn&quot;) String isbn);&#125; 修改控制器调用接口1234567891011121314@RestControllerpublic class UserController &#123; @Resource UserServiceFeign userServiceFeign; @GetMapping(&quot;borrow/&#123;isbn&#125;&quot;) public Book searchBook(@PathVariable(&quot;isbn&quot;) String isbn) &#123; return userServiceFeign.findByIsbn(isbn); &#125;&#125; 修改主启动类增加@EnableFeignClient注解 12345678910111213141516@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class Base01ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01ConsumerApplication.class, args); &#125; @Bean @LoadBalanced //启用ribbon的负载均衡 public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 特殊属性说明fallback和fallbackFactory，主要用于熔断机制，调用失败时，走的回退方法，可以用来抛出异常或者给出默认的数据。 decode404:配置响应状态为404时，是否抛出FeignException 调用的原理OpenFeign基于JDK的动态代理。 @EnableFeignClients：加上该注解，Springboot启动的时候，会导入FeignClientsRegistrar，扫描所有带有@FeignClient注解的接口 解析到@FeignClient的配置属性后，扩展Spring Bean Definition的注册逻辑上面，最终注册一个FeignClientFactoryBean，此对象会产生一个代理类对象。 设置超时时间可以参考在FeignClientProperties中的数据，主要是其内部类FeignClientConfiguration 123456feign: client: config: GOODS: #指定服务 connectTimeout: 1000 readTimeout: 1000 Hystrix（容错保护、断路器）背景在微服务的架构当中，原本一个大的服务会拆分成多个小服务单元，服务单元之间无法避免会有相互的依赖关系。由于这种依赖关系，当某一个服务单元出现故障，容易引起故障的蔓延，最终有可能导致整个系统的瘫痪。 雪崩效应：当某一个服务单元出现故障，容易引起故障的蔓延，顺着调用链向上传递，最终有可能导致整个系统的瘫痪的现象。 产生场景 硬件故障：服务器宕机，机房断电，光纤被挖断… 流量激增：异常流量激增，重试也会增加流量 缓存问题：由于缓存的问题，导致服务提供者的负荷增加了，引起服务的不可用。 程序BUG: 程序逻辑错误导致内存泄漏，JVM长时间进行FullGC。 同步等待：服务间采用同步调用机制，同步等待导致资源的耗尽。 Hystrix的目标：在于通过控制哪些远程访问、服务以及第三方的节点，从而对延迟或者故障提供更强大的容错能力。 Hystrix是干什么的NetFlix公司开源的，用于分布式系统的延迟和容错处理的开源库。用于隔离远程访问、服务以及第三方的库，防止级联失败，从而提升系统的可用性以及容错性。 CAP: C: 一致性。分布式集群中节点（broker）上的数据要保持一致。 A：可用性，要求服务端能够在指定的时间快速响应用户。 P: 分区容错性，当集群或者分布式系统中的某一个节点（服务）出现问题后，整个集群或分布式系统的使用不能收到影响。 要么是CP，要么AP 服务降级： 假设系统比较忙或者不可用的情况下，给一个友好提示或者默认处理。触发降级的场合：程序运行异常、超时、服务熔断触发服务降级，线程池当中并发量达到阈值也可能导致服务降级。 服务熔断：达到最大服务访问量以后，直接拒绝访问，然后调用服务降级的方法给出友好提示。 服务限流：秒杀，抢红包等一系列高并发操作，严控一窝蜂的过来拥挤，让大家排队有序进行。 RestTemplate方法依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; service中的方法 降级方法的参数和返回值要和原来方法一致 12345678910111213141516171819202122232425262728293031@Servicepublic class UserService &#123; //服务提供者的服务URL //String host = &quot;http://localhost:8080&quot;; //用服务名替换具体的服务器的URL String host = &quot;http://BOOKAPP&quot;; @Resource RestTemplate restTemplate; @HystrixCommand(fallbackMethod = &quot;fallback&quot;) public Book searchBook(String isbn)&#123; System.out.println(&quot;用户查找图书&quot;); String url = host + &quot;/book/&quot; + isbn; Book book = restTemplate.getForObject(url, Book.class); return book; &#125; public String getServer()&#123; String url = host + &quot;/server&quot;; String server = restTemplate.getForObject(url, String.class); return server; &#125; public Book fallback(String isbn)&#123; return new Book(&quot;XXXX&quot;,&quot;服务器出现异常&quot;,&quot;&quot;,0.0); &#125;&#125; 启动类 增加@EnableHystrix或者@EnableCircuitBreaker注解 123456789101112131415161718@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableHystrix //启动Hystrix断路器//@EnableCircuitBreaker //启用容错保护组件（）public class Base01ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base01ConsumerApplication.class, args); &#125; @Bean @LoadBalanced //启用ribbon的负载均衡 public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 统一处理在Service类上使用@DefaultProperties注解，指定默认的服务降级的方法。 全局降级的方法，不能带有参数。 需要降级处理的方法上，不指定降级目标方法（回退方法），但是@HystrixCommand注解需要保留 OpenFeign方式开启Hystrix12345feign: httpclient: connection-timeout: 2000 #连接服务端的时间 + 实际读取的时间 hystrix: enabled: true #开启容错保护组件 fallback属性使用@FeignClient的fallback属性，设置成指定的类 处理降级的类，需要实现对应的接口 1234567@Componentpublic class UserServiceFeignException implements UserServiceFeign &#123; @Override public Book findByIsbn(String isbn) &#123; return new Book(&quot;110&quot;,&quot;我是服务器，现在挂机中&quot;,&quot;&quot;,0.0); &#125;&#125; fallbackFactory属性使用@FeignClient的fallbackFactory属性，设置成指定的类 处理降级的类，实现FallbackFactory接口 123456789101112@Componentpublic class UserServiceFeignFactory implements FallbackFactory&lt;UserServiceFeign&gt; &#123; @Override public UserServiceFeign create(Throwable throwable) &#123; return new UserServiceFeign() &#123; @Override public Book findByIsbn(String isbn) &#123; return new Book(&quot;666&quot;,&quot;光纤被挖断了&quot;,&quot;&quot;,0.0); &#125; &#125;; &#125;&#125; 熔断演示HystrixCommandProperties：普通参数HystrixThreadPoolProperties：和线程池相关参数 看板（仪表盘）仪表盘项目创建一个web项目，要把web依赖去掉，增加hystrix-dashboard的依赖 配置项目增加hystrix.dashboard.proxy-stream-allow-list&#x3D;* 在主启动类上要增@EnableHystrixDash注解 配置HystrixMetricsStreamServlet （可以使用配置文件，也可以在启动类当中注册） 被监控项目增加两个依赖 hystrix-dashboard actuator依赖 配置项目 12345management: endpoints: web: exposure: include: hystrix.stream 启动项目测试 启动dashboard，输入localhost:端口号&#x2F;hystrix 启动被监控项目，在前面的页面窗口，输入 localhost:被监控项目端口号&#x2F;actuator&#x2F;hystrix.stream Resilience4J依赖增加springboot-aop以及actuator依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-circuitbreaker-resilience4j&lt;/artifactId&gt;&lt;/dependency&gt; 配置服务可用的配置项目：CircuitBreakerConfig当中，可以去参考 使用断路器网关GatewayGateway是Spring Cloud的子项目，Spring2.X提供的，Spring1.X用的是zuul（已经停更，进入维护期），提供简单有效的API路由管理方式。 Gateway作为zuul的替代品，是Springcloud生态中的网管。是基于WebFlux，高效能的Reactor模式。 Gateway的特点： ​ 支持动态路由：能够匹配路由的任何请求属性 ​ 集成Spring Cloud的服务发现功能 ​ 支持限流功能 ​ 支持路径重写 ​ 提供断言（Predicate）以及过滤器（Filter），可以设置路由的一些条件 功能服务网关：路由转发 + 过滤器 路由转发：接收客户端的请求，将请求转发到指定的微服务上。 过滤器：可以帮助网关实现一些类似于AOP可以完成的一些操作，认证，服务的监控，限流。 案例： 有四个微服务，每个微服务都需要权限的认证 ​ 方案一：每个微服务都实现一下权限认证的代码&#x3D;&#x3D;&#x3D;&gt;基本不会使用 ​ 方案二：将认证服务写成一个公共的服务，每个业务相关的微服务都来调用公共的服务。 ​ 方案三：将认证服务写到网关的过滤器 核心概念路由（Route）：路由是构建网关的基本模块。它由ID,目标URI,一系列的断言和过滤器组成。 断言（Predicate）：开发人员可以通过断言的相关设置，匹配HTTP请求中的参数内容，设置访问路由的条件 过滤器（Filter）：通过过滤器，可以在路由前后进行一些修改 如何编写网关创建一个springcloud项目 增加网关依赖，eureka客户端 配置相应的网关 动态路由1234567891011121314151617181920212223spring: application: name: base03-gateway cloud: gateway: routes: - id: gt-bookapp #id值需要位置# uri: http://localhost:8070 uri: lb://bookapp #lb为固定值，表示负载均衡，bookapp为服务名 predicates: - Path=/** discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由server: port: 10000 #作为eureka的客户端的配置eureka: client: service-url: defaultZone: http://localhost:7100/eureka register-with-eureka: true fetch-registry: true 断言断言（Predicates）是一组匹配规则，请求只有和规则相匹配时才可以访问 -Path : 匹配路径 -After ： - After&#x3D;时间 （在某个时间之后可以访问）由于是ZoneDateTime， 时间需要带有时区 ​ - After&#x3D;2021-11-24T11:35:57.557+08:00[Asia&#x2F;Shanghai] Before： - Before&#x3D;时间 （在某个时间之前可以访问） -Between: - Before&#x3D;时间1, 时间2 -Cookie, phone为key，15911111111 -Header： 表示请求头当中，需要包含某些内容，请求才可以访问 ​ -Header&#x3D;authenticator, 1111 -Method: 匹配请求方式，如 -Method&#x3D;POST,GET -Query：匹配请求的参数 -Query&#x3D;price,\\d+ : 请求当中需要携带price参数，且值必须数字才可以访问 过滤器Spring cloud通过过滤器在请求的前后进行一部分分更新 抽象类AbstractGatewayFilterFactory的子类对象，配置的时候，去掉GatewayFilterFactory后缀 12345678910111213141516171819spring: application: name: base03-gateway cloud: gateway: routes: - id: gt-bookapp #id值需要位置# uri: http://localhost:8070 uri: lb://bookapp #lb为固定值，表示负载均衡，bookapp为服务名 predicates: - Path=/book/** #限制访问的路径 - After=2021-11-24T11:35:57.557+08:00[Asia/Shanghai] filters: - AddRequestHeader=username,xiaoming - RedirectTo=302,http://www.baidu.com discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由 自定义全局过滤器实现GlobalFilter接口，对所有的路由均有效。 123456789101112131415@Componentpublic class MyGlobalFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; //要求访问网关时，必须带有user参数，如果为null，则不放行，拒绝，不为null，则放行 String user = exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;); if (user == null) &#123; System.out.println(&quot;===用户参数user没有设置&quot;); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); exchange.getResponse().setComplete(); //设置拒绝 &#125; return chain.filter(exchange); //放行 &#125;&#125; 局部过滤器实现AbstractGatewayFilterFactory，要以GatewayFilterFactory作为类的后缀名 在指定路由的filters下定义对应的过滤器即可。 123456789101112131415//定义过滤器@Componentpublic class MyTestGatewayFilterFactory extends AbstractGatewayFilterFactory &#123; @Override public GatewayFilter apply(Object config) &#123; return new GatewayFilter() &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;=========局部过滤器=====================&quot;); return chain.filter(exchange); &#125; &#125;; &#125;&#125; 配置过滤器 1234567891011121314151617181920spring: application: name: base03-gateway cloud: gateway: routes: - id: gt-bookapp #id值需要位置# uri: http://localhost:8070 uri: lb://bookapp #lb为固定值，表示负载均衡，bookapp为服务名 predicates: - Path=/book/** #限制访问的路径 - After=2021-11-24T11:35:57.557+08:00[Asia/Shanghai] filters: - MyTest #- AddRequestHeader=username,xiaoming #- RedirectTo=302,http://www.baidu.com discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由 nacosNaming Configuration Service： 注册中心 + 配置中心 + 配置总线的组合组件 中文官网：https://nacos.io/zh-cn/index.html 英文spring： spring.io 下载：https://github.com/alibaba/nacos 使用nacos，不需要单独在编写一个nacos服务器端，已经提供。nacos是基于java代码实现。阿里出品。 注册中心依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2021.0.4.0&lt;/version&gt; &lt;/dependency&gt; 注册配置1234567891011server: port: 8082spring: application: name: GOODS cloud: nacos: discovery: server-addr: http://localhost:8848 namespace: java180 group: dev 主启动类注解123456789@SpringBootApplication@EnableDiscoveryClientpublic class Base04GoodsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Base04GoodsApplication.class, args); &#125;&#125; 配置中心步骤增加依赖 配置 在主启动类增加@EnableDiscoveryClient注解 读取属性的类上，使用@RefreshScope来进行动态属性的拉取 依赖123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2021.0.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;2021.0.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springcloud 2020.x只用去掉了bootstrap，需要重新加上 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; 配置文件配置bootstrap.ymlbootstrap.yml ：会在application.yml读取之前先读，其中的内容是不会被覆盖 123456789101112131415spring: cloud: nacos: discovery: #注册中心 server-addr: http://localhost:8848 namespace: java180 group: dev service: configinfo config: #配置中心 server-addr: http://localhost:8848 namespace: java180 #默认情况下是public，不能写public，不进行此属性的配置即可 group: dev #配置文件定义的profile（group）s file-extension: yaml #需要进行 application: name: configinfo 配置application.yml123spring: profiles: active: test nacos配置中心文件名的命名规则在nacos配置中心设置配置文件时，文件的dataId由三个部分组成，prefix，profile（dev，test，prod），file-extension（yaml或者properties，根据选择的文件类型来决定） ​ prefix-profile.file-extension prefix: 默认为spring.application.name的值(例：项目：nacos-config)，也可以通过配置项spring.cloud.nacos.config.prefix profile: spring.profiles.active对应的环境，如果没有设置多环境，则文件名 prefix.file-extension file-extension: 目前只支持properties和yaml namespace：项目隔离的作用 配置案例configinfo-dev.yaml123456server: port: 10086user: name: zhangsan age: 10 scholl: 五老村小学 属性获取类12345678910@Component@RefreshScope //用于读取远程的配置文件，支持动态刷新@ConfigurationProperties(prefix = &quot;user&quot;)@Datapublic class User &#123; String name; int age; String school;&#125; 主启动类1234567891011@SpringBootApplication@EnableDiscoveryClient //标记是一个nacos的客户端public class Base05ConfiginfoApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext ctx = SpringApplication.run(Base05ConfiginfoApplication.class, args); User bean = ctx.getBean(User.class); System.out.println(bean); &#125;&#125; sentinelSentinel是alibaba提供的用于实时监控、流量控制、异常熔断等管理工具，它可以于nacos进行组合使用，可以对项目进行图形化的配置和管理。 运行启动sentinel，可以通过–server.port指定端口号 1java -jar sentinel-dashboard-1.8.2.jar --server.port=8081 依赖流量控制监控应用流量的QPS(每秒请求次数)或者并发线程数，当达到指定阈值的时候进行流量控制，以避免被瞬间的流量高峰击垮，从而保证应用的高可用性。 资源源：唯一，默认是请求的路径 针对来源：sentinel可以对调用者进行限流，默认是default（不区分来源），想要区分来源的情况，填写来源的服务名 阈值类型： ​ QPS: 每秒请求数量，达到此阈值的时候会限流 ​ 并发线程数 流控模式： ​ 直接：直接限流 ​ 关联：如果请求m1关联m2, 如果m2达到阈值，则限流m1 ​ 链路：需要设置入口资源，对整个链路进行流量限制 流控效果： ​ 快速失败：超出阈值后，直接抛出异常，请求失败 ​ warm up：预热&#x2F;冷启动模式，经过一定的市场（n秒），从codeFactor（&#x3D;3）阈值慢慢达到指定的阈值 ​ 排队等待：当请求超出阈值之后，需要进行排队等待，等待的时间可以进行设置。 123456789101112@GetMapping(&quot;test&quot;) // /test //@SentinelResource(value = &quot;test&quot;,fallback = &quot;fallbackMethod&quot;) @SentinelResource(value = &quot;test&quot;,fallback = &quot;fallbackMethod&quot; ,fallbackClass = InfoFallBackComponent.class) public String test()&#123; System.out.println(&quot;test: &quot; + LocalDateTime.now()); return &quot;game over&quot;; &#125; //public String fallbackMethod(Throwable e)&#123; // return &quot;方法被限流&quot;; //&#125; 熔断降级Sentinel熔断降级主要是适用某个资源请求处理不稳定的情况下，对此资源进行调用限制。 不稳定的因素：调用时间比较常，异常出现的频率高 统计1秒种（1000ms）时间内，如果请求的次数达到2次以上（最小请求数），慢调用（请求的时间超过100猫喵）的比例，达到0.5的情况，就会熔断20秒。 热点key设置调用后端接口的参数，根据方法上来，0为第一个参数，1为第二个参数。 资源名：可以是请求的url，也可以是@SentinelResource的value值。 blockHandler对应的方法，除了参数以及返回值之外，还需要增加一个BlockException参数 sentinel和openfeign进行整合，如何进行服务降级处理。 12345678@GetMapping(&quot;/testHotkey&quot;) @SentinelResource(value = &quot;/testHotkey&quot;,blockHandler = &quot;blockHandler&quot;) public String testHotKey(String p1,String p2) &#123; return &quot;success&quot;; &#125; public String blockHandler(String p1, String p2, BlockException ex) &#123; return &quot;blockHandler&quot;; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2023-09-19T15:32:04.000Z","updated":"2023-09-19T15:48:26.000Z","comments":true,"path":"2023/09/19/Linux常用命令/","link":"","permalink":"http://example.com/2023/09/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"操作系统操作系统是实现控制和管理计算机软硬件资源的系统软件。它可以有效地组织多个程序的运行，方便用户操作。常见的操作系统：windows,mac,linux,OS&#x2F;2,以及各种嵌入式操作系统。目前操作系统的分类：批处理操作系统，分时操作系统，实时操作系统，网络操作系统和分布式操作系统。 操作系统的性能指标：吞吐量，资源利用率，公平性，实时性，可靠性以及安全性。 操作系统功能： ​ 存储管理：内存分配，地址映射，内存的保护以及扩充 ​ 进程管理：进程调度，进程控制，进程之间的通信 ​ 文件管理：文件存储空间管理、文件操作、目录、读写权限等 ​ 设备管理：缓冲设备、设备分配、设备驱动 ​ 用户接口：图形用户接口，命令行接口 LinuxLinux，全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds）于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它支持32位和64位硬件，能运行主要的Unix工具软件、应用程序和网络协议。 在国内用的比较多的版本：Ubuntu，Centos，RedHat Linux的文件基础linux系统以文件为基础，系统子目录当中的文件主要是保证系统的正常运行。 &#x2F;，&#x2F;home &#x2F;usr &#x2F;var &#x2F;bin &#x2F;sbin &#x2F;etc &#x2F;dev &#x2F;lib &#x2F; : linux系统的根目录（主目录） &#x2F;bin &#x2F;sbin: 用于存放linux的系统命令和工具 &#x2F;boot: linux的启动目录，从此开始启动 &#x2F;dev：存放linux当中的所有设备文件 &#x2F;etc: 系统配置文件所在的位置 &#x2F;lib，&#x2F;lib64: 存放操作系统的库文件 &#x2F;home ：用户目录，linux当中每增加一个用户，都会在此目录下相应地增加一个文件，文件名和用户名相同（root除外），给每个用户自己的空间 &#x2F;mnt: 外部设备的挂载点，可以挂载光驱和软盘 &#x2F;root： root用户的目录 &#x2F;usr：通常用来安装各种软件的地方 &#x2F;var：通常用来放置一些变化的文件 &#x2F;var&#x2F;log： 存放系统的日志文件 &#x2F;run: Linux系统中用于存放运行文件的临时目录,通常情况下它会包含一些程序运行时需要的文件,例如PID文件、锁文件、socket文件等等。这些文件的作用是协助程序运行时的交互,确保程序能够顺利地完成任务。 &#x2F;proc: Linux 内核提供了一种通过 &#x2F;proc 文件系统,在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统,它只存在内存当中,而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。 &#x2F;srv&#x2F;:系统服务数据的目录。一些系统服务启动之后,可以在这个目录中保存所需要的数据。 Linux系统是区分大小写，Linux文件没有扩展名 常用命令补全和帮助tab补全：linux当中的命令比较多，无法记全的情况下，可以使用tab键进行提示。当只有一个匹配命令时，tab键可以帮助不全，当有个匹配，双按tab，会提示命令。 当命令的参数或者option信息不清楚，可以使用man命令或者help进行帮助查看。 ​ man 命令（man ls） ​ 命令 –help 目录命令目录和路径主目录和工作目录：每一个用户都有自己的主目录，这个是管理员在创建用户的时候指定的。用户在自己的home目录当中可以进行各种操作，用户对自己的主目录拥有最大的权限。 工作目录：指当前所在的位置，进入linux之后，用户始终都会有一个工作目录。可以使用cd命令切换工作目录。 ​ 可以使用pwd命令查看当前所在的工作目录的完整路径。 目录命令cdls [options]options比较多，无法记住，使用man ls 或者 ls –help方式进行求助 命令比较常，记不住的情况，可以使用tab求助。 1234567-a 显示目录中所有文件大小-k 以KB为单位显示文件大小-m 以MB为单位显示文件大小-g 以GB为单位显示文件大小-h 以易读方式显示文件大小-s 仅显示总计-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和 几个特殊路径： ​ cd &#x2F; :进入根目录 ​ cd ~: 进入当前用户的主目录 ​ cd .. :返回到上一级目录 ​ cd -: 返回上一次所在目录 绝对路径： 从文件的根目录开始的路径，始终以 &#x2F;开头 相对路径：从当前的工作目录开始的路径，要和工作目录结合起来，才能确定所在的位置。 ls：列举指定目录中的文件和目录 mkdir：创建新目录 rmdir：删除指定的目录（必须是空目录，如果不是空，可以先删除此目录中的对象，再删除，还可以使用rm命令） 常用文件命令touch：创建空文件cp：复制文件。可将文件复制到不同的目录，也可将指定目录中的文件复制到其他位置mv：将文件或目录移动至一个新的位置rm: 删除文件或目录ln ： 创建链接（类似与windows的快捷方式）whereis：查找文件。可以查找文件的源、二进制文件或手册which: 查找二进制文件find：查找文件location：查找文件grep ：所有文本 touch：创建空文件用touch命令可以创建一个没有任何内容的空文件。 1touch file01 cp：复制文件类似与DOS命令中的copy语法：cp 选项 源文件或目录 目标文件或目录可以将文件复制到不同的目录，也可以将指定目录中的文件复制到其他位置。常用参数-a：相当与-dpr参数-d：保留链接-f：强制复制，覆盖目标文件-i：覆盖时询问用户-p：保留修改时间和访问权限-r，-R：递归复制（目录到目录）-l：创建链接-v：显示过程 12345678#当前文件夹下复制一个文件cp 3.txt 4.txt #将当前目录下的txt复制到根目录下cp *.txt / #将data目录（文件）复制到2目录下 cp -r data data1/ #将hello文件复制到/opt目录下cp -p hello.java /opt/hello.java mv：移动文件或目录将文件或目录移到一个新的位子。也可以用来修改文件名称mv 选项 源文件或目标 目标文件或目录常用参数：-i：交互方式操作，如果mv操作将导致对已存在文件的覆盖，此时系统询问是否重写，要求用户回答y或n-f：禁止交互操作。覆盖时不会提示。 1mv -i hello.java hello1.java rm： 删除文件或目录​ rm [选项] 文件​ 常用参数：​ -i : 为了避免误删除文件，可以使用此项，进行用户确认删除​ -f: 强制删除，使用该选项后将不提示所删除的文件​ -v: 显示文件的删除速度​ -r: 删除某个目录以及其中所有的文件和子目录。 1234#删除文件rm aa#删除目录rm -rf a 在Linux中可以创建链接文件，当使用rm删除链接文件时，只是删除该链接文件，实际的文件仍旧继续存在。 ln：创建链接文件​ Linux中的链接类似于windows的快捷方式，分两种：软连接和硬链接。​ 创建软链接，只是在指定的位置上生成一个镜像，不会占用磁盘空间。​ 语法： ln -s 目标文件 链接文件名​ 创建硬链接，将在指定的位置上生成一个和源文件大小相同的文件。​ 语法： ln 目标文件 链接文件名​ 无论是软链接还是硬链接，链接文件和目录文件都将保持同步变化。​ 不能创建目录的硬链接。 1234#创建软链接ln -s hello hellolink#查找文件find -name hello whereis：查找文件whereis用来查找程序的源、二进制文件或手册。whereis 选项 文件名常用选项-b：搜索文件的二进制部分-m：搜索文件的手册部分-s：搜索文件的源部分。 不带选项，查找二进制文件和手册的位置 1whereis ls which：查找二进制文件。which 选项 文件名常用选项-n：指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p：与-n参数相同，但此处包含文件路径-w：指定输出时栏位的宽度-V：显示版本信息 1which -V ls find（会问到）：查找文件可以按照文件名、文件类型、用户等去查找。find 路径 选项 [-print] [-exec –ok command] {};常用选项-name filename :查找名为filename的文件-perm：按执行权限来查找-user username：按照文件的所属用户来查找-group groupname：按照组来查找-size n[c] 查长度为n块（n字节）的文件。 123456#根据文件名查找find /home -name 123.sh#根据文件大小查找 (+大于 -小于)find /home -size +20000#根据文件所有者查找：查找所有者为jp的文件find /home -user jp locate：查找文件locate：从已经创建好的一个索引数据库中查找。比find命令的查找速度更快。locate 选项 文件名-b, –basename – 仅匹配路径名的基本名称-c, –count – 只输出找到的数量-d, – 数据库路径 – 使用 DB PATH 指定的数据库，而不是默认数据库 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db-q, – 安静模式，不会显示任何错误讯息。一般不使用参数。 locate 与 find 不同: find 是去硬盘找，locate 只在 &#x2F;var&#x2F;lib&#x2F;slocate 资料库中找。locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 &#x2F;var&#x2F;lib&#x2F;slocate&#x2F;slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为：updatedb 常见问题：无法执行 stat () &#96;&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db’: 没有那个文件或目录解决方案：执行：updatedb命令 123456789[root@centos601 桌面]# locate /etc/shlocate: can not stat () `/var/lib/mlocate/mlocate.db&#x27;: 没有那个文件或目录[root@centos601 桌面]# update locatebash: update: command not found[root@centos601 桌面]# updatedb[root@centos601 桌面]# locate /etc/sh/etc/shadow/etc/shadow-/etc/shells grep（面试常问）：查找文件对查找目标中的具体内容进行查找，是一个强大的文本搜索工具。它是一个管道命令，和其它命令结合使用。工作方式：在一个或多个文件中搜索字符串模板，可以使用正则表达式进行搜索。 在linux或unix系统中，|就是管道命令，把上一个命令的结果交给管道命令（|）后面的命令处理 12#查找/etc/hosts中包含localhost4的内容cat /etc/hosts | grep localhost4 文本内容查看命令cat：文件内容查看输出cat：将文件中的内容输出到设备上，若是多个文件，则按顺序输出。 cat 选项 文件名常用选项 -n：由1开始对所有输出的行数编号 -b：和-n相似，只是对于空白行不进行编号 -s：若遇到连续两行以上的空白行，就替换成一行空白行输出。若准备将多个文件合并为一个文件，则使用以下方式Cat 选项 文件名1 文件名2…… &gt; 新文件 1234#将/etc/hosts文件中的内容输出到/opt/a文件中cat /etc/hosts &gt; /opt/a#查看/opt/a文件的内容cat /opt/a more：分屏显示more分屏显示 ，可以和其它命令结合使用，也可以单独使用。在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； &#x2F;字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管道无用。 12more /etc/profilecat day522 | more less：分屏显示less分屏显示 ，可以和其它命令结合使用，也可以单独使用。less运行时可以输入的命令有： 空白键 ：向下翻动一页； 上下箭头：上一行&#x2F;下一行 [page down]：向下翻动一页； [page up] ：向上翻动一页； &#x2F;字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！) N ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！) q ：离开 less 这个程序； 1more /etc/profile head：显示前几行语法：head [-n number] 文件 1head -n 3 /etc/profile tail（面试常问）：最后几行语法：tail [-n number] 文件 ，常用来读取日志文件 ​ -f : 循环读取 tail -f 文件名 ​ -n ：数字 读取最后几行 1234tail -n 10 /etc/profile#循环读取ping 192.168.66.211 &gt; ping.log &amp;tail -f ping.log 4. 用户管理在Linux中，用户和组的相关信息保存在对应的文件中，一共有三个文件，分别是passwd、shadow和group passwd文件 用户信息文件 &#x2F;etc&#x2F;目录下。 系统中的每一个合法用户账号对应于该文件中的一行记录。 每一行由7个部分组成：注册名:口令：用户标识号：组标识号：备注：用户主目录：命令解释程序 注册名：登陆账户，不能重复，区分大小写。 口令：登陆系统的口令。若第一个字符是“*”，表示禁止该账号登陆。 用户标志号：Linux中唯一的用户标识 组标志号：当行用户的默认工作组标记 备注：保存一些用户的信息 用户主目录：个人用户的主目录，该用户登陆后，将该目录作为用户的工作目录 命令解释程序：当前用户登陆系统时运行的程序名称，通常是一个shell程序的全路径名。 shadow文件 保存用户的口令。&#x2F;etc&#x2F;目录下 该文件不能被普通用户读取，只有超级用户root才有权读取。 group文件 保存在&#x2F;etc&#x2F;group当中 每一行数据内容 用户组名称：用户组密码：用户组标识号：用户列表 用户组管理 添加组：groupaddgroupadd policeman 查看组：通过vi或cat命令vi &#x2F;etc&#x2F;groupcat &#x2F;etc&#x2F;group 删除组：groupdelgroupdel policeman 将现有用户增加到组中usermod -g 组名 用户名 从组中删除用户gpasswd -d 用户名 组名 查看当前用户所在组：groups 用户管理 创建用户：useradduseradd 用户名：创建一个新的用户useradd 用户名 -g 组名 ：添加用户，并加入到某个组当中useradd –m –g 组名 用户名：创建一个新的用户并创建家目录，指定组 修改用户：usermodusermod -g 组名 用户名 ：修改用户信息 创建密码：passwordpasswd 用户名 ：为用户创建密码 删除用户：userdeluserdel 用户名 ：删除用户名userdel -r 用户名 ：删除用户以及用户主目录 su 用户名称 切换用户 管理员权限修改 &#x2F;etc&#x2F;sudoers文件，给对应的用户增加root权限，用户在执行命令式，使用sudo 命令 即可执行管理员的所有权限。 1234## Allow root to run any commands anywhere root ALL=(ALL) ALL#给huangyy增加root权限huangyy ALL=(ALL) ALL 5. 文件权限Linux的文件类型大致可以分为5种：普通文件：用于存储数据、程序等信息的文件。文本文件和二进制文件。目录文件：由文件系统中的一个目录项组成的文件。用户进行只能对其进行读取，不能进行修改设备文件：用于与IO设备提供连接的文件，可以分为字符设备文件和块设备文件。每一种I&#x2F;O设备对应于一个设备文件，存放于&#x2F;dev&#x2F;目录中。链接文件：通过链接文件中指向文件的指针来实现对文件的访问。管道文件：用于进程间传递数据。Linux对管道的操作与对普通文件的操作相同。 drwx r-xr-x test : 第一组 rwx表示test文件的用户所有者(vagrant,vagrant所在的组vgroup（v1,v2,v3,vagrant）)的权限 ​ r-x(黑色) : 文件所有者的同组其他用户的权限（v1,v3,v2） ​ r-x: vgroup组以外的其他用户的权限 操作权限分为三种：R：读取权限 （４），如果是目录，用户可以浏览目录W ：写权限 （２），如果是目录，用户可以删除、移动目录内的文件X: ：执行权限（１），如果是目录，则表示可进入此目录，如果是bash命令，则表示可以执行 改变文件权限使用chmod命令可以修改文件的权限。通过权限字母和操作符表达式的方法来设置权限 语法：chmod [用户类型] [+|-|&#x3D;] [权限字符] 文件名 u&#x3D;用户权限 g&#x3D;组权限 o&#x3D;不同组其他 +：添加权限；-：取消权限 &#x3D;：赋予给定权限并取消其他所有权限。 权限字符：可以使用r、w、x组合，也可以使用s 使用数字来设置权限 chmod [数字组合] 文件名 用3位八进制数来表示文件的3类用户的权限组合 例如751：表示用户权限为rwx，当前用户组权限：r-x 其他用户组权限为–x 12345678910#赋予abc权限rwxr-xr-xchmod 755 abc#同上chmod u=rwx,g=rx,o=rx abc#给abc增加组写权限chmod go+w abc#给abc去除用户执行权限，增加当前组写权限chmod u-x,g+w abc#给所有用户添加读的权限chmod a+r abc 修改文件所有者和组使用chown命令可以修改文件的所有者和组，只有root用户可以更改用户的所有者。只有root用户或文件所有者可以更改文件的组，如果是文件所有者但不是root用户，则只能将组改为当前用户所在组。语法：chown 所有者:组 文件 123#修改文件所有者为xiaohuang#新的用户组为rootchown xiaohuang:root hello.java 6. 进程管理在Linux中，每个执行的程序都称为一个进程。每一个进程都分配一个ID号。每一个进程，都会对应一个父进程。而这个父进程可以复制多个子进程。每个进程都可能以两种方式存在的，前台与后台。所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于在屏幕上无法看到的进程，通常使用后台方式执行。一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。 ps：查看进程ps命令是用来查看系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。显示详细的进程信息(终端上的所有进程，包括其它用户)：ps -a以用户的格式显示进程信息：ps -u显示后台进程运行参数：px –x查看更全面信息 ps -aux 12345678910USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 485 0.0 0.0 0 0 ? S Nov02 0:00 [ext4-dio-unwrit]root 593 0.0 0.0 11248 1372 ? S&lt;s Nov02 0:00 /sbin/udevd -droot 1800 0.1 0.4 260836 8524 ? Sl Nov02 0:20 /usr/sbin/vmtoolsdroot 2044 0.0 0.0 27596 832 ? S&lt;sl Nov02 0:00 auditdrpc 2179 0.0 0.0 18980 876 ? Ss Nov02 0:00 rpcbinddbus 2199 0.0 0.1 32556 2088 ? Ssl Nov02 0:00 dbus-daemon --systemroot 2213 0.0 0.2 84960 4864 ? Ss Nov02 0:00 NetworkManager --pid-file=/var/run/NetworkManager/NetworkManager.pidroot 2220 0.0 0.1 58120 2608 ? S Nov02 0:00 /usr/sbin/modem-managerrpcuser 2237 0.0 0.0 23352 1380 ? Ss Nov02 0:00 rpc.statd USER：用户PID: 进程的IDPPID:父进程的ID%CPU:进程占用的CPU百分比%MEM：进程占用的内存百分比VSZ:使用的虚拟内存量（KB)RSS：该进程占用的固定内存量（KB)STAT:进程的状态。TTY:该进程在哪个终端上运行，若与终端无关，则显示？ 若为pst&#x2F;0等，则表示由网络连接主机进程。TIME:使用CPU的时间 其中STAT常见的值如下： 值 含义 值 含义 D 无法中断的休眠状态（通常 IO 的进程） R 正在运行可中在队列中可过行的 S 处于休眠状态 T 停止或被追踪 &lt; 优先级高的进程 X 死掉的进程 （基本很少见） N 优先级较低的进程 L 有些页被锁进内存 s 进程的领导者（在它之下有子进程） l 多线程，克隆线程（使用 CLONE_THREAD） + 位于后台的进程组 kill（面试常问）：终止进程对于前台进程，在推出程序后该进程将自动结束。在前台进程运行过程中，也可按快捷键Ctrl + C 退出。对于后台进程，需要使用kill命令来终止。 信号量：15，9，默认为15 ，告诉进程需要终止，并不一定立刻终止，如果是9，表示强制终止进程 12#终止pid为4217的进程kill -9 4217 top（面试常问）查看系统当前正在执行的进程的相关信息，包括进程id，内存的使用率，CPU的占有率等（动态，实时） load average: 0.00, 0.01, 0.04，分别表示最近一分钟，五分钟，以及十五分钟的负载状况。 是否load average大于1就是系统负载比较高。不一定。要看CPU的核数和线程数，如果是单核cpu，值等于1就是满负荷，如果是四核，八核，负载大于1说明负载不算太高。 12345-c: 显示完整的进程命令-s: 保密模式-p PID 指定进程显示-n &lt;次数&gt; 执行循环显示次数-H 显示线程数 &amp;字符可以将命令的最后加上“&amp;”，使得程序放到后台运行。 基本用于需要一直运行的服务类进程，比如说tomcat，nginx，mysql 7. 防火墙centos7中采用以下命令对防火墙进行处理。 查看防火墙状态：firewall-cmd –state 停止防火墙： systemctl stop firewalld.service 启动防火墙： systemctl start firewalld.service 重启防火墙： systemctl restart firewalld.service 永久关闭防火墙：systemctl disable firewalld.service 永久关闭后重启：systemctl enable firewalld.service 查看开机防火墙：systemctl is-enabled firewalld.service 端口操作： 开启端口：firewall-cmd –zone&#x3D;public –remove-port&#x3D;80&#x2F;tcp –permanent 刷新：firewall-cmd –reload 查看端口状态：firewall-cmd –zone&#x3D;public –query-port&#x3D;80&#x2F;tcp yes表示端口开放，no表示端口不开放 关闭端口：firewall-cmd –zone&#x3D;public –remove-port&#x3D;80&#x2F;tcp –permanent 12345678910111213141516[root@centos701 etc]# firewall-cmd --zone=public --query-port=80/tcpno[root@centos701 etc]# firewall-cmd --zone=public --add-port=80/tcp --permanentsuccess[root@centos701 etc]# firewall-cmd --reloadsuccess[root@centos701 etc]# firewall-cmd --zone=public --query-port=80/tcpyes [root@centos701 etc]# firewall-cmd --zone=public --remove-port=80/tcp --permanentsuccess[root@centos701 etc]# firewall-cmd --reloadsuccess[root@centos701 etc]# firewall-cmd --zone=public --query-port=80/tcpno 8. 启动以及关机注销logout：注销系统login：回到登录界面shutdown –h now ：立刻关机shutdown +5 ：5分钟后关机shutdown 10:30：在10：30关机shutdown –r now ：立刻关闭系统并重启reboot ：重新启动系统 五. vi的常用指令vi编辑器是Linux下最有名的编辑器，也是我们学习linux必须掌握的工具，在unix下也可以进行程序的开发。开发步骤：vi 文件名输入i，进入插入模式，输入Esc键输入冒号:,再输入wq，保存并退出，如果不保存退出，则输入q! 基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 1. 命令模式用户刚刚启动 vi&#x2F;vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。以下是常用的几个命令： i, I字符 ：切换到输入模式，以输入字符。i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』 a, A字符 ：进入输入模式(Insert mode)，a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』 o, O字符 ：进入输入模式(Insert mode)，这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！ r, R：进入取代模式(Replace mode)，r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止 x字符 ：删除当前光标所在处的字符。 :字符 ：切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 2. 输入模式在命令模式下按下i就进入了输入模式。在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符大小写转换 ENTER：回车键，换行 BACK SPACE：退格键，删除光标前一个字符 DEL：删除键，删除光标后一个字符 方向键：在文本中移动光标 HOME&#x2F;END：移动光标到行首&#x2F;行尾 Page Up&#x2F;Page Down：上&#x2F;下翻页 Insert：切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线 ESC：退出输入模式，切换到命令模式 3. 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。按ESC键可随时退出底线命令模式。在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序，如果文件内容被修改了，会出现错误，要求使用“!”强制退出。 q! ：强制退出vim，并且不保存文件 w： 保存文件 wq：将修改过的文件存储，并且离开vim set nu:在文件中每行加入行号 set nonu：取消行号 输入数字：直接输入数字再按enter，就可以将光标定位到改行行首。 &#x2F;字符串：利用&#x2F;字符串来查找特定的内容，如果查找不是想要的的，可以按“n”键盘继续查找。 ?字符串：同&#x2F;字符串 删除命令命令模式下： ​ x：删除当前字符 ​ 3x: 删除当前光标开始的3个字符，如果想要删除n个字符，将3替换成n ​ X：删除当前光标的前一个字符 ​ dd: 删除当前行 ​ dj：删除下一行 ​ dk：删除上一行 ​ 3d：删除当前行开始往后的3行 底线模式下 ​ :5, 10d: 将5~10的数据删除掉 ​ :5,$d: 将5行以后的数据全部删除掉 拷贝命令行拷贝： ​ yy：拷贝当前行 ​ nyy：拷贝当前行开始的n行，5yy，从当前行开始拷贝5行的数据 ​ p：再当前光标后粘贴 ​ shift +p：在当前行前面进行粘贴 ​ :1,5 co 20: 将1~5行copy放到20行之后 部分拷贝 ​ yw：拷贝一个单词 ​ 2yl：拷贝当前光标开始的2个字符 ​ 3yh：拷贝当前光标前面的3个字符（不包括光标的相关字符） 六. 文件压缩和解压命令tar：将指定目录中的所有文件和目录全部进行备份gzip和gunzip：压缩和解压缩文件Zip和unzip：压缩文件和解压文件 tar命令tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。 -A或–catenate 新增文件到已存在的备份文件。-c或–create 建立新的备份文件。-C&lt;目的目录&gt;或–directory&#x3D;&lt;目的目录&gt; 切换到指定的目录。-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。-v或–verbose 显示指令执行过程。-x或–extract或–get 从备份文件中还原文件。-z或–gzip或–ungzip 通过gzip指令处理备份文件。-Z或–compress或–uncompress 通过compress指令处理备份文件。–delete 从备份文件中删除指定的文件。–exclude&#x3D;&lt;范本样式&gt; 排除符合范本样式的文件。 实际使用时经常联合多个选项一起使用，例如 -zcvf 创建一个压缩文件 -zxvf 还原并解压缩文件 12345678910111213141516#归档文件，将tmp文件夹打包成tmp.tgztar -zcvf tmp.tgz tmp#归档文件，排除tmp目录中的w文件，压缩文件名为tmp.tgz,压缩打包放入tmptar --exclude=tmp/w -zcvf tmp.tgz tmp#创建tmp01目录，并将tmp.tgz解压缩到tmp01目录中。mkdir tmp01tar -zxvf tmp.tgz -C tmp01#将tmp打包成u1.tartar -cf u1.tar tmp#将tmp01打包成u2.tartar -cf u2.tar tmp01#将u1.tar的内容追加到u2.tar当中（u2当中包含tmp和tmp01）tar -A u1.tar -vf u2.tar gzip和gunzip命令gzip gzip命令用于压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。常用选项如下： -d或–decompress或—-uncompress 解开压缩文件。 -f或–force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 -l或–list 列出压缩文件的相关信息。 -v或–verbose 显示指令执行过程。 -V或–version 显示版本信息。 gunzip命令 gunzip命令用于解压文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为”.gz”。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。常用选项如下： -c或–stdout或–to-stdout 把解压后的文件输出到标准输出设备。 -f或-force 强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 -l或–list 列出压缩文件的相关信息。 -v或–verbose 显示指令执行过程。 1234#压缩hello.java文件gzip -vf hello.java#将hello.java.gz解压缩gunzip -vf hello.java.gz zip和unziplinux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。 zip命令的常用选项 -g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。 -q 不显示指令执行过程。 -r 递归处理，将指定目录下的所有文件和子目录一并处理。 -S 包含系统和隐藏文件。 -v 显示指令执行过程或显示版本信息。 unzip常用的选项 1234#将所有的jpg文件压缩成一个z.zip文件zip z.zip *.jpg#解压文件unzip all.zip JDK安装将jdk的linux安装文件放入到linux的某个目录下 解压 1tar -zxvf jdkxxx.tar.gz 设置环境变量 在&#x2F;etc&#x2F;profile的最后增加以下内容 12345JAVA_HOME=/usr/jdk1.8.0_261CLASSPATH=.:$JAVA_HOME/libPATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH 重新加载配置文件 1source /etc/profile 进行测试 javac或者java命令就可以测试","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"java基础","slug":"java基础","date":"2023-09-18T02:36:14.000Z","updated":"2023-09-18T02:38:07.000Z","comments":true,"path":"2023/09/18/java基础/","link":"","permalink":"http://example.com/2023/09/18/java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTML: 表单元素: input, textarea, select, checkbox, radio. 块状元素和行内元素的特点. 图片的属性：src, alt. 链接的属性：href, target. 路径问题：相对路径和绝对路径. 文件上传时form的注意事项：action, method=&quot;post&quot;, enctype=&quot;multipart/form-data&quot;. CSS: 选择器：id, 类, 标签（元素）, 属性, 子孙，子，兄弟，相邻兄弟，伪类，伪元素. display, float, 清除浮动（clear）. position：static, relative, absolute, fixed. 盒子模型（box model）. border-style, border-radius. JavaScript (JS): 弱类型，可以多次声明，赋不同类型的值. var, const, let. break, continue, return. 循环标签 tag: for() &#123; for () &#123; break tag; &#125; &#125;. 输出到控制台：console.log(&quot;aa&quot;);. DOM操作：创建元素，删除节点，事件处理，事件委托. BOM操作：alert(), prompt, confirm, 定时器（setInterval, setTimeout）. 对象创建：let a = &#123;&#125;. 原型链 (prototype). 闭包. ES6的语法，包括箭头函数，模板字符串，解构等. 异步操作：Promise对象，async和await. 模块化：export, import from. 改变上下文（this）：apply, bind, call. 函数中的arguments和callee（不常用）. Java: Java的发展史，JVM的特点，JDK, JRE, JVM之间的关系. 常见运算符：++, --, +=, &amp;, &amp;&amp;, |, ||, ^, instanceof. 基本数据类型和类型转换的示例. switch语句的使用. 数组的创建，扩容，排序和查找. 基本数据类型：byte, short, int, long, float, double, char, boolean. 面向对象编程的三个特点：封装，继承，多态. 访问修饰符：private, default, protected, public. static关键字，final关键字，abstract关键字. 抽象类，接口，内部类的概念. 常用的包装类：Integer, Character. 字符串 (String) 的常见方法和比较. Comparable和Comparator的使用. 替换文件名的示例.","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"区块链基础知识","slug":"区块链基础知识","date":"2023-09-14T03:38:17.000Z","updated":"2023-09-14T03:40:11.000Z","comments":true,"path":"2023/09/14/区块链基础知识/","link":"","permalink":"http://example.com/2023/09/14/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"区块链与隐私保护技术：构建安全可信的去中心化世界随着数字化时代的不断发展，个人数据的保护和隐私成为了一个极其重要的议题。同时，区块链技术的兴起也引发了人们对隐私保护的新思考。本文将探讨区块链与隐私保护的关系，以及当前正在发展的技术和方法，以确保在去中心化世界中维护个人数据的安全和隐私。 区块链基础知识在深入讨论区块链与隐私保护的关系之前，我们需要先了解一些区块链的基础知识。 区块链是什么？ 区块链是一种去中心化的分布式账本技术，最初用于支持加密货币比特币。它是一个由多个区块组成的链式结构，每个区块包含一组交易记录。这些区块按照时间顺序连接在一起，并且通过密码学技术保护其完整性和安全性。 区块链的关键特性 区块链的关键特性包括： 去中心化：没有中央权威机构控制区块链，而是由网络中的多个节点共同维护和验证交易。 不可篡改性：一旦数据被添加到区块链，几乎不可能修改或删除。 透明性：区块链上的所有交易都是公开可见的，任何人都可以查看。 安全性：区块链使用密码学技术来保护数据的机密性和完整性。 区块链与隐私保护的挑战 尽管区块链具有许多优点，但它也带来了一些隐私保护的挑战。其中一些挑战包括： 交易透明性：区块链上的所有交易都是公开的，这意味着交易的参与者和交易金额都可以被追踪。 无法删除数据：一旦数据上链，就很难删除或修改，这可能会导致个人敏感信息的永久性泄露。 链外数据：虽然区块链上的交易数据是公开的，但与之相关的链外数据（如身份信息）可能不受同样的保护，容易被恶意利用。 隐私保护技术为了解决区块链上的隐私保护问题，许多技术和方法已经被提出和发展。以下是一些常见的隐私保护技术： 零知识证明（Zero-Knowledge Proofs） 零知识证明是一种密码学技术，允许一个人向另一方证明他们知道某些信息，而不必透露这些信息的内容。这在区块链上的隐私保护中非常有用。通过零知识证明，用户可以验证自己的交易有效性，而无需公开其交易详细信息。zk-SNARKs（零知识可验证的非交互式参数）是一种常见的零知识证明机制，用于保护以太坊等区块链的隐私。 链上混币技术 链上混币技术允许用户将他们的加密货币与其他用户的加密货币混合在一起，以增加交易的隐私性。这使得很难追踪特定的加密货币流动路径。CoinJoin和Confidential Transactions是两个常见的链上混币技术。 侧链和二层解决方案 侧链和二层解决方案是构建在主区块链之上的附加层，它们可以提供更高级的隐私保护。例如，Lightning Network是比特币的二层解决方案，允许快速且低成本的交易，同时减少了主区块链上的交易记录。 匿名性币种 一些加密货币专注于提供更强的隐私保护。例如，Monero和Zcash都使用不同的隐私技术来确保交易的完全匿名性。这些币种的交易数据被设计成不可追踪和不可链接。 多方计算（Multi-Party Computation） 多方计算是一种协议，允许多个参与者在不透露私有数据的情况下进行计算。这可以用于在区块链上进行私有智能合约的执行，而不泄露相关数据。 去中心化身份验证 去中心化身份验证技术允许用户在区块链上验证其身份，同时控制其个人数据。用户可以选择性地透露身份信息，以确保他们的隐私得到保护。 这些技术共同构建了区块链生态系统，使其成为一个安全、可信、去中心化的基础设施，可用于各种应用程序，从加密货币到供应链管理和智能合约。区块链技术的不断发展和创新将继续推动数字经济的进步。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Excel导入导出","slug":"Excel导入导出","date":"2023-09-14T03:30:44.000Z","updated":"2023-09-14T03:33:10.000Z","comments":true,"path":"2023/09/14/Excel导入导出/","link":"","permalink":"http://example.com/2023/09/14/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"Excel导入导出1. 简介1.1 实现方式 Apache POI POI（Poor Obfuscation Implementation）是Apache提供的操作ms office文档的API，主要针对excel进行操作。 官网 https://poi.apache.org Apache维护 EasyPOI easypoi功能如同名字easy，主打的功能就是容易，让一个没见接触过poi的人员就可以方便的写出Excel导出、Excel导入。 通过简单的注解和模板语言(熟悉的表达式语法)，完成以前复杂的写法。 官网 http://doc.wupaas.com/docs/easypoi 个人维护 EasyExcel EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。 他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。 官网 https://easyexcel.opensource.alibaba.com 阿里维护 1.2 Excel简介excel的基础元素： 工作簿 workbook 就是一个文件 工作表 sheet 属于工作簿 行 row 属于工作表 单元格 cell 属于行，如C2，表示第二行第三列 2. 用法2.1 Apache POI步骤： 添加依赖 123456&lt;!--poi--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;5.2.3&lt;/version&gt;&lt;/dependency&gt; 基本用法 12345678910111213141516171819202122232425262728293031@Testpublic void write() throws Exception &#123; // 1、创建工作簿 Workbook workbook = new HSSFWorkbook(); // 2、创建工作表 Sheet sheet = workbook.createSheet(&quot;wanho&quot;);// 指定工作表名 // 3、创建行 Row row = sheet.createRow(2); // 创建第3行，索引从0开始 // 4、创建单元格 Cell cell = row.createCell(2); // 创建第3行第3列 cell.setCellValue(&quot;南京万和&quot;); // 设置单元格内容 // 5.输出到硬盘 workbook.write(new FileOutputStream(&quot;/Users/txy/Desktop/test.xls&quot;)); System.out.println(&quot;写入成功！&quot;); workbook.close();&#125;@Testpublic void read() throws Exception &#123; // 1、读取工作簿 Workbook workbook = new HSSFWorkbook(new FileInputStream(&quot;/Users/txy/Desktop/test.xls&quot;)); // 2、读取工作表 Sheet sheet = workbook.getSheet(&quot;wanho&quot;); // 根据名称读取工作表 // Sheet sheet = workbook.getSheetAt(0); //根据索引读取工作表，索引从0开始 // 3、读取行 Row row = sheet.getRow(2); // 读取第3行 // 4、读取单元格 Cell cell = row.getCell(2); // 读取第3行第3列 System.out.println(&quot;第3行第3列内容为：&quot; + cell.getStringCellValue()); workbook.close();&#125; 2.2 EasyPOI步骤： 添加依赖 123456&lt;!--easypoi--&gt;&lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt; 基本用法 @Excel 标注在属性上，对Excel列进行描述 工具类： ExcelExportUtil 导出Excel ExcelImportUtil 导入Excel 2.3 EasyExcel步骤： 添加依赖 123456&lt;!--easyexcel--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt; 基本用法 常用注解 @ExcelProperty 标注在属性上，对Excel列进行描述 @ColumnWidth 标注在类和属性上，设置列宽 @ContentStyle 标注在类上，设置内容样式 @HeadFontStyle 标注在类上，设置表头样式 @DateTimeFormat 标注在属性上，设置日期的格式 ….. 工具类： EasyExcel.write() 导出Excel EasyExcel.read() 导入Excel","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"SQL语句中不同类型的join的区别","slug":"SQL语句中不同类型的join的区别","date":"2023-09-03T15:34:05.000Z","updated":"2023-09-03T15:35:49.000Z","comments":true,"path":"2023/09/03/SQL语句中不同类型的join的区别/","link":"","permalink":"http://example.com/2023/09/03/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84join%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"sql之left join、right join、inner join的区别left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录inner join(等值连接) 只返回两个表中联结字段相等的行 举例如下：表A记录如下：aID aNum1 a200501112 a200501123 a200501134 a200501145 a20050115 表B记录如下:bID bName1 20060324012 20060324023 20060324034 20060324048 2006032408 1.left joinsql语句如下:select * from Aleft join Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 20060324045 a20050115 NULL NULL （所影响的行数为 5 行）结果说明:left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID &#x3D; B.bID).B表记录不足的地方均为NULL.2.right joinsql语句如下:select * from Aright join Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404NULL NULL 8 2006032408 （所影响的行数为 5 行）结果说明:仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.3.inner joinsql语句如下:select * from Ainnerjoin Bon A.aID &#x3D; B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404 结果说明: 很明显,这里只显示出了 A.aID &#x3D; B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Spring常用注解","slug":"Spring常用注解","date":"2023-08-29T00:52:13.000Z","updated":"2023-09-25T11:36:32.000Z","comments":true,"path":"2023/08/29/Spring常用注解/","link":"","permalink":"http://example.com/2023/08/29/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"@Param@Param()注解，标注在参数前，为参数指定占位符名称 1public User selectByUsernameAndPassword(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); @Component 及@Repository、@Service、@Controller@Component 定义组件Bean，添加到IoC容器中，不区分组件类型区分组件类型的注解：@Repository 表示Dao组件@Service 表示Service组件@Controller 表示Controller组件 @RequestMapping：@RequestMapping： @ResponseBody@ResponseBody：将方法返回值写到响应体中，一般用来处理Ajax请求，返回JSON数据也可以使用@RestController，相当于@Controller+@ResponseBody注意：ResponseBody与RequestBody区别 @RequiredArgsConstructor：该注解作用于类上 标记为final的对象,会自动进行注入 使用lombok的 @NonNull 注解标记的对象,会自动进行注入 @Resource：@Resource和@Autowired注解都是用来实现依赖注入的。只是@AutoWried按by type自动注入，而@Resource默认按byName自动注入。 @Resource有两个重要属性，分别是name和type @Json衍生@JsonFormat指定序列化和反序列化时的格式，一般用于指定日期、时间和数字的格式@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”,timezone &#x3D; “GMT+8”)，设置响应时的日期格式 @JsonProperty指定序列化和反序列化时的名称 @JsonAlias指定反序列化时的备用别名 @JsonIgnore指定序列化和反序列化时忽略属性 参数来源注解@RequestParam表示参数来源于请求参数，默认为所有参数添加该注解，参数值来源于同名称的请求参数 @PathVariable表示参数来源于URL（URL就是请求路径） @PathVariable：spring3.0的一个新功能：接收请求路径中占位符的值 @PathVariable(“xxx”) 通过 @PathVariable 可以将URL中占位符参数{xxx}绑定到处理器类的方法形参中@PathVariable(“xxx“)@RequestMapping(value&#x3D;”user&#x2F;{id}&#x2F;{name}”)请求路径：http://localhost:8080/hello/show5/1/james @RequestHeader表示参数来源于请求头 @CookieValue表示参数来源于Cookie @RequestBody表示参数来源于请求体，用来接收前端传递给后端的 json 格式的数据 @RequestMapping及其衍生变体@RequestMapping表示共享映射,用于将任意HTTP 请求映射到控制器方法上。如果没有指定请求方式，将接收GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT所有的HTTP请求方式。@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping 都是HTTP方法特有的快捷方式@RequestMapping的变体，分别对应具体的HTTP请求方式的映射注解。 @Transactional@Transactional也可以配置在类上，如果方法上没有配置@Transactional，则使用类上的事务配置 使用@Transactional 注解管理事务的实现步骤分为两步。 第一步，在 xml 配置文件中添加如清单 1 的事务配置信息。除了用配置文件的方式，@EnableTransactionManagement 注解也可以启用事务管理功能。这里以简单的 DataSourceTransactionManager 为例。 第二步，将@Transactional 注解添加到合适的方法上，并设置合适的属性信息。 SpringBoot@SpringBootApplication标注在类上，表示这是一个SpringBoot应用，通过运行该类的main方法来启动SpringBoot应用 @SpringBootConfiguration标注在类上，表示这个类是SpringBoot的配置类 层级关系：@SpringBootConfiguration——&gt;@Configuration——&gt;@Component @Configuration标注在类上，表示这个类是Spring的配置类，相当于是一个xml配置文件 @EnableAutoConfiguration开启自动配置功能，SpringBoot会自动完成许多配置，简化了以前繁琐的配置 @ComponentScan标注在类上，指定要扫描的包，默认只扫描主程序类所在的包及其子包 可以使用@ComponentScan手动指定要扫描的包 @MapperScan：指定Dao接口所在的包API：@Api标注在类上，对类进行说明 @ApiOperation标注在方法上，对方法进行说明 @ApiParam标注在参数上，对方法的参数进行说明 @ApiModel标注在模型Model上，对模型进行说明 @ApiModelProperty标注在属性上，对模型的属性进行说明 @ApiIgnore标注在类或方法上，表示忽略这个类或方法 Mybatis注解：@Insert、@Update、@Delete、@Select这四个注解分别代表将会被执行的 SQL 语句。它们用字符串数组（或单个字符串）作为参数。如果传递的是字符串数组，字符串之间先会被填充一个空格再连接成单个完整的字符串。这有效避免了以 Java 代码构建 SQL 语句时的“丢失空格”的问题。然而，你也可以提前手动连接好字符串。属性有：value，填入的值是用来组成单个 SQL 语句的字符串数组。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Shiro学习","slug":"Shiro学习","date":"2023-08-24T03:15:48.000Z","updated":"2023-08-25T08:34:55.000Z","comments":true,"path":"2023/08/24/Shiro学习/","link":"","permalink":"http://example.com/2023/08/24/Shiro%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Shiro简介1. Shiro是什么？Apache Shiro是一个强大且易用的开源Java安全框架，执行身份认证、授权、密码学和会话管理等 Spring Security也是一个开源的权限管理框架，Spring Security 和 Shiro 的比较如下： Spring Security 是一个重量级的安全管理框架； Shiro 则是一个轻量级的安全管理框架 Spring Security 概念复杂，配置繁琐； Shiro 概念简单、配置简单 Spring Security 功能强大； Shiro 功能简单，但在一般的 SSM 项目中也够用了 Spring Security 依赖于Spring运行； Shiro则相对独立 Spring Security 一般与 Spring Boot&#x2F;Spring Cloud 项目组合使用； Shiro 一般与 SSM 项目结合使用 虽然在 Spring Boot 项目中一般使用 Spring Security ，但也可以使用 Shiro 2. 基本功能​ 身份认证、授权、加密、会话管理 ​ Web支持、缓存、多线程、测试、允许一个用户假装为另一个用户的身份进行访问、记住我 ​ ​ 3. 单词​ authentication [ɔ:ˌθentɪ’keɪʃn] 认证、身份验证 ​ authorization [ˌɔ:θəraɪˈzeɪʃn] 授权 ​ cryptography [krɪpˈtɒgrəfi] 密码学 ​ subject [ˈsʌbdʒɪkt] 主题、学科、主体 ​ token [ˈtəʊkən] 令牌 ​ strategy [ˈstrætədʒi] 策略 ​ realm 领域、范围 ​ principal [ˈprɪnsəpl] 当事人、用户 ​ credentials [krəˈdenʃlz] 凭证 二、身份认证1. 认证流程图​ 2. 执行过程分为五步： Subject 用户主体：请求的发起者，即访问应用的用户 Security Manager 安全管理器：Shiro的核心，用来分发请求，对Shiro中的其他对象进行管理 Authenticator 认证器：用来进行认证操作 Authentication Strategy 认证策略 ：对于多个realm，可以对认证realm的个数进行配置 三种认证策略：AtLeastOneSuccessfulStrategy、FirstSuccessfulStrategy、AllSuccessfulStrategy Realm 安全数据源：用来进行数据匹配的，可以通过多种数据源进行匹配认证，如文件、数据库、QQ、微信、手机号等 3. url过滤场景：有些url的访问需要登录才能访问，如后台管理界面，未登录时不允许访问，自动跳转到登录页面 解决：使用Shiro过滤器，配置url过滤规则 常用的过滤规则： anon 表示url不需要验证 authc 表示url需要登录验证，如果未登录，默认跳转到&#x2F;login.jsp，参考FormAuthenticationFilter类 roles 表示url需要角色验证 perms 表示url需要权限验证 ​ 注：默认所有url都不需要验证，相当于是anon 三、SpringBoot整合Shiro 1. 搭建项目环境步骤： 创建一个springboot工程，选择以下模块：Web、Lombok、DevTools 添加依赖 12345&lt;!--jsp--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml 12345678910server: port: 8080 servlet: context-path: /shirospring: mvc: view: prefix: / suffix: .jsp 创建前端页面 ​ 在webapp文件夹中创建index.jsp和login.jsp index.jsp 12345678910111213141516171819202122&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--受限资源--%&gt; &lt;h1&gt;系统主页&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;用户管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;订单管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;物流管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; login.jsp 12345678910111213141516171819&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;登录界面&lt;/h1&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 配置SpringBoot，兼容JSP 测试 访问 http://localhost:8080/shiro/login.jsp 、 http://localhost:8080/shiro/index.jsp 2. 整合Shiro步骤： 添加依赖 123456&lt;!--shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt; 自定义Realm 123456789101112131415161718192021/** * 自定义Realm，继承AuthorizingRealm */public class ShiroRealm extends AuthorizingRealm &#123; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; return null; &#125;&#125; 创建配置类ShiroConfig 123456789101112131415161718192021222324252627282930313233343536373839404142@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/index.jsp&quot;, &quot;authc&quot;);// 表示这个资源需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); return realm; &#125;&#125; 测试 ​ 访问 http://localhost:8080/shiro/index.jsp，发现会自动跳转到login.jsp，因为这个资源需要登录认证 3. 认证和退出步骤： 在index.jsp添加欢迎信息和退出 12欢迎您：&lt;shiro:principal/&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;退出登录&lt;/a&gt; 编写UserController 1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/login&quot;) public String login(String username, String password) &#123; // 获取主体对象 Subject subject = SecurityUtils.getSubject(); try &#123; subject.login(new UsernamePasswordToken(username,password)); return &quot;index&quot;; &#125; catch (UnknownAccountException e) &#123; e.printStackTrace(); System.out.println(&quot;用户不存在！&quot;); &#125; catch (IncorrectCredentialsException e) &#123; e.printStackTrace(); System.out.println(&quot;密码错误！&quot;); &#125; catch (AuthenticationException e)&#123; e.printStackTrace(); System.out.println(&quot;认证失败！&quot;); &#125; return &quot;redirect:/login.jsp&quot;; &#125; @RequestMapping(&quot;logout&quot;) public String logout() &#123; Subject subject = SecurityUtils.getSubject(); subject.logout(); return &quot;redirect:/login.jsp&quot;; &#125;&#125; 修改自定义的ShiroRealm 123456789101112131415161718192021222324public class ShiroRealm extends AuthorizingRealm &#123; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 if (!&quot;admin&quot;.equals(username)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，然后交由凭证匹配器（CredentialsMatcher）进行凭证的判断，默认是对密码进行判断 return new SimpleAuthenticationInfo(username,&quot;123&quot;,this.getName()); // 参数：用户信息、密码、realm名称 &#125;&#125; 修改配置类ShiroConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/user/login&quot;,&quot;anon&quot;);// 表示这个为公共资源，一定是在受限资源上面 map.put(&quot;/**&quot;,&quot;authc&quot;);//表示这个为受限资源，需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); return realm; &#125;&#125; 测试 登录和退出的功能正常 未登录时不能访问index.jsp 4. 加密的认证通常需要对密码进行加密，常用的散列算法有md5、sha等，都是非对称的算法 对于普通的散列加密，如果知道加密后的值，可以通过穷举算法，暴力破解出对应的明文 所以建议进行散列加密时可以添加salt（盐），相当于对原始密码+盐进行散列加密，盐值一般放在数据库中 同时可以配置散列次数，次数一般放在配置文件中 步骤： 创建数据库 12345678910drop database if exists shiro;create database shiro charset utf8;use shiro; create table t_user ( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(40) comment &#x27;用户名&#x27;, password varchar(40) comment &#x27;密码&#x27;, salt varchar(255) comment &#x27;盐值&#x27;) engine=innodb default charset=utf8 comment &#x27;用户表&#x27;; 添加依赖 1234567891011121314151617&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920server: port: 8080 servlet: context-path: /shirospring: mvc: view: prefix: / suffix: .jsp datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/shiro?useUnicode=true&amp;characterEncoding=utf8 username: root password: rootmybatis: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml 创建注册页面register.jsp 12345678910111213141516171819&lt;%@page contentType=&quot;text/html;UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;注册界面&lt;/h1&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/register&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;立即注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建Entity、Mapper、Service、Controller 修改自定义的ShiroRealm 123456789101112131415161718192021222324252627282930313233public class ShiroRealm extends AuthorizingRealm &#123; @Autowired private UserService userService; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 User user = userService.findByUsername(username); if (ObjectUtils.isEmpty(user)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，交由AuthenticatingRealm进行密码匹配（使用密码匹配器CredentialsMatcher） return new SimpleAuthenticationInfo( user.getUsername(), // 用户信息 user.getPassword(), // 密码 ByteSource.Util.bytes(user.getSalt()), // salt盐值 this.getName()); //realm名称 &#125;&#125; 修改配置类ShiroConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Configurationpublic class ShiroConfig &#123; /** * ShiroFilter，对资源进行过滤处理 */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置url过滤规则 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;/user/login&quot;,&quot;anon&quot;);// 表示这个为公共资源，一定是在受限资源上面 map.put(&quot;/user/register&quot;,&quot;anon&quot;); map.put(&quot;/register.jsp&quot;,&quot;anon&quot;); map.put(&quot;/**&quot;,&quot;authc&quot;);//表示这个为受限资源，需要登录认证 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); // 设置认证界面 shiroFilterFactoryBean.setLoginUrl(&quot;/login.jsp&quot;); // 默认就是跳转到/login.jsp return shiroFilterFactoryBean; &#125; /** * 创建安全管理器 */ @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); return securityManager; &#125; /** * 创建自定义Realm */ @Bean public Realm getRealm() &#123; ShiroRealm realm = new ShiroRealm(); // 创建密码匹配器，支持散列算法 HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(); credentialsMatcher.setHashAlgorithmName(&quot;md5&quot;); // 设置加密算法 credentialsMatcher.setHashIterations(1024); // 设置散列次数 // 设置密码匹配器 realm.setCredentialsMatcher(credentialsMatcher); return realm; &#125;&#125; 测试 ​ 注册和登录的功能正常 五、授权1. 简介授权也称为访问控制，控制用户对资源的访问 权限：增删改查 CRUD 角色：权限的集合，如系统管理员、老师、学生 2. 授权流程图​ 执行过程，分为4步： Subject 发送请求，对角色和权限进行判断 hasRole()、isPermitted() SecurityManager 接收Subject的请求 Authorizer 授权器 Realm 查询角色和权限信息 3. 基本用法步骤： 创建数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455drop database if exists shiro;create database shiro charset utf8;use shiro; create table t_user ( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(40) comment &#x27;用户名&#x27;, password varchar(40) comment &#x27;密码&#x27;, salt varchar(255) comment &#x27;盐值&#x27;) engine=innodb default charset=utf8 comment &#x27;用户表&#x27;;create table t_role ( id int not null primary key auto_increment, name varchar(60) default null) engine=innodb default charset=utf8 comment &#x27;角色表&#x27;;create table t_perms ( id int not null primary key auto_increment, name varchar(80) default null, url varchar(255) default null) engine=innodb default charset=utf8 comment &#x27;权限表&#x27;;create table t_user_role ( id int not null primary key auto_increment, userid int default null, roleid int default null) engine=innodb default charset=utf8 comment &#x27;用户角色表&#x27;;create table t_role_perms ( id int not null primary key auto_increment, roleid int default null, permsid int default null) engine=innodb default charset=utf8 comment &#x27;角色权限表&#x27;;insert into t_user values (null, &#x27;aaa&#x27;, &#x27;37c80a50a975580fb2fb287bee20a04a&#x27;, &#x27;K2*LWFB#&#x27;); -- 密码为123insert into t_user values (null, &#x27;bbb&#x27;, &#x27;93a2dc457a2f9c50fa0a9f2b9de9f456&#x27;, &#x27;DwOkv&amp;WW&#x27;); -- 密码为123insert into t_user values (null, &#x27;ccc&#x27;, &#x27;37c80a50a975580fb2fb287bee20a04a&#x27;, &#x27;K2*LWFB#&#x27;); -- 密码为123insert into t_role values (null, &#x27;admin&#x27;);insert into t_role values (null, &#x27;user&#x27;);insert into t_role values (null, &#x27;stu&#x27;);insert into t_perms values (null, &#x27;admin:*:*&#x27;, null);insert into t_perms values (null, &#x27;user:*:*&#x27;, null);insert into t_perms values (null, &#x27;user:find:*&#x27;, null);insert into t_user_role values (null, 1, 1);insert into t_user_role values (null, 1, 2);insert into t_user_role values (null, 2, 2);insert into t_user_role values (null, 3, 3);insert into t_role_perms values (null, 1, 1);insert into t_role_perms values (null, 2, 2);insert into t_role_perms values (null, 2, 3);insert into t_role_perms values (null, 3, 3); 创建Entity、Mapper、Service 修改自定义的ShiroRealm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ShiroRealm extends AuthorizingRealm &#123; @Resource private UserService userService; @Resource private PermsService permsService; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = (String) principalCollection.getPrimaryPrincipal(); // 获取角色信息 User user = userService.findRolesByUsername(username); List&lt;String&gt; roles = user.getRoles().stream().map(Role::getName).collect(Collectors.toList()); // 获取权限信息 List&lt;String&gt; perms = user.getRoles().stream().flatMap(role -&gt; &#123; List&lt;Perms&gt; list = permsService.findPermsByRoleId(role.getId()); return list.stream().map(Perms::getName); &#125;).collect(Collectors.toList()); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addRoles(roles); info.addStringPermissions(perms); System.out.println(roles); System.out.println(perms); return info; &#125; /** * 认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); // 用户名 User user = userService.findByUsername(username); if (ObjectUtils.isEmpty(user)) &#123; throw new UnknownAccountException(); &#125; // 返回AuthenticationInfo，然后交由凭证匹配器（CredentialsMatcher）进行凭证的判断，默认是对密码进行判断 return new SimpleAuthenticationInfo( user.getUsername(), // 用户信息 user.getPassword(), // 密码 ByteSource.Util.bytes(user.getSalt()), // salt盐值 this.getName()); //realm名称 &#125;&#125; 测试 ​ 不同用户由于角色和权限的不同，登录后看到的系统主页是不一样的！ 六、JWT1. 简介 JWT（JSON Web Token）是目前最流行的跨域认证解决方案。 传统的认证流程，使用session： 12345671、用户向服务器发送用户名和密码2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等3、服务器向用户返回一个 session_id，写入用户的 Cookie4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份存在的问题：扩展性差、服务器内存占用较高 JWT的认证流程，使用token： 123451、用户向服务器发送用户名和密码2、服务器验证通过后，会生成一个token（JWT），表示用户的身份3、服务器向用户返回该token，客户端存储token，可以存储在Cookie、localStorage或sessionStorage中4、用户随后的每一次请求，都要带上这个token，一般放请求头中携带5、服务器收到token并验证是否有效，由此得知用户的身份。 2. JWT原理JWT 原理：服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 12345&#123; &quot;姓名&quot;: &quot;张三&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2023年6月12日0点0分&quot;&#125; 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。 为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 优点： 服务器不再保存任何 session 数据，服务器变成无状态了 由客户端保存身份信息，即JWT令牌 token，一般存储在客户端的localStorage中 客户端每次请求时，JWT令牌随着请求头一起提交 3. JWT数据结构实际的 JWT 大概就像下面这样。 它是一个很长的字符串，中间用点.分隔成三个部分。 JWT的三个部分如下： Header（头部） Payload（载荷） Signature（签名） 3.1 头部（Header）Header 部分是一个 JSON 对象，用于描述该JWT的基本信息，例如签名所用的算法及令牌的类型等。 1234&#123; &quot;alg&quot;:&quot;HS256&quot;, &quot;typ&quot;:&quot;JWT&quot;&#125; 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；type属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 注： Base64URL 算法和 Base64 算法基本类似，但有一些小的不同，其会将个别特殊符合替换掉。 3.2 载荷（Playload）Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 除了官方字段，你还可以在这个部分自定义私有字段，下面就是一个例子。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 这个 JSON 对象也要使用 Base64URL 算法转成字符串。 1eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 注意：由于Base64URL是对称算法，可以被解密为明文信息，所以一般不建议存放敏感数据。 3.3 签名（Signature）Signature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。 4. 优缺点优点： 因为json的通用性，所以JWT是可以跨语言的 因为有了payload部分，所以JWT可以在自身存储一些其他业务所必要的非敏感信息 便于传输，JWT的构成非常简单，字节占用很小，所以它是非常便于传输的 它不需要在服务端保存会话信息，所以易于扩展，例如集群或微服务环境下。 JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 缺点： JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次 JWT 不加密的情况下，不能将敏感数据写入 JWT。 由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 5. 在Java中使用JWT步骤： 添加依赖 123456&lt;!--java-jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 基本用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class JwtTest &#123; /** * 生成令牌 */ @Test public void generate()&#123; Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;(); payload.put(&quot;id&quot;,1001); payload.put(&quot;name&quot;,&quot;tom&quot;); Calendar c = Calendar.getInstance(); c.add(Calendar.SECOND,30); // JWTCreator.Builder builder = JWT.create(); String token = JWT.create() .withPayload(payload) // 载荷 .withExpiresAt(c.getTime()) // 过期时间 .sign(Algorithm.HMAC256(&quot;secret&quot;)); // 签名：算法和密钥 System.out.println(token); &#125; /** * 校验令牌 * 如果令牌过期，会抛异常TokenExpiredException * 一般会返回boolean，表示校验是否通过 */ @Test public void valid()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; try &#123; JWT.require(Algorithm.HMAC256(&quot;secret&quot;)).build().verify(token); &#125; catch (Exception e) &#123; // 如果令牌过期，会抛异常TokenExpiredException e.printStackTrace(); &#125; &#125; /** * 解析令牌 * 如果令牌过期，会抛异常TokenExpiredException */ @Test public void parse()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; DecodedJWT decodedJWT = JWT.require(Algorithm.HMAC256(&quot;secret&quot;)).build().verify(token); // 获取载荷中的信息 Long id = decodedJWT.getClaim(&quot;id&quot;).asLong(); String name = decodedJWT.getClaim(&quot;name&quot;).asString(); System.out.println(id+&quot;-&quot;+name); &#125; /** * 反码令牌 * 直接获取载荷信息，不会校验是否过期 */ @Test public void decode()&#123; String token =&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEwMDEsImV4cCI6MTY4NjU3NTczNn0.W4CdE-upxcAGK4uVD-awRXIl0Y6Q8NHTS8PG4dhjJeo&quot;; DecodedJWT decodedJWT = JWT.decode(token); Long id = decodedJWT.getClaim(&quot;id&quot;).asLong(); String name = decodedJWT.getClaim(&quot;name&quot;).asString(); System.out.println(id+&quot;-&quot;+name); &#125;&#125; 七、整合步骤： 创建一个springboot工程，选择以下模块：Web、Lombok、DevTools、Spring Data Redis 添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!--mysql、druid、mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--knife4j--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--java-jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- easy-captcha --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt; &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- hutool --&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.15&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920212223242526272829303132server: port: 8080spring: # DruidDataSource datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/project?useUnicode=true&amp;characterEncoding=utf8 username: root password: root # knife4j mvc: pathmatch: matching-strategy: ant_path_matcher # redis redis: host: localhost port: 6379 database: 0# MyBatismybatis: type-aliases-package: net.wanho.po mapper-locations: classpath:mapper/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl map-underscore-to-camel-case: true# PageHelperpagehelper: helper-dialect: mysql 数据库 123456789101112131415161718192021drop database if exists project;create database project charset utf8;use project;create table user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(50) unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, status tinyint comment &#x27;帐号状态（0正常 1停用）&#x27;) engine innodb default charset utf8 comment &#x27;用户表&#x27;;create table student( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(50) comment &#x27;姓名&#x27;, age int comment &#x27;年龄&#x27;, gender varchar(50) comment &#x27;性别&#x27;, address varchar(50) comment &#x27;地址&#x27;, birth date comment &#x27;生日&#x27;) engine innodb default charset utf8 comment &#x27;学生表&#x27;;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"}]},{"title":"Vue3学习","slug":"Vue3学习","date":"2023-08-22T08:31:19.000Z","updated":"2023-08-23T00:52:03.000Z","comments":true,"path":"2023/08/22/Vue3学习/","link":"","permalink":"http://example.com/2023/08/22/Vue3%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、简介1. 介绍​ Vue 2 将于 2023 年 12 月 31 日停止维护，详见 Vue 2 延长 LTS。 ​ Vue 3是Vue.js的下一个主要版本，最初于2020年9月发布，Vue 3支持Vue 2的大多数特性。 2. 优点 更快更省 Object.defineProperty ——&gt; Proxy 重构 Virtual DOM 运行速度更快，打包体积更小 更好的TypeScript集成 团队开发更轻松 架构更灵活，阅读源码更轻松 可以独立使用Vue内部模块 组合式API（Composition API） 一组低侵入式的、函数式的 API 更好的逻辑复用与代码组织 更好的类型推导 二、创建Vue3项目1. 简介Vue.js官方提供了两种创建Vue 3项目的方式：vue-cli 或 vite 区别如下: 运行方式不同 vue-cli使用Webpack进行项目打包，这意味着启动和打包速度相对较慢 vite使用ES模块系统，利用浏览器原生的模块解析器来运行，启动速度更快，打包速度也更快。 默认配置有区别 vue-cli提供了更多的默认配置和插件，可以帮助开发者更快地创建和部署Vue.js项目 vite则采用更加精简的配置和插件，让开发者自由地选择第三方插件和配置模块。 2. 使用 viteVite是一种新型前端构建工具，能够显著提升前端开发体验。 特点： 快速的冷启动，不需要等待打包操作 即时的热模块更新，替换性能和模块数量的解耦让更新飞起 真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变 操作步骤： 123456789# 创建项目npm init vue@latest # 基于Vite# 安装依赖cd vue3-projectnpm install# 运行项目npm run dev 三、API 风格Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API 1. 选项式 API (Options API)使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。 选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。 123456789101112131415161718192021222324&lt;script&gt;export default &#123; // data() 返回的属性将会成为响应式的状态，并且暴露在 this 上 data() &#123; return &#123; count: 0 &#125; &#125;, // methods 是一些用来更改状态与触发更新的函数，它们可以在模板中作为事件处理器绑定 methods: &#123; increment() &#123; this.count++ &#125; &#125;, // 生命周期钩子会在组件生命周期的各个不同阶段被调用，例如这个函数就会在组件挂载完成后被调用 mounted() &#123; console.log(`The initial count is $&#123;this.count&#125;.`) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 2. 组合式 API (Composition API)通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。 在单文件组件中，组合式 API 通常会与&lt;script setup&gt;搭配使用。这个 setup 属性是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，&lt;script setup&gt; 中的导入和顶层变量&#x2F;函数都能够在模板中直接使用。 下面是使用了组合式 API 与 &lt;script setup&gt; 改造后和上面的模板完全一样的组件： 1234567891011121314151617181920&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 响应式状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() =&gt; &#123; console.log(`The initial count is $&#123;count.value&#125;.`)&#125;)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 四、响应式APIVue 3 提供的一组具有响应式特性的函数式API，都是以函数形式提供的 1. reactivereactive()函数接收一个普通对象，返回该普通对象的响应式代理对象 简单来说，就是用来创建响应式的数据对象 12345678910&lt;script setup&gt; // 导入reactive函数 import &#123; reactive &#125; from &#x27;vue&#x27; // 创建响应式数据对象，是一个代理对象 const user = reactive(&#123; name:&#x27;tom&#x27;, age:18 &#125;)&lt;/script&gt; 2. refref()函数接收一个参数值，返回一个响应式的数据对象。该对象只包含一个指向内部值的 .value 属性 在模板中访问时，无需通过.value属性，它会自动展开 3. toReftoRef()函数用来将 reactive 对象的一个属性创建为一个 ref，并且这个 ref 具有响应性，可以被传递。 4. toRefstoRefs()函数用来将 reactive 对象创建为一个普通对象，但该普通对象的每个属性都是一个 ref，并且这个 ref 具有响应性，可以被传递。 5. computedcomputed() 函数用来创建计算属性，函数的返回值是一个 ref 的实例 6. watchwatch() 函数用来监视数据的变化，从而触发特定的操作 6. watchEffectwatchEffect()函数接收一个函数作为参数，并立即执行该函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。 五、组件间数据传递1. 父子组件父向子传递数据：属性绑定+数据拦截 使用defineProps接收父组件传递的数据 子向父传递数据：事件监听+事件触发 使用defineEmits自定义事件，然后触发事件 注：defineProps 和 defineEmits是自动导入的，不需要手动导入 2. 依赖注入依赖注入就是祖先组件向后代组件传递数据，使用provide() 和 inject() 函数来实现 在祖先组件中使用provide()函数向下传递数据 在后代组件中使用inject()函数获取上层传递过来的数据 六、生命周期钩子函数Vue 3 中的生命周期函数和 Vue 2.x 相比做了一些调整和变化，对应关系如下： beforeCreate -&gt; 使用 setup() created -&gt; 使用 setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured 七、模板 Refs通过 ref()函数还可以引用页面上的元素或组件，功能类似于 vue 2.x中的 vm.$refs 步骤： 创建一个空的 ref 对象并返回它 在页面上为元素添加 ref 属性，并设置属性值与创建的 ref 对象的名称相同 当页面渲染完成后，可以通过该 ref 对象获取到页面中对应的DOM元素 八、Pinia状态管理Pinia（小菠萝）是一个轻量级的、基于Vue 3的状态管理库，提供了更简单的 API，支持Typescript和组合式API风格。 与Vuex相比，Pinia抛弃了Mutation操作，保留state、getters、actions，且提供了更简便的用法。 官网 https://pinia.vuejs.org/zh/ 基本用法，步骤： 定义store 1234567891011121314import &#123; ref, computed &#125; from &#x27;vue&#x27;import &#123; defineStore &#125; from &#x27;pinia&#x27;export const useUser = defineStore(&#x27;user&#x27;, () =&gt; &#123; const msg = ref(&#x27;welcome to pinia&#x27;) const reverseMsg = computed(() =&gt; msg.value.toUpperCase().split(&#x27; &#x27;).reverse().join(&#x27; &#x27;)) function setMsg(newValue) &#123; msg.value = newValue &#125; return &#123; msg, reverseMsg, setMsg &#125;&#125;) 使用store 1234567891011&lt;script setup&gt; import &#123; useUser &#125; from &#x27;@/stores/user&#x27; const user = useUser()&lt;/script&gt;&lt;template&gt; &lt;p&gt;&#123;&#123; user.msg &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; user.reverseMsg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;user.setMsg(&#x27;hello world&#x27;)&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt; 附录：vite常用插件1. unplugin-auto-importunplugin-auto-import 自动导入插件，能够自动引入ref、reavtive等函数，不需要再自己引入 步骤： 安装插件 执行npm install -D unplugin-auto-import 配置插件，编辑vite.config.js 123456789101112131415import AutoImport from &#x27;unplugin-auto-import/vite&#x27;export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; imports:[&#x27;vue&#x27;,&#x27;vue-router&#x27;,&#x27;pinia&#x27;] // 自动导入相关函数 &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 2. vite-plugin-pagesvite-plugin-pages 自动读取指定目录下的文件，生成路由信息，不需要自己去逐个配置路由 步骤： 安装插件 执行npm install -D vite-plugin-pages 配置插件，编辑vite.config.js 123456789101112131415161718192021import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Pages from &#x27;vite-plugin-pages&#x27;export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; imports:[&#x27;vue&#x27;,&#x27;vue-router&#x27;,&#x27;pinia&#x27;] // 自动导入相关函数 &#125;), Pages(&#123; dirs:[ &#123; dir: &quot;src/views&quot;, baseRoute: &quot;&quot; &#125;], // 修改默认文件夹 importMode: &quot;async&quot; &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 自动生成路由，编辑router&#x2F;index.js 12345678import routes from &#x27;~pages&#x27;const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes&#125;)export default router 注意： vite-plugin-pages默认读取的页面文件夹是 pages，默认读取的页面是 index.vue 所以最好先在pages文件夹下面创建一个 index.vue文件","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"JDK8新特性","slug":"JDK8新特性","date":"2023-08-22T08:30:50.000Z","updated":"2023-08-22T08:32:35.000Z","comments":true,"path":"2023/08/22/JDK8新特性/","link":"","permalink":"http://example.com/2023/08/22/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"一、类型推断的改进类型推断(推导) 是 JDK7的特性，JDK8中做了改进。 二、默认方法JDK8 新增了接口的默认方法，默认方法就是一个在接口中有具体实现的方法，即非抽象方法。 定义默认方法时需要使用 default 关键字进行修饰。 也可以定义静态方法，且不需要使用 default 修饰。 三、Lambda表达式Lambda 表达式是一个匿名函数，允许把函数作为一个方法的参数。 Lambda 表达式可以认为是对匿名内部类的一种简化，使代码变的更简洁紧凑。 但并不是所有的匿名内部类都可以简化为Lambda表达式，只有函数式接口的匿名内部类才可以使用Lambda表达式来进行简化 函数式接口：就是接口中只有一个抽象方法，Lambda表达式正好是针对这个唯一的抽象方法使用的 Lambda表达式的语法： 123(parameters) -&gt; expression或(parameters) -&gt; &#123; statement; &#125; 注意: 参数类型是可选的 : 可以省略参数的类型声明，由编译器统一识别，进行类型推断 参数小括号是可选的 : 当方法只有一个参数时，可以省略参数小括号 方法体大括号是可选的: 当方法体只包含一条语句时，可以省略方法体大括号 return关键字是可选的 : 当方法体只包含一条语句，且需要返回该语句的执行结果时，可以省略return 四、方法引用方法引用是一种语法糖操作，作用是简化Lambda在调用已经存在的方法时的表达式。 方法引用可以直接引用已有Java类或对象的方法或构造方法，使用一对冒号 :: 方法引用的几种类型： 静态方法引用（类名::静态方法名） 实例方法引用（对象名::实例方法名） 类的实例方法引用（类名::实例方法名） 构造方法引用（类名::new） 五、函数式接口函数式接口 Functional Interface：就是有且只有一个抽象方法的接口，但可以有多个非抽象方法。 函数式接口（的实现类的对象）可以隐式转换为Lambda表达式，进行简化。 Java 8 提供了一个特殊的注解**@FunctionalInterface**，用于标注一个接口是函数式接口 1234567891011121314151617181920212223242526272829/** * JDK8之前的函数式接口 */java.lang.Runnablejava.lang.Comparable&lt;T&gt;java.util.Comparator&lt;T&gt;java.io.FileFilterjava.io.FilenameFilterjava.lang.reflect.InvocationHandler...... /** * JDK8新增的函数式接口，主要在java.util.function包中 */ // 消费型接口java.util.function.Consumer&lt;T&gt; void accept(T t); // 接收一个参数, 无返回// 供给型接口java.util.function.Supplier&lt;T&gt; T get(); // 无参数, 返回一个结果// 函数型接口java.util.function.Function&lt;T, R&gt; R apply(T t); // 接收一个参数, 返回一个结果// 断言型接口java.util.function.Predicate&lt;T&gt; boolean test(T t); // 接收一个参数, 返回一个布尔值的结果 六、Stream API1. 简介Java 8 API 添加了一个新的抽象称为Stream流，它可以让你以一种声明的方式来处理数据。 Stream主要用于集合操作，支持链式编程，极大的简化了代码。 Stream将要处理的元素集合看作为一种流，数据在流的管道中传输，可以在管道的节点上对元素进行处理，如：筛选、排序、聚合等。 元素流在管道中经过 中间操作 的处理，最后由 终止操作 得到前面处理的结果。 Stream流的操作步骤： 获取Stream对象 中间操作（实现要做的数据处理操作） 终止操作 2. 获取Stream对象三种方式： 通过Collection接口中的stream方法或parallelStream方法获取集合的流 通过Arrays类中的stream方法获取数组的流（串行流） 通过Stream接口中的of方法获取一个或多个元素的流（串行流） 3. 基本使用3.1 Stream特点Stream不会存储元素 Stream不会改变源对象，它会返回一个持有结果的新Stream对象。 Stream中间操作都会返回一个持有结果的新Stream对象，可以对新的Stream继续执行其他的中间操作，这样的多个连续操作，可以串联成一个管道。 Stream的中间操作是延迟执行的，需要执行终止操作，才会真正的执行中间操作。 3.2 惰性求值多个中间操作可以连起来，形成一个流水线。除非流水线上触发了终止操作，否则中间操作不会被执行。 只有当发生终止操作时，才会一次性处理全部的操作，这种情况称为 惰性求值 。 3.3 内部迭代以前对集合遍历都是通过 Iterator 或 For-Each 的方式，这种显式的在集合外部进行迭代的方式称为 外部迭代。 在集合内部进行迭代的方式称为 内部迭代。例如：集合的forEach方法、Stream的操作的forEach方法（是一个终止操作）。 4. 中间操作4.1 筛选与切片filter(Predicate predicate) 从流中获取符合条件的元素 limit(long maxSize) 截断流，使其元素不超过指定数量 skip(long n) 跳过多个元素，返回一个扔掉了 n 个元素的流，如果流中的元素不足 n，则返回一个空的流 distinct() 通过流中的元素的 hashCode和equals方法进行判断是否重复 4.2 映射map(Function&lt;T, R&gt; mapper) 将回调方法的操作应用到每一个元素上，将其映射成一个新的元素。 flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper) 将流中的每一个元素都转换成一个流，然后将所有的流连成一个新的流。 mapToInt(ToIntFunction&lt;T&gt; mapper) 将流中的每一个元素转换成int类型的元素，然后返回包含所有转换后值的流 mapToLong(ToLongFunction&lt;T&gt; mapper) 将流中的每一个元素转换成long类型的元素，然后返回包含所有转换后值的流 mapToDouble(ToDoubleFunction&lt;T&gt; mapper) 将流中的每一个元素转换成double类型的元素，然后返回包含所有转换后值的流 peek(Consumer&lt;? super T&gt; action) 作用与map()类似，但无需返回值，属于消费型接口 4.3 排序sorted() 返回一个新的流，其中元素按照自然顺序升序排序。 sorted(Comparator&lt;T&gt; comparator) 根据比较器指定的排序规则，对流中的元素进行排序。 5. 终止操作5.1 查找与匹配forEach(Consumer c)遍历流中的数据,该方法接收一个Consumer函数式接口，会将每一个流的元素交给函数 allMatch(Predicate&lt;T&gt; predicate) 元素全部满足要求时，才会返回 true，否则返回 false（短路操作） anyMatch(Predicate&lt;T&gt; predicate) 元素只要有一个满足要求，就会返回 true，否则返回 false（短路操作） noneMatch(Predicate&lt;? super T&gt; predicate) 元素全部不满足要求时，才会返回 true，否则返回 false（短路操作） findFirst() 取出流中第一个元素，会把结果封装成 Optional 类型的对象。 findAny() 取出符合要求的一个元素(任意的、只要满足要求即可)。 count() 统计流中的元素个数。 max(Comparator&lt;T&gt; comparator) 找最大的元素。 min(Comparator&lt;T&gt; comparator) 找最小的元素。 5.2 归约归约：将流中的元素反复结合起来，得到一个值。 reduce(BinaryOperator&lt;T&gt; accumulator) 对流中的元素进行累计操作。前一次的操作结果会作为下一次操作的参数，最终返回一个 使用 Optional 封装的累计结果。 reduce(T identity, BinaryOperator&lt;T&gt; accumulator) 对流中的元素进行累计操作。根据初始值 identity 进行累计操作，最终返回一个和流中元素类型一致的结果。 5.3 收集collect(Collector&lt;T, A, R&gt; collector) 收集处理的结果，将流转换成指定集合，一般通过Collectors工具类指定集合类型 七、Optional 类型Optional 是一个容器，可以保存 T 类型的值，或仅仅保存null。 Optional 主要的作用是用来解决空指针异常的。 Optional 提供了很多有用的方法，这样程序员就不用显式进行空值判断了。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Redis学习","slug":"Redis学习","date":"2023-08-21T13:30:53.000Z","updated":"2023-08-22T08:33:47.000Z","comments":true,"path":"2023/08/21/Redis学习/","link":"","permalink":"http://example.com/2023/08/21/Redis%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Redis简介1. 关于NoSQLNoSQL的全称是Not only SQL，意即”不仅仅是SQL”，是一项全新的数据库革命性运动 NoSQL，泛指非关系型的数据库，如Redis、MongoDB和memcached等内存数据库。 产生背景： 海量数据、数据多样化和实时性 高并发、高可扩和高性能 2. Redis是什么Redis是一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求。 Redis数据就是以key-value形式来存储数据： key只能是字符串类型 value可以是以下五种类型：String、List、Set、Sorted-Sets、Hash 3. Redis优势优点： 应用广泛，技术成熟，简单易用 基于内存，高性能（Redis读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s ） 丰富的数据类型 数据持久化 支持主从备份和读写分离 支持集群 4. Redis的应用场景 缓存（数据查询、短连接、菜单内容、新闻内容、商品内容等） 分布式集群架构中的session分离 聊天室的在线好友列表 任务队列（秒杀、抢购、12306等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） 二、安装Redis1. 安装1.1 WindowsRedis程序文件redis-win.zip 解压到无空格无中文目录下 redis-server.exe 启用服务的命令 redis-cli.exe 连接服务端的命令 端口号6379 12345678# 默认连接【本机+6379】redis-cli# 指定连接 -h ip -p 端口redis-cli -h 127.0.0.1 -p 6379# 连接好了，退出exit# 关闭redis服务器redis-cli shutdown 使用图形化客户端工具 Redis Desktop Manager.exe 1.2 Linux​ 步骤： 解压redis-3.2.8.tar.gz 12cd ~/softwaretar -zxf redis-3.2.8.tar.gz 编译 12cd redis-3.2.8make 安装 12mkdir ~/software/redis-binmake install PREFIX=~/software/redis-bin/ #PREFIX选项用来指定安装的位置 启动redis 12345cd ~/software/redis-bin/bin/./redis-server #使用默认配置文件启动，默认配置文件所在目录redis-3.2.8/redis.conf或cp ~/software/redis-3.2.8/redis.conf myredis.conf #复制默认配置文件到当前目录，并改名./redis-server myredis.conf #使用指定的配置文件启动 连接redis 123./redis-cli #默认连接本机的6379端口(redis默认使用的端口号)或./redis-cli -h IP地址 -p 端口号 #连接指定主机、指定端口的redis，如./redis-cli -h localhost -p 6379 测试 12127.0.0.1:6379&gt; set name tom127.0.0.1:6379&gt; get name 关闭 方式1：在服务器窗口中按 Ctrl+C 方式2：在客户端连接后输入 shutdown 或 直接输入 redis-cli shutdown ​ 查看进程 123ps -ef | grep redis #查看redis的进程信息或lsof -i:6379 #查看6379端口的进程信息 2. 配置编辑redis.conf配置文件： 123456789daemonize yes #配置为守护进程，后台启动port 6379 #修改监听端口#让redis支持远程访问，默认只允许本地访问#bind 127.0.0.1 #注释掉该行，允许所有主机访问redisprotected-mode no #关闭保护模式requirepass 123 #配置redis密码，使用时需要输入auth 123进行认证，认证后才能操作redis 三、Redis数据类型1. String类型1.1 简介​ 字符串类型是Redis中最为基础的数据存储类型，它是以二进制形式存储的，这便意味着该类型可以存储任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。 1.2 操作 set&#x2F;get&#x2F;append&#x2F;strlen 12345678910111213141516171819202122$ redis-cli 127.0.0.1:6379&gt; select 0 #切换到第1个数据库（默认共有16个数据库，通过数字来进行命名，索引从0开始）OK127.0.0.1:6379&gt; keys * #显示所有的键key(empty list or set)127.0.0.1:6379&gt; set name tom #设置键OK127.0.0.1:6379&gt; get name #获取键对应的值&quot;tom&quot;127.0.0.1:6379&gt; append mykey &quot;hello&quot; #如果该键不存在，则创建，返回当前value的长度(integer) 5127.0.0.1:6379&gt; append mykey &quot; world&quot; #如果该键已经存在，则追加，返回追加后value的长度(integer) 11127.0.0.1:6379&gt; get mykey #获取mykey的值&quot;hello world&quot;127.0.0.1:6379&gt; strlen mykey #获取mykey的长度(integer) 11#EX和PX表示失效时间，单位为秒和毫秒，两者不能同时使用；NX表示数据库中不存在时才能设置,XX表示存在时才能设置127.0.0.1:6379&gt; set mykey &quot;this is test&quot; EX 5 NX OK127.0.0.1:6379&gt; get mykey&quot;this is test&quot; ​ 注：命令不区分大小写，但key和value区分大小写 incr&#x2F;decr&#x2F;incrby&#x2F;decrby 1234567891011121314151617181920127.0.0.1:6379&gt; flushdb #清空数据库OK127.0.0.1:6379&gt; set mykey 20OK127.0.0.1:6379&gt; incr mykey #递增1(integer) 21127.0.0.1:6379&gt; decr mykey #递减1(integer) 20127.0.0.1:6379&gt; del mykey #删除该键(integer) 1127.0.0.1:6379&gt; decr mykey(integer) -1127.0.0.1:6379&gt; del mykey(integer) 1127.0.0.1:6379&gt; incr mykey(integer) 1127.0.0.1:6379&gt; incrby mykey 5 #递增5，即步长(integer) 15127.0.0.1:6379&gt; decrby mykey 10 #递减10(integer) 5 2. List类型2.1 概述​ 在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。​ 从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。 2.2 操作 lpush&#x2F;lpushx&#x2F;lrange 1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; flushdbOK#创建键mykey及与其关联的List，然后将参数中的values从左到右依次插入127.0.0.1:6379&gt; lpush mykey a b c d(integer) 4#获取从位置0开始到位置2结束的3个元素127.0.0.1:6379&gt; lrange mykey 0 21) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;#获取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;a&quot;#获取从倒数第3个到倒数第2个的元素127.0.0.1:6379&gt; lrange mykey -3 -21) &quot;c&quot;2) &quot;b&quot;#lpushx表示键存在时才能插入，mykey2键此时并不存在，因此该命令将不会进行任何操作，其返回值为0127.0.0.1:6379&gt; lpushx mykey2 e (integer) 0#可以看到mykey2没有关联任何List Value127.0.0.1:6379&gt; lrange mykey2 0 -1(empty list or set)#mykey键此时已经存在，所以该命令插入成功，并返回链表中当前元素的数量127.0.0.1:6379&gt; lpushx mykey e(integer) 5#获取该键的List中的第一个元素127.0.0.1:6379&gt; lrange mykey 0 01) &quot;e&quot; lpop&#x2F;llen 123456789101112127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; lpush mykey a b c d(integer) 4#取出链表头部的元素，该元素在链表中就已经不存在了127.0.0.1:6379&gt; lpop mykey&quot;d&quot;127.0.0.1:6379&gt; lpop mykey&quot;c&quot;#在执行lpop命令两次后，链表头部的两个元素已经被弹出，此时链表中元素的数量是2127.0.0.1:6379&gt; llen mykey(integer) 2 lrem&#x2F;lindex&#x2F;lset&#x2F;ltrim 12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; flushdbOK#准备测试数据127.0.0.1:6379&gt; lpush mykey a b c d a c(integer) 6#从头部(left)向尾部(right)操作链表，删除2个值等于a的元素，返回值为实际删除的数量127.0.0.1:6379&gt; lrem mykey 2 a(integer) 2#查看删除后链表中的全部元素127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;c&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;#获取索引为1(头部的第二个元素)的元素值127.0.0.1:6379&gt; lindex mykey 1&quot;d&quot;#将索引为1(头部的第二个元素)的元素值设置为新值e127.0.0.1:6379&gt; lset mykey 1 eOK#查看是否设置成功127.0.0.1:6379&gt; lindex mykey 1&quot;e&quot;#索引值6超过了链表中元素的数量，该命令返回nil127.0.0.1:6379&gt; lindex mykey 6(nil)#设置的索引值6超过了链表中元素的数量，设置失败，该命令返回错误信息。127.0.0.1:6379&gt; lset mykey 6 h(error) ERR index out of range#仅保留索引值0到2之间的3个元素，注意第0个和第2个元素均被保留。127.0.0.1:6379&gt; ltrim mykey 0 2OK#查看trim后的结果127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;c&quot;2) &quot;e&quot;3) &quot;c&quot; 3. Set类型3.1 概述​ 在Redis中，我们可以将Set类型看作为没有排序的字符集合，也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。Set可包含的最大元素数量是4294967295。​ 和List类型不同的是，Set集合中不允许出现重复的元素，这一点和Java中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions并、intersections交和differences差。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。 3.2 操作 sadd&#x2F;smembers&#x2F;sismember&#x2F;scard 123456789101112131415161718192021222324252627#由于该键myset之前并不存在，因此参数中的三个成员都被正常插入127.0.0.1:6379&gt; sadd myset a b c(integer) 3#查看集合中的元素，从结果可以，输出的顺序和插入顺序无关(无序的)127.0.0.1:6379&gt; smembers myset1) &quot;a&quot;2) &quot;c&quot;3) &quot;b&quot;#由于参数中的a在myset中已经存在，因此本次操作仅仅插入了d和e两个新成员（不允许重复）127.0.0.1:6379&gt; sadd myset a d e(integer) 2#查看插入的结果127.0.0.1:6379&gt; smembers myset1) &quot;a&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;b&quot;5) &quot;e&quot;#判断a是否已经存在，返回值为1表示存在127.0.0.1:6379&gt; sismember myset a(integer) 1#判断f是否已经存在，返回值为0表示不存在127.0.0.1:6379&gt; sismember myset f(integer) 0#获取集合中元素的数量127.0.0.1:6379&gt; scard myset(integer) 5 srandmember&#x2F;spop&#x2F;srem&#x2F;smove 123456789101112131415161718192021222324252627282930313233343536373839127.0.0.1:6379&gt; del myset(integer) 1#准备测试数据127.0.0.1:6379&gt; sadd myset a b c d(integer) 4#查看集合中的元素127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot;4) &quot;b&quot;#随机返回一个成员，成员还在集合中127.0.0.1:6379&gt; srandmember myset&quot;c&quot;#取出一个成员，成员会从集合中删除127.0.0.1:6379&gt; spop myset&quot;b&quot;#查看移出后Set的成员信息127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot;#从Set中移出a、d和f三个成员，其中f并不存在，因此只有a和d两个成员被移出，返回为2127.0.0.1:6379&gt; srem myset a d f(integer) 2#查看移出后的输出结果127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;127.0.0.1:6379&gt; del myset(integer) 1#为后面的smove命令准备数据127.0.0.1:6379&gt; sadd myset a b(integer) 2127.0.0.1:6379&gt; sadd myset2 c d(integer) 2#将a从myset移到myset2，从结果可以看出移动成功127.0.0.1:6379&gt; smove myset myset2 a(integer) 1 3.3 应用范围 可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。 充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。 4. Sorted-Sets类型4.1 概述​ Sorted-Sets和Sets类型极为相似，也称为Zset，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序（默认）。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。​ 在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。 4.2 操作 zadd&#x2F;zrange&#x2F;zcard&#x2F;zrank&#x2F;zcount&#x2F;zrem&#x2F;zscore&#x2F;zincrby 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#添加一个分数为1的成员127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot;(integer) 1#添加两个分数分别是2和3的两个成员127.0.0.1:6379&gt; zadd myzset 2 &quot;two&quot; 3 &quot;three&quot;(integer) 2#通过索引获取元素，0表示第一个成员，-1表示最后一个成员。WITHSCORES选项表示返回的结果中包含每个成员及其分数，否则只返回成员127.0.0.1:6379&gt; zrange myzset 0 -1 WITHSCORES1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;5) &quot;three&quot;6) &quot;3&quot;#获取myzset键中成员的数量 127.0.0.1:6379&gt; zcard myzset(integer) 3#获取成员one在集合中的索引，0表示第一个位置127.0.0.1:6379&gt; zrank myzset one(integer) 0#成员four并不存在，因此返回nil127.0.0.1:6379&gt; zrank myzset four(nil)#获取符合指定条件的成员数量，分数满足表达式1 &lt;= score &lt;= 2的成员的数量127.0.0.1:6379&gt; zcount myzset 1 2(integer) 2#删除成员one和two，返回实际删除成员的数量127.0.0.1:6379&gt; zrem myzset one two(integer) 2#查看是否删除成功127.0.0.1:6379&gt; zcard myzset(integer) 1#获取成员three的分数。返回值是字符串形式127.0.0.1:6379&gt; zscore myzset three&quot;3&quot;#由于成员two已经被删除，所以该命令返回nil127.0.0.1:6379&gt; zscore myzset two(nil)#将成员three的分数增加2，并返回该成员更新后的分数127.0.0.1:6379&gt; zincrby myzset 2 three&quot;5&quot;#将成员three的分数增加-1，并返回该成员更新后的分数127.0.0.1:6379&gt; zincrby myzset -1 three&quot;4&quot;#查看在更新了成员的分数后是否正确127.0.0.1:6379&gt; zrange myzset 0 -1 withscores1) &quot;three&quot;2) &quot;4&quot; zrangebyscore&#x2F;zremrangebyscore&#x2F;zremrangebyrank 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; del myzset(integer) 1127.0.0.1:6379&gt; zadd myzset 1 one 2 two 3 three 4 four(integer) 4#通过分数获取元素，获取分数满足表达式1 &lt;= score &lt;= 2的成员127.0.0.1:6379&gt; zrangebyscore myzset 1 21) &quot;one&quot;2) &quot;two&quot;#-inf表示第一个成员，+inf表示最后一个成员，limit后面的参数用于限制返回成员的数量，#2表示从位置索引(0-based)等于2的成员开始，取后面3个成员，类似于MySQL中的limit127.0.0.1:6379&gt; zrangebyscore myzset -inf +inf withscores limit 2 31) &quot;three&quot;2) &quot;3&quot;3) &quot;four&quot;4) &quot;4&quot;#根据分数删除成员，删除分数满足表达式1 &lt;= score &lt;= 2的成员，并返回实际删除的数量127.0.0.1:6379&gt; zremrangebyscore myzset 1 2(integer) 2#看一下上面的删除是否成功127.0.0.1:6379&gt; zrange myzset 0 -11) &quot;three&quot;2) &quot;four&quot;#根据索引删除成员，删除索引满足表达式0 &lt;= rank &lt;= 1的成员127.0.0.1:6379&gt; zremrangebyrank myzset 0 1(integer) 2#查看上一条命令是否删除成功127.0.0.1:6379&gt; zcard myzset(integer) 0 4.3 应用范围 可以用于大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOP 10的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。 Sorted-Sets类型还可用于构建索引数据。 5. Hash类型5.1 概述 可以将Redis中的Hash类型看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。 5.2 操作 hset&#x2F;hget&#x2F;hlen&#x2F;hexists&#x2F;hdel&#x2F;hsetnx 12345678910111213141516171819202122232425262728293031#给键值为myhash的键设置字段为field1，值为itany127.0.0.1:6379&gt; hset myhash field1 &quot;itany&quot;(integer) 1#获取键值为myhash，字段为field1的值127.0.0.1:6379&gt; hget myhash field1&quot;itany&quot;#myhash键中不存在field2字段，因此返回nil127.0.0.1:6379&gt; hget myhash field2(nil)#给myhash关联的Hashes值添加一个新的字段field2，其值为liu127.0.0.1:6379&gt; hset myhash field2 &quot;liu&quot;(integer) 1#获取myhash键的字段数量127.0.0.1:6379&gt; hlen myhash(integer) 2#判断myhash键中是否存在字段名为field1的字段，由于存在，返回值为1127.0.0.1:6379&gt; hexists myhash field1(integer) 1#删除myhash键中字段名为field1的字段，删除成功返回1127.0.0.1:6379&gt; hdel myhash field1(integer) 1#再次删除myhash键中字段名为field1的字段，由于上一条命令已经将其删除，因为没有删除，返回0127.0.0.1:6379&gt; hdel myhash field1(integer) 0#通过hsetnx命令给myhash添加新字段field1，其值为itany，因为该字段已经被删除，所以该命令添加成功并返回1127.0.0.1:6379&gt; hsetnx myhash field1 &quot;itany&quot;(integer) 1#由于myhash的field1字段已经通过上一条命令添加成功，因为本条命令不做任何操作后返回0127.0.0.1:6379&gt; hsetnx myhash field1 &quot;itany&quot;(integer) 0 hincrby 1234567891011121314127.0.0.1:6379&gt; del myhash(integer) 1#准备测试数据127.0.0.1:6379&gt; hset myhash field 5(integer) 1#给myhash的field字段的值加1，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field 1(integer) 6#给myhash的field字段的值加-1，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field -1(integer) 5#给myhash的field字段的值加-10，返回加后的结果127.0.0.1:6379&gt; hincrby myhash field -10(integer) -5 hmset&#x2F;hmget&#x2F;hgetall&#x2F;hkeys&#x2F;hvals 123456789101112131415161718192021222324127.0.0.1:6379&gt; del myhash(integer) 1#为该键myhash，一次性设置多个字段，分别是field1 = &quot;hello&quot;, field2 = &quot;world&quot;127.0.0.1:6379&gt; hmset myhash field1 &quot;hello&quot; field2 &quot;world&quot;OK#获取myhash键的多个字段，其中field3并不存在，因为在返回结果中与该字段对应的值为nil127.0.0.1:6379&gt; hmget myhash field1 field2 field31) &quot;hello&quot;2) &quot;world&quot;3) (nil)#返回myhash键的所有字段及其值，从结果中可以看出，他们是逐对列出的127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;hello&quot;3) &quot;field2&quot;4) &quot;world&quot;#仅获取myhash键中所有字段的名字127.0.0.1:6379&gt; hkeys myhash1) &quot;field1&quot;2) &quot;field2&quot;#仅获取myhash键中所有字段的值127.0.0.1:6379&gt; hvals myhash1) &quot;hello&quot;2) &quot;world&quot; 四、Key操作命令1. 命令列表 命令用法 解释 keys pattern 获取所有匹配pattern参数的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。 del key [key…] 从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。 exists key 判断指定键是否存在。 persist key 如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。 expire key seconds 该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 ttl key 获取该键所剩的超时描述。 type key 获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。 2. 操作 keys&#x2F;del&#x2F;exists 123456789101112131415161718192021222324252627282930313233127.0.0.1:6379&gt; flushdbOK#添加String类型的数据127.0.0.1:6379&gt; set mykey 2OK#添加List类型的数据127.0.0.1:6379&gt; lpush mylist a b c(integer) 3#添加Set类型的数据127.0.0.1:6379&gt; sadd myset 1 2 3(integer) 3#添加Sorted-Set类型的数据127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot; 2 &quot;two&quot;(integer) 2#添加Hash类型的数据127.0.0.1:6379&gt; hset myhash username &quot;tom&quot;(integer) 1#根据参数中的模式，获取当前数据库中符合该模式的所有key，从输出可以看出，该命令在执行时并不区分与Key关联的Value类型127.0.0.1:6379&gt; keys my*1) &quot;myset&quot;2) &quot;mykey&quot;3) &quot;myzset&quot;4) &quot;myhash&quot;5) &quot;mylist&quot;#删除了两个Keys127.0.0.1:6379&gt; del mykey mylist(integer) 2#查看刚刚删除的Key是否还存在，从返回结果看，mykey确实已经删除了127.0.0.1:6379&gt; exists mykey(integer) 0#查看一下没有删除的Key，以和上面的命令结果进行比较127.0.0.1:6379&gt; exists myset(integer) 1 ttl&#x2F;persist&#x2F;expire 12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; flushdbOK#准备测试数据，将该键的超时设置为100秒127.0.0.1:6379&gt; set mykey &quot;hello&quot; ex 100OK#通过ttl命令查看还剩多少秒127.0.0.1:6379&gt; ttl mykey(integer) 97#立刻执行persist命令，该存在超时的键变成持久化的键，即将该Key的超时去掉127.0.0.1:6379&gt; persist mykey(integer) 1#ttl的返回值告诉我们，该键已经没有超时了127.0.0.1:6379&gt; ttl mykey(integer) -1#为后面的expire命令准备数据127.0.0.1:6379&gt; del mykey(integer) 1127.0.0.1:6379&gt; set mykey &quot;hello&quot;OK#设置该键的超时被100秒127.0.0.1:6379&gt; expire mykey 100(integer) 1#用ttl命令看当前还剩下多少秒，从结果中可以看出还剩下96秒127.0.0.1:6379&gt; ttl mykey(integer) 96#重新更新该键的超时时间为20秒，从返回值可以看出该命令执行成功127.0.0.1:6379&gt; expire mykey 20(integer) 1#再用ttl确认一下，从结果中可以看出被更新了127.0.0.1:6379&gt; ttl mykey(integer) 17#立刻更新该键的值，以使其超时无效。127.0.0.1:6379&gt; set mykey &quot;world&quot;OK#从ttl的结果可以看出，在上一条修改该键的命令执行后，该键的超时也无效了127.0.0.1:6379&gt; ttl mykey(integer) -1 type 123456789101112131415161718192021222324127.0.0.1:6379&gt; del mykey(integer) 1#添加不同类型的测试数据127.0.0.1:6379&gt; set mykey 2OK127.0.0.1:6379&gt; lpush mylist a b c(integer) 3127.0.0.1:6379&gt; sadd myset 1 2 3(integer) 3127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot; 2 &quot;two&quot;(integer) 2127.0.0.1:6379&gt; hset myhash username &quot;tom&quot;(integer) 1#分别查看数据的类型127.0.0.1:6379&gt; type mykeystring127.0.0.1:6379&gt; type mylistlist127.0.0.1:6379&gt; type mysetset127.0.0.1:6379&gt; type myzsetzset127.0.0.1:6379&gt; type myhashhash 五、持久化1. 概述Redis提供了两种数据持久化的方式： RDB 该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘。 AOF 该机制将以日志的形式记录服务器所处理的每一个写操作 在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。 2. RDBRedis Database：通过单文件的方式来持久化 RDB是默认的持久化方式，默认存储在启动redis服务器时所在当前目录下的dump.rdb文件中，一般都会修改存储在一个固定的目录中 编辑配置文件： 1234$ vi myredis.conf dbfilename dump.rdb #持久化文件的名称 #dir ./ #持久化文件的目录,默认为执行redis-server命令时所在的当前目录 dir /home/soft01/software/dump/ #修改存储位置为一个固定的目录 持久化的时机： 在数据库关闭时会持久化（需要注意的是在数据库宕机时不会生成，数据可能会丢失） 满足特定条件时会持久化，编辑配置文件： 1234$ vi myredis.conf save 900 1 #在900秒内，只要有1个key发生变化，就会dump持久化 save 300 10 save 60 10000 优缺点： 缺点：可能会丢失数据 优点：效率比较高 3. AOFAppend Only File：通过操作日志的方式来持久化 编辑配置文件： 12345$ vi myredis.conf appendonly yes #开启aof模式的持久化 appendfilename &quot;appendonly.aof&quot; #aof的持久化文件 appendfsync everysec #每一秒进行一次持久化操作，可取值：always、everysec、no dir /home/soft01/software/dump/ #持久化文件的目录，与RDB相同 优缺点： 缺点：效率比较差 优点：丢失数据量比较少 六、SpringBoot整合Redis1. 用法步骤： 创建一个SpringBoot工程，选择以下模块：Spring Data Redis、Web、Lombok、DevTools 配置redis 12345678910111213spring: redis: host: localhost port: 6379 password: database: 0 # lettuce连接池配置 lettuce: pool: max-wait: 10000 max-idle: 20 min-idle: 10 max-active: 8 注：Java中操作Redis主要有两种客户端：jedis和lettuce，SpringBoot中默认使用的是lettuce 基本操作 使用SpringDataRedis提供的工具类：RedisTemplate 2. RedisConfig配置类1234567891011121314151617181920212223242526/** * Redis配置类 */@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // 设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); // 设置key的序列化方式 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setHashKeySerializer(stringRedisSerializer); // 设置value的序列化方式 GenericJackson2JsonRedisSerializer jsonRedisSerializer =new GenericJackson2JsonRedisSerializer(); redisTemplate.setValueSerializer(jsonRedisSerializer); redisTemplate.setHashValueSerializer(jsonRedisSerializer); return redisTemplate; &#125;&#125; 七、Redis应用：验证码将验证码存储在Redis中 添加依赖，使用captcha生成验证码 123456&lt;!--easy-captcha--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt; &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"如何解决跨域问题","slug":"如何解决跨域问题","date":"2023-08-21T03:44:39.000Z","updated":"2023-09-07T02:40:21.000Z","comments":true,"path":"2023/08/21/如何解决跨域问题/","link":"","permalink":"http://example.com/2023/08/21/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"方法一定义一个配置类，实现WebMvcConfigurer接口，重写addCorsMappings方法 123456789101112@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOriginPatterns(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;*&quot;) .maxAge(3600); &#125;&#125; 方法二在xml中添加如下配置: 123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;/mvc:cors&gt; 方法三在vue项目中vue.config.js内配置代理： 1234567891011121314module.exports = defineConfig(&#123; transpileDependencies: true, devServer: &#123; // 配置代理 proxy:&#123; &#x27;/api&#x27;:&#123; // 所有以/api开头的请求都会被代理到target上 target: &#x27;http://localhost:8080&#x27;, // 代理的目标地址 changeOrigin: true, // 支持跨域 pathRewrite: &#123; // 重写路径 &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125; 在main.js中配置axios： 1234// axios配置import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;/api/&#x27;Vue.prototype.$http = axios 在组件中method中定义方法： 123async getCode()&#123; const &#123;data:res&#125; = await this.$http.get(&#x27;captchaImage&#x27;)&#125;,","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"SpringBoot学习","slug":"SpringBoot学习","date":"2023-08-17T08:36:01.000Z","updated":"2023-08-17T08:40:14.000Z","comments":true,"path":"2023/08/17/SpringBoot学习/","link":"","permalink":"http://example.com/2023/08/17/SpringBoot%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、SpringBoot简介1. SpringBoot是什么？产生背景：Spring开发变的越来越笨重，大量的XML文件、繁琐的配置、复杂的部署流程、整合第三方框架难度大等，导致开发效率低下 SpringBoot是一个用来简化Spring应用的初始创建和开发过程的框架，简化配置，实现快速开发 融合了整个Spring技术栈，JavaEE开发的一站式解决方案 参考：Spring官网 https://spring.io/projects 2. 为什么使用SpringBoot？优点： 快速创建独立运行的Spring项目并与主流框架集成 内置Servlet容器，应用无需打成WAR包 使用starter(启动器)管理依赖并进行版本控制 大量的自动配置，简化开发 提供准生产环境的运行时监控，如指标、健康检查、外部配置等 无需配置XML，没有冗余代码生成，开箱即用 二、第一个SpringBoot程序1. 环境要求 SpringBoot 2.x JDK 8及以上 Maven 3.5及以上 Tomcat 9及以上 2. 操作步骤步骤： 创建一个maven的java工程 传统web应用需要创建一个web工程，后期要打成war包，然后放到tomcat中，太麻烦 而SpringBoot应用只需要创建一个java工程，后期直接打成可执行的jar包，其内置tomcat 导入SpringBoot的相关依赖 12345678910111213&lt;!-- 继承SpringBoot的父工程 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- 添加web应用的starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写Controller 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; return &quot;Hello World&quot;; &#125;&#125; 编写主程序类，用来启动SpringBoot应用 12345678910/** * 使用@SpringBootApplication标注主程序类，表示这是一个SpringBoot应用 */@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 启动SpringBoot应用 SpringApplication.run(MainApplication.class, args); //传入主程序类的Class对象 &#125;&#125; 注：主程序类必须放到其他类的上层包中，因为默认只扫描主程序类所在的包及其子包 运行主程序并访问测试 http://localhost:8080/hello 部署打包 添加spring-boot-maven-plugin插件，将应用打成可执行的jar包，然后直接执行java -jar springboot01-helloworld-1.0-SNAPSHOT.jar 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 分析HelloWorldPOM文件： 父项目是spring-boot-starter-parent 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt; 父项目的父项目是spring-boot-dependencies，用来管理SpringBoot应用中依赖的版本，进行版本控制 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt;&lt;/parent&gt; 通过启动器starter指定依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 主程序类： @SpringBootApplication 标注在类上，表示这是一个SpringBoot应用，通过运行该类的main方法来启动SpringBoot应用 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration 标注在类上，表示这个类是SpringBoot的配置类 层级关系：@SpringBootConfiguration——&gt;@Configuration——&gt;@Component @Configuration标注在类上，表示这个类是Spring的配置类，相当于是一个xml配置文件 @EnableAutoConfiguration 开启自动配置功能，SpringBoot会自动完成许多配置，简化了以前繁琐的配置 @ComponentScan 标注在类上，指定要扫描的包，默认只扫描主程序类所在的包及其子包 可以使用@ComponentScan手动指定要扫描的包 三、基本用法1. 快速创建项目步骤： 使用Spring Initializer快速创建SpringBoot项目 ​ 选择SpringBoot 2.x 版本 ​ 勾选Web、Lombok模块 基本操作 ​ 默认生成的.mvn、.gitignore、mvnw、mvnw.cmd，可以直接删除 ​ resources文件夹的目录结构 1234|-resources |-static // 存放静态资源，如css、js、imgs等 |-templates // 存放模板页面，可以使用模板引擎，如thymeleaf、freemarker等 |-application.properties // SpringBoot应用的配置文件，可以修改默认设置 ​ 注：SpringBoot生成的可执行jar包使用嵌入式的Tomcat，默认不支持JSP 修改banner图案 ​ 在resources&#x2F;目录下创建名为banner.txt的文件，内容如下生成 ​ 在线生成：https://patorjk.com/software/taag ​ 经典图案 ：https://blog.csdn.net/vbirdbest/article/details/78995793 1234567891011121314151617181920212223::Spring Boot Version:: $&#123;spring-boot.version&#125;////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88&quot; . &quot;88 //// (| ^_^ |) //// O\\ = /O //// ____/`---&#x27;\\____ //// .&#x27; \\\\| |// `. //// / \\\\||| : |||// \\ //// / _||||| -:- |||||- \\ //// | | \\\\\\ - /// | | //// | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | //// \\ .-\\__ `-` ___/-. / //// ___`. .&#x27; /--.--\\ `. . ___ //// .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. //// | | : `- \\`.;`\\ _ /`;.`/ - ` : | | //// \\ \\ `-. \\_ __\\ /__ _/ .-` / / //// ========`-.____`-.___\\_____/___.-`____.-&#x27;======== //// `=---=&#x27; //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG ////////////////////////////////////////////////////////////////////// 2. 配置文件2.1 简介SpringBoot的默认全局配置文件有两个： application.properties application.yml 注：文件名固定，存放在classpath:/ 或 classpath:/config/目录下 2.2 YAML文件YAML是专门用来写配置文件的语言，文件的后缀名为.yml，语法规则： 使用缩进表示层级关系，相同层级的元素左侧要对齐 键和值之间以冒号+空格隔开 key: value # 表示注释 1234server: port: 8081 servlet: context-path: /springboot02 2.3 多环境切换针对不同的环境，可以提供不同的配置，例如，不同环境下使用的数据库配置大多是不同的 常用的环境： 开发环境 dev 测试环境 test 生产环境 prod 可以通过命名约定来定义多个配置文件，格式：application-&#123;profile&#125;.yml 然后在application.yml文件中使用spring.profiles.active 来激活某一个环境配置 123spring: profiles: active: dev 3. 热部署​ 使用SpringBoot提供的devtools实现热部署 ​ 原理：实时监控classpath下文件的变化（即编译后的target目录），如果发生变化则自动重启 ​ 配置：添加devtools的依赖即可（需要开启IDEA的自动编译） 1234567&lt;!-- devtools热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 补充：开启IDEA的自动编译，IDEA默认是不自动编译的 Settings——&gt;搜索Compiler——&gt;勾选Build project automatically Help——&gt;Find Action——&gt;搜索Registry——&gt;勾选compiler.automake.allow.parallel 4. 定义配置类4.1 添加组件通过定义配置类 向容器中添加组件，使用注解：@Configuration和@Bean 123456789101112// 标注在类上，表示这是一个配置类，相当于以前编写的Spring配置文件@Configurationpublic class SpringConfig &#123; // 标注在方法上，向容器中添加一个组件，将方法的返回值添加到容器中，方法名作为组件id @Bean public Date date()&#123; Calendar c = Calendar.getInstance(); c.set(2008,5,10); return c.getTime(); &#125;&#125; 4.2 跨域访问定义一个配置类，实现WebMvcConfigurer接口，重写addCorsMappings方法 123456789101112@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOriginPatterns(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;*&quot;) .maxAge(3600); &#125;&#125; 5. 数据校验5.1 简介数据校验就是数据的合法性检查，在服务器端也可以对数据进行校验，一般使用 JSR303 校验 JSR303是Java为Bean数据合法性校验提供的标准框架，是一种声明式校验 JSR303通过在Bean属性上标注类似于@NotNull、@Max等注解来指定校验规则，并通过标准的验证接口对Bean进行验证 注解 功能 @Null 必须为null @NotNull 不能为null @NotBlank 字符串不能为null，且长度大于 0，会去掉前后空格 @Max(value) 数字必须小于等于指定值 @Min(value) 数字必须大于等于指定值 @Size(min,max) 长度必须在指定的范围内（可以是字符串、数组、集合等） @Past 时间必须是过去的时间 @Future 时间必须是将来的时间 @Pattern 必须符合指定的正则表达式 JSR303的扩展： Hibernate Validator扩展注解 Hibernate Validator是JSR303的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解 注解 功能 @Length(min,max) 字符串长度必须在指定范围之间 @NotEmpty 字符串不能为空 @Email 必须是合法的邮箱 @Range(min,max,message) 数值必须在指定的范围内 5.2 基本用法步骤： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在Bean上添加校验注解 12345678910111213141516171819202122@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable &#123; private Integer id; @NotBlank(message = &quot;用户名不能为空&quot;) private String username; @NotBlank(message = &quot;密码不能为空&quot;) @Length(min = 6,max = 12,message = &quot;密码长度必须在6~12之间&quot;) private String password; @Range(min = 18,max = 30,message = &quot;年龄只能在18~30之间&quot;) private int age; @NotNull(message = &quot;生日不能为空&quot;) @Past(message = &quot;生日必须是过去的时间&quot;) @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birthday;&#125; 在方法形参前添加@Valid注解 12345678910@RestControllerpublic class AjaxController &#123; @RequestMapping(&quot;/addUser&quot;) public String addUser(@Valid User user)&#123; // @Valid 开启对User对象的数据校验 System.out.println(user); return &quot;success&quot;; &#125;&#125; 6. 定时任务6.1 简介在项目开发中，经常需要编写定时任务来执行一些周期性的任务。 比如定时备份数据库、定时发送邮件、定时清理数据、定时提醒或通知等。 例如生活中网上购物时如果用户收到了商品，但一直没有确认收货，过了一个星期这个订单就需要自动转变为已收货状态，这种实时性不高的情景就可以用定时任务实现。 定时任务的实现： Quartz框架：是一个开源的任务调度框架 Spring Boot内置定时任务 Cron表达式是一个字符串，由6个字段组成，每个字段使用空格隔开 ，用于指定定时任务的执行时间。也称为七子表达式 字段 取值范围 说明 秒 0-59 分 0-59 时 0-23 日 1-31 月 1-12 星期 0-7 0和7都表示星期日 年 1970~2099 此项非必需，可以省略 使用以下特殊字符来指定执行时间： 星号（*）：表示匹配该字段的所有可能值 问号（?）：表示不关心该字段具体的值 斜线（&#x2F;）：表示指定一个间隔 逗号（,）：表示列举多个值 连字符（-）：表示指定一个范围 6.2 基本用法我们可以使用Spring Boot提供的定时任务，非常简单。 步骤： 定制任务，使用@Scheduled 1234567891011121314@Componentpublic class MyScheduledTasks &#123; @Scheduled(fixedRate = 3000) // 每隔3秒执行一次 public void task1() &#123; System.out.println(&quot;定时任务1执行了！&quot;); &#125; @Scheduled(cron = &quot;0 0 3 * * ?&quot;) // 每天凌晨3点执行 public void task2() &#123; System.out.println(&quot;定时任务2执行了！&quot;); &#125;&#125; 启用定时任务，使用@EnableScheduling 123456789@SpringBootApplication@EnableScheduling // 开启定时任务public class Springboot02QuickApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot02QuickApplication.class, args); &#125;&#125; 7. 日志SLF4j是一个日志标准，提供了日志接口，并不是日志系统的具体实现，其具体实现有：log4j、log4j2、slf4j-simple、logback等。 SpringBoot默认使用的日志是logback 常见的日志级别： debug、info、warn、error 使用步骤： 创建logback.xml日志配置文件，默认会自动加载该文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;!--日志存放目录--&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;./logs&quot; /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式：%d表示日期，%thread表示线程名，%-5level表示级别从左显示5个字符宽度，%logger&#123;50&#125;表示logger名字最长50个字符，%msg表示日志消息，%n表示换行符 --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 DEBUG --&gt; &lt;appender name=&quot;DEBUG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;!--日志文件名--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/debug/manage-remote-debug.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;16&lt;/MaxHistory&gt; &lt;!--日志文件切割大小--&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--过滤日志级别--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 INFO --&gt; &lt;appender name=&quot;INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/info/manage-remote-info.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;16&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 WARN --&gt; &lt;appender name=&quot;WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/warn/manage-remote-warn.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;24&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 每天生成日志文件 ERROR --&gt; &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/error/manage-remote-error.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;32&lt;/MaxHistory&gt; &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;OnMatch&gt;ACCEPT&lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 设置logger --&gt; &lt;logger name=&quot;net.wanho&quot; level=&quot;debug&quot;/&gt; &lt;!-- 设置root --&gt; &lt;root level=&quot;warn&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;INFO&quot; /&gt; &lt;appender-ref ref=&quot;WARN&quot; /&gt; &lt;appender-ref ref=&quot;ERROR&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; 记录日志 123456789101112131415161718192021@Slf4j // lombok注解，自动创建log对象public class LogTest &#123; // private static final Logger log = LoggerFactory.getLogger(LogTest.class); @Test public void test() &#123; log.debug(&quot;debug消息&quot;); log.info(&quot;info消息&quot;); log.warn(&quot;warn消息&quot;); log.error(&quot;error消息&quot;); try &#123; System.out.println(5/0); &#125; catch (Exception e) &#123; log.error(e.getMessage()); throw new RuntimeException(e); &#125; &#125;&#125; 注：可以在IDEA中安装Grep Console插件，便于在控制台以不同颜色区别日志级别 四、整合MyBatis123456789drop database if exists springboot;create database springboot charset utf8;use springboot;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(100) not null unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 1. MyBatis步骤： 创建一个工程，选择以下模块：Web、MyBatis、Lombok 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt;&lt;/dependency&gt; 注：SpringBoot默认使用的连接池是HikariCP，是一款轻量、高性能的连接池。 配置application.yml 12345678910111213# 配置MyBatismybatis: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml configuration: # 打印sql log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 下划线映射为驼峰 map-underscore-to-camel-case: true# 配置PageHelperpagehelper: helper-dialect: mysql 使用@MapperScan指定Dao接口所在的包 12345678@SpringBootApplication//指定Dao接口所在的包，动态创建Dao实现类@MapperScan(&quot;net.wanho.mapper&quot;)public class Springboot04MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04MybatisApplication.class, args); &#125;&#125; 配置Dao、Service、Controller等 可以在Dao接口上添加@Repository 或 @Mapper，以解决在Service层注入时提示找不到bean的问题 2. MyBatis-Plus参考：http://mp.baomidou.com 2.1 基本用法步骤： 创建一个springboot工程，选择以下模块：Web、Lombok 添加依赖 1234567891011121314151617&lt;!--mbyatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 配置application.yml 1234567891011121314151617181920212223242526# 配置DataSourcespring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8 username: root password: root initialSize: 5 maxActive: 50 minIdle: 3 maxWait: 5000# 配置MyBatis-Plusmybatis-plus: type-aliases-package: net.wanho.entity mapper-locations: classpath:mapper/*.xml configuration: # 打印sql log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 下划线映射为驼峰 map-underscore-to-camel-case: true global-config: db-config: # id-type: auto # 使用数据库的自动增长，不可作为分布式ID使用 id-type: assign_id # 使用雪花算法自动生成long类型的数字，分布式的情况下可使用 配置MybatisPlusConfig 1234567891011121314@Configuration@MapperScan(&quot;net.wanho.mapper&quot;)public class MyBatisPlusConfig &#123; /** * 配置MP的分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 定义Mapper，继承BaseMapper 12345/** * 继承BaseMapper接口，通用Mapper */public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 注：当数据库表名和字段名 与 类名和属性名不一致时，需要使用@TableName、@TableId、@TableField注解对实体类进行标注 定义Service，使用通用Service 12345678910111213/** * 继承IService接口，通用Service */public interface UserService extends IService&lt;User&gt; &#123;&#125;/** * 继承ServiceImpl类，通用Service实现类 */@Service@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125; 使用Mybatis-plus提供的接口 2.2 逻辑删除物理删除和逻辑删除： 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 步骤： 在表中添加逻辑删除标识列 1is_deleted tinyint default 0 comment &#x27;是否删除（0表示正常，1表示删除）&#x27; 在实体类中添加逻辑删除属性 123@TableLogic@TableField(value = &quot;is_deleted&quot;)private Integer isDeleted; ​ 也可以进行全局配置 123456mybatis-plus: global-config: db-config: logic-delete-field: isDeleted # 全局逻辑删除字段 logic-delete-value: 1 # 标识删除的值(默认为1) logic-not-delete-value: 0 # 逻辑未删除值(默认为0) 测试 测试删除：实际上执行的是更新操作 12-- 实际执行的SQLupdate t_user set is_deleted=1 where id = 1 and is_deleted=0 ​ 测试查询：不会查询被逻辑删除的数据 12-- 实际执行的SQLselect id,username,password,is_deleted t_from user where is_deleted=0 2.3 自动填充在对数据库表进行操作时经常会遇到一些字段，每次都使用相同的方式填充值，比如创建时间、更新时间等。 在阿里巴巴的开发手册中建议每个数据库表都必须要有create_time 和 update_time字段，以便记录每次操作的时间。 此时我们可以使用MyBatis Plus的自动填充功能，完成这些字段的自动填充赋值。 步骤： 在表中添加列 12create_time datetime comment &#x27;创建时间&#x27;,update_time datetime comment &#x27;更新时间&#x27; 在实体类中添加属性 12345@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 创建元对象处理器，实现MetaObjectHandler接口，用于对字段进行填充 1234567891011121314151617@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill ....&quot;); this.strictInsertFill(metaObject, &quot;createTime&quot;, () -&gt; new Date(), Date.class); this.strictInsertFill(metaObject, &quot;updateTime&quot;, () -&gt; new Date(), Date.class); &#125; @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;start update fill ....&quot;); this.strictUpdateFill(metaObject, &quot;updateTime&quot;, () -&gt; new Date(), Date.class); &#125;&#125; 测试 ​ 测试新增：会自动对create_time和update_time进行填充赋值 ​ 测试修改：会自动对update_time进行填充赋值 五、Restful API1.简介Representational State Transfer，简称为REST， 即表现层状态转化 Restful是一种网络应用程序的设计方式与开发方式，基于HTTP 表现层 Representational 资源的表现层，指的是资源的具体呈现形式，如HTML、JSON等 状态转化 State Transfer 指的是状态变化，通过HTTP方法来实现 通过不同的请求方式实现不同的功能，实现表现层状态转化 GET 获取资源，即查询操作 POST 新建资源，即添加操作 PUT 更新资源，即修改操作 DELETE 删除资源，即删除操作 2.设计原则Restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计 Restful API设计原则： 尽量将API 部署在一个专用的域名下，如 http://wanho.net/api 或 http://api.wanho.net API的版本应该在URL中体现，如 http://wanho.net/api/v2 URL中不要使用动词，应使用资源名词，且使用名词的复数形式，如： 功能说明 请求类型 URL 获取用户列表 GET http://wanho.net/api/v2/users 根据id获取用户 GET http://wanho.net/api/v2/users/id 添加用户 POST http://wanho.net/api/v2/users 根据id删除用户 DELETE http://wanho.net/api/v2/users/id 修改用户 PUT http://wanho.net/api/v2/users 注：简单来说，可以使用同一个 URL ，通过约定不同的 HTTP 方法来进行不同的业务操作 服务器响应时返回JSON对象，包含业务逻辑状态码、响应的消息、响应的查询结果 3. 基本用法​ @GetMapping ​ @PostMapping ​ @PutMapping ​ @DeleteMapping 4. 接口测试Postman​ Postman是一款非常优秀的调试工具，可以用来模拟发送各类HTTP请求，进行接口测试。 六、API接口文档1. 简介通常情况下，我们会创建一份API文档来记录所有的接口细节，供其他开发人员使用提供的接口服务，但会存在以下的问题： 接口众多，并且细节复杂 需要根据接口的变化，不断修改API文档，非常麻烦，费时费力 Swagger的出现就是为了解决上述的这些问题，减少创建API文档的工作量 后端人员在代码里添加接口的说明内容，就能够生成可预览的API文档，无须再维护Word文档 让维护文档和修改代码整合为一体，在修改代码逻辑的同时方便的修改文档说明 提供了页面测试功能，便于对接口进行测试 Knife4j是对Swagger的封装，对接口文档UI进行了优化，并做了增强，用起来更方便 2. 使用步骤使用步骤： 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt; 创建配置类 1234567891011121314151617181920212223242526272829303132@Configuration@EnableKnife4j // 启用Knife4jpublic class Knife4jConfig &#123; /** * 创建Restful API文档内容 */ @Bean public Docket Api() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .groupName(&quot;商城模块&quot;) .select() // 指定要暴露的接口所在包 .apis(RequestHandlerSelectors.basePackage(&quot;net.wanho.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; /** * API的基本信息 */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;商城项目后端API接口文档&quot;) .description(&quot;欢迎访问后端API接口文档&quot;) .contact(new Contact(&quot;tangxiaoyang&quot;,&quot;https://github.com/tangyang8942&quot;,&quot;tangxiaoyang@qq.com&quot;)) .version(&quot;1.0&quot;) .build(); &#125;&#125; 配置application.yml 1234spring: mvc: pathmatch: matching-strategy: ant_path_matcher # 用于解决SpringBoot2.6+版本与Swagger的兼容性问题 添加文档内容 使用Swagger提供的注解对接口进行说明，常用注解： @Api 标注在类上，对类进行说明 @ApiOperation 标注在方法上，对方法进行说明 @ApiParam 标注在参数上，对方法的参数进行说明 @ApiModel 标注在模型Model上，对模型进行说明 @ApiModelProperty 标注在属性上，对模型的属性进行说明 @ApiIgnore 标注在类或方法上，表示忽略这个类或方法 查看接口文档页面，并测试接口 启动SpringBoot程序，访问http://localhost:端口/doc.html，查看接口文档 可以在接口文档中对接口进行测试 七、代码生成器Generator1. 简介MyBatis-Plus代码生成器，快速生成 Entity、Mapper、Service、Controller 层代码，支持模板引擎自定义配置 12345678910111213141516171819202122232425drop database if exists springboot;create database springboot charset utf8;use springboot;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(100) not null unique comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, is_deleted tinyint default 0 comment &#x27;是否删除（0表示正常，1表示删除）&#x27;, create_time datetime comment &#x27;创建时间&#x27;, update_time datetime comment &#x27;更新时间&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;;create table t_dept( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;部门名称&#x27;)engine innodb default charset utf8 comment &#x27;部门表&#x27;;create table t_emp( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;姓名&#x27;, salary double comment &#x27;工资&#x27;, dept_id int comment &#x27;部门编号&#x27;, foreign key (dept_id) references t_dept(id))engine innodb default charset utf8 comment &#x27;员工表&#x27;; 2. 基本用法步骤： 创建一个SpringBoot工程，选择以下模块：Web、Lombok 添加依赖 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--mbyatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-plus-generator--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--beetl模板引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;com.ibeetl&lt;/groupId&gt; &lt;artifactId&gt;beetl&lt;/artifactId&gt; &lt;version&gt;3.15.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--guava--&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;32.0.0-jre&lt;/version&gt;&lt;/dependency&gt; 快速生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class CodeGenerator &#123; private static String projectPath = &quot;/Users/txy/code/IdeaProjects/framework/springboot05-generator&quot;; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator generator = new AutoGenerator(); // 1、全局配置 GlobalConfig gc = new GlobalConfig(); gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); gc.setAuthor(&quot;汤小洋&quot;); gc.setOpen(false); gc.setFileOverride(true); // 重新生成时文件是否覆盖 gc.setServiceName(&quot;%sService&quot;); // Service接口的命名方式 gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); gc.setBaseResultMap(true); gc.setBaseColumnList(true); generator.setGlobalConfig(gc); // 2、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;); dsc.setDriverName(&quot;com.mysql.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); generator.setDataSource(dsc); // 3、包配置 PackageConfig pc = new PackageConfig(); pc.setParent(&quot;net.wanho&quot;); pc.setEntity(&quot;po&quot;); // entity 层 pc.setMapper(&quot;mapper&quot;); // mapper 层 pc.setService(&quot;service&quot;); // service层 pc.setController(&quot;controller&quot;); // controller 层 generator.setPackageInfo(pc); // 4、自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setTablePrefix(&quot;t_&quot;); // 过滤表前辍 strategy.setNaming(NamingStrategy.underline_to_camel); //数据库表映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); //数据库列映射到实体属性的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 // 逻辑删除 strategy.setLogicDeleteFieldName(&quot;is_deleted&quot;); // 自动填充 List&lt;TableFill&gt; tableFillList = new ArrayList&lt;&gt;(); tableFillList.add(new TableFill(&quot;create_time&quot;, FieldFill.INSERT)); tableFillList.add(new TableFill(&quot;update_time&quot;, FieldFill.INSERT_UPDATE)); strategy.setTableFillList(tableFillList); generator.setStrategy(strategy); // 6、设置解析模板 generator.setTemplateEngine(new BeetlTemplateEngine() &#123; // 获取主键 String primaryKey = &quot;&quot;; String primaryKeyUnderline=&quot;&quot;; @Override public AbstractTemplateEngine init(ConfigBuilder configBuilder) &#123; AbstractTemplateEngine engine = super.init(configBuilder); // 映射文件放到resources目录下 configBuilder.getPathInfo().put(&quot;xml_path&quot;, projectPath + &quot;/src/main/resources/mapper/&quot; + pc.getModuleName()); return engine; &#125; @Override public Map&lt;String, Object&gt; getObjectMap(TableInfo tableInfo) &#123; for (TableField tableField : tableInfo.getFields()) &#123; if (tableField.isKeyFlag()) &#123; primaryKey = tableField.getPropertyName(); primaryKeyUnderline = tableField.getName(); break; &#125; &#125; // 获取源码中的map Map objectMap = super.getObjectMap(tableInfo); // 额外添加两个键值对 objectMap.put(&quot;entityCamel&quot;, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, tableInfo.getEntityName())); objectMap.put(&quot;primaryKey&quot;, primaryKey); objectMap.put(&quot;primaryKeyUnderline&quot;, primaryKeyUnderline); return objectMap; &#125; &#125;); // 7、执行生成 generator.execute(); &#125;&#125; 自定义模板 可以根据需求自定义模板 entity.java.btl mapper.java.btl mapper.xml.btl service.java.btl serviceImpl.java.btl controller.java.btl 测试 3. 多表查询MyBatis-Plus默认只能完成单表的操作，多表操作仍然需要自己写。 步骤： 在Emp实体类中添加属性 123@ApiModelProperty(value = &quot;部门&quot;)@TableField(exist = false) // 表示该属性不是数据库表中的字段private Dept dept; 编辑EmpMapper.java和EmpMapper.xml 123456public interface EmpMapper extends BaseMapper&lt;Emp&gt; &#123; List&lt;Emp&gt; selectAll(); IPage&lt;Emp&gt; selectByPage(IPage&lt;Emp&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;Emp&gt; queryWrapper);&#125; 1234567891011121314151617&lt;resultMap id=&quot;EmpMap&quot; type=&quot;Emp&quot; extends=&quot;BaseResultMap&quot;&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;dept_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;dept_name&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap&quot;&gt; select e.*, d.name as dept_name from t_emp e left join t_dept d on e.dept_id = d.id&lt;/select&gt;&lt;select id=&quot;selectByPage&quot; resultMap=&quot;EmpMap&quot;&gt; select e.*, d.name as dept_name from t_emp e left join t_dept d on e.dept_id = d.id $&#123;ew.customSqlSegment&#125;&lt;/select&gt; 编辑EmpService和EmpServiceImpl 123456public interface EmpService extends IService&lt;Emp&gt; &#123; List&lt;Emp&gt; findAll(); IPage&lt;Emp&gt; findByPage(IPage&lt;Emp&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;Emp&gt; queryWrapper);&#125; 12345678910111213@Servicepublic class EmpServiceImpl extends ServiceImpl&lt;EmpMapper, Emp&gt; implements EmpService &#123; @Override public List&lt;Emp&gt; findAll() &#123; return this.baseMapper.selectAll(); &#125; @Override public IPage&lt;Emp&gt; findByPage(IPage&lt;Emp&gt; page, Wrapper&lt;Emp&gt; queryWrapper) &#123; return this.baseMapper.selectByPage(page,queryWrapper); &#125;&#125; 测试 123456789101112131415161718192021@SpringBootTestclass EmpServiceImplTest &#123; @Resource private EmpService empService; @Test public void findAll() &#123; System.out.println(empService.findAll()); &#125; @Test public void findByPage() &#123; Page&lt;Emp&gt; page = new Page&lt;&gt;(1, 3); QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.likeRight(&quot;e.name&quot;, &quot;1&quot;); empService.findByPage(page, wrapper); System.out.println(page.getRecords()); &#125;&#125; 八、MyBatis-Plus-Join1. 简介官网 https://mybatisplusjoin.com/ 2. 基本用法步骤： 添加依赖 123456&lt;!--mybatis-plus-join--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-join-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.5&lt;/version&gt;&lt;/dependency&gt; 编辑EmpMapper.java，继承自MPJBaseMapper 12public interface EmpMapper extends MPJBaseMapper&lt;Emp&gt; &#123;&#125; 测试 12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass EmpMapperTest &#123; @Resource private EmpMapper empMapper; @Test public void selectAll()&#123; MPJLambdaWrapper&lt;Emp&gt; wrapper = new MPJLambdaWrapper&lt;Emp&gt;() .selectAll(Emp.class) // 查询Emp类的所有字段 .selectAs(Dept::getName, EmpDTO::getDeptName)// 查询Dept类的name字段 .leftJoin(Dept.class, Dept::getId, Emp::getDeptId) // 左连接 .orderByDesc(Emp::getId); List&lt;EmpDTO&gt; list = empMapper.selectJoinList(EmpDTO.class, wrapper); list.forEach(System.out::println); &#125; @Test public void selectByPage()&#123; Page&lt;EmpDTO&gt; page = new Page&lt;&gt;(1, 3); empMapper.selectJoinPage(page, EmpDTO.class, new MPJLambdaWrapper&lt;Emp&gt;() .selectAll(Emp.class) .selectAs(Dept::getName, EmpDTO::getDeptName) .leftJoin(Dept.class, Dept::getId, Emp::getDeptId) .eq(Dept::getId, 1)); page.getRecords().forEach(System.out::println); &#125;&#125; 九、综合案例基于SpringBoot的日记管理系统（diary） 后端 SpringBoot 前端 LayUI","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Vue基础学习(三)","slug":"Vue基础学习-三","date":"2023-08-15T04:58:17.000Z","updated":"2023-08-15T05:00:12.000Z","comments":true,"path":"2023/08/15/Vue基础学习-三/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%B8%89/","excerpt":"","text":"一、组件化与模块化1. 组件化​ 组件化，是从UI界面的角度进行划分的，将页面构成拆分为一个个组件，方便UI组件的重用 ​ 组件包含：页面构成（template）、样式（css）、功能（js） 2. 模块化​ 模块化，是从代码逻辑的角度进行划分的，将项目按照一定的规则拆分成一个个模块，进行组合使用 ​ 方便代码的分层开发，保证每个功能模块的职能单一 二、构建模块化环境1. 开发环境模块化开发一般需要独立的开发环境，一般都基于 Node.js 和 webpack 进行环境搭建 Node.js 独立JS运行环境和模块系统支持 webpack 自动化的前端构建工作流工具，类似于gulp，但功能更强大 Vue模块化项目环境搭建，可以通过官方提供的环境构建工具 Vue CLI ，称为Vue脚手架 2. Vue脚手架2.1 简介 @vue/cli是一个Vue脚手架，用来快速构建模块化项目结构 cli：command line interface 命令行接口 通过命令行的方式快速构建Vue模块化项目运行环境 2.2 安装脚手架系统环境： node环境：node -v npm环境：npm -v nrm环境： nrm ls 安装@vue&#x2F;cli： 全局安装：npm install @vue/cli -g （需要具有管理员权限） 验证安装：vue --version 查看帮助：vue --help 常用命令： 创建项目：vue create 项目名 或 vue ui 为项目增加扩展插件：vue add 插件 3. 使用脚手架创建项目切换到项目的存放目录，执行 vue create 项目名称，进入交互模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 1.选择构建模式Vue CLI v4.1.2? Please pick a preset: (Use arrow keys) default (babel, eslint) # 默认选项，只包含基础依赖 ——&gt; 直接执行第6步❯ Manually select features # 自定义环境，手动选择特性依赖 # 2.自定义环境的选择Vue CLI v4.1.2? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) # 选择需要的环境特性 ❯◉ Babel # ES6语法兼容转换器（Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，避免运行环境不支持） ◯ TypeScript # TS语法支持 ◯ Progressive Web App (PWA) Support # 构建渐进式Web应用，优化用的 ◯ Router # 集成路由功能 ◯ Vuex # 集成统一数据状态管理器 ◉ CSS Pre-processors # CSS预编译，支持使用LESS、SASS等动态样式语言 ◉ Linter / Formatter # 代码规范检查和格式化检测 ◯ Unit Testing # 单元测试 ◯ E2E Testing # 端到端测试 # 3.所选环境的进一步配置# 如果选择了CSS Pre-processors，则需要选择 动态样式语言? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys) Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) ❯ Less Stylus # 如果选择Linter / Formatter，则需要选择 代码规范检查的规则? Pick a linter / formatter config: (Use arrow keys)❯ ESLint with error prevention only # 使用ESLint，仅检测错误（ESLint是用来统一代码规范和风格的工具） ESLint + Airbnb config # 使用 eslint+airbnb 前端规范 ESLint + Standard config # 使用标准规范 ESLint + Prettier # 使用严格规范# 选择代码规范检查的时机? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◉ Lint on save # 文件保存时 ◯ Lint and fix on commit # 代码整理和提交时 # 4.选择工具配置文件的存放位置? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)❯ In dedicated config files # 存放在独立的配置文件中 In package.json # 集成在package.json文件中 # 5.是否将上述配置保存为一个预设选项，方便以后创建项目使用? Save this as a preset for future projects? Yes? Save preset as: mypreset# 6.创建项目，安装所需依赖Vue CLI v4.1.2✨ Creating project in /Users/appleuser/Desktop/aa-aa.🗃 Initializing git repository...⚙ Installing CLI plugins. This might take a while..........🎉 Successfully created project first-project.👉 Get started with the following commands: 4. 启动项目切换到项目的根目录，执行 npm run serve 启动开发服务器，然后根据提示url访问 npm run 命令名称 是npm内置的脚本执行命令，该命令会自动搜索执行目录下package.json文件中的scripts对应的命令并执行 三、项目结构1. 文件结构​ 通过多个关联文件构成模块化开发环境，最终由webpack工具进行打包合并 12345678910111213141516|-项目名称 |-node_modules # 项目运行所依赖的模块，内容较多，文件较大，拷贝项目时一般不拷贝此目录，可通过npm install自动下载安装 |-public # 项目的静态资源目录，如html、css、js、image等，服务器访问的根目录，对外公开的资源 |-index.html # 默认访问的页面文件 |-src # 源代码目录 |-assets # 静态资源目录 |-components # 自定义组件目录 |-App.vue # 项目的主组件 |-main.js # 项目的启动文件 |-.browserslistrc # 项目的浏览器适配版本 |-.eslintrc.js # eslint配置文件，定义语法校验规则 |-.gitignore # git配置文件，定义忽略文件列表 |-babel.config.js # babel配置文件，定义ES语法转换规则 |-package-lock.json # 对项目的安装模块信息进行本地记录 |-package.json # node项目的描述文件，定义项目的相关描述信息 |-README.md # 项目的说明文件，对项目进行说明介绍 2. 核心文件详解​ Vue模块化项目启动时会自动查找两个核心文件： index.html 和 main.js 2.1 index.html​ index.html是访问应用时默认显示的页面文件，也是Vue项目的容器定义文件 2.2 main.js​ main.js是项目的启动文件，也是Vue模块化项目的整合入口文件 123456/** * 使用ES6提供的模块导入导出功能 */import 模块名 from 文件路径 // 导入模块，模块名可自定义export default &#123;&#125; // 导出模块，默认导出 2.3 App.vue​ App.vue是Vue中提供的一种特殊的组件定义文件，这类文件用于描述模块化项目中的组件 ​ App.vue是项目的主组件，其他组件都是在该组件下加载的 3. 单文件组件​ 以.vue结尾的文件，是Vue.js自定义的一种文件格式，称为单文件组件 ​ 一个.vue文件就是一个单独的组件，在文件内封装了该组件相关的html、css和js，实现了对一个组件的封装 ​ .vue文件由三部分组成： 1234567891011&lt;template&gt; &lt;!-- html，组件的页面结构 --&gt;&lt;/template&gt;&lt;script&gt; // js，组件的功能配置&lt;/script&gt;&lt;style&gt; /* css，组件的样式 */&lt;/style&gt; 四、模块化开发1. 组件样式全局样式和局部样式： 在style标签中定义的样式，默认为全局样式，在所有组件中都有效 可以为style标签指定scoped属性，此时定义的样式为局部样式，只在当前组件中有效 用法：&lt;style scoped&gt; 动态样式支持： 可以为style标签指定lang属性，设置当前使用的样式语言，如：css、less、sass、stylus等 默认使用的是css语法，可以使用动态样式语言 用法：&lt;style lang=&quot;动态样式语言&quot;&gt; 2. 脚本架配置文件vue.config.js 是Vue脚手架@vue&#x2F;cli的全局配置文件，是一个可选的配置文件，如果不存在则使用默认配置，如果项目的根目录中存在这个文件，则项目运行时会自动加载 编辑vue.config.js文件 12345678module.exports = &#123; // 项目的基础url publicPath:&#x27;/film/&#x27;, // 开发服务器的配置 devServer: &#123; port: 8888 &#125;｝ 注：修改vue.config.js文件后，需要重启项目才生效 3. 项目打包当项目要部署上线时，需要先对开发环境的项目进行打包构建操作，生成一个由纯静态文件构成的项目 切换到项目的根目录，执行 npm run build 对项目进行打包构建操作 默认会在项目的根目录下生成一个dist目录，该目录中存放打包后的项目静态文件，可直接部署到生产环境中 打包后可将dist目录中的静态文件拷贝到任意Web服务器中部署运行 生产环境和开发环境： 由于生产环境和开发环境可能会有所不同，有时会导致资源无法访问，此时需要对环境进行配置 编辑vue.config.js文件 123456789101112module.exports = &#123; // 项目的基础url，所有静态资源在加载时的基础路径BASE_URL // publicPath:&#x27;/film/&#x27;, // 判断环境，分别指定生成环境production和开发环境development的地址 publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/film/&#x27; : &#x27;/&#x27;, // 开发服务器的配置 devServer: &#123; port: &#x27;8888&#x27; // 使用的端口 &#125;, // 打包时是否生成map文件，主要用于生成环境下调试js源代码，建议改为false productionSourceMap: false,&#125; 五、全局功能定义1. 简介用于统一定义全局的功能，如：全局组件、全局插件、全局过滤器、全局指令等 使用Vue提供的全局方法Vue.use()，一般在 main.js 文件中使用 Vue.use(Object) 参数Object是一个必须提供install方法的对象，Vue.use会自动调用执行install方法 2. 用法​ 全局组件、全局插件 六、数据交互1. 简介Vue模块化项目的数据交互，使用的就是AJAX技术，发送异步请求 实现异步请求的模块有很多，官方推荐使用 axios 模块 axios是一个基于Promise的HTTP请求客户端，用来发送AJAX请求 2. 安装axios切换到项目的根目录，执行 npm install axios --save 安装模块 在需要使用axios的文件中，通过import axios from &#39;axios&#39;导入模块 导入模块后，可以使用axios对象提供的方法： axios.get(url[, config]) axios.delete(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) 补充：Restful请求，根据HTTP请求方式来区分对资源的操作 GET 获取资源 POST 新建资源 PUT 更新资源 DELETE 删除资源 3. 用法3.1 基本用法使用axios.get(url[,config]) ，传参方式： 通过url传参，即查询字符串方式 通过params选项传参 使用axios.post(url[,data,[config]])，传参方式： 通过查询字符串方式 使用qs模块进行转换import qs from &#39;qs&#39; 注：对于post方式请求，axios发送数据时默认的数据格式为Request Payload，并非我们常用的Form Data格式，所以参数不能直接以json形式传递 3.2 全局引入全局引入axios并添加到Vue原型中，避免在组件中重复引用axios，简化使用 在main.js中导入axios模块 为Vue函数添加一个原型属性$http，指向axios对象 在组件中无需再引入axios模块，直接使用this.$http即可 4. 跨域访问发送请求时，如果协议、主机或端口，只要有任何一个不同，则为跨域访问 两种解决方式： 后端允许跨越访问，设置响应头为Access-Control-Allow-Origin 在前端构建代理服务器，进行请求的转发。配置代理服务器的步骤： 编辑vue.config.js文件 ，添加代理服务器配置 1234567// 配置代理服务器，解决开发阶段的跨域问题（只在开发阶段有效）proxy: &#123; &#x27;/data&#x27;: &#123; // 所有以/data开头的请求都需要被代理转发 target: &#x27;http://127.0.0.1:80&#x27;, // 转发到的目标服务器 logLevel: &#x27;debug&#x27; // 开启调试模式 &#125; &#125; 重启开发服务器，查看日志输出 七、路由1. 简介SPA应用：Single Page Application 单页应用程序 就是只有一个Web页面的应用，所有的操作都在这个页面上完成（容器页面） 浏览器一开始会加载相应的HTML、CSS和JavaScript，然后将所有的活动都局限在该Web页面中 当用户与应用程序交互时通过JavaScript动态更新页面中的内容 在开发SPA单页应用时，需要在不同的组件间切换，从而实现在一个容器页面中显示不同的内容 我们可以使用Vue Router来开发单页应用，根据不同的url地址，路由跳转到不同的组件 路由是一种组件动态分发机制，通过url路径进行组件的切换 根据url路径查找对应的组件，然后将组件显示到指定的页面位置 2. 基本用法创建项目时选择Router路由功能 123456789|-项目名称 |-node_modules |-vue-router # 路由模块 |-src |-router |-index.js # 路由配置文件 |-views # 视图组件目录 |-App.vue |-main.js 核心文件详解：main.js、index.js、App.vue 提供了两个路由组件 &lt;router-link&gt;组件：用来定义导航，默认会创建&lt;a&gt;标签，根据指定的url路径跳转到组件 &lt;router-view&gt;组件：用来渲染url路径对应的组件，将组件显示到当前定义的位置 3. 路由嵌套当应用由多层嵌套的组件构成时，需要使用嵌套路由 关于url路径的定义： 根路径 根路径就是/，默认访问项目时显示的就是根路径对应的组件，即默认显示的组件 嵌套路由的路径 子级路由可以使用相对路径或绝对路径 通配路径 可以使用通配符 *来设置当url路径不存在时显示的组件 4. 路由传参通过&lt;router-link&gt;的to属性传递参数 两种方式： 查询字符串传参 传递参数： 字符串形式 语法：to=&quot;路径?参数名=参数值&amp;参数名=参数值&quot; 对象形式 语法：:to=&quot;&#123;path:&#39;组件的url路径&#39;，query:&#123;key:value,key:value&#125;&#125;&quot; 或 ​ :to=&quot;&#123;name:&#39;组件的路由名称&#39;，query:&#123;key:value,key:value&#125;&#125;&quot; 获取参数： 使用路由对象vm.$route.query获取参数信息 Rest风格传参 传递参数： 字符串形式 语法：to=&quot;/路径/参数/参数&quot; 将参数伪装成请求地址的一部分 在定义路由时需要在url路径中通过:参数名指定参数 对象形式 语法：:to=&quot;&#123;name:&#39;组件的路由名称&#39;，params:&#123;key:value,key:value&#125;&#125;&quot; 对于Rest风格的对象形式传参，只能使用路由名称的形式 获取参数： 使用路由对象vm.$route.params获取参数信息 5. 路由对象路由对象$route，表示当前激活的路由的状态信息，称为激活路由信息对象 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$route访问，且访问的都是同一个对象 该对象中存储着当前激活路由的相关信息 123456$route.path // 当前激活路由的路径$route.fullPath // 当前激活路由的完整路径$route.name // 当前激活路由的名称，即命名路由的name$route.query // 当前激活路由的字符串查询传递的参数$route.params // 当前激活路由的rest方式传递的参数$route.meta // 当前激活路由的元信息 路由元信息： 在定义路由时，可以通过meta属性为当前路由指定一些自定义配置项，称为元信息 在组件中可以通过$route.meta获取到这些元信息 6. 路由守卫也称为路由导航守卫，用来对路由导航进行守卫，控制导航的跳转，可以进行权限的控制 全局前置守卫：使用 router.beforeEach 12345678const router = new VueRouter(&#123; ... &#125;)// 当一个导航触发时，全局前置守卫将被调用 router.beforeEach((to, from, next) =&gt; &#123; // to 即将要访问的目标路由对象 // from 来源于哪个路由对象 // next 是一个函数，表示下一步怎么做，如：next()表示放行，next(&#x27;/login&#x27;)表示跳转到/login路径 &#125;) 全局解析守卫：使用router.beforeResolve 全局后置钩子：使用router.afterEach 7. 路由模式通过mode选项可以修改路由的模式 两种模式： hash模式（默认值） 原理：使用HTML的锚点技术，实现路由匹配和跳转 ​ 通过location.hash获取url中的锚点值，完成 url 跳转，且不会重新加载页面，即不刷新页面 缺点：地址中会出现#号，比较丑陋 history模式 原理：使用HTML5的History技术 ​ 通过history.pushState 完成 url 跳转，且不会重新加载页面 缺点：在生产环境下，如果用户在浏览器中直接访问url路径，则会报错 Not Found ​ 所以在生产环境下，需要后台服务器的配置支持才行（在开发环境下是没问题的） 8. 编程式导航除了使用&lt;router-link&gt;组件来定义导航链接，还可以通过编写js代码，调用路由实例$router的方法来实现路由跳转，称为编程式导航 路由实例$router，表示构建路由时的实例对象，主要用来对路由进行控制，称为 路由控制对象 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$router访问，且访问的都是同一个对象 该对象中包含控制路由的相关方法 1234$router.push(location) // 跳转到指定页面，参数location可以为字符串或对象$router.forward() // 向前一步$router.back() // 后退一步$router.go(n) // 向前或后退多少步 八、Vuex1. 简介Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 采用集中式存储管理应用中所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 简单来说，就是用来集中管理数据的，统一维护项目中的数据状态，相当于是一个全局的数据存储对象store，在所有组件中都可以访问 应用场景：适合于大型的单页应用程序 2. 基本用法创建项目时选择Vuex功能 1234567|-项目名称 |-node_modules |-vuex # vuex模块 |-src |-store |-index.js # vuex配置文件 |-main.js Vuex的核心是store（存储），相当于是一个容器，核心概念： State 定义属性，用来存储状态数据 Getter 定义属性，用来获取从state派生出的状态数据，类似于计算属性 Mutation 定义变化，用来改变状态数据（突变），只能是同步操作，需要通过commit来提交变化mutations Action 定义方法，用来改变状态数据，可以包含异步操作，类似于mutations，但mutations只能是同步操作 Module 用来分模块组织Vuex 3. 使用Vuex3.1 在Vuex中定义状态配置store对象： 定义state 定义getters 定义mutations 定义actions 定义modules 3.2 在组件中访问状态在组件中访问store对象，两种方式： 方式1：通过存储对象$store访问 存储对象$store，表示Vuex中定义的数据存储对象store，包含Vuex中的所有数据信息 该对象为所有组件共享的实例属性，在所有组件中都可以通过this.$store访问，且访问的都是同一个对象 方式2：通过辅助函数访问 Vuex中提供了一些辅助函数，用于获取Vuex中的数据信息，如： mapState() 获取state mapGetters() 获取getters mapMutations() 获取mutations mapActions() 获取actions 注：需要先导入辅助函数import &#123;mapState,mapGetters,mapActions&#125; from &#39;vuex&#39; 4. 模块化当应用变得非常复杂时，store对象会变得相当臃肿，store&#x2F;index.js文件内容会非常多 此时可以将store分成多个模块，每个模块拥有自己的state、getters、mutations、actions 可以根据业务分模块，如：用户数据、产品数据、购物车数据、订单数据等 可以根据页面分模块，如：主页数据、搜索页数据、详情页数据等 Vuex模块化的项目结构： 12345678910111213|-src |-store |-index.js |-state.js // 根级别的state |-getters.js // 根级别的getters |-mutations.js // 根级别的mutations |-actions.js // 根级别的actions |-modules // 分为多个模块，每个模块都可以拥有自己的state、getters、actions、mutations |-user.js // 用户模块 |-product.js // 产品模块 |-cart.js // 购物车模块 |-order.js // 订单模块 |-.... 九、Element UI1. 简介​ Element是饿了么团队提供的一套基于Vue的桌面端组件库，可以快速的搭建网站，提高开发效率 ​ 官方文档 https://element.eleme.cn 2. 用法执行 vue add element为项目安装Element插件 123? How do you want to import Element? Fully import # 完整引入? Do you wish to overwrite Element&#x27;s SCSS variables? No ? Choose the locale you want to load zh-CN ​","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue基础学习(二)","slug":"Vue基础学习-二","date":"2023-08-15T04:44:48.000Z","updated":"2023-08-15T04:54:35.000Z","comments":true,"path":"2023/08/15/Vue基础学习-二/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/","excerpt":"","text":"一、组件1. 简介​ Component 组件是可复用的Vue实例，且带有一个名字，可以把组件作为自定义元素来使用 ​ 将项目中重复出现的页面结构定义为Vue的一个组件实例，或将特殊功能封装成组件 2. 构造器继承函数构造器继承函数，语法： Vue.extend(options) 以基础 Vue 构造器为蓝本，创建一个具有指定配置项的“子类”构造器，也称为组件构造器 可以使用该子类构造器来创建Vue实例（组件） data选项必须以函数形式声明，函数内返回一个包含初始数据的对象 二、定义组件组件分类： 全局组件，在所有Vue实例中都可以使用 局部组件，只能在构建组件的 Vue实例的容器范围内使用 1. 全局组件全局组件的定义，通过全局方法 Vue.component()来定义 两种写法 方式1：Vue.component(组件名, 组件构造器) 先创建组件构造器，然后由组件构造器创建组件 方式2：Vue.component(组件名, 选项对象) 直接创建组件，传入一个选项对象 本质上还是自动调用 Vue.extend 先创建组件构造器 注：组件必须在一个已存在的Vue实例中使用，不能在页面独立使用和存在 2. 局部组件​ 局部组件的定义，依赖于某个Vue实例，通过选项 components:&#123;&#125; 来定义 ​ 用法： 123456new Vue(&#123; components:&#123; &quot;component-a&quot;:Vue.extend(&#123; /* ... */ &#125;), &quot;component-b&quot;:&#123; /* ... */ &#125; &#125;&#125;) 三、组件间数据传递1. 组件间的关系​ 页面组件的关系结构，是一个由许多组件构成的树状结构，组件间存在着两种关系：父子关系、非父子关系 ​ 默认情况下，每个组件实例都是独立的，组件间无法直接访问数据，因此需要进行组件间的数据传递，也称为组件间的通信 2. 父子组件间的数据传递2.1 父向子传递数据技术：属性绑定+数据拦截 步骤： 父组件在调用子组件时，以属性绑定的方式将要传递的数据绑定在子组件标签上 在子组件对象中，使用props选项声明获取的数据，进行绑定属性的拦截，即接收来自父组件的数据 2.2 子向父传递数据技术：事件监听+事件触发 步骤： 父组件在调用子组件时，监听子组件触发的自定义事件，并在父组件中定义回调方法，用来接收数据 在子组件中使用vm.$emit(事件名,数据)触发自定义事件 补充： 子组件向父组件传递数据是不具有响应式的，即子组件数据发生变化时并不会主动触发$emit更新父组件中数据 可以监视子组件数据的变化，当数据发生变化时手动触发$emit更新父组件中数据 四、内置全局组件Vue提供了全局的内置组件，这些组件主要完成的都是功能封装 1. 动态组件多个组件使用同一个挂载点，然后动态地在它们之间切换，称为动态组件 用法：&lt;component :is=&quot;&quot;&gt;&lt;/component&gt; 2. 缓存组件缓存非活动的组件，可以保留组件状态，避免重新渲染，默认每次都会销毁非活动组件并重新创建 一般会结合动态组件使用，用于缓存非活动的组件实例，避免组件的重复创建和删除，提高性能 用法：&lt;keep-alive&gt;动态组件&lt;/keep-alive&gt; 注：&lt;keep-alive&gt;是一个抽象组件，它自身不会渲染为一个 DOM 元素，也不会出现在组件链中 3. 分发组件实现内容的分发，可以在定义组件时指定插槽位置，调用组件时提供要替换插槽位置的内容 在开发组件时，如果组件模板中部分内容暂时不确定，则可以通过&lt;slot&gt;插槽定义页面占位 当调用组件时，再定义对应的内容，会自动替换到插槽位置 用法：&lt;slot&gt;&lt;/slot&gt; 具名插槽：为插槽指定名称，根据插槽名称进行内容分发 在定义插槽时，在slot标签上通过name属性为插槽指定名称 在提供插槽内容时，通过为template标签指定v-slot指令，并以指令参数表示插槽名称 插槽数据作用域：让插槽内容能够访问子组件中的数据，通过作用域插槽控制内容分发时变量的取值范围 在定义插槽时，在slot标签上通过v-bind进行数据绑定 在提供插槽内容时，通过v-slot指令接收绑定的数据，获取的是一个自定义对象","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue基础学习","slug":"Vue基础学习","date":"2023-08-15T03:31:38.000Z","updated":"2023-08-15T03:49:00.000Z","comments":true,"path":"2023/08/15/Vue基础学习/","link":"","permalink":"http://example.com/2023/08/15/Vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、MVVM1. 简介Model-View-ViewModel 模型-视图-视图模型 模型：构成页面内容的相关数据 视图：展示数据的页面 视图模型：介于模型和视图之间，它是连接view和model的桥梁，也是mvvm设计模式的核心思想 2. MVVM框架实现MVVM设计思想的框架： 基本上都高度封装了view-model的交互过程，完成对DOM功能的极限封装 开发者几乎不用操作DOM就可以完成页面和数据的关联交换 开发者只需关心页面的构成和数据的构成，无需关心页面和数据的状态关系 Vue、React、Angular等就是实现MVVM设计思想的前端框架 二、Vue1. 简介 Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架（入门简单、学习成本低，随着深入学习可以根据需求进行功能扩展） Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合 通过简洁的API实现响应的数据绑定和灵活的视图组件 由个人维护：尤雨溪，华人 2. 基本使用Vue的页面使用方式： 即在页面中直接引入Vue核心库的js文件 该方式只是为了让开发者在学习Vue语法时可以快速掌握 实际上Vue并不适合直接使用 页面方式进行语法定义，更推荐使用模块化方式 使用步骤： 获取Vue核心库的js文件 通过地址 https://cdn.jsdelivr.net/npm/vue/dist/vue.js 下载 使用 npm 下载： npm install vue 在页面中引入Vue 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; 创建Vue实例并应用 3. 调试工具安装vue-devtools插件，便于在Chrome浏览器中调试vue 步骤： 将vue-devtools.zip解压缩 打开Chrome浏览器的更多工具——&gt;扩展程序 将解压后的chrome目录拖放到扩展程序中即可 在VSCode中安装Vue相关插件：Vue 3 Snippets、Vetur、Vue Peek、vue-helper 三、基本交互1. 插值表达式语法： &#123;&#123; &#125;&#125; 由两对大括号组成，称为“Mustache”语法 作用：用于在页面标签中插入值，进行数据的绑定显示，且当值发生变化时标签会重新渲染加载，称为响应式特性，即数据状态同步操作 用法：&lt;标签&gt;&#123;&#123; Vue对象数据仓库变量|JS表达式|JS内置对象 &#125;&#125;&lt;/标签&gt; 只能用在标签中间的内容位置 可以绑定三种数据： 数据仓库中的变量 简单的JS表达式 JS内置对象 2. 指令2.1 简介指令 (Directives）是用来扩展html标签的功能，以v-作为前缀 语法： &lt;标签 v-指令名[:参数][.修饰符][=&quot;指令值&quot;]&gt;&lt;/标签&gt; 指令名：指令的名称 指令值：指令的取值，可选 参数：限制当前指令的操作范围，可选 修饰符：限制当前指令的触发条件，可选 特性：无痕迹特性 代码开发时的vue语法，在项目运行时会被删除，不会显示 Vue对象和容器在完成语法解析后，不会在浏览器上保留vue语法定义 2.2 常用指令 指令 取值 作用 v-text string 更新元素的textContent v-html string 更新元素的innerHTML v-pre 无 跳过当前元素和子元素的编译过程，不对vue语法进行编译执行 v-once 无 对当前元素和子元素的vue功能只执行一次 v-cloak 无 在vue实例构建完成前，隐藏未编译的vue语法，需要配合css样式一起使用 v-on Function | Object | Array | 行内表达式 绑定事件监听器，用于事件绑定 v-show any 根据表达式的boolean结果，切换元素的 display CSS 属性，控制元素的显示隐藏 v-if、v-else-if、v-else any 根据表达式的boolean结果，执行元素的创建和删除操作，控制元素的显示隐藏 v-for Array | Object | number | string 基于数据多次渲染元素或模板块，用于循环数据 v-bind any 动态的为标签绑定属性，用于属性绑定 2.3 指令详解v-on事件绑定指令 语法：&lt;标签 v-on[:参数][.修饰符]=&quot;取值&quot;&gt;&lt;/标签&gt; 缩写：可以使用@替代v-on: 参数：指定事件的名称，即事件类型 取值：Function | Object | Array | 行内表达式 修饰符： 按键修饰符——&gt;只有当点击对应的按键时才触发 功能修饰符——&gt;实现特定的功能 修饰符 含义 .capture 添加事件监听器时使用事件捕获模式 .stop 阻止事件传播，调用 event.stopPropagation() .self 只当事件是元素本身触发时才执行回调，即不是事件传播引起的 .prevent 阻止事件的默认行为，调用 event.preventDefault() .once 事件只触发一次 v-bind属性绑定指令 语法：&lt;标签 v-bind[:参数]=&quot;取值&quot;&gt;&lt;/标签&gt; 缩写：省略v-bind 参数：指定要绑定的属性 取值：any 注意：特殊属性的绑定，如boolean类型属性、class、style 3. 响应式原理响应式的概念：实际上就是所谓的数据状态同步操作，当内存中变量数据发生变化时，页面会及时做出响应，进行页面重构渲染 响应式的基础：：Object.defineProperty(obj, prop, descriptor) 用于定义一个对象上的属性以及这个属性的描述符 obj : 操作的目标对象 prop：操作的属性名称 descriptor：属性的详细定义 get（function）：拦截属性的取值操作，为取值操作提供扩展功能 set（function）：拦截属性的赋值操作，为赋值操作提供扩展功能 响应式的原理： 数据劫持 使用Object.defineProperty()实现，称为JS的数据劫持 ​ 注：Vue 不支持 IE8 以及更低版本浏览器 4. 双向数据绑定v-model双向数据绑定指令 语法：&lt;标签 v-model[.修饰符]=&quot;取值&quot;&gt;&lt;/标签&gt; 取值：随表单控件类型不同而不同 限制：仅限于表单中可输入或者可选择的元素，如&lt;input&gt;、&lt;select&gt; 、&lt;textarea&gt; 修饰符： 修饰符 含义 .lazy 使用 change 事件替代input事件 .number 将输入的值转换为数字 .trim 去除首尾的空格 双向数据绑定： 模型数据变化时重新渲染页面（基于Object.defineProperty） 页面数据变化时自动更新模型数据（基于元素事件监听） 四、数据控制​ 对数据进行包装处理和监控 1. 计算属性​ 计算属性（computed）也是用来存储属性数据的，但具有以下特点： 可以对数据进行逻辑处理操作，实现数据包装 计算属性通常依赖于当前Vue对象中的普通属性 当依赖的普通属性发生变化时计算属性也会变化，实现数据监控 ​ 计算属性由两部分组成： get 用来获取计算属性 set 用来设置计算属性 ​ 默认计算属性只有get，如果需要set，可以自己添加，此时需要以对象的形式配置 2. 监视器监视器（watch）是用来监视数据的变化，对数据进行监控 12345678910new Vue(&#123; watch: &#123; 变量:function(newValue, oldValue)&#123;&#125;, // 监控方法 变量:&#123; handler: function(newValue, oldValue)&#123;&#125;, // 监控方法 deep: true, // 开启深度监视 immediate: true // 开启初始化触发 &#125; &#125;,&#125;) 五、实例属性和方法1. 简介​ 通过Vue实例对象可以直接访问的属性和方法，称为实例属性和实例方法 ​ 实例属性和方法都以 $ 开头 2. 实例属性 vm.$el：当前Vue实例使用的根 DOM 元素 vm.$data：当前Vue实例观察的数据对象 vm.$options：当前Vue实例的初始化选项 vm.$refs：当前Vue实例容器中定义了ref属性的所有 DOM 元素 3. 实例方法 vm.$mount：手动挂载Vue实例 vm.$destroy：销毁Vue实例，只会销毁vue的实例对象，不会销毁与其关联的页面容器 vm.$nextTick：在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM并操作 vm.$set：为对象|数组添加一个属性|元素，并实现响应式，触发更新视图，实时监视，等同于全局方法 Vue.set vm.$delete：删除对象|数组的属性|元素，触发更新视图，等同于全局方法 Vue.delete 六、模板和渲染函数1. 模板​ 模板（template）就是定义Vue时指定的页面结构构成 默认使用el选项指定的挂载元素的内容来构成页面模板，同时指定挂载位置 可以使用 template 选项独立定义页面模板，此时el挂载元素的内容将被忽略 2. 渲染函数​ 渲染函数（render）用于通过JavaScript方式定义页面结构模板 默认通过el或template方式定义的页面模板也会被render渲染函数执行 可以使用 render 选项独立定义页面结构的渲染函数，此时template模板将被忽略 优先级：render &gt; template &gt; el 3. 虚拟DOM 模板转换为视图的过程： 将模板template编译成渲染函数render，执行渲染函数就可以得到一个虚拟节点树，即虚拟DOM 然后将虚拟节点树转换为真实DOM，映射到视图上 当Model数据更新时，Vue能够智能地计算出需要重新渲染的节点并对虚拟DOM进行修改（打补丁），然后再更新到视图上 虚拟DOM是什么？ 虚拟DOM（vdom）是一个用JavaScript对象方式描述的页面节点结构树，通过对象的属性来描述节点 实际上它只是对真实DOM的抽象，最终会通过一系列操作使这个虚拟DOM变为真实的DOM，显示在页面上 为什么使用虚拟DOM（优点）： 提高DOM更新效率，提升渲染性能 提供快速的DOM变化比较 减少页面中DOM重新渲染的次数（基于diff算法：找出本次DOM需要更新的节点来更新，其他的不更新） 注：JavaScript直接操作真实DOM时效率是比较低的，需要频繁的操作。 七、生命周期1. 简介Vue实例从创建到销毁的过程，称为生命周期，共有八个阶段： beforeCreate、created beforeMount 、mounted beforeUpdate、updated beforeDestroy、destroyed 在生命周期的每个阶段都提供了相应的钩子函数，可以在钩子函数中执行操作，控制生命周期的各个阶段 2. 生命周期流程 八、自定义指令分类：局部指令、全局指令 1. 局部指令在某个Vue实例中定义的指令，只在该Vue实例关联的容器中有效 123456789101112new Vue(&#123; directives:&#123; 指令名称:&#123; // 提供了5个钩子函数，在不同时机执行 bind: function (参数) &#123;&#125;, inserted: function (参数) &#123;&#125;, update: function (参数) &#123;&#125;, componentUpdated: function (参数) &#123;&#125;, unbind: function (参数) &#123;&#125; &#125; &#125;&#125;); 钩子函数的参数： 1234bind: function (el, binding, vnode, oldVnode) &#123; // el 指令所绑定的元素，DOM对象 // binding 一个对象，包含指令的相关信息&#125; 2. 全局指令使用全局方法 Vue.directive(指令ID,定义对象)定义的指令，在所有Vue实例中都有效 12345678Vue.directive(&#x27;指令名称&#x27;,&#123; // 提供了5个钩子函数，在不同时机执行 bind: function (参数) &#123;&#125;, inserted: function (参数) &#123;&#125;, update: function (参数) &#123;&#125;, componentUpdated: function (参数) &#123;&#125;, unbind: function (参数) &#123;&#125;&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"SpringMVC学习","slug":"SpringMVC学习","date":"2023-08-14T06:41:15.000Z","updated":"2023-08-15T02:49:51.000Z","comments":true,"path":"2023/08/14/SpringMVC学习/","link":"","permalink":"http://example.com/2023/08/14/SpringMVC%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、SpringMVC简介1. 什么是MVC​ M：model 数据模型，封装了业务逻辑，对业务数据进行处理 ​ V：view 视图，封装了显示逻辑，如HTML、JSP、Excel、PDF等 ​ C：controller 控制器，控制整个网站的处理流程，协调视图与模型 ​ MVC是一种Web应用架构，是一种代码设计思想 ​ 思想：将所有客户端请求全部交由控制器，由控制器将其分发，并将结果响应回客户端 ​ 注：区别MVC和三层架构 2. SpringMVC优点​ 简单，使用注解配置替代原生XML配置 ​ 效率高，单例的，将Controller层对象交给IoC容器管理 ​ 扩展性好，方便用户自定义 ​ SpringMVC和Spring无缝衔接 3. 实现原理3.1 流程图 3.2 执行过程分为六步： DispatcherServlet SpringMVC核心控制器：主要作用是用来分发，不进行任何处理 HandlerMapping 映射处理器：根据请求URL映射到具体的处理器Handler Handler就是Controller层实现类，也可称为Controller或Action HandlerAdapter 适配器：用来适配不同的处理器Handler 处理器有两种实现方式：实现接口、基于注解，所以执行之前需要先适配，这样才能知道如何执行 Handler 处理器：执行处理具体业务，并产生数据模型Model和视图名View Handler将数据模型和视图封装成ModelAndView对象并返回 ViewResolver 视图解析器：根据视图名解析为具体的视图，一般多为jsp页面，然后封装为View对象 View 视图：使用具体视图技术进行渲染，结合Model展示数据 视图有很多种形式，如jsp、freemarker、velocity、pdf、excel等 二、第一个SpringMVC程序1. 添加依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&lt;/dependency&gt; 2. 创建Controller12345678910@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public ModelAndView sayHello(String name)&#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;msg&quot;,&quot;Hello &quot;+name); mav.setViewName(&quot;hello&quot;); return mav; &#125;&#125; 3. 核心配置文件名称自定义，如springmvc.xml 1234567891011&lt;!-- 扫包 --&gt;&lt;context:component-scan base-package=&quot;controller&quot;/&gt;&lt;!-- mvc的注解驱动 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 配置ViewResolver --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/view/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 4. 配置核心控制器在web.xml中配置SpringMVC核心控制器，需要指定配置文件的路径 1234567891011121314&lt;!-- 配置DispatcherServlet，核心控制器，本质上就是一个Servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5. 静态资源处理当配置DispatcherServlet的url-pattern为/时，会拦截所有请求（包括静态资源），导致所有静态资源都无法访问 两种处理方式： 使用tomcat提供的默认Servlet 1&lt;mvc:default-servlet-handler/&gt; 使用SpringMVC提供的处理方式 1&lt;mvc:resources mapping=&quot;/imgs/**&quot; location=&quot;/WEB-INF/imgs/&quot; /&gt; 三、方法的返回值1. 返回值类型共有四种类型： ModelAndView 表示数据模型和视图 String 三种形式（写法）： 普通字符串 ——&gt; 表示视图名称，转发到指定视图 forward:url ——&gt; 转发到指定url redirect:url ——&gt; 重定向到指定url void 表示使用HttpServletResponse处理响应 Object 一般需要结合@ResponseBody使用 2. @ResponseBody将方法返回值写到响应体中，一般用来处理Ajax请求，返回JSON数据 SpringMVC默认使用jackson处理json数据的转换，所以需要引入jackson的依赖 可以使用@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;)，设置响应时的日期格式 123456&lt;!--jackson--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 注：也可以使用@RestController，相当于@Controller+@ResponseBody 常用注解： @JsonFormat 指定序列化和反序列化时的格式，一般用于指定日期、时间和数字的格式 @JsonProperty 指定序列化和反序列化时的名称 @JsonAlias 指定反序列化时的备用别名 @JsonIgnore 指定序列化和反序列化时忽略属性 注： json序列化：将Java对象转换为json字符串 json反序列化：将json字符串转换为Java对象 3. 跨域访问允许跨域访问 方式一：使用@CrossOrigin注解，可以在类或方法上添加该注解 方式二：在xml中添加如下配置 123&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;/mvc:cors&gt; 四、方法的参数1. JavaEE组件HttpServletRequest HttpServletResponse HttpSession 2. String、基本类型及包装类@RequestParam 表示参数来源于请求参数，默认为所有参数添加该注解，参数值来源于同名称的请求参数 @PathVariable 表示参数来源于URL（URL就是请求路径） @RequestHeader 表示参数来源于请求头 @CookieValue 表示参数来源于Cookie @RequestBody 表示参数来源于请求体，用来接收前端传递给后端的 json 格式的数据 请求的方式必须为post，post请求才会有请求体 请求的内容类型必须为 json格式，需要设置contentType为application/json;charset=utf8 4. 自定义对象例如：User、UserDTO、UserVo等 @ModelAttribute 将请求数据转换为对象，默认为所有自定义类型添加该注解 要求对象的属性名必须与参数名相同 可以使用@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)，设置接收时的日期格式 注意： 可以使用SpringMVC提供的CharacterEncodingFilter解决POST请求中文乱码问题 控制台输出有乱码时，可以设置tomcat的VM options为-Dfile.encoding=utf8 五、请求路径1. @RequestMapping该注解可以定义在方法上，也可以定义在类上，表示层级关系 请求映射路径的写法： 固定写法 value和path属性互为别名，其值是一个数组，可以指定多个值，允许通过多个路径访问 Rest风格 {变量}表示URL中的占位符，URL中必须有对应的值，可以结合@PathVariable获取值 2. 限定请求方式method属性 限定请求方式：GET、POST、PUT、DELETE等 也可使用@GetMapping、@PostMapping、@PutMapping、@DeleteMapping等注解限定请求方式 六、全局异常处理步骤： 定义一个异常处理类，添加@ControllerAdvice或@RestControllerAdvice 定义异常处理方法，添加@ExceptionHandler 七、拦截器拦截器Interceptor对请求进行拦截处理，类似于过滤器Filter 步骤： 定义一个类，实现HandlerInterceptor接口 1234567891011121314151617181920212223public class HelloInterceptor implements HandlerInterceptor &#123; // 调用目标处理方法之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;HelloInterceptor.preHandle&quot;); return true; // true表示放行，继续调用目标处理方法，false表示不放行 &#125; // 调用目标处理方法之后执行，渲染视图之前 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;HelloInterceptor.postHandle&quot;); &#125; // 渲染视图之后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;HelloInterceptor.afterCompletion&quot;); &#125;&#125; 配置拦截器 12345678&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot; /&gt; &lt;mvc:mapping path=&quot;/path/**&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/path/path1&quot;/&gt; &lt;!-- 排除拦截该请求 --&gt; &lt;bean class=&quot;interceptor.HelloInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 八、文件上传SpringMVC为文件上传提供了支持，基于commons-fileupload 步骤： 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 配置文件解析器 12345&lt;!-- 配置文件解析器，id名称必须为multipartResolver --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot;/&gt;&lt;/bean&gt; 编写页面 12345&lt;form id=&quot;uploadForm&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt; &lt;br&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;doUpload()&quot;&gt;&lt;/form&gt; 编写FileController类 123456789101112131415161718192021/* * 通过参数CommonsMultipartFile接收文件 * 必须在参数前添加@RequestParam注解，否则无法接收文件 */@PostMapping(&quot;/upload&quot;)public AjaxResult upload2(String name, @RequestParam CommonsMultipartFile avatar, HttpServletRequest req) throws IOException &#123; System.out.println(name); System.out.println(avatar); System.out.println(avatar.getOriginalFilename()); // 文件名 System.out.println(avatar.getSize()); // 文件大小 System.out.println(avatar.getInputStream()); // 文件的输入流 String uploadPath = req.getServletContext().getRealPath(&quot;upload&quot;); String filename = UUID.randomUUID() + &quot;.&quot; + FileNameUtil.getSuffix(avatar.getOriginalFilename()); String filePath = uploadPath + File.separator + filename; System.out.println(filePath); avatar.transferTo(new File(filePath)); return AjaxResult.success(filename);&#125; ​ 注：maven打包时默认会忽略空目录，不对空目录进行打包，可以先手动创建一个文件 九、综合案例基于SSM的员工管理系统（ssm-ems） 后端 SSM 前端 LayUI","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Spring学习","slug":"Spring学习","date":"2023-08-10T02:57:52.000Z","updated":"2023-08-11T00:31:36.000Z","comments":true,"path":"2023/08/10/Spring学习/","link":"","permalink":"http://example.com/2023/08/10/Spring%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Spring简介1. Spring是什么？​ spring单词本义是“春天”，程序员的春天 ​ 是一个开源的控制反转(IoC)和面向切面(AOP)的容器框架，用来简化企业开发 ​ 官网：https://spring.io 2. 为什么使用Spring​ 降低组件之间的耦合度，实现软件各层之间的解耦 ​ 提供了众多的技术支持 ​ 对主流框架提供了集成 3. 核心概念IoC：Inversion Of Control 控制反转 控制反转(IoC)就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护由外部容器负责，这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。 外部容器&#x2F;IoC容器：存放对象（bean）的容器 12345678//Service依赖于DAOpublic class UserServiceImpl&#123; //UserDaoImpl由应用内部(Service)创建及维护 private UserDao userDao = new UserDaoImpl(); public void regist(User user)&#123; userDao.insert(user); &#125;&#125; DI：Dependency Injection 依赖注入 依赖注入(DI)就是指在运行期，由外部容器动态地将依赖对象注入到组件中。 1234567891011//依赖对象的创建及维护由外部容器负责public class UserServiceImpl&#123; private UserDao userDao; //通过setter方法，让容器把创建好的依赖对象注入到Service中 public void setUserDao(UserDao userDao)&#123; this.userDao=userDao &#125; public void regist(User user)&#123; userDao.insert(user); &#125;&#125; 二、第一个Spring程序1. 添加依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.27&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 核心配置文件​ 用来进行bean的配置，文件名可自定义，一般默认为applicationContext.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd &quot;&gt; &lt;!-- 定义一个bean id：指定bean的名称 class：指定bean的类型 --&gt; &lt;bean id=&quot;helloSpring&quot; class=&quot;ioc01.HelloSpring&quot;&gt; &lt;!-- 为bean中的属性注入值 --&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3. 操作1234567public static void main(String[] args) &#123; // 获取IoC容器，读取配置文件，初始化Spring上下文 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;ioc01/applicationContext.xml&quot;); // 根据id名称获取bean的实例 HelloSpring helloSpring=(HelloSpring) ac.getBean(&quot;helloSpring&quot;); helloSpring.show();&#125; 4. 案例用户登陆 12345678910&lt;bean id=&quot;userDao&quot; class=&quot;ioc02.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;ioc02.service.impl.UserServiceImpl&quot;&gt; &lt;!-- 通过ref属性注入bean --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userController&quot; class=&quot;ioc02.controller.UserController&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;&lt;/bean&gt; 三、数据装配1. 简介为bean中的属性注入值，称为数据的装配，可装配不同类型的数据： 简单类型 ——&gt; 使用value ​ 基本类型及包装类型、String 其他bean的引用 ——&gt; 使用ref 集合类型 ——&gt;使用相对应的子元素 数组 List Set Map Properties 注：数据装配是通过setter方法进行的，所以必须有setter方法 2. 基本用法123456789101112131415161718192021222324252627282930313233&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;property name=&quot;otherBean&quot; ref=&quot;otherBean&quot;/&gt; &lt;property name=&quot;arrays&quot;&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;lists&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;otherBean&quot;/&gt; &lt;bean class=&quot;ioc03.OtherBean&quot;&gt; &lt;property name=&quot;sex&quot; value=&quot;male&quot;/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aaa&quot; value-ref=&quot;otherBean&quot;/&gt; &lt;entry key=&quot;bbb&quot; value-ref=&quot;otherBean&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/test&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3. 自动装配对于其他bean的引用的装配，IoC容器可以根据bean的名称、类型或构造方法进行自动的注入，称为自动装配 通过bean元素的autowire来配置 1234567891011&lt;!-- 自动装配 autowire 可取值如下： no：不进行自动装配，默认值，同default byName：根据属性名自动装配，自动查找与属性名相同的bean byType：根据属性类型自动装配，自动查找与属性类型相同的bean constructor：根据构造方法自动装配 根据构造方法参数的名称或类型进行自动装配，只要有一个可以装配就行 此时与setter方法无关，可以没有setter方法 --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; autowire=&quot;constructor&quot;/&gt; 四、bean管理1. bean生命周期​ 生命周期：实例化–&gt;数据装配–&gt;初始化方法–&gt;使用–&gt;销毁方法–&gt;从容器中销毁 1234&lt;!-- 生命周期的扩展 init destory --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ​ 在bean实例化并进行数据装配后，会调用初始化方法，执行初始化操作 ​ 在bean销毁之前会调用销毁方法，执行销毁前的操作 2. bean实例化时机​ 默认预先实例化，即在容器启动时实例化，可以设置懒实例化，在第一次使用bean时实例化 123&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; lazy-init=&quot;true&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3. bean作用域​ 在IoC容器中bean默认是单例的 ​ 通过bean元素的scope属性来设置bean的作用域，即是否为单例模式 123456&lt;!-- scope属性 可取值如下： singleton：单例，在容器启动时初始化，默认值 prototype：多例，在每次获取bean时初始化 --&gt;&lt;bean id=&quot;springBean&quot; class=&quot;ioc.SpringBean&quot; scope=&quot;prototype&quot;/&gt; 4. 在普通类中获取bean实际开发中，并不是所有类都需要交由IoC容器管理，某些类并不需要交由容器管理，如各种工具类，本身都提供了静态方法 问题：没有交由容器管理的类，容器是无法进行数据装配的，如何在这些类中获取容器中的bean呢？ 解决：使用ApplicationContextAware获取容器，然后从容器中获取bean 定义IoC容器工具类，步骤： 定义一个类，实现ApplicationContextAware接口 将该类添加到IoC容器中，当实例化时会自动注入当前的ApplicationContext 调用IoC容器工具类，从容器中获取bean 1234567891011121314151617181920212223242526272829303132public class ApplicationContextHolder implements ApplicationContextAware&#123; private static ApplicationContext ac; /** * 会自动注入当前的IoC容器 */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.ac = applicationContext; &#125; /** * 根据名称获取bean * @param beanName * @return */ public static Object getBean(String beanName)&#123; return ac.getBean(beanName); &#125; /** * 根据类型获取bean * @param clazz * @return * @param &lt;T&gt; */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123; return ac.getBean(clazz); &#125;&#125; 五、注解配置1. 简介​ Spring提供了一系列注解来替代配置文件，简化配置 ​ 使用注解时，需要扫描注解所在的包 123&lt;context:component-scan base-package=&quot;net.wanho.dao.impl&quot;/&gt;&lt;context:component-scan base-package=&quot;net.wanho.service.impl&quot;/&gt;&lt;context:component-scan base-package=&quot;net.wanho.controller&quot;/&gt; 2. 常用注解2.1 定义组件@Component 定义组件Bean，添加到IoC容器中，不区分组件类型 区分组件类型的注解： @Repository 表示Dao组件 @Service 表示Service组件 @Controller 表示Controller组件 注：以上三个注解和@Component的作用相同，只是用来表示不同的组件类型 2.2 数据装配注解方式的数据装配是直接使用属性进行注入，不是使用setter方法，所以可以没有setter方法 简单类型 123456789@Value(&quot;666&quot;)private int num;@Value(&quot;true&quot;)private Boolean flag;// @Value(&quot;tom&quot;)@Value(&quot;$&#123;username&#125;&quot;)private String username; 12&lt;!-- 引用属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:ioc/info.properties&quot;/&gt; 其他bean的引用，使用@Autowired 或 @Resource 12345678910111213141516171819202122232425262728// @Autowired // Spring提供的注解，默认按类型注入，如果有多个同类型的，则按名称注入@Resource // Java提供的注解，默认按名称注入，如果没找到，则按类型注入private OtherBean otherBean;/* * 方式1：基于field注入，即在属性上面添加@Autowired或@Resource */@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao;&#125;/* * 方式2：基于constructor注入，即在构造方法上面添加@Autowired或@Resource * 优点：可以为final属性注入、质量高（Spring官方推荐） */@Controller@RequiredArgsConstructor // 可以使用lombok的@RequiredArgsConstructor注解来生成带参构造方法（属性要使用final修饰）public class UserController &#123; private final UserService userService; // @Autowired // 如果类中只有一个构造方法，可以省略该注解 // public UserController(UserService userService) &#123; // this.userService = userService; // &#125;&#125; 2.3 bean生命周期1234567891011// 相当于init-method@PostConstructpublic void init() &#123; System.out.println(&quot;SpringBean.init()&quot;);&#125;// 相当于destroy-method@PreDestroypublic void destroy() &#123; System.out.println(&quot;SpringBean.destroy()&quot;);&#125; 2.4 bean实例化时机123// 默认是预实例化，配置为懒初始化@Lazypublic class SpringBean &#123;&#125; 2.5 scope作用域123//默认是单例，配置为非单例@Scope(&quot;prototype&quot;)public class SpringBean &#123;&#125; 六、AOP1. 简介​ AOP：Aspect Oriented Programming 面向切面编程，是OOP面向对象编程的一种补充 ​ 将程序中的交叉业务逻辑（事务、日志、异常等）代码提取出来，封装成切面，由AOP容器在适当的时机（位置）将封装的切面动态的织入到具体业务逻辑中。 2. 作用 在不改变原有代码的基础上动态添加新的功能 模块化，将分散在各层中的相同代码，通过横向切割的方式抽取到单独的模块中 方便维护 可扩展性强 3. 原理AOP的原理是使用动态代理技术 动态代理的含义： 代理类是在程序运行期间由JVM根据反射等机制动态生成的，自动生成代理类和代理对象 所谓动态是指在程序运行前不存在代理类的字节码文件，代理类和委托类的关系是在程序运行时确定 动态代理的两种技术： jdk技术：适用于有接口时使用，目标对象必须实现一个或多个接口，否则无法使用jdk动态代理 cglib技术：适用于无接口时使用（有接口时也可以使用） 注：Spring默认使用的是jdk动态代理，SpringBoot默认使用的是cglib动态代理 4. 用法步骤： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;&lt;/dependency&gt; 配置Advice 定义增强类并添加@Component和@Aspect注解，表示其为一个切面 配置Pointcut 定义切点表达式 在一个空方法上添加@Pointcut注解，配置切点表达式 为方法添加通知类型注解并指定切点 @Before 前置通知，在方法执行前添加功能 @AfterReturning 后置通知，在方法执行后添加功能 @AfterThrowing 异常通知，在方法抛出异常后添加功能 @Around 环绕通知 在方法执行前后添加功能 配置自动创建代理并织入 1&lt;aop:aspectj-autoproxy /&gt; 七、Spring整合JDBC12345678910drop database if exists spring;create database spring charset utf8;use spring;create table t_user( id int primary key auto_increment, username varchar(50) not null unique, password varchar(50) not null) charset utf8; 1. 基本用法步骤： 添加依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 配置 DataSource–&gt;JdbcTemplate–&gt;Dao–&gt;Service–&gt;Controller 123456@Repositorypublic class UserDaoJdbcImpl implements UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate; // ...&#125; 1234567891011121314&lt;context:property-placeholder location=&quot;classpath:datasource.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2. 事务操作​ JDBC默认是自动提交事务的，每执行完一条SQL语句就提交事务 ​ 问题：如果Service层出现异常，并不会回滚，怎么办？ ​ 解决：配置事务操作（使用的是环绕通知） 1234567&lt;!-- 定义事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务的注解驱动 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 12345678910111213141516// @Transactional也可以配置在类上，如果方法上没有配置@Transactional，则使用类上的事务配置@Transactional(propagation = Propagation.REQUIRED,rollbackFor = Exception.class)public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override @Transactional(propagation = Propagation.SUPPORTS, readOnly = true) public User login(String username, String password) &#123; &#125; @Override //@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, noRollbackFor = ArithmeticException.class, timeout = 3000) public void regist(UserVo userVo) &#123; &#125;&#125; 3. 事务属性和事务特性3.1 事务属性​ 五个事务属性：传播属性、隔离级别、回滚条件、只读优化、超时处理 传播属性 propagation：定义事务的边界，用来配置当前方法是否需要有事务，常用取值： REQUIRED 必须添加事务，如果当前没有事务则创建一个新的事务，一般用于增删改 SUPPORTS 可以没有事务，如果当前有事务则运行，如果没有事务也可以运行，一般用于查询 隔离级别 isolation：用来解决事务并发时会出现的一些问题，四种隔离级别，由低到高依次为： READ_UNCOMMITTED 读未提交——&gt;可能出现脏读、不可重复读、幻读 READ_COMMITTED 读已提交——&gt;避免脏读，但可能出现不可重复读、幻读 REPEATABLE_READ 可重复读——&gt;避免脏读、不可重复读，但可能出现幻读（MySQL默认隔离级别） SERIALIZABLE 可序列化（串行）——&gt;避免脏读、不可重复读、幻读，相当于是单并发，没意义 事务并发时会出现的三个问题（脏读、不可重复读、幻读或虚读）： 脏读: 一个事务读取到另一个事务中没有提交的数据，一般不会发生，如MySQL、Oracle底层默认都是只读取提交的数据 12345-- 打开两个session，即同时登陆两个账户mysql -uroot -pset autocommit=off; insert into t_user values(null,&#x27;alice&#x27;,&#x27;123&#x27;);select * from t_user; 不可重复读 : 一个事务已经读取数据，另一个事务在修改数据，可能导致使用的数据与数据库不同步 幻读或虚读 : 一个事务已经读取数据量，另一个事务在添加或删除数据，可能导致使用的数据量与数据库不一致 注：不可重复读和虚读都是小概率事件，实际开发中一般不需要配置隔离级别，大多是通过定时任务来检查+人工审核 回滚条件 rollback：默认抛出RuntimeException时才进行回滚 ​ rollbackFor&#x3D;”” 表示发生该异常时回滚 ​ noRollbackFor&#x3D;”” 表示发生该异常时不回滚 只读优化 readOnly：在该事务中只能读取，一般用于查询 超时处理 timeout：配置事务超时的时间，一般不配置 3.2 事务特性​ 四个事务特性：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、永久性(Durability) ​ 简称为ACID 八、Spring整合MyBatis​ 步骤： 添加依赖 12345678910111213141516&lt;!-- Spring整合MyBatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.13&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 创建Mapper映射文件 映射文件存放位置，两种形式： 将映射文件放在resources目录下 映射文件会进行打包部署 将映射文件放在java目录下 默认只会对该目录下的java代码进行打包部署，如果希望对该目录下的配置文件也进行打包，需要添加额外的配置 编辑pom.xml文件： 123456789101112131415161718192021&lt;build&gt; &lt;resources&gt; &lt;!-- 将java目录下的配置文件也进行打包 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 配置 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 可以引用独立的mybatis配置文件，也可以不用 --&gt; &lt;!-- &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 指定映射文件所在路径 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:org/wanho/mapper/*Mapper.xml&quot;&gt;&lt;/property&gt; &lt;!-- 为映射的类指定别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;net.wanho.entity&quot;&gt;&lt;/property&gt; &lt;!-- 自定义配置 --&gt; &lt;property name=&quot;configuration&quot;&gt; &lt;bean class=&quot;org.apache.ibatis.session.Configuration&quot;&gt; &lt;!-- 打印sql --&gt; &lt;property name=&quot;logImpl&quot; value=&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;/&gt; &lt;!-- 下划线映射为驼峰 --&gt; &lt;property name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 分页插件 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;helperDialect&quot;&gt;mysql&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 通过反射创建Dao实现类，然后放到IoC容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 指定Dao接口所在的包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;net.wanho.dao&quot;/&gt; &lt;!--注入sqlSessionFactory，通过value注入String类型的名称--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"MyBatis学习","slug":"MyBatis学习","date":"2023-08-08T05:28:46.000Z","updated":"2023-08-09T02:44:35.000Z","comments":true,"path":"2023/08/08/MyBatis学习/","link":"","permalink":"http://example.com/2023/08/08/MyBatis%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、简介1. MyBatis是什么MyBatis的前身叫iBatis 是一个持久层框架，或称为 ORM框架 用来访问数据库，做数据持久化操作 本质上只是对JDBC进行封装，简化JDBC繁琐的操作 ​ 注：框架就是别人写好的，对某些技术进行的封装，封装成对应的jar、js、css等，我们可以直接拿过来使用，简化开发 2. 持久层​ DAO：Data Access Object 数据访问对象 ​ 用来对数据进行持久化操作，如将数据存入数据库、硬盘等，可以永久保存 3. ORMObject Relational Mapping 对象关系映射 Java程序和数据库之间的映射关系： 类 ——&gt; 表 对象 ——&gt; 一条数据 属性 ——&gt; 列 4. 回顾JDBC​ JDBC访问数据库的步骤 1234567891011Class.forName(driverClassName);Connection conn = DriverManager.getConnection(url,user,password);PrepareStatement ps = conn.preparedStatement(sql);//ps.executeUpdate()ResultSet rs = ps.executeQuery();while(rs.next)&#123; //RM(RowMapper)行映射&#125;rs.close();ps.close();conn.close(); 数据库操作中的可变部分： 连接信息 dirverClassName、 url、user、password（也称为数据源datasource） SQL语句 RM行映射 二、第一个MyBatis程序1. 创建项目并添加依赖1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 数据库设计1234567891011drop database if exists mybatis;create database mybatis charset utf8;use mybatis;create table t_user( id int primary key auto_increment comment &#x27;编号&#x27;, username varchar(20) unique not null comment &#x27;用户名&#x27;, password varchar(50) comment &#x27;密码&#x27;, phone varchar(20) comment &#x27;电话&#x27;, address varchar(100) comment &#x27;地址&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 3. 创建主配置文件config主配置文件，在一个mybatis工程中有且只有一个 用来配置与整个工程相关的信息，如环境配置、别名配置、插件配置、注册mapper文件等 文件名可自定义，一般命名为mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments：配置当前工程中可能使用的所有数据库环境 default属性：指定默认使用的环境，取值为某一个environment的id --&gt; &lt;environments default=&quot;hello&quot;&gt; &lt;!-- envirinment：配置某一个数据库环境，可以有多个 id属性：指定该环境的唯一标识符 --&gt; &lt;environment id=&quot;hello&quot;&gt; &lt;!-- transactionManager：配置事务管理器 type属性：指定事务管理器的类型，取值有两种： jdbc：使用简单的jdbc事务操作，如开启、提交、回滚 在mybatis中，默认是关闭自动提交事务的，即conn.setAutoCommit(false) managed：将事务交给其他框架/容器来处理，如spring mybatis不负责事务，什么都不会做 --&gt; &lt;transactionManager type=&quot;jdbc&quot;&gt;&lt;/transactionManager&gt; &lt;!-- dataSource：配置数据源 type属性：配置数据源的类型，取值有三种： UNPOOLED：简单的JDBC配置，未使用连接池，相当于DriverManager.getConnection(url,username,password) POOLED：使用连接池技术 JNDI：通过外部容器获取连接 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--&lt;environment id=&quot;world&quot;&gt;--&gt; &lt;!--&lt;transactionManager type=&quot;&quot;&gt;&lt;/transactionManager&gt;--&gt; &lt;!--&lt;dataSource type=&quot;&quot;&gt;&lt;/dataSource&gt;--&gt; &lt;!--&lt;/environment&gt;--&gt; &lt;/environments&gt; &lt;!-- 注册当前工程中使用的所有映射文件 --&gt; &lt;mappers&gt; &lt;!-- mapper：注册某一个mapper文件，可以有多个 resource属性：指定映射文件的路径，写的是相对于src的路径，使用正斜杠分隔 --&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 小技巧： 创建配置文件的模板：Settings——&gt;搜索template——&gt;File and Code Templates——&gt;Files——&gt;Create Template 4. 创建映射文件mapper映射配置文件，在一个mybatis工程中可以有多个mapper文件 用来配置dao功能相关的sql操作，如sql语句、CURD操作、字段映射等 每个实体类对应一个映射文件，每一个mapper文件相当于原来三层架构中dao实现类 文件名可自定义，一般命名为XxxMapper.xml，放到mapper文件夹中 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace属性：指定当前mapper配置文件的唯一标识符，取值为对应接口的全名--&gt;&lt;mapper namespace=&quot;dao.UserDao&quot;&gt; &lt;!-- insert：用来执行添加操作 id属性：表示当前的方法名，取值必须与接口中的方法名相同 parameterType属性：表示方法的参数类型 如果参数是对象，可以使用类的全名 如果参数是普通数据，可以使用mybatis中的别名，见参考文档12页 标签体：编写sql语句 使用#&#123;xxx&#125;表示占位符 如果参数是对象，则xxx为对象的属性 如果参数是普通数据，则xxx为参数名 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;entity.User&quot;&gt; insert into t_user (username, password, phone, address) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt; 小技巧： 去除背景：Settings——&gt;Editor——&gt;Color Scheme——&gt;General——&gt;Code——&gt;Injected language fragment，取消勾选右边的Background XML注释风格：Settings——&gt;Editor——&gt;Code Style——&gt;XML——&gt;Code Generation，取消勾选下面的两个 编写SQL时提示表和列： 在右侧的工具栏，添加数据库连接 Settings——&gt;搜索SQL Dialects——&gt;将右边的都选择为MySQL 5. 测试类1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; /** * 创建SqlSession，称为持久化管理器，是MyBatis操作的核心 */ // 1.创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); // 2.创建SqlSessionFactory，读取核心配置文件 SqlSessionFactory factory = builder.build(Test01.class.getClassLoader().getResourceAsStream(&quot;mybatis-config.xml&quot;)); // 3.创建SqlSession SqlSession session = factory.openSession(); // Connection connection = session.getConnection(); // System.out.println(connection); User user = new User(); user.setUsername(&quot;alice&quot;); user.setPassword(&quot;123&quot;); user.setPhone(&quot;110&quot;); user.setAddress(&quot;南京&quot;); /** * 获取DAO实现类的实例，并执行数据库操作 */ UserDao userDao = session.getMapper(UserDao.class); // 参数为接口的Class对象 // System.out.println(userDao); // 代理对象，通过代理自动生成DAO的实现类 userDao.insertUser(user); session.commit(); // 提交事务&#125; 6. MyBatisUtil工具类MyBatisUtil工具类： （1）MyBatisUtils主要职责是：● 帮助我们初始化SqlSessionFactory这个对象；同时让SqlSessionFactory全局唯一；● 获得SqlSession对象的方法；● 关闭SqlSession对象的方法； （2）在实际开发中，会经常使用MyBatisUtils工具类； 添加模板，实现快捷操作：Settings——&gt;搜索template——&gt;Live Templates 12345678910111213SqlSession session = null;try &#123; session = MyBatisUtil.getSession(); $END$ session.commit();&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();&#125; finally &#123; MyBatisUtil.close();&#125; 三、config文件1. settings123456&lt;!-- 自定义配置 --&gt;&lt;settings&gt; &lt;!-- 打印sql --&gt; &lt;!--&lt;setting name=&quot;logImpl&quot; value=&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;/&gt;--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; logImpl可以输出日志注：setting一定要在environment的上面，否则会报错。 2. typeAliases12345678910111213141516&lt;!-- 配置别名，为当前工程中的某些类指定别名--&gt;&lt;typeAliases&gt; &lt;!-- typeAlias：为某个类配置别名 type属性：指定类名 alias属性：指定类的别名 --&gt; &lt;!--&lt;typeAlias type=&quot;entity.User&quot; alias=&quot;User&quot;/&gt;--&gt; &lt;!-- package：为某个包下的所有类配置别名 name属性：指定包名，该包下所有类的别名就是其类名（别名不区分大小写，但建议与类名完全一致） --&gt; &lt;package name=&quot;entity&quot;/&gt;&lt;/typeAliases&gt; 3. properties1234&lt;!-- 引用外部的properties文件--&gt;&lt;properties resource=&quot;datasource.properties&quot;&gt;&lt;/properties&gt; 1234567&lt;!-- 通过$&#123;key&#125;访问properties文件中的值--&gt;&lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; 四、mapper文件1. insert​ 保存返回主键 123456789101112&lt;!-- useGeneratedKeys属性：设置保存时是否返回主键，取值有两个： false：表示不返回主键，默认值 true：表示返回主键，会自动将返回的主键绑定到参数对象的主键属性中 keyProperty属性：指定对象的哪个属性为主键属性，即主键所映射的属性，必须指定--&gt;&lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user (username, password, phone, address) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;address&#125;)&lt;/insert&gt; 2. update1234567891011&lt;!-- update：执行修改操作--&gt;&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update t_user set username=#&#123;username&#125;, password=#&#123;password&#125;, phone=#&#123;phone&#125;, address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; 3. delete1234567&lt;!-- delete：执行删除操作--&gt;&lt;delete id=&quot;deleteById&quot; parameterType=&quot;int&quot;&gt; delete from t_user where id=#&#123;id&#125;&lt;/delete&gt; 4. select123456789101112131415161718192021222324252627282930313233343536&lt;!-- select：执行查询操作 resultType属性：表示返回的结果类型 如果返回的是一个对象，会自动进行映射 前提条件：查询结果的字段名必须与对象的属性名完全相同--&gt;&lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select id,username,password,phone,address from t_user where id=#&#123;id&#125;&lt;/select&gt;&lt;!-- 当方法返回值为对象集合时，resultType指定的是集合中对象的类型，而非集合本身--&gt;&lt;select id=&quot;selectAll&quot; resultType=&quot;User&quot;&gt; &lt;!-- include：用于引用sql代码段 refid属性：指定要引用的sql代码段的id值 --&gt; select &lt;include refid=&quot;userColumn&quot;/&gt; from t_user&lt;/select&gt;&lt;!-- 模糊查询--&gt;&lt;select id=&quot;selectByUsername&quot; resultType=&quot;User&quot;&gt; select &lt;include refid=&quot;userColumn&quot;/&gt; from t_user &lt;!-- 方式1：使用concat()函数拼接 --&gt; &lt;!-- where username like concat(&#x27;%&#x27;,#&#123;username&#125;,&#x27;%&#x27;) --&gt; &lt;!-- 方式2：传参时直接拼接上% --&gt; where username like #&#123;username&#125;&lt;/select&gt; 5. sql片段123456789101112&lt;!-- sql：定义sql代码段，便于复用 id属性：指定该sql代码段的唯一标识符--&gt;&lt;sql id=&quot;UserColumn&quot;&gt; id,username,password,phone,address&lt;/sql&gt;&lt;sql id=&quot;BaseQuery&quot;&gt; select id,username,password,phone,address from t_user&lt;/sql&gt; 五、手动映射​ 当数据库查询结果的字段名与Java对象的属性名不同时，如何映射？ 1234567create table t_user2( user_id int primary key auto_increment comment &#x27;编号&#x27;, user_username varchar(20) unique not null comment &#x27;用户名&#x27;, user_password varchar(50) comment &#x27;密码&#x27;, user_phone varchar(20) comment &#x27;电话&#x27;, user_address varchar(100) comment &#x27;地址&#x27;)engine innodb default charset utf8 comment &#x27;用户表&#x27;; 1. 使用别名123456789101112131415&lt;!-- 使用别名：为查询结果的每个字段指定别名，与对象的属性名相同，此时相当于自动映射--&gt;&lt;select id=&quot;selectById2&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select user_id id, user_username username, user_password password , user_phone phone , user_address address from t_user2 where user_id=#&#123;id&#125;&lt;/select&gt; 2. 使用resultMap123456789101112131415161718&lt;!-- resultMap：定义结果映射，将数据库的字段与对象的属性进行映射 id属性：指定该resultMap的唯一标识符 type属性：映射的对象类型--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id：配置主键映射 result：配置其他映射 property属性：映射的属性名 column属性：映射的字段名 --&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;user_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;user_password&quot;/&gt; &lt;result property=&quot;phone&quot; column=&quot;user_phone&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;user_address&quot;/&gt;&lt;/resultMap&gt; 1234567891011121314&lt;!-- resultMap属性：引用一个resultMap，使用该resultMap进行手动映射 其值为已存在的某一个resultMap标签的id值--&gt;&lt;select id=&quot;selectById3&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt; select user_id, user_username, user_password , user_phone, user_address from t_user2 where user_id=#&#123;id&#125;&lt;/select&gt; 六、多个参数1. 使用@Param()注解12// 使用@Param()注解，标注在参数前，为参数指定占位符名称public User selectByUsernameAndPassword(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); 1234567&lt;!-- 使用@Param()定义的名称引用指定的参数--&gt;&lt;select id=&quot;selectByUsernameAndPassword&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;pwd&#125;&lt;/select&gt; ​ 注：如果方法只有一个参数，不需要加@Param注解，可以在占位符#{ }中使用任意名称 2. 将参数封装为对象12345&lt;!-- 将多个参数封装成一个对象，然后传递该对象 --&gt;&lt;select id=&quot;selectByUsernameAndPassword2&quot; parameterType=&quot;UserDTO&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; ​ 注：可以自定义一个参数对象，如UserDTO、UserParam等 3. 将参数封装为Map1234567&lt;!-- 将多个参数封装成一个Map集合，在#&#123;&#125;占位符中根据key获取value--&gt;&lt;select id=&quot;selectByUsernameAndPassword3&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; ​ 注：parameterType属性可以省略 4. #{}与${}的区别#{ }的含义 #{ }表示一个占位符 即JDBC中的？ 占位不会出现SQL注入的问题 ${ }的含义 ${}表示一个拼接符 拼接会导致SQL注入，如查询条件输入&#39;&#39; or 1=1就会有注入情况 如果排序时要指定排序列名和排序方式，此时就必须使用字符的拼接，即使用${ } 七、动态SQL​ 根据条件的不同，动态的拼接SQL语句，称为动态SQL ​ 传统JDBC拼接： 12345678StringBuffer sql=new StringBuffer();sql.append(&quot;select * from t_user where 1=1&quot;);if(username!=null &amp;&amp; !&quot;&quot;.equals(username))&#123; sql.append(&quot; and username=? &quot;);&#125;if(password!=null &amp;&amp; !&quot;&quot;.equals(password))&#123; sql.append(&quot; and password=? &quot;);&#125; 1. if1234567891011121314151617181920&lt;!-- if标签：用来进行条件的判断 test属性：判断表达式的值，如果为true，则拼接该sql片段，否则不拼接--&gt;&lt;select id=&quot;selectByParams&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where 1=1 &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; and password = #&#123;password&#125; &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; and phone = #&#123;phone&#125; &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; and address = #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 2. choose123456789101112131415161718192021222324252627&lt;!-- choose标签：用来进行条件的选择，只会拼接一个SQL when标签： test属性：判断表达式的值，如果为true，则拼接该sql片段，此时不再判断其它when otherwise标签：当所有when都不成立时，则拼接该sql片段--&gt;&lt;select id=&quot;selectByParams2&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where &lt;choose&gt; &lt;when test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; username = #&#123;username&#125; &lt;/when&gt; &lt;when test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password = #&#123;password&#125; &lt;/when&gt; &lt;when test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; phone = #&#123;phone&#125; &lt;/when&gt; &lt;when test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; address = #&#123;address&#125; &lt;/when&gt; &lt;otherwise&gt; 1=1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 3. where1234567891011121314151617181920212223&lt;!-- where标签：一般结合if或choose一起使用 作用：1.添加where关键字 2.删除sql片段的第一个连接关键字，如and、or等 3.如果没有拼接任何sql片段，则不会添加where关键字--&gt;&lt;select id=&quot;selectByParams3&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; &lt;where&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; or password = #&#123;password&#125; &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; and phone = #&#123;phone&#125; &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; and address = #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 4. set1234567891011121314151617181920212223&lt;!-- set标签：一般结合if或choose一起使用 作用：1.添加set关键字 2.删除sql片段的末尾逗号--&gt;&lt;update id=&quot;updateUser2&quot; parameterType=&quot;User&quot;&gt; update t_user &lt;set&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password = #&#123;password&#125;, &lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt; phone = #&#123;phone&#125;, &lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt; address = #&#123;address&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; 5. trim123456789101112131415161718192021222324&lt;!-- trim标签： 作用：1.在开头或末尾添加特定的前缀prefix或后缀suffix 2.删除开头prefixOverrides或末尾suffixOverrides的特定内容 注：当属性值可能有多个时，可以使用竖杠|来表示或者的意思，且竖杠的后面不能有空格--&gt;&lt;insert id=&quot;insertUser2&quot; parameterType=&quot;User&quot;&gt; insert into t_user &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;id,&lt;/if&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;username,&lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;password,&lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt;phone,&lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt;address,&lt;/if&gt; &lt;/trim&gt; values &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;#&#123;id&#125;,&lt;/if&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt;#&#123;phone&#125;,&lt;/if&gt; &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt;#&#123;address&#125;,&lt;/if&gt; &lt;/trim&gt;&lt;/insert&gt; 6. foreach12345678910111213141516&lt;!-- foreach标签：当参数是集合时，用来对集合进行遍历，一般用在in条件中 collection属性：要遍历的集合，默认List集合指定为list，Map集合指定为map，数组指定为array item属性：迭代变量 open属性：遍历前添加的字符串 close属性：遍历后添加的字符串 separator属性：元素分隔符 index属性：当前迭代元素的索引--&gt;&lt;select id=&quot;selectByIds&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;BaseQuery&quot;/&gt; where id in &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; 八、多表关系映射1. 简介关联关系： 多对一，多个员工都在同一个部门中 一对多，一个部门中有多个员工 一对一，一个员工只能有一个身份证 多对多，一个员工可以同时开发多个项目，一个项目也可以同时有多个员工开发 数据库设计： 123456789101112create table t_dept( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;部门名称&#x27;)engine innodb default charset utf8 comment &#x27;部门表&#x27;;create table t_emp( id int primary key auto_increment comment &#x27;编号&#x27;, name varchar(20) comment &#x27;姓名&#x27;, salary double comment &#x27;工资&#x27;, dept_id int comment &#x27;部门编号&#x27;, foreign key (dept_id) references t_dept(id))engine innodb default charset utf8 comment &#x27;员工表&#x27;; 2. 保存操作12345678&lt;mapper namespace=&quot;dao.DeptDao&quot;&gt; &lt;insert id=&quot;insertDept&quot; parameterType=&quot;Dept&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_dept (name) values (#&#123;name&#125;) &lt;/insert&gt;&lt;/mapper&gt; 12345678&lt;mapper namespace=&quot;dao.EmpDao&quot;&gt; &lt;insert id=&quot;insertEmp&quot; parameterType=&quot;Emp&quot;&gt; insert into t_emp (name, salary, dept_id) values (#&#123;name&#125;,#&#123;salary&#125;,#&#123;dept.id&#125;) &lt;/insert&gt;&lt;/mapper&gt; 3. 多对一在一个对象中定义另一个对象的属性 两种实现方式： 使用关联属性，即直接使用association标签 使用嵌套查询，即使用association的select属性，引用其他select，通过多个单表查询来实现 12345678910111213141516171819202122232425262728293031323334353637383940&lt;resultMap id=&quot;BaseMap&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;EmpMap&quot; type=&quot;Emp&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- association：用于配置关联属性，多对一的关系 property属性：当前需要映射的是对象中的哪个属性 javaType属性：当前映射的属性的Java类型 标签体：对当前映射的属性所在的表进行映射 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;deptId&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;deptName&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;EmpMap2&quot; type=&quot;Emp&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- select属性：引用其他的select查询配置 值为：select所在Mapper文件的namespace.select的id值 column属性：当前查询的某列，作为查询条件，传递给引用的select查询配置的参数 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot; select=&quot;dao.DeptDao.selectById&quot; column=&quot;dept_id&quot;&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap&quot;&gt; select &lt;include refid=&quot;EmpColumn&quot;/&gt; from t_emp e left join t_dept d on e.dept_id=d.id&lt;/select&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;EmpMap2&quot;&gt; select id,name,salary,dept_id from t_emp&lt;/select&gt; 嵌套查询的缺点：效率低，会进行多次查询，存在N+1问题 首先查询了1次emp表，获取到N条dept_id的记录 对于每一个不同的dep_id，都会去dept表中进行一次查询，可能会查询N次 所以，总查询次数可能为：1次emp表+N次dept表 4. 一对多在一个对象中定义另一个对象的集合 两种实现方式： 使用集合属性，即直接使用collection标签 使用嵌套查询，即使用collection的select属性，引用其他select，通过多个单表查询来实现 12345678910111213141516171819202122232425262728293031323334353637&lt;resultMap id=&quot;BaseMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;DeptMap&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- collection：用于配置集合属性，一对多的关系 property属性：当前需要映射的集合属性 ofType属性：集合属性中对象的类型 标签体：对集合属性中对象所在的表进行映射 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;empId&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;empName&quot;/&gt; &lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;DeptMap2&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- select属性 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot; select=&quot;dao.EmpDao.selectByDeptId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;DeptMap&quot;&gt; select &lt;include refid=&quot;DeptColumn&quot;/&gt; from t_dept d left join t_emp e on d.id=e.dept_id&lt;/select&gt;&lt;select id=&quot;selectAll&quot; resultMap=&quot;DeptMap2&quot;&gt; select id,name from t_dept&lt;/select&gt; 5. 懒加载1234567891011121314&lt;resultMap id=&quot;DeptMap2&quot; type=&quot;Dept&quot; extends=&quot;BaseMap&quot;&gt; &lt;!-- fetchType属性：指定集合属性的加载时机 lazy：延迟加载，当使用到集合属性时，才会加载 eager：立即加载，查询主表时，就会查询集合属性 也可以在主配置文件中，通过setting标签，配置全局的fetchType属性 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot; select=&quot;dao.EmpDao.selectByDeptId&quot; column=&quot;id&quot; fetchType=&quot;lazy&quot;/&gt;&lt;/resultMap&gt;&lt;settings&gt; &lt;!-- 懒加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 九、缓存1. 简介将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据库的压力，同时提高系统性能。 合理使用缓存是优化中最常见的操作。 2. 一级缓存一级缓存是SqlSession级别的，存储在SqlSession中，默认是开启的 一般来说，一个请求中的所有增删改查操作都是在 同一个sqlSession里面的，可以认为每个请求都有自己的一级缓存 如果同一个SqlSession会话中 2个查询中间有一个 insert 、update或delete 语句，那么之前查询的所有缓存都会清空 流程： 用户发起查询请求，查找某条数据，SqlSession 先去缓存中查找，是否有该数据，如果有，读取； 如果没有，从数据库中查询，并将查询到的数据放入一级缓存区域，供下次查找使用。 当SqlSession 执行commit，即增删改操作时会清空缓存。这么做的目的是避免脏读。 生效的条件： 必须使用同一SqlSession，执行同一个查询方法才会有效 同一个SqlSession，如果查询条件不同，则无效 同一个SqlSession，如果两次查询期间执行了任何一次的增删改操作，则无效 3. 二级缓存二级缓存是 mapper 级别的缓存，多个SqlSession去操作同一个Mapper的sql语句时，多个SqlSession可以共用二级缓存 二级缓存是跨SqlSession的，因此二级缓存的作用范围更大 二级缓存默认是关闭的，需要手动开启 流程： 开启二级缓存后，用户查询时，会先去二级缓存中找，找不到了再去一级缓存中找 一级缓存也没有查询到，则查询数据库 当SqlSession会话提交或者关闭时，一级缓存的数据会刷新到二级缓存中 启用二级缓存：在 XxxMapper.xml 映射文件中，添加：&lt;cache/&gt; 十、分页插件1. 简介​ PageHelper是一款基于mybatis的分页插件 2. 用法2.1 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 2.2 插件的配置​ 在mybatis核心配置文件中配置插件 123456&lt;plugins&gt; &lt;!-- 配置mybatis分页插件 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 2.3 使用​ 分为三步： 123456789101112131415161718192021// 1.配置分页信息，指定页码、页大小int pageNum = 3;int pageSize = 4;PageHelper.startPage(pageNum, pageSize);// 2.获取原始数据UserDao userDao = session.getMapper(UserDao.class);List&lt;User&gt; users = userDao.selectAll();for (User user:users)&#123; System.out.println(user);&#125; // 3.将原始数据封装成分页数据PageInfo&lt;User&gt; pageInfo=new PageInfo&lt;&gt;(users);System.out.println(pageInfo);System.out.println(&quot;页码：&quot;+pageInfo.getPageNum());System.out.println(&quot;页大小：&quot;+pageInfo.getPageSize());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;分页数据：&quot;+pageInfo.getList()); 十一、其他1. MyBatisX​ 一款全免费且强大的 IDEA 插件，支持跳转，自动补全生成 SQL，代码生成。 1234567891011create table t_product( pro_id int primary key auto_increment comment &#x27;编号&#x27;, pro_name varchar(100) comment &#x27;产品名称&#x27;, pro_price decimal(10,2) comment &#x27;产品价格&#x27;, pro_number int comment &#x27;产品数量&#x27;, pro_introduce text comment &#x27;产品介绍&#x27;, pro_state tinyint comment &#x27;产品状态(0未通过,1审核中,2已审核)&#x27;, add_time datetime comment &#x27;添加时间&#x27;, is_del tinyint comment &#x27;是否删除(0正常,1删除)&#x27;) engine innodb default charset utf8 comment &#x27;产品表&#x27;; 1234&lt;settings&gt; &lt;!-- 下划线映射为驼峰 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 2. MyBatisCodeHelperPro​ 功能更强大，收费！","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"}]},{"title":"Maven学习","slug":"Maven学习","date":"2023-08-07T01:16:39.000Z","updated":"2023-08-08T05:29:16.000Z","comments":true,"path":"2023/08/07/Maven学习/","link":"","permalink":"http://example.com/2023/08/07/Maven%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一、Maven简介1. 什么是Maven​ maven [ˈmeɪvn] 专家、内行 ​ Apache Maven 是一个软件项目管理和构建工具，可以帮助创建和管理项目 ​ 基于项目对象模型（POM：Project Object Model）的概念，帮助开发者构建一个项目的完整生命周期 ​ 官网：http://maven.apache.org/ 2. 为什么使用Maven 项目的管理工具 项目规模很大时一定会将项目进行拆分，拆分成多个工程，使用Maven在多个工程之间建立依赖关系 jar包的管理工具 通过仓库管理jar包、解决jar包的依赖、自动下载jar包 自动化的构建工具 编译代码、执行测试、打包、部署等 3. 术语 中央仓库 是一个网络仓库，用于存放jar包和maven插件 https://repo1.maven.org/maven2 https://mvnrepository.com 本地仓库 从中央仓库下载的jar包的存放位置，也是一个仓库，只不过是存放在本地电脑上 镜像仓库 对中央仓库做的镜像（mirror） 阿里云提供的镜像仓库 https://maven.aliyun.com/repository/public 私服 局域网内部搭建的maven服务器 二、安装Maven1. 下载安装包​ 从maven官网下载安装包，这里使用apache-maven-3.6.0-bin.tar.gz 2. 解压安装包​ 将安装包解压到无中文、无空格的路径下，如：D:\\software\\apache-maven-3.6.0 ​ 配置环境变量，将bin目录添加到Path变量中，如：D:\\software\\apache-maven-3.6.0\\bin ​ 测试，在DOS窗口中执行以下命令： 1mvn -version 3. 配置本地仓库本地仓库的默认位置： ~&#x2F;.m2&#x2F;repository（如 C:&#x2F;Users&#x2F;登录用户&#x2F;.m2&#x2F;repository） 修改本地仓库的位置：编辑conf&#x2F;setting.xml文件 1234&lt;settings&gt; &lt;!--指定本地仓库的位置--&gt; &lt;localRepository&gt;D:\\maven-repos&lt;/localRepository&gt;&lt;/settings&gt; 4. 配置镜像仓库​ 使用maven时默认从中央仓库下载所需的包(插件)，比较慢，可以配置使用阿里云提供的镜像仓库 ​ 编辑maven主目录下的&#x2F;conf&#x2F;setting.xml文件，在&lt;mirrors&gt;&lt;/mirrors&gt;标签中添加如下内容： 123456&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;!-- 名称自定义，必须唯一 --&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;!-- 所有访问都使用该镜像仓库 --&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 5. 配置Maven的JDK版本​ 修改maven默认使用的jdk版本，编辑conf&#x2F;setting.xml文件，在profiles标签里面添加如下内容 123456789101112&lt;profile&gt; &lt;id&gt;jdk‐1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 三、使用Maven1. 在IDEA中集成maven指定Maven主目录和配置文件：Settings——&gt;搜索Maven——&gt;Maven Home directory和User settings file 注：切换Porject后要重新配置maven 2. 创建maven项目File——&gt;New——&gt;Module——&gt;Maven Archetype Archetype：maven-archetype-quickstart（Java项目） &#x2F; maven-archetype-webapp（Java Web项目） GroupId : net.wanho.shop（组织域名反向+项目名称） ArtifactId : shop-product（模块名称） Version : 1.0.1（版本） 3. 目录结构Maven项目的目录结构如下： 1234567891011121314|-项目名称 |-src //程序代码 |-main //主代码 |-java //源代码 |-用于存放源代码，相当于传统项目中的src，传统项目的包名.类名，如net.wanho.shop.dao |-resources //配置文件 |-用于存放配置文件 |-webapp //网站根目录 |-WEB-INF |-web.xml |-test //测试代码，目录结构和main中完全一致 |-java |-resources |-pom.xml //maven核心配置文件 如果没有对应的目录，可以自己创建，但必须符合该目录结构 在IDEA中目录是分类型的，常用的有四种： Sources Root：主代码的目录——&gt;src&#x2F;main&#x2F;java Test Sources Root：测试代码的目录——&gt;src&#x2F;test&#x2F;java Resources Root：主代码所需资源的目录——&gt;src&#x2F;main&#x2F;resources Test Resources Root：测试代码所需资源的目录——&gt;src&#x2F;test&#x2F;resources 默认情况下新建的目录是普通的Directory，创建后可以设置目录的类型： 右击目录——&gt;Mark Directory As 每种目录的图标有所不同 4. 执行maven操作在IDEA中管理所有Maven项目：View——&gt;Tool Windows——&gt;Maven Maven项目的生命周期： 命令 作用 描述 clean 清理 删除target目录 compile 编译 将main&#x2F;中的源代码编译成字节码文件，放在target&#x2F;classes目录下 test 测试 执行测试类（使用JUnit），并生成测试报告，放在target&#x2F;surefire-reports目录下 package 打包 将java项目打包成jar，将web项目打包成war，放在target目录下 install 安装 将项目的jar包安装到本地仓库，供其他项目使用 注意： 问题：在Maven Projects中项目显示为灰色，表示该maven项目未被管理，不可用 解决：在Maven Projects里点击”+”，选择项目对应的pom.xml文件 四、pom.xml文件1. 简介​ pom:project object model 项目对象模型 ​ pom.xml是Maven的核心配置文件，与项目构建相关的所有配置都在该文件中 2. 坐标​ 用来唯一的标识每个项目，必须为项目定义坐标，且坐标必须唯一 ​ Maven坐标是通过一些元素定义的：groupId、artifactId、version 123456789&lt;!-- 坐标： groupId：定义组织id，表示当前模块隶属的项目，采用&quot;组织域名反向+项目名称&quot; artifactId：定义模块id version：定义当前的版本--&gt;&lt;groupId&gt;net.wanho.shop&lt;/groupId&gt;&lt;artifactId&gt;shop-product&lt;/artifactId&gt;&lt;version&gt;1.0.1&lt;/version&gt; 3. dependency​ 如何查找一个jar包的坐标? https://mvnrepository.com 12345678910111213141516171819202122232425262728293031&lt;!-- dependency基本配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; ​ scope表示依赖的作用域，用来配置依赖的jar包的可作用范围，即在什么地方可以使用 取值 含义 举例 compile 表示该依赖可以在整个项目中使用，参与打包部署，默认值 fastjson test 表示该依赖只能在测试程序中使用，不参与打包和部署 junit provided 表示编写源代码的时候需要，不参与打包部署 lombok、servlet-api（因为tomcat中已有） runtime 表示运行时需要，编译代码时不需要 mysql-connector（通过接口反射加载） 4. properties​ 全局属性，一般情况下用于定义全局的jar的版本 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 可以自定义标签名，然后使用 $&#123;标签名&#125; 获取标签中的值 一般情况下用于定义全局的jar的版本，相当于定义全局变量 --&gt; &lt;spring.version&gt;5.3.27&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 注：快速将jar包的版本添加到properties中：右击版本号——&gt;Refactor——&gt;Property 5. repositories​ 用于配置当前工程使用的远程仓库 ​ 查找顺序：本地仓库、pom.xml中配置的远程仓库、maven主录下的conf&#x2F;setting.xml中配置的远程仓库 1234567&lt;repositories&gt; &lt;!-- 有些最新版本的jar包，在中央仓库中可能并没有，此时可以指定其他可用的远程仓库 --&gt; &lt;repository&gt; &lt;id&gt;springio&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 6. plugins插件是一种工具，如 maven-clean-plugin插件是用来清理项目的工具 maven-compile-plugin插件是用来编译代码的工具 tomcat7-maven-plugin插件是用来将web项目自动打包并部署到tomcat的工具 1234567891011121314&lt;build&gt; &lt;plugins&gt; &lt;!-- tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8888&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 7. 案例Web应用的开发，模块名称：shop-user 步骤： 添加依赖 12345678910111213&lt;!-- servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 创建HelloServlet类 1234567891011121314151617@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setAttribute(&quot;name&quot;,&quot;tom&quot;); List&lt;Integer&gt; nums = Arrays.asList(13, 25, 38); req.setAttribute(&quot;nums&quot;,nums); Properties p=new Properties(); p.load(HelloServlet.class.getClassLoader().getResourceAsStream(&quot;stu.properties&quot;)); System.out.println(p); req.setAttribute(&quot;age&quot;,p.getProperty(&quot;age&quot;)); req.setAttribute(&quot;sex&quot;,p.getProperty(&quot;sex&quot;)); req.getRequestDispatcher(&quot;/index.jsp&quot;).forward(req,resp); &#125;&#125; 创建index.jsp 1234567891011121314151617&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--默认生成的web.xml文件使用的是web-app_2_3.dtd，会忽略EL表达式，需要启用EL表达式--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 姓名：$&#123;name&#125; &lt;br&gt; &lt;ul&gt; &lt;c:forEach items=&quot;$&#123;hobbies&#125;&quot; var=&quot;hobby&quot;&gt; &lt;li&gt;$&#123;hobby&#125;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; stu.properties 123name=aliceage=21sex=male 五、Maven中的关系1. 继承含义：一个Maven工程继承自另一个Maven工程，分别称为子工程、父工程 场景：实际开发中一个大项目会拆分为多个子项目（子模块&#x2F;子工程），多个子工程使用的技术基本都相同，即多个子工程中使用的是相同的依赖或插件等配置，此时可以把相同配置抽取到一个父工程中，进行统一管理，保持一致性，简化pom.xml配置 步骤： 创建三个工程：子工程child01和child02、父工程parent 将父项目的打包方式设置为pom 12345678&lt;!-- 打包方式 jar：java项目的打包方式，默认值 war：web项目的打包方式 pom：父项目的打包方式 注：将父工程打包方式设置为pom后，父工程将不会被打包，因此不要在父工程中写java代码，父工程只是用来简化POM配置 --&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 在子项目中引用父项目，指定父项目的坐标，并指定父项目pom.xml文件的路径 12345678&lt;!-- 引用父项目，指定父项目的坐标 --&gt;&lt;parent&gt; &lt;groupId&gt;net.wanho.study&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 指定父项目pom.xml文件的相对物理路径 --&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; 注：如果子项目的位置是在父项目所在的目录中，则可以省略不配置relativePath项 问题：有时并不是父项目的所有ja包都需要被子项目继承，但又希望能够对依赖进行统一管理，如：jar包版本的控制，怎么办？ 解决：配置dependencyManagement 步骤： 在父项目中配置dependencyManagement此时父项目只进行jar包的管理，父项目的jar包默认并不会被子项目继承 12345678910111213141516171819202122&lt;!-- dependencyManagement表示父项目只进行依赖的管理，依赖默认不会被子项目继承 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在子项目中引用父项目中的依赖 如果子项目想继承父项目的jar包，需要在子项目中手动引用，且引用时只需要配置groupId和artifactId，无需指定版本version 123456789101112131415&lt;dependencies&gt; &lt;!-- 父项目配置dependencyManagement后默认并不会继承过来，需要手动在子项目中引用 只需要指定groupId和artifactId，无需指定版本version 可以指定要引用的依赖，并不一定要使用父项目中所有的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 聚合将多个子项目聚合到一个父项目中，然后通过对该父项目进行操作，从而实现对所有的聚合项目的操作 在父项目中聚合子项目： 12345&lt;!-- 聚合子项目，指定子项目的根目录--&gt;&lt;modules&gt; &lt;module&gt;../child01&lt;/module&gt; &lt;module&gt;../child02&lt;/module&gt;&lt;/modules&gt; 3. 依赖项目C —&gt; 项目B —&gt; 项目A 概念：如果项目C依赖于项目B，项目B依赖于项目A，则项目C也依赖于项目A，这叫依赖的传递 步骤： 配置依赖关系 child03——&gt;child02——&gt;child01 在child01中添加依赖时，child02和child03会传递该依赖，也会出现该依赖 3.1 控制依赖的传递并不是所有的依赖都会被传递： scope为compile的依赖会被传递 scope为test和provided的依赖不会被传递 配置optional为true的依赖不会被传递 123456&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 表示该jar包不传递 --&gt;&lt;/dependency&gt; 3.2 继承和依赖的区别继承： 使用&lt;parent&gt; 继承是指子项目可以继承父项目的数据和配置，从而简化配置 继承时父项目一般都是自己创建的项目，也可以是第三方的 依赖： 使用&lt;dependencies&gt; 依赖是指jar包可以通过依赖的方式引入 依赖时所依赖的jar包一般多是第三方的，也可以是自己创建的依赖项目 六、Maven综合应用1. 分析将项目分为多个工程，可以按层次分，也可以按模块分，或者同时按层次和模块分 以ums为例，使用Maven创建和管理项目： 父工程：ums-parent dao工程：ums-dao service工程：ums-service web工程：ums-web 2. 步骤2.1 创建工程 创建父工程：ums-parent File——&gt;New——&gt;Module——&gt;Maven Archetype——&gt;maven-archetype-quickstart GroupId：net.wanho.ums ArtifactId：ums-parent Context root：~&#x2F;IdeaProjects&#x2F;framework&#x2F;ums-parent 创建子工程：ums-dao 右键ums-parent父工程——&gt;New——&gt;Module——&gt;Maven Archetype——&gt;maven-archetype-quickstart ArtifactId：ums-dao Content root：~&#x2F;IdeaProjects&#x2F;framework&#x2F;ums-parent&#x2F;ums-dao 创建子工程：ums-service 创建子工程：ums-web，web工程 2.2 配置依赖 在父工程中配置依赖管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;javax.servlet-api.version&gt;4.0.1&lt;/javax.servlet-api.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;mysql-connector-java.version&gt;5.1.38&lt;/mysql-connector-java.version&gt; &lt;fastjson.version&gt;1.2.31&lt;/fastjson.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;hutool-all.version&gt;5.8.15&lt;/hutool-all.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hutool --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;$&#123;hutool-all.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在各个子工程中引用依赖 ums-dao 123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; ums-service 123456&lt;!-- 依赖于dao --&gt;&lt;dependency&gt; &lt;groupId&gt;net.wanho.ums&lt;/groupId&gt; &lt;artifactId&gt;ums-dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; ums-web 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 依赖于service --&gt; &lt;dependency&gt; &lt;groupId&gt;net.wanho.ums&lt;/groupId&gt; &lt;artifactId&gt;ums-service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 部署访问 先对其他模块进行install操作，然后再对ums-web进行部署访问 2.3 配置dao子工程​ create.sql 123456789drop database if exists ums;create database ums charset utf8;use ums;create table t_user( id int primary key auto_increment, username varchar(100), password varchar(100), age int) engine=Innodb charset utf8; ​ datasource.properties 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ums?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=root 2.3 配置service子工程2.4 配置web子工程2.5 测试​ 只要修改了其他模块，都需要先对这些模块进行install操作，然后再对ums-web进行部署访问","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"}]},{"title":"Java-后端多表增删改查","slug":"Java-后端多表增删改查","date":"2023-07-30T11:27:36.000Z","updated":"2023-08-03T02:36:11.000Z","comments":true,"path":"2023/07/30/Java-后端多表增删改查/","link":"","permalink":"http://example.com/2023/07/30/Java-%E5%90%8E%E7%AB%AF%E5%A4%9A%E8%A1%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","excerpt":"","text":"1. Many2One1.1 数据建模关系图 表结构123456789101112131415161718192021222324252627282930313233drop table if exists t_clazz;/*==============================================================*//* Table: t_clazz 父 *//*==============================================================*/create table t_clazz( bno varchar(20) not null, name varchar(20), primary key (bno));alter table t_clazz comment &#x27;班级表&#x27;;drop table if exists t_student;/*==============================================================*//* Table: t_student 子 *//*==============================================================*/create table t_student( sid varchar(20) not null comment &#x27;学号 主键&#x27;, name varchar(20) comment &#x27;姓名&#x27;, age int(3) comment &#x27;年龄&#x27;, sex int(1) comment &#x27;性别 0 男 1 女&#x27;, bno varchar(20), primary key (sid));alter table t_student comment &#x27;学生信息表&#x27;;alter table t_student add constraint FK_stu_clazz_bno foreign key (bno) references t_clazz (bno) on delete restrict on update restrict; 表数据12345678910111213141516171819public abstract class BaseTest &#123; protected JDBCTemplate jdbcTemplate = new JDBCTemplate() ; // 初始化 测试环境 @Before public void before()&#123; //清空表数据 truncate table 截断表 无法使用 关联关系 先删除儿子 在删除爹 jdbcTemplate.update(&quot;delete from t_student &quot;) ; jdbcTemplate.update(&quot;delete from t_clazz &quot;) ; //插入班级数据 jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B001&#x27;,&#x27;Java177&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B002&#x27;,&#x27;Java178&#x27;)&quot;) ; //插入 68 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student(sid,name,age,sex,bno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;张三&quot;+(i+1)+&quot;&#x27;,18,0,&#x27;B001&#x27;)&quot;) ; &#125; &#125;&#125; 1.2 领域建模1234public class Clazz &#123; private String bno ; private String name ;&#125; 1234567public class Student &#123; private String sid ; private String name ; private Integer age ; private Integer sex ; private Clazz clazz = new Clazz() ;&#125; 1.3 列表DAO12-- 分页查询的SQL： select sid,s.name,age,sex,c.bno &quot;clazz.bno&quot;,c.name &quot;clazz.name&quot; from t_student s left join t_clazz c on s.bno = c.bno where 1=1 12345// t_student表 t_clazz表 同名列 二义性 条件查询需指定 哪个表的nameif (query!=null &amp;&amp; StringUtils.isNotEmpty(query.getName())) &#123; sb.append(&quot; and s.name like ?&quot;) ; paramList.add(&quot;%&quot;+query.getName()+&quot;%&quot;); &#125; jsplist-stu.jsp 12345678910111213141516171819202122232425262728293031&lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;班号&lt;/th&gt; &lt;th&gt;班名&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;studentPage.list&#125;&quot; var=&quot;student&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;sid&quot; value=&quot;$&#123;student.sid&#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.clazz.bno&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.clazz.name&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-stu.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-stu.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt;&lt;/table&gt; 1.4 新增beforeDAO123public interface ClazzDAO &#123; List&lt;Clazz&gt; selectAll() ;&#125; 1234567891011public class ClazzDAOImpl implements ClazzDAO &#123; private JDBCTemplate jdbcTemplate = new JDBCTemplate() ; @Override public List&lt;Clazz&gt; selectAll() &#123; String DQL = &quot;select bno,name from t_clazz&quot; ; Object[] paramAy = &#123;&#125; ; return jdbcTemplate.queryList(DQL,Clazz.class,paramAy); &#125;&#125; Service123456789101112public class ClazzService &#123; private ClazzDAO clazzDAO = new ClazzDAOImpl() ; /** * 查询所有班级 * @return */ public Collection&lt;Clazz&gt; list()&#123; return clazzDAO.selectAll(); &#125;&#125; Controller1234567891011121314151617@WebServlet(...&quot;/toAddView-stu.do&quot;&#125;)public class StudentServlet extends HttpServlet &#123; private ClazzService clazzService = new ClazzService() ; ... service(..)&#123; else if (&quot;/toAddView-stu.do&quot;.equals(requestURI))&#123; this.toAddView(request,response) ; &#125; &#125; //跳转到新增学生界面 protected void toAddView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Collection&lt;Clazz&gt; clazzList = clazzService.list(); request.setAttribute(&quot;clazzList&quot;,clazzList); request.getRequestDispatcher(&quot;/add-stu.jsp&quot;).forward(request,response); &#125;&#125; Jsplist-stu.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toAddView-stu.do&quot; class=&quot;btn btn-primary&quot;&gt;添加学生&lt;/a&gt; add-stu.jsp 1234567891011&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;班级&lt;/label&gt; &lt;select name=&quot;clazz.bno&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择班级--&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;option value=&quot;$&#123;clazz.bno&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/div&gt; 1.5 新增DAO123456@Overridepublic boolean insert(Student student) &#123; String DQL = &quot;insert into t_student(sid,name,age,sex,bno) values (?,?,?,?,?)&quot; ; Object[] paramAy = &#123;student.getSid(),student.getName(),student.getAge(),student.getSex(),student.getClazz().getBno()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; Controller12//重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/page-stu.do&quot;); 1.6 查看jspmodify-stu.jsp 123456789101112131415&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;班级&lt;/label&gt; &lt;select name=&quot;clazz.bno&quot; class=&quot;form-control&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择班级--&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;option value=&quot;$&#123;clazz.bno&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/div&gt;//设置下拉框被选中$(&quot;select&quot;).val(&quot;$&#123;student.clazz.bno&#125;&quot;) Controller123456789101112protected void view(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得查看的学生编号 String sid = request.getParameter(&quot;sid&quot;); //2.调用业务方法 Student student = studentService.get(sid); //3.request作用域中设置 学生信息 request.setAttribute(&quot;student&quot;,student); Collection&lt;Clazz&gt; clazzList = clazzService.list(); request.setAttribute(&quot;clazzList&quot;,clazzList); //4.跳转页面 服务器内部跳转 request.getRequestDispatcher(&quot;/modify-stu.jsp&quot;).forward(request,response); &#125; DAO1String DQL = &quot;select sid,s.name,age,sex,c.bno \\&quot;clazz.bno\\&quot;,c.name \\&quot;clazz.name\\&quot; from t_student s left join t_clazz c on s.bno = c.bno where s.sid=?&quot; ; 1.7 修改DAO123456@Overridepublic boolean update(Student student) &#123; String DQL = &quot;update t_student set name=?,age=?,sex=?,bno=? where sid=?&quot; ; Object[] paramAy = &#123;student.getName(),student.getAge(),student.getSex(),student.getClazz().getBno(),student.getSid()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; 2. One2Many2.1 列表[单表]controller1234567891011121314151617181920212223242526272829303132@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;&#125;)public class ClazzServlet extends HttpServlet &#123; /** 班级业务实例 */ private ClazzService clazzService = new ClazzService() ; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得请求的url 包含项目名 String requestURI = request.getRequestURI(); //2. 去掉项目名 /list-stu.do /add-stu.do requestURI = requestURI.replace(request.getContextPath(),&quot;&quot;); //3.判断 url 与方法 调用 if (&quot;/list-clazz.do&quot;.equals(requestURI))&#123; this.list(request,response) ; &#125; &#125; /** * * @param request * @param response * @throws ServletException * @throws IOException */ protected void list(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 调用业务方法 Collection&lt;Clazz&gt; clazzCollection = clazzService.list(); //2. 把查询数据保存 四种(pageContext,request,session,application)属性作用域中 set ==&gt; list-stu.jsp get request.setAttribute(&quot;clazzList&quot;,clazzCollection); //3. 跳转到 list-stu.jsp request.getRequestDispatcher(&quot;/list-clazz.jsp&quot;).forward(request,response); &#125;&#125; jspindex.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/list-clazz.do&quot;&gt;班级列表&lt;/a&gt; &lt;br&gt; list-clazz.jsp 1234567891011 &lt;c:forEach items=&quot;$&#123;clazzList&#125;&quot; var=&quot;clazz&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;bno&quot; value=&quot;$&#123;clazz.sid&#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;clazz.bno&#125;&lt;/td&gt; &lt;td&gt;$&#123;clazz.name&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-clazz.do?sid=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-clazz.do?sid=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 2.2 新增准备【裸跳页面】逻辑上： 直接怼到页面 比如 add-clazz.jsp OCP A. 代码复用 B.新增班级 【权限访问控制？当前登录用户是否有权限？】 jsplist-clazz.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toAddView-clazz.do&quot; class=&quot;btn btn-primary&quot;&gt;添加班级&lt;/a&gt; add-clazz.jsp 1234567891011121314151617181920212223242526272829&lt;h1&gt;新增班级&lt;/h1&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/add-clazz.do&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sid&quot;&gt;班号&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sid&quot; name=&quot;bno&quot; value=&quot;$&#123;param.bno&#125;&quot; placeholder=&quot;请输入班号&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sname&quot;&gt;班名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sname&quot; name=&quot;name&quot; value=&quot;$&#123;param.name&#125;&quot; placeholder=&quot;请输入班名&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;新增&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;重置&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; Controller1234567891011// ClazzServlet@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;&#125;).... else if(&quot;/toAddView-clazz.do&quot;.equals(requestURI))&#123; this.toAddView(request,response) ; &#125;//跳转到新增班级界面protected void toAddView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher(&quot;/add-clazz.jsp&quot;).forward(request,response);&#125; 2.3 新增【单表】controller12345678910111213141516171819202122232425262728//添加新的请求 url@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;&#125;)//添加判断 调用自定义的方法else if(&quot;/add-clazz.do&quot;.equals(requestURI))&#123; this.add(request,response) ;&#125;protected void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置请求中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); //调用 自定义 工具类 实现：解析请求自动封装 pojo中 Clazz clazz = RequestUtil.parseParameter(request, Clazz.class); //4. 调用业务方法 boolean saveRs = clazzService.save(clazz); //5. 根据业务方法的返回值 if (saveRs)&#123; //6.响应 //重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do&quot;); return; &#125; //新增失败 view实现显示效果 request.setAttribute(&quot;errorMsg&quot;,&quot;班号已经存在！！！&quot;); //使用服务器内部跳转 request.getRequestDispatcher(&quot;/toAddView-clazz.do&quot;).forward(request,response);&#125; Service12345678910111213... ClazzService &#123; public boolean save(Clazz clazz) &#123; //获得新增的班号 String bno = clazz.getBno() ; //1.判断是否 新增的班号 db 中已经存在 Clazz dbClazz = clazzDAO.selectById(bno); if (dbClazz!=null)&#123; return false ; &#125; //班号不存在 向数据库插入数据 return clazzDAO.insert(clazz) ; &#125;&#125; DAO12345... ClazzDAO&#123; Clazz selectById(String bno); boolean insert(Clazz clazz);&#125; 123456789101112131415... ClazzDAOImpl ... &#123; @Override public Clazz selectById(String bno) &#123; String DQL = &quot;select bno,name from t_clazz where bno=?&quot; ; Object[] paramAy = &#123;bno&#125; ; return jdbcTemplate.queryObject(DQL,Clazz.class,paramAy); &#125; @Override public boolean insert(Clazz clazz) &#123; String DQL = &quot;insert into t_clazz(bno,name) values (?,?)&quot; ; Object[] paramAy = &#123;clazz.getBno(),clazz.getName()&#125; ; return jdbcTemplate.update(DQL,paramAy); &#125;&#125; 2.4 删除【单表&#x2F;子记录依赖】jsplist-clazz.jsp 123 &lt;form action=&#x27;$&#123;pageContext.request.contextPath&#125;/del-clazz.do&#x27;&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;bno&quot; value=&quot;$&#123;clazz.bno&#125;&quot; /&gt;&lt;/td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/del-clazz.do?bno=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;/a&gt; controller1234567891011121314151617181920@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;&#125;)else if(&quot;/del-clazz.do&quot;.equals(requestURI))&#123; this.del(request,response) ;&#125;protected void del(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得 删除的班号 String[] idAy = request.getParameterValues(&quot;bno&quot;); //把数组 拼接成一个 字符串 String id =&quot;&quot;; for (String s : idAy) &#123; id +=s+&quot;,&quot; ; &#125; id = id.substring(0,id.length()-1) ; //2. 调用业务方法 boolean removeRs = clazzService.remove(id); String msg = removeRs?&quot;&quot;:&quot;del-fail&quot; ; response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do?msg=&quot;+msg);&#125; Service123456789101112131415161718public class ClazzService &#123; private StudentDAO studentDAO = new StudentDAOImpl() ; public boolean remove(String id) &#123; //字符串 转成数组 String[] sidAy = id.split(&quot;,&quot;); for (String bno : sidAy) &#123; //根据FK 查询学生列表 List&lt;Student&gt; studentList = studentDAO.selectByFk(bno); //删除班级编号 在学生表中出现了 不能删除 if (!studentList.isEmpty())&#123; return false ; &#125; &#125; //调用批处理删除 return clazzDAO.delete(sidAy) ; &#125;&#125; DAOStudentDAO1List&lt;Student&gt; selectByFk(String bno) ; 123456@Overridepublic List&lt;Student&gt; selectByFk(String bno) &#123; String DQL = &quot;select sid,name,age,sex from t_student where bno=?&quot; ; Object[] paramAy = &#123;bno&#125; ; return jdbcTemplate.queryList(DQL,Student.class,paramAy);&#125; ClazzDAO1boolean delete(String ... idAy) ; 123456789101112public class ClazzDAOImpl implements ClazzDAO &#123; @Override public boolean delete(String... sidAy) &#123; String DML = &quot;delete from t_clazz where bno=?&quot; ; Object[][] paramAy = new Object[sidAy.length][1] ; for (int i = 0; i &lt; sidAy.length; i++) &#123; paramAy[i][0] = sidAy[i] ; &#125; return jdbcTemplate.updateBatch(DML,paramAy); &#125;&#125; 2.5 查看【N+1】jsplist-clazz.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/view-clazz.do?bno=$&#123;clazz.bno&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;修改&lt;/a&gt; modify-clazz.jsp 1234567891011121314151617&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;sname&quot; name=&quot;name&quot; value=&quot;$&#123;clazz.name&#125;&quot; placeholder=&quot;请输入班名&quot;/&gt;&lt;c:forEach items=&quot;$&#123;clazz.studentList&#125;&quot; var=&quot;student&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; Controller1234567891011121314151617@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;,&quot;/view-clazz.do&quot;&#125;)else if(&quot;/view-clazz.do&quot;.equals(requestURI))&#123; this.view(request,response) ;&#125;protected void view(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得查看的学生编号 String bno = request.getParameter(&quot;bno&quot;); //2.调用业务方法 Clazz clazz = clazzService.get(bno) ; //3.request作用域中设置 学生信息 request.setAttribute(&quot;clazz&quot;,clazz); //4.跳转页面 服务器内部跳转 request.getRequestDispatcher(&quot;/modify-clazz.jsp&quot;).forward(request,response);&#125; Service12345678910 public Clazz get(String bno) &#123; //N+1查询 //1. 根据班级id 查询 班级对象 单表查询 Clazz clazz = clazzDAO.selectById(bno); //2. 根据班级id 查询当前班级的学生列表 单表查询 List&lt;Student&gt; studentList = studentDAO.selectByFk(bno); //3.当前班级对象的 stuList属性进行赋值 clazz.setStudentList(studentList); return clazz ;&#125; 2.6 修改【单表】jspmodify-clazz.jsp 12&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/modify-clazz.do&quot; method=&quot;post&quot;&gt; .... controller123456789101112131415161718192021222324@WebServlet(name = &quot;ClazzServlet&quot;,urlPatterns = &#123;&quot;/list-clazz.do&quot;,&quot;/toAddView-clazz.do&quot;,&quot;/add-clazz.do&quot;,&quot;/del-clazz.do&quot;,&quot;/view-clazz.do&quot;,&quot;/modify-clazz.do&quot;&#125;)else if(&quot;/modify-clazz.do&quot;.equals(requestURI))&#123; this.modify(request,response) ;&#125;protected void modify(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置请求中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); //调用 自定义 工具类 实现：解析请求自动封装 pojo中 Clazz clazz = RequestUtil.parseParameter(request, Clazz.class); //4. 调用业务方法 boolean modifyRs = clazzService.modify(clazz); //5. 根据业务方法的返回值 if (modifyRs)&#123; //6.响应 //重定向 进行查询 response.sendRedirect(request.getContextPath()+&quot;/list-clazz.do&quot;); return; &#125; request.setAttribute(&quot;errorMsg&quot;,&quot;修改班级失败！！！&quot;); request.getRequestDispatcher(&quot;/view-clazz.do&quot;).forward(request,response);&#125; Service123public boolean modify(Clazz clazz) &#123; return clazzDAO.update(clazz) ;&#125; DAO1boolean update(Clazz clazz); 123456@Overridepublic boolean update(Clazz clazz) &#123; String DQL = &quot;update t_clazz set name=? where bno=?&quot; ; Object[] paramAy = &#123;clazz.getName(),clazz.getBno()&#125; ; return jdbcTemplate.update(DQL,paramAy);&#125; 3. Many2Many3.1 数据建模表关系 表结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869drop table if exists t_clazz;/*==============================================================*//* Table: t_clazz 父 *//*==============================================================*/create table t_clazz( bno varchar(20) not null, name varchar(20), primary key (bno));alter table t_clazz comment &#x27;班级表&#x27;;drop table if exists t_student;/*==============================================================*//* Table: t_student 子 *//*==============================================================*/create table t_student( sid varchar(20) not null comment &#x27;学号 主键&#x27;, name varchar(20) comment &#x27;姓名&#x27;, age int(3) comment &#x27;年龄&#x27;, sex int(1) comment &#x27;性别 0 男 1 女&#x27;, bno varchar(20), primary key (sid));alter table t_student comment &#x27;学生信息表&#x27;;drop table if exists t_teacher;/*==============================================================*//* Table: t_teacher *//*==============================================================*/create table t_teacher( tno varchar(20) not null, tname varchar(20), primary key (tno));alter table t_teacher comment &#x27;教师表&#x27;;drop table if exists t_student_teacher;/*==============================================================*//* Table: t_student_teacher *//*==============================================================*/create table t_student_teacher( tno varchar(20) not null, sid varchar(20) not null comment &#x27;学号 主键&#x27;, primary key (tno, sid));alter table t_student_teacher comment &#x27;教师学生关系表&#x27;;alter table t_student_teacher add constraint FK_stu_teacher_teacher_tno foreign key (tno) references t_teacher (tno) on delete restrict on update restrict;alter table t_student_teacher add constraint FK_stu_teacher_stu_sid foreign key (sid) references t_student (sid) on delete restrict on update restrict;alter table t_student add constraint FK_stu_clazz_bno foreign key (bno) references t_clazz (bno) on delete restrict on update restrict; 表数据12345678910111213141516171819202122232425@Beforepublic void before()&#123; //清空表数据 truncate table 截断表 无法使用 关联关系 先删除儿子 在删除爹 jdbcTemplate.update(&quot;delete from t_student_teacher &quot;) ; jdbcTemplate.update(&quot;delete from t_teacher &quot;) ; jdbcTemplate.update(&quot;delete from t_student &quot;) ; jdbcTemplate.update(&quot;delete from t_clazz &quot;) ; //插入班级数据 jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B001&#x27;,&#x27;Java177&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_clazz(bno,name) values (&#x27;B002&#x27;,&#x27;Java178&#x27;)&quot;) ; //插入学生 68 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student(sid,name,age,sex,bno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;张三&quot;+(i+1)+&quot;&#x27;,18,0,&#x27;B001&#x27;)&quot;) ; &#125; //插入教师数据 jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T001&#x27;,&#x27;赵贺贺&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T002&#x27;,&#x27;赵健&#x27;)&quot;) ; jdbcTemplate.update(&quot;insert into t_teacher(tno,tname) values (&#x27;T003&#x27;,&#x27;马美平&#x27;)&quot;) ; //插入学生与教师关系表 68*2 条测试数据 for (int i = 0; i &lt; 68; i++) &#123; jdbcTemplate.update(&quot;insert into t_student_teacher(sid,tno) values (&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;T001&#x27;),(&#x27;S&quot;+(i+1)+&quot;&#x27;,&#x27;T002&#x27;)&quot;) ; &#125;&#125; 3.2 列表pojo1234public class Teacher &#123; private String tno ; private String tname ;&#125; 12345public class Student &#123; ... /**Many2Many 一个学生拥有多个老师 */ private List&lt;Teacher&gt; teacherList ;&#125; DAO123public interface TeacherDAO &#123; List&lt;Teacher&gt; selectBySid(String sid) ;&#125; 123456789public class TeacherDAOImpl implements TeacherDAO &#123; private JDBCTemplate jdbcTemplate = new JDBCTemplate() ; @Override public List&lt;Teacher&gt; selectBySid(String sid) &#123; String DQL = &quot;select tno,tname from t_teacher where tno in (select tno from t_student_teacher where sid = ?)&quot; ; Object[] paramAy = &#123;sid&#125; ; return jdbcTemplate.queryList(DQL, Teacher.class,paramAy); &#125;&#125; service123456789101112131415161718192021public class StudentService &#123; private TeacherDAO teacherDAO = new TeacherDAOImpl() ; public void selectPage(Page&lt;Student, StudentQuery&gt; page)&#123; //1.统计总记录数 long count = studentDAO.count(page.getCond()); //2.查询当前页面的数据 List&lt;Student&gt; studentList = studentDAO.selectPage(page); //循环所有的学生列表 for (Student student : studentList) &#123; //根据学号查询老师信息 List&lt;Teacher&gt; teacherList = teacherDAO.selectBySid(student.getSid()); //设置到 当前学生的 关联老师集合属性 student.setTeacherList(teacherList); &#125; //3. 设置总记录数 page.setTotalRecord(count); //4. 设置当前页的数据 page.setList(studentList); &#125;&#125; jsplist-stu.jsp 123456&lt;td&gt; &lt;c:forEach items=&quot;$&#123;student.teacherList&#125;&quot; var=&quot;teacher&quot; varStatus=&quot;vs&quot;&gt; $&#123;teacher.tname&#125; &lt;c:if test=&quot;$&#123;not vs.last&#125;&quot;&gt;,&lt;/c:if&gt; &lt;/c:forEach&gt;&lt;/td&gt; 3.3 显示关联教师DAO123public interface TeacherDAO &#123; List&lt;Teacher&gt; selectAll();&#125; 12345678public class TeacherDAOImpl implements TeacherDAO &#123; @Override public List&lt;Teacher&gt; selectAll() &#123; String DQL = &quot;select tno,tname from t_teacher&quot; ; Object[] paramAy = &#123;&#125; ; return jdbcTemplate.queryList(DQL, Teacher.class,paramAy); &#125;&#125; Service123456789101112131415161718public class StudentService &#123; private TeacherDAO teacherDAO = new TeacherDAOImpl() ; /** * 根据id 查询学生信息 * @param sid * @return */ public Student get(String sid)&#123; //学生信息 班级信息 Student student = studentDAO.selectById(sid) ; // N+1 根据学生id 查询关联的教师 List&lt;Teacher&gt; teacherList = teacherDAO.selectBySid(sid); // 设置当前学生关联的教师信息 student.setTeacherList(teacherList); return student ; &#125;&#125; Controller1234567891011121314151617181920@WebServlet(.... &quot;/toSelectView-teacher.do&quot;&#125;)else if (&quot;/toSelectView-teacher.do&quot;.equals(requestURI))&#123; this.toSelectTeacherView(request,response) ;&#125;protected void toSelectTeacherView(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获得学生的id String sid = request.getParameter(&quot;sid&quot;); //2.查询当前学生信息 Student student = studentService.get(sid); //3.查询所有的老师信息 List&lt;Teacher&gt; teacherList = teacherService.list() ; //4. 数据存放在作用域中 request.setAttribute(&quot;student&quot;,student); request.setAttribute(&quot;teacherList&quot;,teacherList); request.getRequestDispatcher(&quot;/select-teacher.jsp&quot;).forward(request,response);&#125; Jsplist-stu.jsp 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/toSelectView-teacher.do?sid=$&#123;student.sid&#125;&quot; class=&quot;btn btn-info btn-sm&quot;&gt;关联教师&lt;/a&gt; select-teacher.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div class=&quot;container&quot;&gt; &lt;h1&gt;学生选择教师&lt;/h1&gt; &lt;div class=&quot;widget-content padded clearfix&quot;&gt; &lt;!-- 学生基本信息 --&gt; &lt;table class=&quot;table detail-view&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;td&gt;$&#123;student.sid&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性别&lt;/th&gt; &lt;td&gt;$&#123;student.sex eq 0 ?&quot;男&quot;:&quot;女&quot;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;td&gt;$&#123;student.clazz.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;!-- 教师信息 --&gt; &lt;form action=&quot;&quot;&gt; &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/th&gt; &lt;th&gt;工号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;teacherList&#125;&quot; var=&quot;teacher&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;tno&quot; value=&quot;$&#123;teacher.tno&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;$&#123;teacher.tno&#125;&lt;/td&gt; &lt;td&gt;$&#123;teacher.tname&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;关联教师&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 循环当前学生的关联老师信息 &lt;c:forEach items=&quot;$&#123;student.teacherList&#125;&quot; var=&quot;teacher&quot;&gt; $(&quot;:checkbox[value=&#x27;$&#123;teacher.tno&#125;&#x27;]&quot;).prop(&#x27;checked&#x27;,true) &lt;/c:forEach&gt;&lt;/script&gt; 3.4 设置关联教师jspselect-teacher.jsp 123456 &lt;!-- 教师信息 --&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/set-teacher.do&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sid&quot; value=&quot;$&#123;student.sid&#125;&quot;&gt;.... &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;tno&quot; value=&quot;$&#123;teacher.tno&#125;&quot;/&gt;&lt;/td&gt; DAO12345public interface StudentDAO &#123; boolean deleteRefBySid(String sid) ; boolean insertRef(Student student) ;&#125; 12345678910111213141516171819202122232425public class StudentDAOImpl implements StudentDAO &#123; @Override public boolean deleteRefBySid(String sid) &#123; String DQL = &quot;delete from t_student_teacher where sid = ?&quot; ; Object[] paramAy = &#123;sid&#125; ; return jdbcTemplate.update(DQL,paramAy); &#125; @Override public boolean insertRef(Student student) &#123; //获得当前学生的学号 String sid = student.getSid(); //获得当前学生关联的教师信息 List&lt;Teacher&gt; teacherList = student.getTeacherList(); String DML = &quot;insert into t_student_teacher(sid,tno) values(?,?)&quot; ; Object[][] paramAy = new Object[teacherList.size()][2] ; for (int i = 0; i &lt; teacherList.size(); i++) &#123; //教师信息 Teacher teacher = teacherList.get(i); paramAy[i][0] = sid ; paramAy[i][1] = teacher.getTno() ; &#125; return jdbcTemplate.updateBatch(DML,paramAy); &#125;&#125; Service12345678910public class StudentService &#123; public boolean setTeacher(Student student)&#123; //1.中间表删除 当前学号 关联所有信息 boolean delRs = studentDAO.deleteRefBySid(student.getSid()) ; //2.批量新增 中间表 关联信息 boolean insertRs = studentDAO.insertRef(student) ; return delRs &amp;&amp; insertRs ; &#125;&#125; controller123456789101112131415161718192021222324252627@WebServlet(...&quot;/set-teacher.do&quot;&#125;)else if (&quot;/set-teacher.do&quot;.equals(requestURI))&#123; this.setTeacher(request,response) ;&#125;protected void setTeacher(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获得学生的id String sid = request.getParameter(&quot;sid&quot;); // 关联的教师工号 String[] tnoAy = request.getParameterValues(&quot;tno&quot;); //封装学生对象 Student student = new Student(); student.setSid(sid); List&lt;Teacher&gt; teacherList = new ArrayList&lt;&gt;() ; for (String tno : tnoAy) &#123; Teacher teacher = new Teacher(); teacher.setTno(tno); teacherList.add(teacher); &#125; //设置关联关系 student.setTeacherList(teacherList); boolean rs = studentService.setTeacher(student) ; //重新查询 response.sendRedirect(request.getContextPath()+&quot;/page-stu.do&quot;);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Vue指令学习","slug":"Vue指令学习","date":"2023-07-24T06:34:03.000Z","updated":"2023-07-25T11:25:24.000Z","comments":true,"path":"2023/07/24/Vue指令学习/","link":"","permalink":"http://example.com/2023/07/24/Vue%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Vue构成vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。之前接触到的 App.vue 文件本质上就是一个 vue 的组件。每个 .vue 组件都由 3 部分构成，分别是： 模板结构 功能 template 组件的模板结构 script 组件的 JavaScript 行为 style 组件的样式 其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。vue 规定：每个组件对应的模板结构，需要定义到 template 节点中。 在 template 中使用指令在组件的 template 节点中，支持使用前面所学的指令语法，来辅助开发者渲染当前组件的 DOM 结构。代码示例如下： 123456789&lt;template&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;!-- 使用&#123;&#123; &#125;&#125;插值表达式 --&gt;&lt;p&gt;生成一个随机数字: &#123;&#123; (Math. random() * 10). toFixed(2) &#125;&#125;&lt;/p&gt;&lt;!-- 使用v-bind属性绑定 --&gt;&lt;p :title=&quot;new Date().tolocaleTimeString()&quot;&gt;我在学习vue.js&lt;/p&gt;&lt;!-- 属性v-on事件绑定 --&gt;&lt;button @click=”showInfo&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt; 在 template 中定义根节点在 vue 2.x 的版本中，template 节点内的 DOM 结构仅支持单个根节点： 1234567&lt;template&gt; &lt;!-- vue 2.x中，template节点内的所有元素，最外层“必须有”唯一的根节点进行包裹，否则报错 --&gt;&lt;div&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;h2&gt;这是副标题&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt; 但是，在 vue 3.x 的版本中，&lt; template&gt; 中支持定义多个根节点： 12345&lt;template&gt;&lt;!-- 这是包含多个根节点的template结构，因为h1标签和h2标签外层没有包裹性质的根元素 --&gt;&lt;h1&gt;这是App根组件&lt;/h1&gt;&lt;h2&gt;这是副标题&lt;/h2&gt;&lt;/template&gt; 组件的 script 节点vue 规定：组件内的 &lt; script&gt; 节点是可选的，开发者可以在 &lt; script&gt; 节点中封装组件的 JavaScript 业务逻辑。&lt; script &gt; 节点的基本结构如下： 1234&lt;script&gt;//今后，组件相关的data数据、methods方法等，都需要定义到export default所导出的对象中。export default &#123;&#125;&lt;/script&gt; script 中的 name 节点可以通过 name 节点为当前组件定义一个名称，代码如下： 123456&lt;script&gt;export default &#123;// name属性指向的是当前组件的名称（建议：每个单词的首字母大写）name: &#x27;MyApp&#x27;&#125;&lt;/script&gt; 在使用 vue-devtools 进行项目调试的时候，自定义的组件名称可以清晰的区分每个组件。 script 中的 data 节点vue 组件渲染期间需要用到的数据，可以定义在 data 节点中： 123456789101112&lt;script&gt;export default &#123;// 组件的名称 name: &#x27;MyApp&#x27;,// 组件的数据（data方法中return出去的对象，就是当前组件渲染期间需要用到的数据对象） data() &#123; return &#123; username: &#x27;哇哈哈&#x27;, &#125; &#125;,&#125;&lt;/script&gt; 其中组件中的 data 必须是函数，vue 规定：组件中的 data 必须是一个函数，不能直接指向一个数据对象。因此在组件中定义 data 数据节点时，下面的方式是错误的： 123data: &#123; // 组件中，不能直接让 data 指向一个数据对象（会报错） count: 0&#125; script 中的 methods 节点组件中的事件处理函数，必须定义到 methods 节点中，示例代码如下： 12345678910111213export default &#123; name: &#x27;MyApp&#x27;, // 组件的名称 data() &#123; // 组件的数据 return &#123; count: 0, &#125; &#125;, methods: &#123; //处理函数 addCount() &#123; this.count++ &#125;, &#125;,&#125; 组件的 style 节点vue 规定：组件内的 &lt; style &gt; 节点是可选的，开发者可以在 &lt; style &gt; 节点中编写样式美化当前组件的 UI 结构。&lt; script &gt; 节点的基本结构如下： 12345&lt;style&gt;h1 &#123;font-weight: normal;&#125;&lt;/style&gt; 其中 &lt; style &gt; &lt;&#x3D;”” font&#x3D;””&gt; 标签上的 lang&#x3D;”css” 属性是可选的，它表示所使用的样式语言。默认只支持普通的 css 语法，可选值还有 less、scss 等。多学一招：让 style 中支持 less 语法：如果希望使用 less 语法编写组件的 style 样式，可以按照如下两个步骤进行配置：① 运行 npm install less -D 命令安装依赖包，从而提供 less 语法的编译支持；② 在 &lt; style &gt; &lt;&#x3D;”” font&#x3D;””&gt; 标签上添加 lang&#x3D;”less” 属性，即可使用 less 语法编写组件的样式。 123456789&lt;style&gt;h1 &#123;font-weight: normal;&#125;i &#123;color: red;font-style: normal;&#125;&lt;/style&gt; Vue指令插值表达式 目的: 在dom标签中, 直接插入内容 又叫: 声明式渲染&#x2F;文本插值 语法: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; person.age &gt; 100 ? `老头` : `小伙` &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // data 格式固定, 定义vue数据之处 data() &#123; // key相当于变量名 return &#123; msg: `hello vue!!!`, person: &#123; name: `张三丰`, age: 108, &#125;, &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 总结: dom中插值表达式赋值, vue的变量必须在data里声明注意点：1.在插值表达式中使用的数据 必须在data中进行了提供2.支持的是表达式，而非语句，比如：if for …3.不能在标签属性中使用插值（插值表达式只能在标签中间使用），比如：&lt;p title=&quot;&#123;&#123;username&#125;&#125;&quot;&gt;我是P标签&lt;/p&gt; v-bind 目标: 给标签属性设置vue变量的值 vue指令, 实质上就是特殊的 html 标签属性, 特点: v- 开头 每个指令, 都有独立的作用 语法：v-bind:属性名=&quot;vue变量&quot; 简写：:属性名=&quot;vue变量&quot; 123456789&lt;!-- vue指令-v-bind属性动态赋值 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;我是a标签&lt;/a&gt;&lt;img :src=&quot;imgSrc&quot;&gt;图片服务器:https://demo-video-oss.oss-cn-hangzhou.aliyuncs.com/images/mm.jpg或 指定尺寸 https://demo-video-oss.oss-cn-hangzhou.aliyuncs.com/images/mm.jpg?x-oss-process=image/resize,w_60,h_60 总结: 把vue变量的值, 赋予给dom属性上, 影响标签显示效果 v-on 目标: 给标签绑定事件 语法 v-on:事件名&#x3D;”要执行的 少量代码 “ v-on:事件名&#x3D;”methods中的函数” v-on:事件名&#x3D;”methods中的函数(实参)” 简写: @事件名&#x3D;”methods中的函数” 123456789101112131415161718192021222324&lt;!-- vue指令: v-on事件绑定--&gt;&lt;p&gt;你要买商品的数量: &#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count = count + 1&quot;&gt;增加1&lt;/button&gt;&lt;button v-on:click=&quot;addFn&quot;&gt;增加1个&lt;/button&gt;&lt;button v-on:click=&quot;addCountFn(5)&quot;&gt;一次加5件&lt;/button&gt;&lt;button @click=&quot;subFn&quot;&gt;减少&lt;/button&gt;&lt;script&gt; export default &#123; // ...其他省略 methods: &#123; addFn()&#123; // this代表export default后面的组件对象(下属有data里return出来的属性) this.count++ &#125;, addCountFn(num)&#123; this.count += num &#125;, subFn()&#123; this.count-- &#125; &#125; &#125;&lt;/script&gt; 总结: 常用@事件名, 给dom标签绑定事件, 以及&#x3D;右侧事件处理函数 v-on事件对象 目标: vue事件处理函数中, 拿到事件对象 语法: 无传参, 通过形参直接接收 传参, 通过$event指代事件对象传给事件处理函数 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止百度&lt;/a&gt; &lt;hr&gt; &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止去百度&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; one(e)&#123; e.preventDefault() &#125;, two(num, e)&#123; e.preventDefault() &#125; &#125;&#125;&lt;/script&gt; v-on修饰符 目的: 在事件后面.修饰符名 - 给事件带来更强大的功能 语法: @事件名.修饰符&#x3D;”methods里函数” .stop - 阻止事件冒泡 .prevent - 阻止默认行为 .once - 程序运行期间, 只触发一次事件处理函数 123456789101112131415161718192021&lt;template&gt; &lt;div @click=&quot;fatherFn&quot;&gt; &lt;!-- vue对事件进行了修饰符设置, 在事件后面.修饰符名即可使用更多的功能 --&gt; &lt;button @click.stop=&quot;btn&quot;&gt;.stop阻止事件冒泡&lt;/button&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;.prevent阻止默认行为&lt;/a&gt; &lt;button @click.once=&quot;btn&quot;&gt;.once程序运行期间, 只触发一次事件处理函数&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fatherFn()&#123; console.log(&quot;father被触发&quot;); &#125;, btn()&#123; console.log(1); &#125; &#125;&#125;&lt;/script&gt; 总结: 修饰符给事件扩展额外功能 v-on按键修饰符 目标: 给键盘事件, 添加修饰符, 增强能力 语法: @keyup.enter - 监测回车按键 @keyup.esc - 监测返回按键 更多修饰符 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; enterFn()&#123; console.log(&quot;enter回车按键了&quot;); &#125;, escFn()&#123; console.log(&quot;esc按键了&quot;); &#125; &#125;&#125;&lt;/script&gt; 总结: 多使用事件修饰符, 可以提高开发效率, 少去自己判断过程 例1：翻转字符串 目标: 点击按钮 - 把文字取反显示 - 再点击取反显示(回来了) 提示: 把字符串取反赋予回去 正确代码: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;反转字符串&lt;/h1&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;reverseStr&quot;&gt;反转字符串&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: `我是我爹的儿`, &#125; &#125;, methods: &#123; reverseStr() &#123; this.msg = this.msg.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 总结: 记住方法特点, 多做需求, vue是数据变化视图自动更新, 减少操作DOM时间, 提高开发效率 v-model 目标: 把value属性和vue数据变量, 双向绑定到一起 语法: v-model&#x3D;”vue数据变量” 双向数据绑定 数据变化 -&gt; 视图自动同步 视图变化 -&gt; 数据自动同步 演示: 用户名绑定 - vue内部是MVVM设计模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;!-- v-model:是实现vuejs变量和表单标签value属性, 双向绑定的指令 --&gt; &lt;div&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; v-model=&quot;pass&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;来自于: &lt;/span&gt; &lt;!-- 下拉菜单要绑定在select上 --&gt; &lt;select v-model=&quot;from&quot;&gt; &lt;option value=&quot;北京市&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;南京市&quot;&gt;南京&lt;/option&gt; &lt;option value=&quot;天津市&quot;&gt;天津&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- (重要) 遇到复选框, v-model的变量值 非数组 - 关联的是复选框的checked属性 数组 - 关联的是复选框的value属性 --&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;抽烟&quot;&gt;抽烟 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;喝酒&quot;&gt;喝酒 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;写代码&quot;&gt;写代码 &lt;/div&gt; &lt;div&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;男 &lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;女 &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍&lt;/span&gt; &lt;textarea v-model=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; username: &quot;&quot;, pass: &quot;&quot;, from: &quot;&quot;, hobby: [], sex: &quot;&quot;, intro: &quot;&quot;, &#125;; // 总结: // 特别注意: v-model, 在input[checkbox]的多选框状态 // 变量为非数组, 则绑定的是checked的属性(true/false) - 常用于: 单个绑定使用 // 变量为数组, 则绑定的是他们的value属性里的值 - 常用于: 收集勾选了哪些值 &#125;&#125;;&lt;/script&gt; 总结: 本阶段v-model只能用在表单元素上, 以后学组件后讲v-model高级用法 v-model修饰符 目标: 让v-model拥有更强大的功能 语法: v-model.修饰符&#x3D;”vue数据变量” .number 以parseFloat转成数字类型 .trim 去除首尾空白字符 （记下：去除字符串中间 空格 不是vue ） .lazy 在change事件时触发而非inupt触发 时 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;span&gt;年龄:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;人生格言:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;motto&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍:&lt;/span&gt; &lt;textarea v-model.lazy=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: &quot;&quot;, motto: &quot;&quot;, intro: &quot;&quot; &#125; &#125;&#125;&lt;/script&gt; 总结: v-model修饰符, 可以对值进行预处理, 非常高效好用 v-text和v-html 目的: 更新DOM对象的innerText&#x2F;innerHTML 语法: v-text&#x3D;”vue数据变量” v-html&#x3D;”vue数据变量” 注意: 会覆盖插值表达式 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; str: &quot;&lt;span&gt;我是一个span标签&lt;/span&gt;&quot; &#125; &#125;&#125;&lt;/script&gt; 总结: v-text把值当成普通字符串显示, v-html把值当做html解析 v-show和v-if 目标: 控制标签的隐藏或出现 语法: v-show&#x3D;”vue变量” v-if&#x3D;”vue变量” 原理 v-show 用的display:none隐藏 (频繁切换使用) v-if 直接从DOM树上移除 高级 v-else使用 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 v-show=&quot;isOk&quot;&gt;v-show的盒子&lt;/h1&gt; &lt;h1 v-if=&quot;isOk&quot;&gt;v-if的盒子&lt;/h1&gt; &lt;div&gt; &lt;p v-if=&quot;age &gt; 18&quot;&gt;我成年了&lt;/p&gt; &lt;p v-else&gt;还得多吃饭&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isOk: true, age: 15 &#125; &#125;&#125;&lt;/script&gt; 总结: 使用v-show和v-if以及v-else指令, 方便通过变量控制一套标签出现&#x2F;隐藏 例2：折叠面板 目标: 点击展开或收起时，把内容区域显示或者隐藏 此案例使用了less语法, 项目中下载模块 1yarn add less@3.0.4 less-loader@5.0.0 -D 只有标签和样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; &gt; 收起 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;寒雨连江夜入吴,&lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;body &#123; background-color: #ccc; #app &#123; width: 400px; margin: 20px auto; background-color: #fff; border: 4px solid blueviolet; border-radius: 1em; box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.5); padding: 1em 2em 2em; h3 &#123; text-align: center; &#125; .title &#123; display: flex; justify-content: space-between; align-items: center; border: 1px solid #ccc; padding: 0 1em; &#125; .title h4 &#123; line-height: 2; margin: 0; &#125; .container &#123; border: 1px solid #ccc; padding: 0 1em; &#125; .btn &#123; /* 鼠标改成手的形状 */ cursor: pointer; &#125; &#125;&#125;&lt;/style&gt; 参考答案: 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt; &#123;&#123; isShow ? &#x27;收起&#x27; : &#x27;展开&#x27; &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt; &lt;p&gt;寒雨连江夜入吴, &lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isShow: false &#125; &#125;&#125;&lt;/script&gt; v-for 目标: 列表渲染, 所在标签结构, 按照数据数量, 循环生成 语法 v-for&#x3D;”(值, 索引) in 目标结构” v-for&#x3D;”值 in 目标结构” 目标结构: 可以遍历数组 &#x2F; 对象 &#x2F; 数字 &#x2F; 字符串 (可遍历结构) 注意: v-for的临时变量名不能用到v-for范围外 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- v-for 把一组数据, 渲染成一组DOM --&gt; &lt;!-- 口诀: 让谁循环生成, v-for就写谁身上 --&gt; &lt;p&gt;学生姓名&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;item&quot;&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;学生详细信息&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;obj in stuArr&quot; :key=&quot;obj.id&quot;&gt; &lt;span&gt;&#123;&#123; obj.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.sex &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.hobby &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- v-for遍历对象(了解) --&gt; &lt;p&gt;老师信息&lt;/p&gt; &lt;div v-for=&quot;(value, key) in tObj&quot; :key=&quot;value&quot;&gt; &#123;&#123; key &#125;&#125; -- &#123;&#123; value &#125;&#125; &lt;/div&gt; &lt;!-- v-for遍历整数(了解) - 从1开始 --&gt; &lt;p&gt;序号&lt;/p&gt; &lt;div v-for=&quot;i in count&quot; :key=&quot;i&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; arr: [&quot;小明&quot;, &quot;小欢欢&quot;, &quot;大黄&quot;], stuArr: [ &#123; id: 1001, name: &quot;孙悟空&quot;, sex: &quot;男&quot;, hobby: &quot;吃桃子&quot;, &#125;, &#123; id: 1002, name: &quot;猪八戒&quot;, sex: &quot;男&quot;, hobby: &quot;背媳妇&quot;, &#125;, ], tObj: &#123; name: &quot;蜘蛛精&quot;, age: 18, class: &quot;昆虫&quot;, &#125;, count: 10, &#125;; &#125;,&#125;;&lt;/script&gt; 总结: vue最常用指令, 铺设页面利器, 快速把数据赋予到相同的dom结构上循环生成","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Java-常见异常","slug":"Java-常见异常","date":"2023-07-20T10:54:44.000Z","updated":"2023-08-03T01:27:16.000Z","comments":true,"path":"2023/07/20/Java-常见异常/","link":"","permalink":"http://example.com/2023/07/20/Java-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/","excerpt":"","text":"1.ClassCastException(类转换异常)数据类型转换错误，比如有个String temp&#x3D;”abc”; 如果设为(int)temp就会报错了，因为它们类型不一样，但是设为(object)temp就可以，因为object是它们的父类 2.IndexOutOfBoundsException(数组越界)这个异常我们在操作数组的时候会经常遇到，异常的解释是“数组下标越界”，现在程序中大多都有对数组的操作，因此在调用数组的时候一定要认真检查，看自己调用的下标是不是超出了数组的范围，一般来说，显示(即直接用常数当下标)调用不太容易出这样的错，但隐式(即用变量表示下标)调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。 3.NullPointerException(空指针)这个异常在编程时也经常遇到，异常的解释是 “程序遇上了空指针”，简单地说就是调用了未经初始化的对象或者是不存在的对象，这个错误经常出现在调用数组这些操作中，对数组操作中出现空指针，很多情况下是一些刚开始学习编程的人常犯的错误，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化(如果要调用的话)。 4.IllegalAccessException(安全权限异常)这个异常的解释是“没有访问权限“，当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常。 5. IOException(输入输出异常)一般读写文件会出现这个异常,比如你想从磁盘上读一个文件到你写的程序,如果硬盘上没有这文件,java虚拟机就会报这个异常","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-多表查询","slug":"Mysql-多表查询","date":"2023-07-18T16:27:20.000Z","updated":"2023-07-18T16:30:57.000Z","comments":true,"path":"2023/07/19/Mysql-多表查询/","link":"","permalink":"http://example.com/2023/07/19/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"1.DDLcreate 创建 alter 修改 drop 删除 truncate清空&#x2F;截断 【事务自动提交】 1.1 创建表常用创建 1234567表名 练习： t_emp tb_emp tbl_emp 项目： sys_ oa_ order_ product_create table 表名( 字段名 数据类型 [列级约束], 字段名 数据类型 [列级约束], [表级约束]) ; 1234CREATE TABLE t_emp01( id INT, NAME VARCHAR(20)) ; 查看表结构 1DESC t_emp01; 查看表创建语句 1SHOW CREATE TABLE t_emp01 ; CTAS语法创建表【没约束】 123CREATE TABLE emp10 AS SELECT * FROM emp WHERE deptno = 10;CREATE TABLE emp20 AS SELECT empno id,ename NAME,sal sal FROM emp WHERE deptno = 20;CREATE TABLE myemp AS SELECT * FROM emp WHERE 1=2 ; 1.2 约束主键 PK 非空+唯一 123456789101112131415CREATE TABLE t_emp02( id INT PRIMARY KEY, NAME VARCHAR(20)) ;或CREATE TABLE t_emp03( id INT , NAME VARCHAR(20), PRIMARY KEY (id)) ;INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;a&#x27;) ;INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) ;查询：INSERT INTO t_emp02 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) 错误代码： 1062Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27; 123456789CREATE TABLE t_emp04( id INT , NAME VARCHAR(20), PRIMARY KEY (id,NAME) -- 联合主键) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;a&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;1&#x27;,&#x27;b&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;2&#x27;,&#x27;b&#x27;) ;INSERT INTO t_emp04 (id,NAME) VALUES (&#x27;2&#x27;,&#x27;a&#x27;) ; 查看表约束 123-- 查询数据字典：SELECT * FROM `information_schema`.`TABLE_CONSTRAINTS` WHERE TABLE_SCHEMA=&#x27;scott&#x27; AND table_name=&#x27;t_emp04&#x27;; 外键 FK 参考完整性 可以为 NULL 给值 只能关联 另一个主键 123456789101112131415161718192021222324CREATE TABLE mydept AS SELECT * FROM dept ;CREATE TABLE myemp02 ( id INT PRIMARY KEY, NAME VARCHAR(20), deptno INT REFERENCES mydept(deptno)) ;或CREATE TABLE myemp03 ( id INT PRIMARY KEY, NAME VARCHAR(20), deptno INT , CONSTRAINT fk_myemp03 FOREIGN KEY (deptno) REFERENCES mydept(deptno) -- 注意：PK) ;INSERT INTO myemp03(id,NAME,deptno) VALUES (3,&#x27;aaa&#x27;,NULL) ;INSERT INTO myemp03(id,NAME,deptno) VALUES (4,&#x27;aaa&#x27;,88) ; -- 88 部门表中没有该数据查询：INSERT INTO myemp03(id,NAME,deptno) VALUES (4,&#x27;aaa&#x27;,88) 错误代码： 1452Cannot add or update a child row: a foreign key constraint fails (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `mydept` (`DEPTNO`))DELETE FROM `mydept` WHERE deptno = 10 ; -- 10部门下 有关联的员工查询：delete from `mydept` where deptno = 10 错误代码： 1451Cannot delete or update a parent row: a foreign key constraint fails (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `mydept` (`DEPTNO`)) 非空 1234CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) NOT NULL -- 该列不能为空) ; 唯一 1234CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) UNIQUE -- 该列唯一 可以为 null 【只能一个null】) ; 默认值 12345CREATE TABLE t_emp05( id INT PRIMARY KEY, NAME VARCHAR(20) , age INT DEFAULT 18 ) ; 自增长 123456789-- 历史遗留问题：ID 使用雪花算法 【通过程序控制】CREATE TABLE t_emp08( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ) ;INSERT INTO t_emp08 (id,NAME) VALUES (NULL,&#x27;a&#x27;) ;INSERT INTO t_emp08 (id,NAME) VALUES (200,&#x27;b&#x27;) ;INSERT INTO t_emp08 (id,NAME) VALUES (NULL,&#x27;c&#x27;) ; 1.3 修改表注意： 权限问题 ？ 修改表名 1ALTER TABLE t_emp08 RENAME TO tbl_emp08 ; 修改字段名 1ALTER TABLE tbl_emp08 CHANGE NAME e_name VARCHAR(20); 修改字段类型 1ALTER TABLE tbl_emp08 MODIFY e_name VARCHAR(80); 添加字段 12ALTER TABLE tbl_emp08 ADD age INT ;ALTER TABLE tbl_emp08 ADD sex INT AFTER id ; 删除字段 1ALTER TABLE tbl_emp08 DROP COLUMN sex ; 1.4 删除表12-- 最新的备份 最新的简历DROP TABLE tbl_emp08 ; 1.5 清空表1234567891011-- 1. 清空表中数据 表结构保留 DDL事务自动提交 不可回滚 速度快 自增长从1开始-- 降低高水位TRUNCATE TABLE myemp03 ;TRUNCATE TABLE mydept; -- FK 外键引用查询：truncate table mydept错误代码： 1701Cannot truncate a table referenced in a foreign key constraint (`scott`.`myemp03`, CONSTRAINT `fk_myemp03` FOREIGN KEY (`deptno`) REFERENCES `scott`.`mydept` (`DEPTNO`))-- 2. delete where过滤条件 DML语句 事务不提交 可以回滚 速度慢delete from myemp03 where .... DDL练习12345678910111213141516171819202122232425262728293031323334351.创建一张表 student id int name varchar(10) age int(10) tel varchar（10） 给 id 字段添加主键约束 自增长 给 name 字段添加非空约束 给 age 字段 默认值 0 给 tel 添加唯一 非空 约束 2.创建一张学员兴趣爱好表 hobby id int(10) hobby_name varchar(10) sid int --学生 id 给 sid 字段添加外键约束 3.创建一个表emp1empno int(10)ename varchar(50)4.emp1 添加一个字段 sal int(4)5.emp1 修改字段 ename varchar(100) 6.emp1 删除字段 sal7.把表 emp1 改成 emp2 SQL面试题面试题一（厦门）12345678910111213141516Table: （员工emp1） id name 1 a 2 b 3 c 4 dTable:( 性别sext) id sex 1 男 4 女 5 男找出忘记填写性别的员工? create table emp1(id int,name varchar(20)) ; insert into emp1(id,name) values (1,&#x27;a&#x27;),(2,&#x27;b&#x27;),(3,&#x27;c&#x27;),(4,&#x27;d&#x27;) ; create table sext(id int,sex varchar(20)) ; insert into sext(id,sex) values (1,&#x27;男&#x27;),(4,&#x27;女&#x27;),(5,&#x27;男&#x27;) ; 12345-- 员工id 没有在 sext表出现过? -- inselect * from emp1 where id not in (select id from sext) ;-- existsselect * from emp1 e where not exists (select null from sext where id=e.id) ; 面试题二（上海）12345678910111213141516表一(AAA) 商品名称 mc 商品总量 sl A 100 B 120表二(BBB) 商品名称 mc 出库数量 sl A 10 A 20 B 10 B 20 B 30用一条 SQL 语句算出商品 A,B 目前还剩多少？ create table AAA(mc varchar(20),sl int) ; insert into AAA (mc,sl) values (&#x27;A&#x27;,100),(&#x27;B&#x27;,120) ; create table BBB(mc varchar(20),sl int) ; insert into BBB (mc,sl) values (&#x27;A&#x27;,10),(&#x27;A&#x27;,20),(&#x27;B&#x27;,10),(&#x27;B&#x27;,20),(&#x27;B&#x27;,30) ; 12345678910111213-- 期望结果： -- mc sl-- A 70 -- B 60 -- 方法1: 子查询 select mc, sl-(select sum(sl) from BBB where mc=a.mc) sy from AAA a ;-- 方法2: 多表-- 先分组select mc,sum(sl) from BBB group by mc ;-- 看做一张表select a.mc, a.sl-t.sum_sl from AAA a join (select mc,sum(sl) sum_sl from BBB group by mc) t on a.mc = t.mc ; 面试题三（上海）1234567891011121314151617181920212223242526272829人员情况表（employee）中字段包括，员工号（ID），姓名（name），年龄（age），文化程度（wh）：包括四种情况（本科以上，大专，高中，初中以下）,现在我要根据年龄字段查询统计出：表中文化程度为本科以上，大专，高中，初中以下，各有多少人，占总人数多少。结果如下A：学历 年龄 人数 百分比本科以上 20 34 14大专 20 33 13高中 20 33 13初中以下 20 100 40本科以上 21 50 20。。。。。。SQL 查询语句如何写？create table employee(id int primary key auto_increment, name varchar(20), age int(2), wh varchar(20) ) ;insert into employee(id,name,age,wh) values (null,&#x27;a&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;b&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;c&#x27;,21,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;d&#x27;,20,&#x27;本科以上&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;大专&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,21,&#x27;大专&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,21,&#x27;高中&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;高中&#x27;) ;insert into employee(id,name,age,wh) values (null,&#x27;e&#x27;,20,&#x27;初中以下&#x27;) ; 123456查询结果集B：-- [行列转换]学历 20岁 21岁本科以上 3 1大专 2 2高中 4 1SQL 查询语句如何写？ 面试题四（福州）1234567891011121314151617181920212223242526272829303132333435363738四张表-- 学生表 create table student(sid varchar(20),sname varchar(20));insert into student values(1,&#x27;小明&#x27;);insert into student values(2,&#x27;小花&#x27;);-- 教师表 create table teacher(tid varchar(20),tname varchar(20)) ;insert into teacher values(1,&#x27;陈红&#x27;);insert into teacher values(2,&#x27;陈白&#x27;);-- 课程表 create table course(cid varchar(20),cname varchar(20)，ctype varchar(20)) ;insert into course values(1,&#x27;语文&#x27;,&#x27;文科&#x27;);insert into course values(2,&#x27;数学&#x27;,&#x27;理科&#x27;);-- 选课表 create table choose_course(ccid varchar(20),sid varchar(20),tid varchar(20), cid varchar(20));-- 小明选了陈红老师的语文insert into choose_course values(1,1,1,1);-- 小明选了陈红老师的数学insert into choose_course values(2,1,1,2);-- 小花选了陈红老师的数学insert into choose_course values(3,2,1,2);-- 小明选了陈白老师的语文insert into choose_course values(1,1,2,1);-- 小花选了陈红老师的语文insert into choose_course values(4,2,1,1);-- 1. 查找陈红老师教的学生是那些？-- 2.找学生小明所有的文科老师？-- 3.找出没有选修陈红老师的学生？-- 4.教的学生最少的老师？ 面试题五（厦门）12345678910111213141516171819202122232425262728293031323334-- 8:00--12:00 为迟到, 12:00--18:00 为早退-- 打卡表 card create table card( cid int(10), ctime timestamp , cuser int(10) ); -- 人员表 personcreate table person( pid int(10), name varchar(10)) ;-- 插入人员表的数据insert into person values(1,&#x27;a&#x27;);insert into person values(2,&#x27;b&#x27;);-- 插入打卡的数据insert into card values(1,&#x27;2009-07-19 08:02:00&#x27;,1);insert into card values(2,&#x27;2009-07-19 18:02:00&#x27;,1);insert into card values(3,&#x27;2009-07-19 09:02:00&#x27;,2);insert into card values(4,&#x27;2009-07-19 17:02:00&#x27;,2);insert into card values(5,&#x27;2009-07-20 08:02:00&#x27;,1);insert into card values(6,&#x27;2009-07-20 16:02:00&#x27;,1);insert into card values(7,&#x27;2009-07-20 07:02:00&#x27;,2);insert into card values(8,&#x27;2009-07-20 20:02:00&#x27;,2);-- 查询 迟到 早退的员工姓名？查询结果如下:工号 姓名 打卡日期 上班打卡 下班打卡 迟到 早退1 a 2009-07-19 08:02:00 18:02:00 是 否1 a 2009-07-20 08:02:00 16:02:00 是 是2 b 2009-07-19 09:02:00 17:02:00 是 是 2. DML事务不自动提交 2.1 插入数据所有字段插入 123INSERT INTO dept(deptno,dname,loc) VALUES (11,&#x27;dev&#x27;,&#x27;NJ&#x27;) ;-- 所有列插入 可以省略列名 【不建议】 考虑兼容问题？INSERT INTO dept VALUES (12,&#x27;dev&#x27;,&#x27;NJ&#x27;) ; 插入多条 1INSERT INTO dept(deptno,dname,loc) VALUES (13,&#x27;dev&#x27;,&#x27;NJ&#x27;),(14,&#x27;test&#x27;,&#x27;BJ&#x27;) ; 查询结果集插入 1234-- CTAS 语法创建表 【同时拷贝数据 没有约束】CREATE TABLE myemp AS SELECT * FROM emp ;-- 查询结果集 插入 myemp表中INSERT INTO myemp SELECT * FROM emp ; 2.2 更新数据1UPDATE myemp SET sal=sal*1.5 ,comm=500 WHERE empno =7788 ; 2.3 删除数据1DELETE FROM myemp WHERE empno = 7788 ; DML练习：123456789-- 1.往 emp 表中插入 empno,ename,sal 数据（111,&#x27;1&#x27;,1000)(222,&#x27;2&#x27;,2000) insert into emp(empno,ename,sal) values (111,&#x27;1&#x27;,1000),(222,&#x27;2&#x27;,2000) ;-- 2.把 empno=111 的员工 comm 改成 100 update emp set comm = 100 where empno = 111 ;-- 3.往 dept 表中插入编号50 ，dname，loc 与10部门相同 的数据 insert into dept(deptno,dname,loc) select 55,dname,loc from dept where deptno=10 ;-- 4.删除 empno=111 的数据 delete from emp where empno=111 ; 3. 视图view &#x3D; 虚表 table &#x3D; 基表 【1.数据安全性 2.简化查询】 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 3.1 简单视图增删改查 &#x3D;&#x3D;&gt; 基表 增删改查 123456789-- 创建或替换视图CREATE OR REPLACE VIEW v_emp10ASSELECT empno,ename,sal FROM emp WHERE deptno = 10 ;-- 查询 基表SELECT * FROM v_emp10 ;-- 插入视图数据 基表数据插入INSERT INTO v_emp10 (empno,ename,sal) VALUES (333,&#x27;xxx&#x27;,800) ; 3.2 高级视图只能查询 无法新增 删除 修改 【统计函数 ，多表数据】 1234567CREATE OR REPLACE VIEW v_emp10ASSELECT deptno,COUNT(0) cut FROM emp GROUP BY deptno ;SELECT * FROM v_emp10 ;-- 无法插入数据 基表没有该列【cut 统计出来的】INSERT INTO v_emp10 (deptno,cut) VALUES (80,6) ; 视图练习1234-- 1.创建一个包含所有雇员的雇员编号、雇员名称、部门名称和薪金的视图 -- 2.创建一个包含各种工作的薪金总和的视图 4.索引 4.1 优缺点&#x2F;分类123456789101112优势1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。劣势1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。索引分类1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引2） 唯一索引 ：索引列的值必须唯一，但允许有空值3） 复合索引 ：即一个索引包含多个列 4.2 创建索引1234-- 创建索引CREATE INDEX idx_dept_dname ON dept(dname) ;-- 查看SQL执行计划EXPLAIN SELECT * FROM dept WHERE dname=&#x27;SALES&#x27;; 4.3 删除索引12-- 删除索引DROP INDEX idx_dept_dname ON dept ; 4.4 查看索引1SHOW INDEX FROM dept ; 4.5 索引设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I&#x2F;O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 12345678创建复合索引: CREATE INDEX idx_name_email_status ON tb_xx(NAME,email,STATUS);就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 索引练习:1-- 1. 在 emp 表的 ename 上创建一个索引 并查看执行计划？ 5. 存储过程 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 5.1 创建存储过程1234CREATE PROCEDURE procedure_name ([proc_parameter[,...]])begin -- SQL语句end ; 示例 ： 12345678delimiter $create procedure pro_test1()begin select &#x27;Hello Mysql&#x27; ;end$delimiter ; DELIMITER 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 5.2 调用存储过程1call procedure_name() ; 5.3 查看存储过程12345678910-- 查询db_name数据库中的所有的存储过程select name from mysql.proc where db=&#x27;db_name&#x27;;-- 查询存储过程的状态信息show procedure status;-- 查询某个存储过程的定义show create procedure test.pro_test1 \\G; 5.4 删除存储过程1DROP PROCEDURE [IF EXISTS] sp_name ； 5.5 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 1DECLARE var_name[,...] type [DEFAULT value] 示例 : 123456789delimiter $create procedure pro_test2() begin declare num int default 5; select num+ 10; end$delimiter ; SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： 1SET var_name = expr [, var_name = expr] ... 示例 : 12345678910DELIMITER $CREATE PROCEDURE pro_test3()BEGIN DECLARE NAME VARCHAR(20); SET NAME = &#x27;MYSQL&#x27;; SELECT NAME ;END$DELIMITER ; 也可以通过select … into 方式进行赋值操作 : 12345678910DELIMITER $CREATE PROCEDURE pro_test5()BEGIN declare countnum int; select count(*) into countnum from city; select countnum;END$DELIMITER ; if条件判断语法结构 : 1234567if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 需求： 1234567根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ----------&gt; 身材高挑 170 - 180 ---------&gt; 标准身材 170 以下 ----------&gt; 一般身材 示例 : 12345678910111213141516171819delimiter $create procedure pro_test6()begin declare height int default 175; declare description varchar(50); if height &gt;= 180 then set description = &#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description = &#x27;标准身材&#x27;; else set description = &#x27;一般身材&#x27;; end if; select description ;end$delimiter ; 调用结果为 : 传递参数语法格式 : 1234567create procedure procedure_name([in/out/inout] 参数名 参数类型)...IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认OUT: 该参数作为输出，也就是该参数可以作为返回值INOUT: 既可以作为输入参数，也可以作为输出参数 IN - 输入 需求 : 1根据定义的身高变量，判定当前身高的所属的身材类型 示例 : 12345678910111213141516delimiter $create procedure pro_test5(in height int)begin declare description varchar(50) default &#x27;&#x27;; if height &gt;= 180 then set description=&#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description=&#x27;标准身材&#x27;; else set description=&#x27;一般身材&#x27;; end if; select concat(&#x27;身高 &#x27;, height , &#x27;对应的身材类型为:&#x27;,description);end$delimiter ; OUT-输出 需求 : 1根据传入的身高变量，获取当前身高的所属的身材类型 示例: 12345678910create procedure pro_test5(in height int , out description varchar(100))begin if height &gt;= 180 then set description=&#x27;身材高挑&#x27;; elseif height &gt;= 170 and height &lt; 180 then set description=&#x27;标准身材&#x27;; else set description=&#x27;一般身材&#x27;; end if;end$ 调用: 123call pro_test5(168, @description)$select @description$ @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 case结构语法结构 : 12345678910111213141516171819202122232425方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE;方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 需求: 1给定一个月份, 然后计算出所在的季度 示例 : 1234567891011121314151617181920212223delimiter $create procedure pro_test9(month int)begin declare result varchar(20); case when month &gt;= 1 and month &lt;=3 then set result = &#x27;第一季度&#x27;; when month &gt;= 4 and month &lt;=6 then set result = &#x27;第二季度&#x27;; when month &gt;= 7 and month &lt;=9 then set result = &#x27;第三季度&#x27;; when month &gt;= 10 and month &lt;=12 then set result = &#x27;第四季度&#x27;; end case; select concat(&#x27;您输入的月份为 :&#x27;, month , &#x27; , 该月份为 : &#x27; , result) as content ; end$delimiter ; while循环语法结构: 12345while search_condition do statement_list end while; 需求: 1计算从1加到n的值 示例 : 1234567891011121314delimiter $create procedure pro_test8(n int)begin declare total int default 0; declare num int default 1; while num&lt;=n do set total = total + num; set num = num + 1; end while; select total;end$delimiter ; repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : 1234567REPEAT statement_list UNTIL search_conditionEND REPEAT; 需求: 1计算从1加到n的值 示例 : 123456789101112131415161718delimiter $create procedure pro_test10(n int)begin declare total int default 0; repeat set total = total + n; set n = n - 1; until n=0 end repeat; select total ; end$delimiter ; loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： 12345[begin_label:] LOOP statement_listEND LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 eave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： 123456789101112131415161718192021delimiter $CREATE PROCEDURE pro_test11(n int)BEGIN declare total int default 0; ins: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP ins; select total;END$delimiter ; 游标&#x2F;光标游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。 声明光标： 1DECLARE cursor_name CURSOR FOR select_statement ; OPEN 光标： 1OPEN cursor_name ; FETCH 光标： 1FETCH cursor_name INTO var_name [, var_name] ... CLOSE 光标： 1CLOSE cursor_name ; 示例 : 初始化脚本: 12345678910create table emp( id int(11) not null auto_increment , name varchar(50) not null comment &#x27;姓名&#x27;, age int(11) comment &#x27;年龄&#x27;, salary int(11) comment &#x27;薪水&#x27;, primary key(`id`))engine=innodb default charset=utf8 ;insert into emp(id,name,age,salary) values(null,&#x27;金毛狮王&#x27;,55,3800),(null,&#x27;白眉鹰王&#x27;,60,4000),(null,&#x27;青翼蝠王&#x27;,38,2800),(null,&#x27;紫衫龙王&#x27;,42,1800); 12345678910111213141516171819202122232425262728-- 查询emp表中数据, 并逐行获取进行展示create procedure pro_test11()begin declare e_id int(11); declare e_name varchar(50); declare e_age int(11); declare e_salary int(11); declare emp_result cursor for select * from emp; open emp_result; fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary); close emp_result;end$ 通过循环结构 , 获取游标中的数据 : 12345678910111213141516171819202122232425DELIMITER $create procedure pro_test12()begin DECLARE id int(11); DECLARE name varchar(50); DECLARE age int(11); DECLARE salary int(11); DECLARE has_data int default 1; DECLARE emp_result CURSOR FOR select * from emp; DECLARE EXIT HANDLER FOR NOT FOUND set has_data = 0; open emp_result; repeat fetch emp_result into id , name , age , salary; select concat(&#x27;id为&#x27;,id, &#x27;, name 为&#x27; ,name , &#x27;, age为 &#x27; ,age , &#x27;, 薪水为: &#x27;, salary); until has_data = 0 end repeat; close emp_result;end$DELIMITER ; 6.函数语法结构: 12345CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ...END; 案例 : 定义一个存储过程, 请求满足条件的总记录数 ; 1234567891011121314delimiter $create function count_city(countryId int)returns intbegin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum;end$delimiter ; 调用: 12select count_city(1);select count_city(2); 7.触发器介绍触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 创建触发器语法结构 : 12345678910111213create trigger trigger_name before/after insert/update/deleteon tbl_name [ for each row ] -- 行级触发器begin trigger_stmt ;end; 示例 需求 1通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ; 首先创建一张日志表 : 12345678create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment &#x27;操作类型, insert/update/delete&#x27;, operate_time datetime not null comment &#x27;操作时间&#x27;, operate_id int(11) not null comment &#x27;操作表的ID&#x27;, operate_params varchar(500) comment &#x27;操作参数&#x27;, primary key(`id`))engine=innodb default charset=utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_insert_triggerafter insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;insert&#x27;,now(),new.id,concat(&#x27;插入后(id:&#x27;,new.id,&#x27;, name:&#x27;,new.name,&#x27;, age:&#x27;,new.age,&#x27;, salary:&#x27;,new.salary,&#x27;)&#x27;)); end $DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_update_triggerafter update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;update&#x27;,now(),new.id,concat(&#x27;修改前(id:&#x27;,old.id,&#x27;, name:&#x27;,old.name,&#x27;, age:&#x27;,old.age,&#x27;, salary:&#x27;,old.salary,&#x27;) , 修改后(id&#x27;,new.id, &#x27;name:&#x27;,new.name,&#x27;, age:&#x27;,new.age,&#x27;, salary:&#x27;,new.salary,&#x27;)&#x27;)); end $DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_delete_triggerafter delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#x27;delete&#x27;,now(),old.id,concat(&#x27;删除前(id:&#x27;,old.id,&#x27;, name:&#x27;,old.name,&#x27;, age:&#x27;,old.age,&#x27;, salary:&#x27;,old.salary,&#x27;)&#x27;)); end $DELIMITER ; 测试： 123456insert into emp(id,name,age,salary) values(null, &#x27;光明左使&#x27;,30,3500);insert into emp(id,name,age,salary) values(null, &#x27;光明右使&#x27;,33,3200);update emp set age = 39 where id = 3;delete from emp where id = 5; 删除触发器语法结构 : 1drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 语法结构 ： 1show triggers ；","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Ajax学习","slug":"Ajax","date":"2023-07-13T10:33:25.000Z","updated":"2023-08-03T05:43:27.000Z","comments":true,"path":"2023/07/13/Ajax/","link":"","permalink":"http://example.com/2023/07/13/Ajax/","excerpt":"","text":"1.接口文档概念及说明 我们使用的 url，数据接口，或者简称为接口。 接口是服务器提供的一个url地址，通过这个url地址，我们可以操作服务器上的资源。 通过Ajax技术向一个接口发送请求，也叫做调用接口。 接口是谁设计的呢 后端设计的（学java的、学php的同学、…..） 后端设计完接口之后，会提供一个接口文档给前端开发工程师 一个好的接口文档，至少需要包含下面几项内容 接口说明（通过接口说明，大致了解到接口是干什么用的） 接口的url（发送ajax请求，必要的条件） 接口请求方式（发送ajax请求，必要的条件） 请求参数（参数名称、数据类型、是否必填、参数说明等） 响应格式 响应示例 请求的根路径 http://localhost:8080/day19-02-ajax 图书管理 1.1 图书列表 接口URL： &#x2F;api&#x2F;getbooks 调用方式： GET 参数格式： 参数名称 参数类型 是否必选 参数说明 id String 否 图书Id bookname String 否 图书名称 author String 否 作者 publisher String 否 出版社 响应格式： 数据名称 数据类型 说明 status Number 200 成功；500 失败； msg String 对 status 字段的详细说明 data Array 图书列表 +id String 图书Id +bookname String 图书名称 +author String 作者 +publisher String 出版社 返回示例： 123456789&#123; &quot;status&quot;: 200, &quot;msg&quot;: &quot;获取图书列表成功&quot;, &quot;data&quot;: [ &#123; &quot;id&quot;: &quot;B001&quot;, &quot;bookname&quot;: &quot;西游记&quot;, &quot;author&quot;: &quot;吴承恩&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125;, &#123; &quot;id&quot;: &quot;B002&quot;, &quot;bookname&quot;: &quot;红楼梦&quot;, &quot;author&quot;: &quot;曹雪芹&quot;, &quot;publisher&quot;: &quot;上海图书出版社&quot; &#125;, &#123; &quot;id&quot;: &quot;B003&quot;, &quot;bookname&quot;: &quot;三国演义&quot;, &quot;author&quot;: &quot;罗贯中&quot;, &quot;publisher&quot;: &quot;北京图书出版社&quot; &#125; ]&#125; 1.2 添加图书 接口URL： &#x2F;api&#x2F;addbook 调用方式： POST 参数格式： 参数名称 参数类型 是否必选 参数说明 bookname String 是 图书名称 author String 是 作者 publisher String 是 出版社 响应格式： 数据名称 数据类型 说明 status Number 201 添加成功；500 添加失败； msg String 对 status 字段的详细说明 返回示例： 1234&#123; &quot;status&quot;: 201, &quot;msg&quot;: &quot;添加图书成功&quot;&#125; 1.3 删除图书 接口URL： &#x2F;api&#x2F;delbook 调用方式： GET 参数格式： 参数名称 参数类型 是否必选 参数说明 id String 是 图书Id 响应格式： 数据名称 数据类型 说明 status Number 200 删除成功；500 未指定要删除的图书Id；502 要删除的图书不存在； msg String 对 status 字段的详细说明 返回示例： 1234&#123; &quot;status&quot;: 200, &quot;msg&quot;: &quot;删除图书成功！&quot;&#125; 2.服务器端开发2.1 vo封装返回结果123456789101112131415161718192021222324/** * 封装 ajax 响应结果 */public class AjaxResult &#123; /**响应状态码 */ private Integer status ; /**响应消息*/ private String msg ; /**响应数据 主要是查询接口返回的数据*/ private Object data ; public AjaxResult(Integer status, String msg) &#123; super(); this.status = status; this.msg = msg; &#125; public AjaxResult(Integer status, String msg, Object data) &#123; super(); this.status = status; this.msg = msg; this.data = data; &#125;&#125; 2.2 pojo1234567891011121314151617public class Book &#123; private String id ; private String bookname ; private String author ; private String publisher ; public Book() &#123; super(); // TODO Auto-generated constructor stub &#125; public Book(String id, String bookname, String author, String publisher) &#123; super(); this.id = id; this.bookname = bookname; this.author = author; this.publisher = publisher; &#125;&#125; 2.3 Service1234567891011121314151617181920212223242526272829public class BookService &#123; private static Map&lt;String,Book&gt; bookMap = Collections.synchronizedMap(new LinkedHashMap&lt;&gt;()) ; static &#123; bookMap.put(&quot;B001&quot;, new Book(&quot;B001&quot;,&quot;西游记&quot;,&quot;吴承恩&quot;,&quot;北京图书出版社&quot;)) ; bookMap.put(&quot;B002&quot;, new Book(&quot;B002&quot;,&quot;西红楼梦&quot;,&quot;曹雪芹&quot;,&quot;上海图书出版社&quot;)) ; bookMap.put(&quot;B003&quot;, new Book(&quot;B003&quot;,&quot;三国演义&quot;,&quot;罗贯中&quot;,&quot;北京图书出版社&quot;)) ; &#125; public AjaxResult save(Book book) &#123; //获得随机id String id = UUID.randomUUID().toString() ; //设置书籍id book.setId(id); bookMap.put(id, book); return new AjaxResult(201, &quot;添加图书成功&quot;) ; &#125; public AjaxResult remove(String id) &#123; if(!bookMap.containsKey(id)) &#123; return new AjaxResult(500, &quot;502 要删除的图书不存在&quot;) ; &#125; bookMap.remove(id) ; return new AjaxResult(200, &quot;删除图书成功！&quot;) ; &#125; public AjaxResult find(Book book) &#123; //此次忽略 条件 查询 return new AjaxResult(200, &quot;获取图书列表成功&quot;,bookMap.values()) ; &#125;&#125; 2.4 Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@WebServlet(&#123; &quot;/api/getbooks&quot;, &quot;/api/addbook&quot;, &quot;/api/delbook&quot; &#125;)public class BookController extends HttpServlet &#123; private static final long serialVersionUID = 1L; private BookService bookService = new BookService() ; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json;charset=UTF-8&quot;); String requestURI = request.getRequestURI() ; requestURI = requestURI.substring((request.getContextPath()+&quot;/api/&quot;).length()) ; try &#123; Method m = this.getClass().getDeclaredMethod(requestURI, HttpServletRequest.class,HttpServletResponse.class) ; AjaxResult ajaxResult = (AjaxResult)m.invoke(this, request,response) ; String json = JSON.toJSONString(ajaxResult) ; PrintWriter out = response.getWriter(); out.print(json); out.flush(); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; protected AjaxResult getbooks(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;POST&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; return bookService.find(null) ; &#125; protected AjaxResult addbook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;GET&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; String bookname = request.getParameter(&quot;bookname&quot;) ; String author = request.getParameter(&quot;author&quot;) ; String publisher = request.getParameter(&quot;publisher&quot;) ; Book book = new Book() ; book.setBookname(bookname); book.setAuthor(author); book.setPublisher(publisher); return bookService.save(book) ; &#125; protected AjaxResult delbook(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; if(&quot;POST&quot;.equals(request.getMethod())) &#123; return new AjaxResult(405, &quot;请求的方式不允许！&quot;) ; &#125; String id = request.getParameter(&quot;id&quot;) ; if(id==null || id.equals(&quot;&quot;)) &#123; return new AjaxResult(500, &quot;未指定要删除的图书Id&quot;) ; &#125; return bookService.remove(id) ; &#125;&#125; 3. 接口测试准备工作： 121. tomcat先启动2. 安装 postman【默认安装】 3.1 图书列表 3.2 添加图书 3.3 删除图书 4. Ajax4.1 浏览器&#x2F;服务器交互模型 4.2 Ajax基本概念1234HTML是骨架CSS是颜值JS是行为数据是灵魂 AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用浏览器内置对象 XMLHttpRequest 与服务器通信。 Ajax是一种技术，通过浏览器内置对象和服务器进行数据交互的技术。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。 AJAX最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 你可以使用AJAX最主要的两个特性做下列事： 在不重新加载页面的情况下发送请求给服务器。 接受并使用从服务器发来的数据。 4.3 Ajax请求和浏览器请求1234567891011浏览器请求 是浏览器本能的请求 不需要执行任何JS代码 地址栏输入地址后，按下回车即可发送请求 接收到服务器的响应后，浏览器自动渲染响应结果到页面中Ajax请求 是通过浏览器内置对象（XHR）完成的 通过执行一段JS代码，才能实现的请求 响应结果由程序员自行处理，浏览器只负责接收响应结果。无论是浏览器请求，还是Ajax请求，道理都一样，都符合浏览器 – 服务器交互模型 123456789101112131415Ajax 优点： 可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 只更新页面的部分数据，节省带宽 用户体验好 异步，不阻塞 不阻塞，Ajax 代码之后的 其他 JS 代码无需等待 Ajax 代码执行完毕，即可执行。 多个Ajax请求可以同时进行。 Ajax 缺点: 1、增加了设计和开发时间 2、比构建经典Web应用程序更复杂 3、AJAX应用程序中的安全性较低，因为所有文件都是在客户端下载的。 4、可能出现网络延迟问题 5、禁用JavaScript的浏览器无法使用该应用程序。 6、由于安全限制，只能使用它来访问服务于初始页面的主机的信息。如果需要显示来自其他服务器的信息，则无法在AJAX中显示 4.4 JQuery封装的ajax方法$.get() 123jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求，从而将服务器上的资源请求到客户端来进行使用。 $.get() 函数的语法如下： $.get(url,[data],[success],[dataType]) 参数 是否必填 类型 说明 url 是 string 请求资源的接口地址，一般由后端开发工程师提供 data 否 string|array|object 请求参数，由后端提供 success 否 function 请求成功后触发的回调函数，函数的形参为响应结果 dataType 否 string 预期服务器端响应的数据的类型，一般不用设置 1234567891011121314//定义 请求接口地址 及 请求参数let url = &#x27;http://localhost:8080/day19-02-Ajax/api/getbooks&#x27;let obj = &#123; id: 1, bookname: &#x27;西游记&#x27;,&#125; ;//发送ajax get 请求$.get( url, obj, function (res) &#123; console.log(res) &#125;) $.post() 123jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，用于向服务器提交资源。 $.post() 函数的语法如下： $.post(url,[data],[success],[dataType]) 参数 是否必填 类型 说明 url 是 string 请求资源的接口地址，一般由后端开发工程师提供 data 否 string|array|object 请求参数，由后端提供 success 否 function 请求成功后触发的回调函数，函数的形参为响应结果 dataType 否 string 预期服务器端响应的数据的类型，一般不用设置 1234567891011// 定义路径和参数let url = &#x27;http://localhost:8080/day19-02-Ajax/api/addbook&#x27;;let obj = &#123; bookname: &#x27;三体之地球往&#x27;, author: &#x27;刘慈欣&#x27;, publisher: &#x27;中央人民出版社&#x27;&#125;;// 发送post类型的ajax$.post(url, obj, function (res) &#123; console.log(res);&#125;); $.ajax() 123456789$.ajax() - 一个综合的发送Ajax请求的方法，即可以发送GET方式的请求，也可以发送POST方式的请求，还可以根据需求配置更加复杂的Ajax请求，使用频率最高。$.ajax(&#123; method:&#x27;GET|POST&#x27;, // 请求方式 必填 url:&#x27;url接口地址&#x27;, //请求的接口地址 必填 data:&#x27;object|array|string&#x27;, // 请求参数 ，可选 success:function(res)&#123; //请求成功后的回调函数 res 表示响应结果 &#125;&#125;) 123456789101112// $.ajax(); 传递的参数是对象;// 四个关键参数都是一个属性形式存在！$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080/day19-02-Ajax/api/getbooks&#x27;, data: &#123; id: 1 &#125;, success: function (res) &#123; console.log(res); &#125;&#125;) 4.5 network工具使用 network工具使用 All – 查看所有请求 XHR – 查看Ajax请求 JS – 查看请求了哪些JS文件 CSS – 查看请求了哪些CSS文件 Img – 查看请求了哪些图片 Media – 查看请求了哪些音频、视频等 Font – 查看请求了哪些字体文件 Doc – document，查看请求了哪些html文件 4.6 综合案例效果图 素材12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!-- 套一个 .container 内容就有版心了 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;!-- bootstrap3 =&gt; 组件 =&gt; 面板 =&gt; 带标题的面版 =&gt; 情境效果 --&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;添加图书&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;!-- bootstrap3 =&gt; 全局CSS样式 =&gt; 表单 =&gt; 内联表单 --&gt; &lt;div class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;书名&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;书名&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpBookname&quot; placeholder=&quot;请输入书名&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;作者&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;作者&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpAuthor&quot; placeholder=&quot;请输入作者&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputAmount&quot;&gt;出版社&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;出版社&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inpPublisher&quot; placeholder=&quot;请输入出版社&quot; /&gt; &lt;!-- &lt;div class=&quot;input-group-addon&quot;&gt;.00&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;btnAdd&quot; type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt; 添加 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注意: 第二部分是table标签，要写道 container 里面，panel下面 --&gt; &lt;!-- bootstrap3 =&gt; 全局CSS样式 =&gt; 表格 =&gt; 带边框的表格 --&gt; &lt;table class=&quot;table table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;西游记&lt;/td&gt; &lt;td&gt;吴承恩&lt;/td&gt; &lt;td&gt;北京图书出版社&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 5. CORS 错误跨源资源分享（CORS）是一种允许服务器放宽同源策略的标准。这用于明确允许一些跨源请求，同时拒绝其他请求。例如，如果站点提供外界嵌入的服务，则可能需要放宽同源策略。设置这样的 CORS 配置并不一定容易，并且可能存在一些挑战。在这些页面中，我们将研究一些常见的 CORS 错误消息以及如何解决它们。 如果未正确设置 CORS 配置，浏览器控制台将显示错误，例如 “Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite” 表示请求因违反 CORS 安全规则而被阻止。但这可能不一定是设置错误。因为用户的 Web 应用程序和远程外部服务可能故意禁止该请求。如果要使端点可用，则需要进行一些调试才能成功。 什么是跨域问题前端调用的后端接口不属于同一个域（域名或端口不同），就会产生跨域问题，也就是说你的应用访问了该应用域名或端口之外的域名或端口。 服务器端 开启跨域 12345678910111213141516171819202122232425262728/** * 功能描述：解决跨域过滤器 */@WebFilter(&quot;/api/*&quot;)public class CORSFilter implements Filter &#123; private final int time = 20*24*60*60; public void init(FilterConfig fConfig) throws ServletException &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse resp = (HttpServletResponse) response; // 添加参数，允许任意domain访问 resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 这个allow-headers要配为*，这样才能允许所有的请求头 resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;); resp.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); resp.setHeader(&quot;Access-Control-Max-Age&quot;, time+&quot;&quot;); chain.doFilter(request, resp); &#125; public void destroy() &#123; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"}]},{"title":"jQuery","slug":"jQuery","date":"2023-07-13T02:52:36.000Z","updated":"2023-07-13T02:58:04.000Z","comments":true,"path":"2023/07/13/jQuery/","link":"","permalink":"http://example.com/2023/07/13/jQuery/","excerpt":"","text":"1. JQ1.1 jQ概述jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。JavaScript库：是一个封装好的特定的集合包大量的方法。从封装函数的角度理解库，就是在JavaScrip库中，封装了很多预先定义好的函数在里面JQuery就是这样的一个js文件: 本质上就是对我们之前原生js代码封装后的一个js文件j 代表js Query 代表查询 优点： 轻量级。核心文件才几十kb，不会影响页面加载速度 跨浏览器兼容。基本兼容了现在主流的浏览器 链式编程、隐式迭代 对事件、样式、动画支持，大大简化了DOM操作 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等 免费、开源 初体验1234567891011121314151617181920212223242526272829303132&lt;!-- 使用 原生js 与 JQ PK 点击事件 --&gt; &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 隐式循环 2. 链式操作 3. $(dom对象) 转成 jq对象 调用 jq 的方法 $(&quot;li&quot;).mouseover(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;)).mouseout(e=&gt;$(e.target).css(&#x27;backgroundColor&#x27;,&#x27;&#x27;)) &lt;/script&gt; &lt;script&gt; //原生 let liCompAy = document.querySelectorAll(&#x27;li&#x27;) liCompAy.forEach((liComp) =&gt; &#123; liComp.addEventListener(&#x27;mouseover&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `pink` console.log(`鼠标覆盖`) &#125;) liComp.addEventListener(&#x27;mouseout&#x27;, (e) =&gt; &#123; e.target.style.backgroundColor = `` console.log(`鼠标离开`) &#125;) &#125;) &lt;/script&gt; 入口函数12无需关心JS代码书写顺序 DOM中如果在HTML结构之前写JS代码,需要设置加载事件,获取HTML元素 【加载事件 window.onload】 123456789101112131415&lt;script&gt; //原生 window.addEventListener(&quot;load&quot;,()=&gt;&#123; let inputComp = document.querySelector(&quot;#name&quot;) console.log(`姓名 原生 :$&#123;inputComp.value&#125;`); &#125;) &lt;/script&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //JQ $(()=&gt;console.log(`姓名JQ: $&#123;$(&quot;#name&quot;).val()&#125;`)) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; DOM JQ转换12345678910DOM对象: 通过 document 方式获取到的元素都叫DOM对象jQuery对象 通过 $ 方式获取到的元素都叫 JQ对象将JQ对象转为DOM对象方式: JQ对象[索引] JQ对象.get(索引)将DOM对象转化为JQ对象: $(dom对象)注意： 只能由DOM对象 调用DOM的属性及方法，只能使用JQ对象调用 JQ的属性及方法 12345678910111213141516171819202122&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;张三疯&quot;&gt; &lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //dom对象 // let inputComp = document.querySelector(&quot;#name&quot;) // .val() jq的方法 必须 jq对象调用 .value dom的属性 必须 dom对象调用 // console.log(`姓名:$&#123;inputComp.value&#125;`); // jq对象 使用$开头 dom对象 // let $input = $(&quot;#name&quot;) // console.log(`姓名: $&#123;$input.val()&#125;`); //dom 转 jq let jq = $(dom) // let $input = $(inputComp) // console.log(`姓名: $&#123;$input.val()&#125;`); // jq 转 dom [0] .get(0) let $input = $(&quot;#name&quot;) // let input = $input[0] let input = $input.get(0) console.log(`姓名:$&#123;input.value&#125;`); &lt;/script&gt; 1.2 JQ 选择器基本选择器1234561. id选择器 #id值 $(&quot;#name&quot;)2. class选择器 .class值 $(&quot;.a&quot;)3. 标签选择器 标签名 $(&quot;li&quot;)4. 并集 OR , $(&quot;h1,#name,.a&quot;) 5. 交集 AND 直接写 $(&quot;li.c1&quot;)6. 适配 * $(&quot;*&quot;) 123456789101112131415161718192021&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li class=&quot;red&quot;&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data7&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`id选择器:$&#123;$(&#x27;#d5&#x27;).html()&#125;`) console.log(`class选择器:$&#123;$(&#x27;.red&#x27;).html()&#125;`) console.log(`标签选择器:$&#123;$(&#x27;ul&#x27;).html()&#125;`) console.log(`并集选择器===========`) $(&#x27;.red,#d5&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) $(&#x27;li.blue&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;) $(&#x27;*&#x27;).css(&#x27;fontSize&#x27;, &#x27;80px&#x27;)&lt;/script&gt; 层次选择器12345678910111. 儿子 &gt; $(&quot;tr&gt;td&quot;) $(&#x27;元素&#x27;).children([选择器]); 2. 后代 空格 $(&quot;table td&quot;) $(&#x27;元素&#x27;).find(选择器); 3. 下一个弟弟 + $(&quot;#data2+li&quot;) next() $(&quot;#data2&quot;).next(&quot;li&quot;)4. 所有的弟弟 ~ $(&quot;#data2~li&quot;) nextAll() $(&quot;#data2&quot;).nextAll(&quot;li&quot;)5. 上一个哥哥 prev() $(&quot;#data2&quot;).prev(&quot;li&quot;)6. 所有的哥哥 prevAll() $(&quot;#data2&quot;).prevAll(&quot;li&quot;)7. 同胞【哥哥弟弟们】 siblings() $(&quot;#data2&quot;).siblings(&quot;li&quot;) 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li id=&quot;d5&quot;&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;ul&gt;li&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&quot;html li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5+li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).next(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5~li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).nextAll(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prev(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&quot;#d5&quot;).prevAll(&quot;li&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;) $(&#x27;#d5&#x27;).siblings(&#x27;li&#x27;).css(&#x27;color&#x27;, &#x27;blue&#x27;)&lt;/script&gt; 属性选择器123451.拥有该属性 [attr] $(&quot;[name]&quot;)2.等于属性值 [attr=value] $(&quot;[name=&#x27;sid&#x27;]&quot;)3.使用属性值开头 [attr^=value] $(&quot;[name^=&#x27;s&#x27;]&quot;)4.使用属性值结尾 [attr$=value] $(&quot;[name$=&#x27;s&#x27;]&quot;)5.包含该属性值 [attr*=value] $(&quot;[name*=&#x27;s&#x27;]&quot;) 123456789101112131415&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;abc.html&quot;&gt;data1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;aaa.html&quot;&gt;data2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;ccc.html&quot;&gt;data3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;abcd.html&quot;&gt;data4&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a&gt;data5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;[href]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href=&#x27;aaa.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href^=&#x27;a&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href$=&#x27;c.html&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;) $(&quot;[href*=&#x27;c&#x27;]&quot;).css(&quot;fontSize&quot;,&quot;36px&quot;)&lt;/script&gt; 过滤选择器基本过滤选择器12345671. 第一个 :first $(&quot;li:first&quot;)2. 最后一个 :last $(&quot;li:last&quot;)3. 偶数 :even $(&quot;li:even&quot;)4. 奇数 :odd $(&quot;li:odd&quot;)5. 等于索引 :eq(idx) 或 .eq(idx) $(&quot;li:eq(1)&quot;) 或 $(&quot;li&quot;).eq(1) 从0开始6. 小于索引 :lt(idx) $(&quot;li:lt(3)&quot;)7. 大于索引 :gt(idx) $(&quot;li:gt(3)&quot;) 123456789101112131415161718 &lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li:first&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:last&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:even&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:odd&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:eq(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li&#x27;).eq(2).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:lt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;li:gt(2)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;)&lt;/script&gt; 可见性过滤选择器121. 隐藏 :hidden2. 可见 :visible 1234567891011121314151617&lt;!-- 1. 隐藏 :hidden2. 可见 :visible--&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;显示&lt;/button&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).click(() =&gt; &#123; $(&#x27;img:visible&#x27;).hide(1000) &#125;) $(&#x27;button:eq(1)&#x27;).click(() =&gt; &#123; $(&#x27;img:hidden&#x27;).show(1000) &#125;)&lt;/script&gt; 表单过滤选择器12345678910111213141. input标签 :input $(&quot;input&quot;) &lt;input /&gt;2. type=&#x27;text&#x27; :text $(&quot;input[type=&#x27;text&#x27;]&quot;) &lt;input type=&#x27;text&#x27;/&gt;3. type=&#x27;password&#x27;:password $(&quot;input[type=&#x27;password&#x27;]&quot;) &lt;input type=&#x27;password&#x27;/&gt;4. type=&#x27;radio&#x27; :radio $(&quot;input[type=&#x27;radio&#x27;]&quot;) &lt;input type=&#x27;radio&#x27;/&gt;5. type=&#x27;checkbox&#x27;:checkbox $(&quot;input[type=&#x27;checkbox&#x27;]&quot;) &lt;input type=&#x27;checkbox&#x27;/&gt;6. type=&#x27;submit&#x27; :submit $(&quot;input[type=&#x27;submit&#x27;]&quot;) &lt;input type=&#x27;submit&#x27;/&gt;7. type=&#x27;image&#x27; :image $(&quot;input[type=&#x27;image&#x27;]&quot;) &lt;input type=&#x27;image&#x27;/&gt;8. type=&#x27;reset&#x27; :reset $(&quot;input[type=&#x27;reset&#x27;]&quot;) &lt;input type=&#x27;reset&#x27;/&gt;9. type=&#x27;button&#x27; :button $(&quot;input[type=&#x27;button&#x27;]&quot;) &lt;input type=&#x27;button&#x27;/&gt;10.type=&#x27;file&#x27; :file $(&quot;input[type=&#x27;file&#x27;]&quot;) &lt;input type=&#x27;file&#x27;/&gt;===========================布尔值属性==================11.被选中的单选/复选按钮 :checked $(&quot;:radio:checked&quot;)12.下拉框被选中 :selected $(&quot;:selected&quot;)13.被禁用 :disabled $(&quot;:disabled&quot;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;form action=&quot;xxController&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;admin1&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; value=&quot;admin2&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;hidden&quot; value=&quot;S1001&quot; /&gt; &lt;input type=&quot;text&quot; value=&quot;S1001&quot; disabled /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; value=&quot;123&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;CS&quot; /&gt;CS &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;LOL&quot; checked /&gt;LOL &lt;input type=&quot;checkbox&quot; name=&quot;likes&quot; value=&quot;DOTA&quot; checked /&gt;DOTA &lt;br /&gt; &lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt; &lt;br /&gt; &lt;select name=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;data1&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;data2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;data3&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;image&quot; src=&quot;./images/1.jpg&quot; alt=&quot;&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`第一文本输入框:$&#123;$(&quot;input&quot;).val()&#125;`); console.log(`第一文本输入框:$&#123;$(&quot;:input&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;input[type=&#x27;text&#x27;]:eq(1)&quot;).val()&#125;`); console.log(`第二文本输入框:$&#123;$(&quot;:input:text:eq(1)&quot;).val()&#125;`); console.log(`密码输入框:$&#123;$(&quot;:password&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio&quot;).val()&#125;`); console.log(`单选按钮:$&#123;$(&quot;:radio:checked&quot;).val()&#125;`); $(&quot;:radio[value=&#x27;1&#x27;]&quot;)[0].checked = true $(&quot;:checkbox:checked&quot;).each((idx,e)=&gt;&#123; // console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); console.log(`索引:$&#123;idx&#125;========value:$&#123;$(e).val()&#125;`); &#125;) $.each($(&quot;:checkbox:checked&quot;),(idx,e)=&gt;&#123; console.log(`索引:$&#123;idx&#125;========value:$&#123;e.value&#125;`); &#125;) $(&#x27;:submit&#x27;).val(&#x27;我是提交按钮&#x27;) $(&quot;:image&quot;).attr(&quot;src&quot;,&#x27;./images/html-css-js.png&#x27;) $(&quot;:reset&quot;).val(`回到解放前`) console.log(`file的name属性值:$&#123;$(&#x27;:file&#x27;).attr(&#x27;name&#x27;)&#125;`) console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).val()&#125;`); console.log(`select被选中的值：$&#123;$(&quot;select :selected&quot;).text()&#125;`); console.log(`获得禁用的值:$&#123;$(&#x27;:disabled&#x27;).val()&#125;`) console.log(`获得隐藏的值:$&#123;$(&#x27;input:hidden&#x27;).val()&#125;`)&lt;/script&gt; 1.3 JQ注册事件鼠标事件121. 鼠标进入 mouseover = mouseenter2. 鼠标离开 mouseout = mouseleave 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* $(&#x27;li&#x27;) .mouseover(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) &#125;) .mouseout((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;)) */ $(&#x27;li&#x27;) .mouseenter((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;)) .mouseleave((e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;))&lt;/script&gt; 123456789101112131415161718192021&lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;ul class=&quot;ul1&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;联系我们&lt;/a&gt; &lt;ul class=&quot;u2&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;邮件联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;电话联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;微信联系&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;.nav .ul1&gt;li:last&quot;).mouseenter(()=&gt;$(&quot;.u2&quot;).show()).mouseleave(()=&gt;$(&quot;.u2&quot;).hide()) &lt;/script&gt; 键盘事件121. 键盘按下 keydown2. 键盘释放 keyup 1234567&lt;input type=&quot;text&quot; /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;input&#x27;) .keydown((e) =&gt; console.log(e.keyCode)) .keyup(() =&gt; console.log(`释放`))&lt;/script&gt; 表单事件1234561.单击 click2.双击 dblclick3.值改变 change4.失去焦点 blur5.获得焦点 focus6.表单提交 submit 1234567891011121314151617181920212223242526272829&lt;form action=&quot;logcontroller&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;span id=&quot;accountError&quot;&gt;&lt;/span&gt;&lt;br /&gt; &lt;input type=&quot;password&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;:text&#x27;).focus((e) =&gt; $(e.target).css(&#x27;borderColor&#x27;, &#x27;red&#x27;)) $(&#x27;:text&#x27;).blur(() =&gt; &#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return &#125; console.log(`======用户名=====`) $(&#x27;#accountError&#x27;).html(``) &#125;) $(&quot;form&quot;).submit((e)=&gt;&#123; if ($(&#x27;:text&#x27;).val().length === 0) &#123; // alert(`用户名不能为空`) $(&#x27;#accountError&#x27;).html(`&lt;font color=&#x27;red&#x27;&gt;用户名不能为空&lt;font&gt;`) $(&#x27;:text&#x27;).focus() return e.preventDefault() &#125; &#125;)&lt;/script&gt; 事件绑定1234561.绑定 bind(&quot;事件名&quot;,事件处理函数) = on (&quot;事件名&quot;,事件处理函数) 【结构固定,内容多变】 $(&quot;button:eq(0)&quot;).click(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;click&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).dblclick(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;dblclick&quot;,()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).blur(()=&gt;&#123;...&#125;) $(&quot;button:eq(0)&quot;).on(&quot;blur&quot;,()=&gt;&#123;...&#125;)2.解绑 unbind(&quot;事件名&quot;) = off(&quot;事件名&quot;)3.只执行一次 one(&quot;事件名&quot;,事件处理函数) 1234567891011&lt;button&gt;绑定 click 按钮1&lt;/button&gt;&lt;button&gt;解除 click 按钮2&lt;/button&gt;&lt;button&gt;只绑定一次 click 按钮3&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).on(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).on(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).off(&#x27;click&#x27;)) $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`按钮1 被点击了..11.`)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;button:eq(0)&#x27;).unbind(&#x27;click&#x27;)) $(&#x27;button:eq(2)&#x27;).one(&#x27;click&#x27;, () =&gt; console.log(`按钮3 被点击了..11.`))&lt;/script&gt; 复合事件12该事件由2个或2个以上的函数hover(fnOver,fnOut) 1234567891011121314151617&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;li&#x27;).hover( (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;), (e) =&gt; $(e.target).css(&#x27;backgroundColor&#x27;, &#x27;red&#x27;) )&lt;/script&gt; 123456789101112131415161718 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;价格与包装&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;售后保障&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;商品评价&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;.box li&#x27;).hover( (e) =&gt; (e.target.className = &#x27;active&#x27;), (e) =&gt; (e.target.className = &#x27;&#x27;) )&lt;/script&gt; 事件冒泡1234触发子元素事件 级联 触发 父元素的事件【阻止事件冒泡:】1. event.stopPropagation()2. event.cancelBubble = true 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; #d1 &#123; width: 200px; height: 200px; background-color: pink; &#125; #d2 &#123; width: 100px; height: 100px; background-color: yellowgreen; &#125; #d3 &#123; width: 40px; height: 40px; background-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;d1&quot;&gt; &lt;div id=&quot;d2&quot;&gt; &lt;div id=&quot;d3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;#d1&#x27;).bind(&#x27;click&#x27;, () =&gt; console.log(`爷爷被点击了`)) $(&#x27;#d2&#x27;).bind(&#x27;click&#x27;, function () &#123; console.log(`爸爸被点击了`) // event 内置对象 浏览器中 内置 对象 event.cancelBubble = true &#125;) $(&#x27;#d3&#x27;).bind(&#x27;click&#x27;, (e) =&gt; &#123; console.log(`你小子被点击了`) //e.stopPropagation() event.stopPropagation() &#125;)&lt;/script&gt; 事件默认行为1234默认事件行为： 比如 &lt;a href=&quot;addStu()&quot;&gt;...&lt;/a&gt; 默认链接到目标地址【阻止事件默认行为】1. javaScript:2. event.preventDefault() 12345678&lt;a href=&quot;http://www.baidu.com&quot;&gt;去百度 1 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:&quot;&gt;去百度 2 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;javaScript:void(0)&quot;&gt;去百度 3 &lt;/a&gt; &lt;br /&gt;&lt;a href=&quot;&quot;&gt;去百度 4 &lt;/a&gt; &lt;br /&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;a&#x27;).bind(&#x27;click&#x27;, () =&gt; event.preventDefault())&lt;/script&gt; 表单序列化1234567序列化: 一次获取到表单中所有元素内容$(&#x27;form&#x27;).on(&#x27;submit&#x27;, function () &#123; // 通过 jQuery 对象的 serialize 方法，获取所有表单元素的数据 $(this).serialize(); // 阻止表单默认提交 return false;&#125;) 12345678910111213141516171819202122 &lt;form action=&quot;02-login-rs.html&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;account&quot; placeholder=&quot;请输入账号&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;pswd&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; placeholder=&quot;请输入年龄&quot; /&gt; &lt;br /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; location.href = `xxController?$&#123;$(&#x27;form&#x27;).serialize()&#125;` //阻止默认行为 event.preventDefault() &#125;) /* $(&#x27;form&#x27;).bind(&#x27;submit&#x27;, () =&gt; &#123; let account = $(&quot;input[name=&#x27;account&#x27;]&quot;).val() let pswd = $(&quot;input[name=&#x27;pswd&#x27;]&quot;).val() location.href = `xxController?account=$&#123;account&#125;&amp;pswd=$&#123;pswd&#125;` //阻止默认行为 event.preventDefault() &#125;) */&lt;/script&gt; 1.4 JQ操作样式1234561.$(&#x27;元素&#x27;).css(&#x27;属性&#x27;, 值); 设置单个属性样式 $(&#x27;元素&#x27;).css(&#123;&#x27;属性&#x27;: &#x27;值&#x27;,&#x27;属性&#x27;: &#x27;值&#x27;&#125;) 设置多个属性样式2.$(&#x27;元素&#x27;).addClass(&#x27;类名 类名&#x27;); 3.$(&#x27;元素&#x27;).hasClass(&#x27;类名&#x27;);4.$(&#x27;元素&#x27;).removeClass(&#x27;类名&#x27;);5.$(&#x27;元素&#x27;).toggleClass(&#x27;类名&#x27;); 123456789101112131415161718192021222324&lt;style&gt; .pic &#123; width: 400px; height: 400px; border: 10px solid #000; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;/&gt;&lt;button&gt;添加样式1&lt;/button&gt;&lt;button&gt;添加样式2&lt;/button&gt;&lt;button&gt;添加样式3&lt;/button&gt;&lt;button&gt;删除样式4&lt;/button&gt;&lt;button&gt;切换样式5&lt;/button&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:eq(0)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#x27;width&#x27;, &#x27;80px&#x27;)) $(&#x27;button:eq(1)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).css(&#123; width: &#x27;80px&#x27; &#125;)) $(&#x27;button:eq(2)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).addClass(&#x27;pic&#x27;)) $(&#x27;button:eq(3)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).removeClass(&#x27;pic&#x27;)) $(&#x27;button:eq(4)&#x27;).bind(&#x27;click&#x27;, () =&gt; $(&#x27;img&#x27;).toggleClass(&#x27;pic&#x27;)) console.log(`是否拥有pic样式: $&#123;$(&#x27;img&#x27;).hasClass(&#x27;pic&#x27;)&#125;`)&lt;/script&gt; 1.5 jQ操作属性12345678910111. 操作内置属性 获取: $(对象).prop(&#x27;属性名&#x27;); 设置: $(对象).prop(&#x27;属性名&#x27;, 值);2.操作自定义属性 获取: $(对象).attr(自定义属性名); 设置: $(对象).attr(自定义属性名, 值);3. 获取表单控件中的值 $(对象).val() $(对象).val(值);4. 操作普通标签中的值 $(对象).text(值); $(对象).html(值); 12345678910111213141516171819202122232425&lt;input type=&quot;text&quot; value=&quot;admin&quot; name=&quot;username&quot; data-user-id=&quot;S1001&quot; /&gt;&lt;span&gt;111111&lt;/span&gt;&lt;div&gt;&lt;h1&gt;2222&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(`获得内置属性: $&#123;$(&#x27;input&#x27;).prop(&#x27;name&#x27;)&#125;`) $(&#x27;input&#x27;).prop(&#x27;name&#x27;, &#x27;uname&#x27;) console.log(`获得自定义属性: $&#123;$(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;)&#125;`) $(&#x27;input&#x27;).attr(&#x27;data-user-id&#x27;, &#x27;S6666&#x27;) console.log(`获得value属性: $&#123;$(&#x27;input&#x27;).val()&#125;`) $(&#x27;input&#x27;).val(&#x27;zhang3&#x27;) console.log(`获得innerText: $&#123;$(&#x27;span&#x27;).text()&#125;`) $(&#x27;span&#x27;).text(&#x27;span&#x27;) console.log(`获得innerHTML: $&#123;$(&#x27;div&#x27;).html()&#125;`) $(&#x27;div&#x27;).html(`&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt;&lt;/ul&gt;`)&lt;/script&gt; 1.6 jQ操作元素删除元素1231. $对象.remove(); 从页面中将当前标签删除2. $对象.empty(); 将标签中的所有内容清空3. $对象.html(&#x27;&#x27;); 将标签中的所有内容清空 创建元素121. $对象.html(&#x27;html标签名&#x27;); 直接在标签中添加新标签2. let res = $(&#x27;html标签&#x27;); 创建标签, 返回: JQ标签对象 添加元素1234567891. $父元素.append(元素); 将创建元素添加到父元素末尾2. $父元素.prepend(元素); 将创建元素添加到父元素开始1.尾部添加 父.append(子) 子.appendTo(父) 2.开始添加 父.prepend(子) 子.prependTo(父) 12345678910111213141516171819202122232425262728293031&lt;ul&gt; &lt;li&gt;data1&lt;/li&gt; &lt;li&gt;data2&lt;/li&gt; &lt;li&gt;data3&lt;/li&gt; &lt;li&gt;data4&lt;/li&gt; &lt;li&gt;data5&lt;/li&gt; &lt;li&gt;data6&lt;/li&gt; &lt;li&gt;data7&lt;/li&gt; &lt;li&gt;data8&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;p&gt;我的div中p&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jQuery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.删除元素 $(&#x27;ul li:first&#x27;).remove() $(&#x27;ul li:last&#x27;).empty() $(&#x27;ul li:last&#x27;).html(``) //2.创建元素 $(&quot;ul li:first&quot;).html(`&lt;p&gt;aaaa&lt;/p&gt;`) let btn = $(`&lt;button&gt;按钮&lt;/button&gt;`) //3.添加元素 $(&#x27;div&#x27;).append(btn) btn.appendTo($(&#x27;div&#x27;)) $(&#x27;div&#x27;).prepend(btn) btn.prependTo($(&#x27;div&#x27;))&lt;/script&gt; 例：根据素材： 03-信息发布.html 实现元素添加&#x2F;删除功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; .msg &#123; width: 980px; padding-bottom: 10px; border: 1px solid #ccc; margin: 50px auto; &#125; textarea &#123; width: 880px; height: 100px; border: 0 none; border: 1px solid orange; resize: none; outline-style: none; border-radius: 10px; display: block; margin: 50px auto 0 auto; padding-left: 20px; padding-top: 20px; box-sizing: border-box; &#125; .btn &#123; width: 80px; height: 40px; display: block; float: right; margin-right: 50px; margin-top: 20px; background-color: blue; color: #fff; text-align: center; text-decoration: none; line-height: 40px; border-radius: 10px; clear: both; &#125; .content &#123; width: 880px; margin: 80px auto 0 auto; &#125; .item &#123; height: 50px; line-height: 50px; border-bottom: 1px dashed #ccc; padding-left: 20px; &#125; .item p &#123; float: left; &#125; .del &#123; float: right; text-decoration: none; color: #999; &#125; .del:hover &#123; color: orange; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;msg&quot;&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;btn&quot;&gt;发布&lt;/a&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;三天没吃肉啦&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./jslib/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //发布 $(`a.btn`).bind(`click`, () =&gt; &#123; //创建 元素 let divItemElt = $(`&lt;div class=&quot;item&quot;&gt; &lt;p&gt;$&#123;$(&#x27;textarea&#x27;).val()&#125;&lt;/p&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;del&quot;&gt;删除&lt;/a&gt; &lt;/div&gt;`) //添加元素 $(`div.content`).prepend(divItemElt) //清空输入框 $(&#x27;textarea&#x27;).val(``) console.log(`===发布=======`) &#125;) //删除 使用 事件委托 代理 $(`div.content`).on(`click`, `.del`, () =&gt; &#123; if (confirm(`确认删除吗?`)) &#123; $(event.target).parent().remove() &#125; console.log(`===删除=========`) &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"JDBC","slug":"JDBC","date":"2023-07-11T10:37:55.000Z","updated":"2023-07-11T16:45:26.000Z","comments":true,"path":"2023/07/11/JDBC/","link":"","permalink":"http://example.com/2023/07/11/JDBC/","excerpt":"","text":"JDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。 1. JDBC1.1 简介 1.2 工作原理 1.3 JDBC API 1.4 JDBC 驱动 1.5 Connection[会话] 1.6 Statement【执行SQL】Statement用于执行静态 SQL 语句 PreparedStatement表示预编译的 SQL 语句的对象。 CallableStatement用于执行 SQL 存储过程的接口。 存储过程定义1234567891011121314151617DELIMITER $$CREATE PROCEDURE p_save_dept(v_deptno INT,v_dname VARCHAR(20),v_loc VARCHAR(20) ,OUT v_rs INT ) BEGIN DECLARE cut INT(1) ; SELECT COUNT(0) INTO cut FROM dept WHERE deptno = v_deptno ; IF cut = 1 THEN SET v_rs = -1 ; END IF ; IF cut = 0 THEN SET v_rs = 1 ; INSERT INTO dept (deptno,dname,loc) VALUES (v_deptno,v_dname,v_loc) ; COMMIT ; END IF ;END $$DELIMITER ; 数据库直接调用12CALL p_save_dept(11,&#x27;aa&#x27;,&#x27;NJ&#x27;,@rs) ;SELECT @rs ; JDBC调用1234567891011Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;root&quot;);CallableStatement cs = conn.prepareCall(&quot;&#123;call p_save_dept(?,?,?,?)&#125;&quot;);cs.setInt(1,12);cs.setString(2,&quot;dev&quot;);cs.setString(3,&quot;NJ&quot;);cs.registerOutParameter(4, JDBCType.INTEGER);cs.execute() ;int out = cs.getInt(4);System.out.println(out);cs.close();conn.close(); 1.7 ResultSet 【查询结果集】 2. DAO2.1 什么是DAO 2.2 DAO作用 2.3 组成部分 2.4 示例 3.DbutilsDbutils：主要是封装了JDBC的代码，简化dao层的操作。作用：帮助java程序员，开发Dao层代码的简单框架。框架的作用：帮助程序员，提高程序的开发效率。 3.1 环境搭建jar包下载 https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils/1.7 3.2 官网地址https://commons.apache.org/proper/commons-dbutils/examples.html 3.3 Dbutils三个核心类介绍1：DbUtils：连接数据库对象—-jdbc辅助方法的集合类，线程安全构造方法：DbUtils()作用：控制连接，控制事务，控制驱动加载额一个类。 2：QueryRunner：SQL语句的操作对象，可以设置查询结果集的封装策略，线程安全。构造方法：（1）QueryRunner()：创建一个与数据库无关的QueryRunner对象，后期再操作数据库的会后，需要手动给一个Connection对象，它可以手动控制事务。Connection.setAutoCommit(false); 设置手动管理事务Connection.commit(); 提交事务 （2）QueryRunner(DataSource ds)：创建一个与数据库关联的queryRunner对象，后期再操作数据库的时候，不需要Connection对象，自动管理事务。DataSource：数据库连接池对象。 12345678 //构造函数与增删改查方法的组合：QueryRunner() update(Connection conn, String sql, Object... params) query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) QueryRunner(DataSource ds) update(String sql, Object... params) query(String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) 3：ResultSetHandle：封装数据的策略对象——将封装结果集中的数据，转换到另一个对象策略：封装数据到对象的方式（示例：将数据库保存在User、保存到数组、保存到集合）方法介绍：handle（ResultSet rs） 3.4 创建DBCP连接池1、创建DBCP链接池配置文件：名称为 dbcp.properties 内容如下： 12345driverClassName=com.mysql.jdbc.Driverusername=rootpassword=123456url=jdbc:mysql://127.0.0.1:3306/long1?characterEncoding=UTF8maxActive=2 2、读取配置文件，创建 DataSource 连接池实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.test.dbcp;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;public class DbcpDataSource &#123;/* * 重点：创建一个DataSource * 步骤为：1、用Properties类读取配置文件。 * 2、通过工厂类，读取这个Properties类获取的配置文件，创建出DataSource * DataSource作用： * 创建DataSource可以返回多个连接。可以实现dbutil简化操作数据库的流程。 *///1、创建一个静态的datasourceprivate static DataSource ds;//2、在静态代码块中，给ds赋值static&#123; //读取资源文件 try&#123; Properties p = new Properties(); p.load(DbcpDataSource.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;)); //在dbcp中有一个工厂类，读取一个资源文件,创建一个datasource ds = BasicDataSourceFactory.createDataSource(p); System.out.println(&quot;创建DataSource为&quot;+ds); &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125; &#125;//提供一个方法用于获取整个datasource对象public static DataSource getDataSource()&#123; return ds; &#125;//提供一个方法，获取connection连接public static Connection getConnection()&#123; Connection con = null; try&#123; con = ds.getConnection(); System.out.println(&quot;通过DataSource获取connection连接&quot;+con); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return con; &#125;&#125; 另外也可以不配置文件直接使用 1234567891011121314static &#123; //模拟初始化数据 Properties prop = new Properties(); prop.setProperty(&quot;driverClassName&quot;,&quot;com.mysql.jdbc.Driver&quot;); prop.setProperty(&quot;url&quot;,&quot;jdbc:mysql://localhost:3306/customer?useSSL=false&amp;characterEncoding=utf8&quot;); prop.setProperty(&quot;password&quot;,&quot;root&quot;); prop.setProperty(&quot;username&quot;,&quot;root&quot;); try&#123; dataSource = DruidDataSourceFactory.createDataSource(prop); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; //初始化 连接池&#125; 3.5 DBUtil 增删改查12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.test.ts;import java.sql.SQLException;import java.util.List;import javax.persistence.Version;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayHandler;import org.apache.commons.dbutils.handlers.ArrayListHandler;import org.junit.Test;import com.test.dbcp.DbcpDataSource;public class DbutilTests &#123;/* * dbutil向数据库新增数据 */@Testpublic void add() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run1 = new QueryRunner(DbcpDataSource.getDataSource()); //申明对象，获取DataSource链接池 //2、书写SQL字符串语句 String sq1 = &quot;INSERT INTO student(id,namee,sex,birth,department,address)&quot; + &quot;VALUES(3,&#x27;王思&#x27;,&#x27;男&#x27;,1995,&#x27;英文系&#x27;,&#x27;山东沧州&#x27;)&quot;; //3、执行sql语句 int result1 = run1.update(sq1); System.out.println(&quot;新增数据库结果，更新了数据有：&quot;+result1+&quot;条&quot;); &#125;/* * dbutil 修改数据库数据 * */@Testpublic void update() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run2 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句 String sq2 = &quot;UPDATE student SET sex=? WHERE id=?&quot;; //3、执行SQL语句 int result2 = run2.update(sq2, &quot;男&quot;,16); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result2+&quot;条&quot;); &#125;/* * dbutil 删除数据库数据 */@Testpublic void delete() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run3 = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource连接池 //2、书写SQL字符串语句（这个sql语句的作用是每次删除ID号最大的数据） String sq3 = &quot;DELETE FROM student WHERE id IN &quot; + &quot;(SELECT a.id FROM &quot; + &quot;(SELECT MAX(id) id FROM student a WHERE id IN&quot; + &quot;(SELECT id FROM student b WHERE a.id=b.id ORDER BY id DESC)) a)&quot;; //3、执行SQL语句 int result3 = run3.update(sq3); System.out.println(&quot;更新数据库结果，更新了数据有：&quot;+result3+&quot;条&quot;); &#125;/* * dbutil 查询，将结果封装成Object对象，返回第一行数据 */@Testpublic void query() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run = new QueryRunner(DbcpDataSource.getDataSource());//申明对象，获取DataSource链接池 //2、查询 String sq4 = &quot;Select * from student&quot;; Object[] var = run.query(sq4, new ArrayHandler()); if(var !=null)&#123; System.out.print(&quot;输出学生表查询的信息&quot;+&quot;\\n&quot;); for(Object o :var)&#123; System.out.print(o+&quot;\\n&quot;); &#125; &#125; &#125;/* * dbutil 查询 ，将结果封装成Object对象，返回所有的数据 * */@Testpublic void query2() throws SQLException&#123; //1、申明QueryRunner对象执行SQL语句 QueryRunner run5 = new QueryRunner(DbcpDataSource.getDataSource()); //2、书写sql语句 String sq5 = &quot;select * from student&quot;; //3、查询sql List&lt;Object[]&gt; list = run5.query(sq5, new ArrayListHandler()); //4、遍历结果 if(list!=null)&#123; for(Object[] os:list)&#123; for(Object o :os)&#123; System.out.println(&quot;ArrayListHandler()显示查询到的所有数据：&quot;+o+&quot;\\t&quot;); &#125; System.out.println(&quot;\\n--------------------------------------------&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"}]},{"title":"Tomcat-servlet","slug":"Tomcat-servlet","date":"2023-07-11T01:34:13.000Z","updated":"2023-07-11T02:13:21.000Z","comments":true,"path":"2023/07/11/Tomcat-servlet/","link":"","permalink":"http://example.com/2023/07/11/Tomcat-servlet/","excerpt":"","text":"Tomcat是web容器。在进行web项目开发的时候，经常需要http协议，也就是基于请求和响应，比如你在百度输入一行内容搜索，那么百度服务器如何处理这个请求呢？它需要创建servlet来处理，servlet其实就是java程序，只是在服务器端的java程序，servlet通过配置文件拦截你的请求，并进行相应处理，然后展示给你相应界面。那么servlet如何创建？这时候就要用到tomcat了。 1.网络编程1.1 图解 1.2 Server123456789101112131415161718192021222324252627282930313233343536public class ServerApp &#123; public static void main(String[] args) throws IOException &#123; //忠告 数组 final String[] ADVICE_AY = &#123;&quot;每天吃钙，到老我也健康膝盖!&quot;,&quot;听人劝，吃饱饭！&quot;,&quot;代码写的好，要饭要到老！&quot;&#125;; //随机数 final Random RAND = new Random(); //创建服务器端 套接字 ServerSocket serverSocket = new ServerSocket(8080); //服务器端 一直接受 客户端的请求 死循环 while (true)&#123; //获得 客户端套接字 Socket socket = serverSocket.accept(); new Thread(()-&gt;&#123; try &#123; // 获得输出流 OutputStream os = socket.getOutputStream(); //输出 随机字符串 字节流数组 os.write(ADVICE_AY[RAND.nextInt(ADVICE_AY.length)].getBytes(&quot;UTF-8&quot;)); //清空 缓存 os.flush(); InputStream is = socket.getInputStream(); byte[] ay = new byte[1024] ; is.read(ay) ; System.out.println(&quot;来着客户端的消息:&quot;+new String(ay)); //释放流 os.close(); is.close(); //关闭套接字 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 1.3 Client1234567891011121314151617181920public class ClientApp &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080); //获得输入流 InputStream is = socket.getInputStream(); byte[] ay = new byte[1024]; is.read(ay) ; //打印 服务器端消息 System.out.println(&quot;来着服务器端消息:&quot;+new String(ay)); //获得输出流 OutputStream os = socket.getOutputStream(); os.write((&quot;hello Server !!!&quot;+Math.random()).getBytes()); os.flush(); is.close(); os.close(); socket.close(); &#125;&#125; 2. CS&#x2F;BS架构2.1 图解 2.2 C&#x2F;S与B&#x2F;S区别123456789101112131415161718191．硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的，不必是专门的网络硬件环境，例如电话上网，租用设备. 信息自己管理. 有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。2．对安全要求不同：C/S 一般面向相对固定的用户群，对信息安全的控制能力很强。 一般高度机密的信息系统采用C/S 结构适宜。可以通过B/S发布部分可公开信息。B/S 建立在广域网之上， 对安全的控制能力相对弱， 可能面向不可知的用户。3．对程序架构不同：C/S 程序可以更加注重流程， 可以对权限多层次校验， 对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑，建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统。SUN 和IBM推JavaBean 构件技术等，使 B/S更加成熟.。4．软件重用不同：C/S 程序可以不可避免的整体性考虑， 构件的重用性不如在B/S要求下的构件的重用性好。B/S 的多重结构，要求构件相对独立的功能， 能够相对较好的重用，就如买来的餐桌可以再利用，而不是做在墙上的石头桌子。5．系统维护不同：C/S 程序由于整体性，必须整体考察，处理出现的问题以及系统升级、升级难、 可能是再做一个全新的系统。B/S 构件组成，方便构件个别的更换，实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级。 3. 手动部署3.0 创建web应用 3.1 静态html http://localhost/web01/hello.html 3.2 动态jsp http://localhost/web01/hello.jsp 3.3 Servlet1234567891011121314151617Servlet = Server applet 运行在服务器 tomcat上的小程序1.必须 规范：必须实现 Servlet 接口 //直接实现 Servlet 接口 A implements Servlet&#123; &#125; HttpServlet implments Servlet&#123; &#125; //间接实现 Servlet 接口 A extends HttpServlet&#123; ... &#125; 源码参考： 123456789101112131415161718192021import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class HelloWorld extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;Hello World!&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;Hello World Servlet ... !&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125;&#125; 编译 javac -cp D:\\java168_2\\server\\apache-tomcat-8.5.73\\lib\\servlet-api.jar .\\HelloWorld.java 部署 121. 桌面： aa文件下/HelloWorld.class 放在 classess文件夹下2. tomcat/lib/servlet-api.jar lib 空着 配置12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 访问http://localhost/web01/hello.do 4. IDE web开发4.1 创建项目 4.2 创建Servlet123456789public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //控制台输出 IDE console System.out.println(&quot;=====HelloServlet===doGet 该方法被执行啦=======&quot;); //通过 流 浏览器 输出 hello ... resp.getWriter().println(&quot;&lt;h1&gt; hello ...&lt;/h1&gt;&quot;); &#125;&#125; 4.3 配置Servlet123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;!-- 注册 servlet 类 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wanho.java171.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 映射 servlet 类访问路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.4 访问Servlethttp://localhost/day10-01-servlet/hello.do 基于请求驱动 地址栏直接怼 超链接 location.href form action&#x3D;“” 基于事件驱动 5.Servlet API5.1 HttpServletRequest12345678//获得请求参数的值方法1： String name = request.getParameter(&quot;name&quot;);&quot;name&quot; 参数名： 注意：如果参数名 不存在 String name 的值？ null 如果参数名 存在 没有值 String name 的值？ &quot;&quot; //1.针对 post 请求有效 中文乱码 req.setCharacterEncoding(&quot;UTF-8&quot;); 12345678910111213141516//兼容： get/postpublic class TestRequestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException &#123; //获得用户请求参数 使用 HttpServletRequest req 对象 String name = request.getParameter(&quot;name&quot;); String age = request.getParameter(&quot;age&quot;); System.out.println(&quot;姓名:&quot;+name+&quot;,年龄:&quot;+age); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 注意：doPost与doGet的区别GET调用用于获取服务器信息，并将其做为响应返回给客户端。当经由Web浏览器或通过HTML、JSP直接访问Servlet的URL时，一般用GET调用。 POST用于客户端把数据传送到服务器端，是可以隐藏传送给服务器的任何数据。Post适合发送大量的数据。 区别： 1、生成方式 get生成方式有四种：1）直接在URL地址栏中输入URL。2）网页中的超链接。3）form中method为get。4）form中method为空时，默认是get提交。 post生成方式：form中method属性为post。 2、数据传送方式 get方式：表单数据存放在URL地址后面。所有get方式提交时HTTP中没有消息体。 post方式：表单数据存放在HTTP协议的消息体中以实体的方式传送到服务器。 3、服务器获取数据方式 GET方式：服务器采用request.QueryString来获取变量的值。 POST方式：服务器采用request.Form来获取数据。 4、传送的数据量 GET方式：数据量长度有限制，一般不超过2kb。因为是参数传递，且在地址栏中，故数据量有限制。 POST方式：适合大规模的数据传送。因为是以实体的方式传送的。 5、安全性 GET方式：安全性差。因为是直接将数据显示在地址栏中，浏览器有缓冲，可记录用户信息。所以安全性低。 POST方式：安全性高。因为post方式提交数据时是采用的HTTP post机制，是将表单中的字段与值放置在HTTP HEADER内一起传送到ACTION所指的URL中，用户是看不见的。 6、在用户刷新时 GET方式：不会有任何提示、 POST方式：会弹出提示框，问用户是否重新提交 5.2 HttpServletResponse响应字符流12345// 1.响应 [html内容] 字符输出流resp.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter out = resp.getWriter();//通过 流 浏览器 输出 hello ... 类似： js ： document.write(&quot;html代码&quot;)out.println(&quot;&lt;h1&gt; hello . 该方法被执行啦..&lt;/h1&gt;&quot;); 响应URL12//2. 响应URL 浏览器 根据响应URL 再次发送新的请求resp.sendRedirect(&quot;./request.do&quot;) ;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"}]},{"title":"Java-捕获异常","slug":"Java-捕获异常","date":"2023-07-03T11:09:06.000Z","updated":"2023-07-03T11:35:12.000Z","comments":true,"path":"2023/07/03/Java-捕获异常/","link":"","permalink":"http://example.com/2023/07/03/Java-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/","excerpt":"","text":"捕获异常使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方。try&#x2F;catch代码块中的代码称为保护代码，使用 try&#x2F;catch 的语法如下： 1234567try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 实例:下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第四个元素的时候就会抛出一个异常。 1234567891011121314// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest&#123; public static void main(String args[])&#123; try&#123; int a[] = new int[2]; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; System.out.println(&quot;Out of the block&quot;); &#125;&#125; 以上代码编译运行输出结果如下 12Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block 多重捕获块一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。多重捕获块的语法如下所示： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;catch(异常类型3 异常的变量名3)&#123; // 程序代码&#125; 上面的代码段包含了 3 个 catch块。可以在 try 语句后面添加任意数量的 catch 块。如果保护代码中发生异常，异常被抛给第一个 catch 块。如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。如果不匹配，它会被传递给第二个 catch 块。如此，直到异常被捕获或者通过所有的 catch 块。 实例:该实例展示了怎么使用多重 try&#x2F;catch。 12345678910try &#123; file = new FileInputStream(fileName); x = (byte) file.read();&#125; catch(FileNotFoundException f) &#123; // Not valid! f.printStackTrace(); return -1;&#125; catch(IOException i) &#123; i.printStackTrace(); return -1;&#125; throws&#x2F;throw 关键字在Java中， throw 和 throws 关键字是用于处理异常的。throw 关键字用于在代码中抛出异常，而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。 throw 关键字throw 关键字用于在当前方法中抛出一个异常。通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 throw 关键字抛出异常，以告知调用者当前代码的执行状态。例如，下面的代码中，在方法中判断 num 是否小于 0，如果是，则抛出一个 IllegalArgumentException 异常。 12345public void checkNumber(int num) &#123; if (num &lt; 0) &#123; throw new IllegalArgumentException(&quot;Number must be positive&quot;); &#125;&#125; throws 关键字throws 关键字用于在方法声明中指定该方法可能抛出的异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常。例如，下面的代码中，当 readFile 方法内部发生 IOException 异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理 IOException 异常。 123456789public void readFile(String filePath) throws IOException &#123; BufferedReader reader = new BufferedReader(new FileReader(filePath)); String line = reader.readLine(); while (line != null) &#123; System.out.println(line); line = reader.readLine(); &#125; reader.close();&#125; 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException： 12345678910import java.io.*;public class className&#123; public void withdraw(double amount) throws RemoteException, InsufficientFundsException &#123; // Method implementation &#125; //Remainder of class definition&#125; finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; 实例:123456789101112131415public class ExcepTest&#123; public static void main(String args[])&#123; int a[] = new int[2]; try&#123; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); &#125; finally&#123; a[0] = 6; System.out.println(&quot;First element value: &quot; +a[0]); System.out.println(&quot;The finally statement is executed&quot;); &#125; &#125;&#125; 以上实例编译运行结果如下： 123Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed 注意下面事项： 1.catch 不能独立于 try 存在。2.在 try&#x2F;catch 后面添加 finally 块并非强制性要求的。3.try 代码后不能既没 catch 块也没 finally 块。4.try, catch, finally 块之间不能添加任何代码。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Mysql-查询基础","slug":"Mysql-查询基础","date":"2023-07-03T10:27:29.000Z","updated":"2023-07-11T01:36:23.000Z","comments":true,"path":"2023/07/03/Mysql-查询基础/","link":"","permalink":"http://example.com/2023/07/03/Mysql-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 查询基础1.0 基本概念12345678DDL:[数据定义语言] create , alter , drop , truncate 语句 【事务自动提交】DML:[数据操作语言] insert ,update, delete 语句DQL:[数据查询语言] selectDCL:[数据控制语言] grant[授权] ，revoke[撤销] ,commit , rollback , savepoint 表结构 初始化脚本scott.sql 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394drop database if exists scott;create database scott;use scott;DROP TABLE IF EXISTS BONUS;CREATE TABLE BONUS (ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,SAL DOUBLE NULL ,COMM DOUBLE NULL ) ;-- ------------------------------ Records for BONUS-- ------------------------------ ------------------------------ Table structure for DEPT-- ----------------------------DROP TABLE IF EXISTS DEPT;CREATE TABLE DEPT (DEPTNO INT(2) PRIMARY KEY,DNAME VARCHAR(14) NULL ,LOC VARCHAR(13) NULL );-- ------------------------------ Records for DEPT-- ----------------------------INSERT INTO DEPT VALUES (&#x27;10&#x27;, &#x27;ACCOUNTING&#x27;, &#x27;NEW YORK&#x27;);INSERT INTO DEPT VALUES (&#x27;20&#x27;, &#x27;RESEARCH&#x27;, &#x27;DALLAS&#x27;);INSERT INTO DEPT VALUES (&#x27;30&#x27;, &#x27;SALES&#x27;, &#x27;CHICAGO&#x27;);INSERT INTO DEPT VALUES (&#x27;40&#x27;, &#x27;OPERATIONS&#x27;, &#x27;BOSTON&#x27;);-- ------------------------------ Table structure for EMP-- ----------------------------DROP TABLE IF EXISTS EMP;CREATE TABLE EMP (EMPNO INT(4) PRIMARY KEY ,ENAME VARCHAR(10) NULL ,JOB VARCHAR(9) NULL ,MGR INT(4) NULL ,HIREDATE DATETIME NULL ,SAL DOUBLE(7,2) NULL ,COMM DOUBLE(7,2) NULL ,DEPTNO INT(2) NULL );-- ------------------------------ Records for EMP-- ----------------------------INSERT INTO EMP VALUES (&#x27;7369&#x27;, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, &#x27;7902&#x27;, &#x27;1980-12-17 00:00:00&#x27;, &#x27;800&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7499&#x27;, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-20 00:00:00&#x27;, &#x27;1600&#x27;, &#x27;300&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7521&#x27;, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-02-22 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;500&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7566&#x27;, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-04-02 00:00:00&#x27;, &#x27;2975&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7654&#x27;, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-28 00:00:00&#x27;, &#x27;1250&#x27;, &#x27;1400&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7698&#x27;, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-05-01 00:00:00&#x27;, &#x27;2850&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7782&#x27;, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, &#x27;7839&#x27;, &#x27;1981-06-09 00:00:00&#x27;, &#x27;2450&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7788&#x27;, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1987-04-19 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7839&#x27;, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, null, &#x27;1981-11-17 00:00:00&#x27;, &#x27;5000&#x27;, null, &#x27;10&#x27;);INSERT INTO EMP VALUES (&#x27;7844&#x27;, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, &#x27;7698&#x27;, &#x27;1981-09-08 00:00:00&#x27;, &#x27;1500&#x27;, &#x27;0&#x27;, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7876&#x27;, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, &#x27;7788&#x27;, &#x27;1987-05-23 00:00:00&#x27;, &#x27;1100&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7900&#x27;, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, &#x27;7698&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;950&#x27;, null, &#x27;30&#x27;);INSERT INTO EMP VALUES (&#x27;7902&#x27;, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, &#x27;7566&#x27;, &#x27;1981-12-03 00:00:00&#x27;, &#x27;3000&#x27;, null, &#x27;20&#x27;);INSERT INTO EMP VALUES (&#x27;7934&#x27;, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, &#x27;7782&#x27;, &#x27;1982-01-23 00:00:00&#x27;, &#x27;1300&#x27;, null, &#x27;10&#x27;);-- ------------------------------ Table structure for &quot;SALGRADE&quot;-- ----------------------------DROP TABLE IF EXISTS SALGRADE;CREATE TABLE SALGRADE (GRADE INT(2) NULL ,LOSAL DOUBLE NULL ,HISAL DOUBLE NULL ) ;-- ------------------------------ Records for SALGRADE-- ----------------------------INSERT INTO SALGRADE VALUES (&#x27;1&#x27;, &#x27;700&#x27;, &#x27;1200&#x27;);INSERT INTO SALGRADE VALUES (&#x27;2&#x27;, &#x27;1201&#x27;, &#x27;1400&#x27;);INSERT INTO SALGRADE VALUES (&#x27;3&#x27;, &#x27;1401&#x27;, &#x27;2000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;4&#x27;, &#x27;2001&#x27;, &#x27;3000&#x27;);INSERT INTO SALGRADE VALUES (&#x27;5&#x27;, &#x27;3001&#x27;, &#x27;9999&#x27;);-- ------------------------------ Foreign Key structure for table EMP-- ----------------------------ALTER TABLE EMP ADD FOREIGN KEY (DEPTNO) REFERENCES DEPT (DEPTNO); 1.1 简单select所有行所有列1SELECT * FROM emp ; 限制列1SELECT empno,ename,sal FROM emp ; 限制行1SELECT * FROM emp WHERE deptno = 10 ; 1.2 算术运算符 + - * &#x2F;注意： null 值不参与计算 【null 未知值 不确定值 x？】 1SELECT sal+comm FROM emp ; -- comm null 值 + 【运算】1234SELECT 3+4 ;SELECT &#x27;3&#x27;+4 ;SELECT &#x27;3&#x27;+&#x27;4&#x27; ;SELECT &#x27;3&#x27;+&#x27;ABC&#x27; ; -- 3 [不报错] &#x2F; 【除法】1SELECT 5/2 ; -- 2.5000 1.3 别名 AS标准： AS “dept.dname” 1SELECT ename AS &quot;from&quot; ,sal AS &quot;员工 工资&quot; FROM emp AS e 1.4 null 空值安全 等于&#x2F;全等于 ：&lt;&#x3D;&gt; 与 &#x3D; 区别：可以判断null值 is null123SELECT * FROM emp WHERE comm IS NULL ;SELECT * FROM emp WHERE comm &lt;=&gt; NULL ; is not null123SELECT * FROM emp WHERE comm IS NOT NULL ;SELECT * FROM emp WHERE NOT comm IS NULL ; 1.5 去重复行 distinct1SELECT DISTINCT deptno ,job FROM emp ; 1.6 排序 order by堆表：快速插入数据 【搬家公司 –&gt; 家具】 默认： 升序 ASC 降序 DESC 基本排序12SELECT * FROM emp ORDER BY sal ASC;SELECT * FROM emp ORDER BY sal DESC; 结果集列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC; 排序多列1SELECT empno,ename,sal FROM emp ORDER BY 3 DESC ,1 ASC ; nullOracle 数据库有专用关键字，mysql没有 12345-- null firstSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),99999,comm) DESC ;-- null lastSELECT empno,ename,sal,comm FROM emp ORDER BY IF(ISNULL(comm),-1,comm) DESC ; 1.7 比较运算符 &lt;&#x3D;&gt; 安全等于【比较null值】 &#x3D; 等于【不能比较null值】 !&#x3D; &lt;&gt; &lt; &lt;&#x3D; &gt; &gt;&#x3D; between and 1234SELECT * FROM emp WHERE deptno != 10 ;SELECT * FROM emp WHERE deptno &lt;&gt; 10 ;SELECT * FROM emp WHERE sal BETWEEN 800 AND 3000 ;SELECT * FROM emp WHERE sal&gt;=800 AND sal&lt;=3000 ; 1.8 in not inin12SELECT * FROM emp WHERE deptno IN (10,20) ;SELECT * FROM emp WHERE deptno =10 OR deptno =20 ; not in12-- 注意： not in (去null值)SELECT * FROM emp WHERE deptno NOT IN (10,20,NULL) ; 1.9 模糊查询_ 一个字符 % N个字符 1SELECT * FROM emp WHERE ename LIKE &#x27;__A%&#x27;; 1234-- zhang_san _进行转义 _不是 like 匹配字符 而是数据SELECT * FROM emp WHERE ename LIKE &#x27;%\\_%&#x27;;SELECT * FROM emp WHERE ename LIKE &#x27;%\\%%&#x27;; 1.10 正则 REGEXP12345^ 匹配开头$ 匹配结尾. 任何一个字符[abc] 范围匹配一个 [a-z] [0-9]* 匹配任意次 12345678-- s开头的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;^S&#x27; ;-- T结尾的姓名SELECT * FROM emp WHERE ename REGEXP &#x27;T$&#x27; ;-- 第二个字母 CSELECT * FROM emp WHERE ename REGEXP &#x27;.C&#x27; ;-- 包含字母 OSELECT * FROM emp WHERE ename REGEXP &#x27;.*O.*&#x27; ; 1.11 逻辑运算符not ! and &amp;&amp; or || 1SELECT NOT 1=1 , ! (1=1) ; 1.12 limitTOPN 1234567-- limit 位置偏移量, 行数 -- 第一页SELECT * FROM emp LIMIT 0,5 ;SELECT * FROM emp LIMIT 5 ;-- 第二页SELECT * FROM emp LIMIT 5,5 ; 例1：123456789101112131415161718-- 1.选择在部门 30 中员工的所有信息 select * from emp where deptno = &#x27;30&#x27; ;-- 2 列出职位为（MANAGER）的员工的编号，姓名 select empno,ename from emp where job = &#x27;MANAGER&#x27; ;-- 3 找出奖金高于工资的员工 select * from emp where comm&gt;sal ;-- 4 找出每个员工奖金和工资的总和 select sal+if(isnull(comm),0,comm) month_sal ,ename from emp order by month_sal desc ;-- 5 找出部门 10 中的经理(MANAGER)和部门 20 中的普通员工(CLERK)select * from emp where (deptno,job) in ((10,&#x27;MANAGER&#x27;),(20,&#x27;CLERK&#x27;)) ;-- 6 找出部门 10 中既不是经理MANAGER也不是普通员工CLERK，而且工资大于等于 2000 的员工select * from emp where deptno = 10 and job not in (&#x27;MANAGER&#x27;,&#x27;CLERK&#x27;) and sal&gt;=2000 ;-- 7 找出有奖金的员工的不同工作select distinct job from emp where comm is not null ;-- 8 找出没有奖金或者奖金低于 500 的员工select * from emp where comm is null or comm&lt;500 ;-- 9 显示雇员姓名，根据其服务年限，将最老的雇员排在最前面select ename from emp order by hiredate asc ; 2. 单行函数2.1 数值函数绝对值 1SELECT ABS(-11.5) ; 平方根 1SELECT SQRT(100) ; 求余 1SELECT MOD(5,2) ; 向上取整 1SELECT CEIL(3.001) ,CEIL(3.000) ; 向下取整 1SELECT FLOOR(3.999) ,CEIL(3.000) ; 随机数 1SELECT RAND() ; 四舍五入 1SELECT ROUND(11.5),ROUND(-11.5) ; 2.2 字符函数字符个数 123SELECT * FROM emp WHERE CHAR_LENGTH(ename) = 5 ;SELECT * FROM emp WHERE ename LIKE &#x27;_____&#x27; ; 字符串连接 12345-- concat() null 值 返回 nullSELECT CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT(&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;,NULL) ;-- concat_ws() null值不参与 【第一个参数 连接符 】SELECT CONCAT_WS(&#x27;,&#x27;,&#x27;hello&#x27;,&#x27;word&#x27;,&#x27;java167&#x27;),CONCAT_WS(&#x27;*&#x27;,&#x27;hello&#x27;,NULL,&#x27;word&#x27;,&#x27;java167&#x27;) 字符串替换 12-- db 索引从 1 开始SELECT INSERT(&#x27;hellojava167&#x27;,3,2,&#x27;**&#x27;) ; 大小写转换 1SELECT UPPER(&#x27;hello java&#x27;),LOWER(&#x27;JAVA hello&#x27;) ; 左右截取字符串 1SELECT LEFT(&#x27;helloworld&#x27;,5),RIGHT(&#x27;helloworld&#x27;,5) ; 左右填充字符串 1SELECT LPAD(&#x27;helloworld&#x27;,15,&#x27;-&#x27;),RPAD(&#x27;helloworld&#x27;,15,&#x27;*&#x27;) ; 首尾去空格 12SELECT TRIM(&#x27; abc ddd &#x27;) ;SELECT TRIM(&#x27;abc&#x27; FROM &#x27;abcxxxyyyabc&#x27;) ; 重复生成字符串 1SELECT REPEAT(&#x27;hello&#x27;,5) ; 字符串比较 12-- 1 0 -1SELECT STRCMP(&#x27;abc&#x27;,&#x27;def&#x27;) ,STRCMP(&#x27;abc&#x27;,&#x27;abc&#x27;),STRCMP(&#x27;zzz&#x27;,&#x27;abc&#x27;); 字符串截取 1234SELECT SUBSTRING(&#x27;helloworld&#x27;,1,5) ,SUBSTRING(&#x27;helloworld&#x27;,5),SUBSTRING(&#x27;helloworld&#x27;,-5);SELECT MID(&#x27;helloworld&#x27;,1,5) ,MID(&#x27;helloworld&#x27;,5),MID(&#x27;helloworld&#x27;,-5); 查找索引 1SELECT LOCATE(&#x27;o&#x27;,&#x27;helloworld&#x27;) ,POSITION(&#x27;o&#x27; IN &#x27;helloworld&#x27;),INSTR(&#x27;helloworld&#x27;,&#x27;o&#x27;) ; 2.3 日期函数当前日期 123456-- 年月日SELECT CURRENT_DATE , CURRENT_DATE() , CURDATE();-- 时分秒SELECT CURRENT_TIME ,CURRENT_TIME(), CURTIME();-- 年月日 时分秒SELECT CURRENT_TIMESTAMP,CURRENT_TIMESTAMP(),LOCALTIME(),NOW(),SYSDATE() ; 日期之间相差天数 1SELECT DATEDIFF(NOW(),hiredate) FROM emp ; 当前日期该月最后一天 1SELECT LAST_DAY(NOW()) ; 日期加减 123SELECT DATE_ADD(NOW(),INTERVAL 1 DAY) ;SELECT DATE_SUB(NOW(),INTERVAL 1 DAY) ; 周 年 月 小时 分 12345SELECT WEEK(NOW()),YEAR(NOW()),MONTH(NOW()),HOUR(NOW()),MINUTE(NOW()) ;SELECT DAYOFMONTH(NOW()),DAY(NOW()),DAYOFYEAR(NOW()) ;-- 提取日期中 部分字段SELECT EXTRACT(YEAR FROM NOW()),EXTRACT(MONTH FROM NOW()) ; 日期格式化 12SELECT DATE_FORMAT(NOW(),&#x27;%Y/%m/%d %h:%i&#x27;);SELECT * FROM emp WHERE DATE_FORMAT(hiredate,&#x27;%m&#x27;) = &#x27;02&#x27; ; 2.4 条件判断函数if 12SELECT IF(3&lt;2,&#x27;aaa&#x27;,&#x27;bbb&#x27;);SELECT IF(STRCMP(&#x27;xyz&#x27;,&#x27;abc&#x27;),&#x27;yes&#x27;,&#x27;no&#x27;); ifnull 1SELECT sal+IFNULL(comm,0) FROM emp ; case 12345678910111213-- 根据部门 10 dev 20 test 30 public others SELECT empno, ename, CASE deptno WHEN 10 THEN &#x27;dev&#x27; WHEN 20 THEN &#x27;test&#x27; WHEN 30 THEN &#x27;public&#x27; ELSE &#x27;others&#x27; END dnameFROM emp ; 例2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546-- 1 找出每个月倒数第三天受雇的员工（如：2009-5-29） -- date_add last_dayselect * from emp where date_add(hiredate,INTERVAL 2 day) = last_day(hiredate);-- 2 找出 25 年前雇的员工 -- datediffselect * from emp where datediff(now(),hiredate)/365&gt;25 ;-- 3 所有员工名字前加上 Dear ,并且名字首字母大写 -- concat concat_ws upper substring midselect concat(&#x27;Dear&#x27;,upper(mid(ename,1,1)),mid(ename,2)) from emp ;-- 4 找出姓名为 5 个字母的员工 -- char_length like _select * from emp where char_length(ename) = 5 ;-- 5 找出姓名中不带 R 这个字母的员工 -- not likeselect * from emp where ename not like &#x27;%R%&#x27; ;-- 6 显示所有员工的姓名的第一个字 -- substringselect substring(ename,1,1) from emp ;-- 7 显示所有员工，按名字降序排列，若相同，则按工资升序排序 select ename,sal from emp order by ename desc , sal asc ;-- 8 假设一个月为 30 天，找出所有员工的日薪，不计小数 -- floor isnull if ifnullselect floor((sal+ifnull(comm,0))/30) from emp ;-- 9 找到 2 月份受雇的员工 -- month date_formatselect * from emp where month(hiredate) = 2 ;-- 10 列出员工加入公司的天数(四舍五入） select datediff(now(),hiredate) from emp ;-- 11 分别用 case 列出员工所在的部门，-- deptno=10 显示&#x27;部门 10&#x27;, -- deptno=20 显示&#x27;部门 20&#x27; -- deptno=30 显示&#x27;部门 30&#x27; -- deptno=40 显示&#x27;部门 40&#x27; -- 否则为&#x27;其他部门&#x27; select empno,ename ,case when deptno between 10 and 30 then &#x27;重要部门&#x27; when deptno&gt;40 then &#x27;辅助部门&#x27; else &#x27;其他部门&#x27; end dname from emp ; 3. 分组函数统计函数 组函数 聚合函数 count sum min max avg 3.1 注意：null值不参与统计 123SELECT COUNT(comm) FROM emp ; -- 4 表中数据 16行SELECT COUNT(0) FROM emp ; 分组函数不能出现where子句 12-- 查询工资大于平均工资的员工SELECT * FROM emp WHERE sal &gt; AVG(sal) ; 3.2 group by注意： 只要有group by 子句： ​ select 子句要求：只能写 group by 出现的列名 + 5 个分组函数 12345678910SELECT deptno, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno ; 多个分组条件： 12345678910SELECT deptno,job, COUNT(0) dept_count, SUM(sal) dept_sum_sal, MIN(sal) dept_min_sal, MAX(sal) dept_max_sal, AVG(sal) dept_avg_sal FROM emp GROUP BY deptno,job ; 3.3 having123456789-- 根据部门分组 查询部门人数大于 2人的部门编号 人数-- 根据部门分组 查询部门人数大于 2人的部门编号 人数SELECT deptno, COUNT(0) dept_countFROM empGROUP BY deptnoHAVING COUNT(0)&gt;2 ; 3.4 完整的SQL1234567891011121314select 列名1 ,列名2...列名Nfrom 表1,表2 .... 表Nwhere 限制行【分组前过滤】group by 分组列having 分组后过滤order by 排序limit 偏移量,行数 12345678910111213-- 查询工资大于500 按照部门分组 如果部门相同按照工种分组 人数大于等于1 按照人数排降序 第2~5条SELECT deptno, job, COUNT(0) dept_count FROM emp WHERE sal &gt; 500 GROUP BY deptno, job HAVING COUNT(0) &gt;= 1 ORDER BY 3 DESC LIMIT 2, 3 ; 3.5 行列转换12345678910CREATE TABLE stu( sname VARCHAR(20), sub VARCHAR(20), score VARCHAR(20));INSERT INTO stu (sname,sub,score) VALUES (&#x27;zs&#x27;,&#x27;chinese&#x27;,&#x27;100&#x27;),(&#x27;zs&#x27;,&#x27;math&#x27;,&#x27;99&#x27;),(&#x27;zs&#x27;,&#x27;english&#x27;,&#x27;98&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;li&#x27;,&#x27;chinese&#x27;,&#x27;80&#x27;),(&#x27;li&#x27;,&#x27;math&#x27;,&#x27;89&#x27;),(&#x27;li&#x27;,&#x27;english&#x27;,&#x27;88&#x27;);INSERT INTO stu (sname,sub,score) VALUES (&#x27;ww&#x27;,&#x27;chinese&#x27;,&#x27;70&#x27;),(&#x27;ww&#x27;,&#x27;math&#x27;,&#x27;79&#x27;),(&#x27;ww&#x27;,&#x27;english&#x27;,&#x27;78&#x27;);COMMIT ; 1234567SELECT sname, CASE sub WHEN &#x27;chinese&#x27; THEN score END chinese , CASE sub WHEN &#x27;math&#x27; THEN score END math , CASE sub WHEN &#x27;english&#x27; THEN score END english FROM stu 12345678SELECT sname, SUM(CASE sub WHEN &#x27;chinese&#x27; THEN score END) chinese , SUM(CASE sub WHEN &#x27;math&#x27; THEN score END) math , SUM(CASE sub WHEN &#x27;english&#x27; THEN score END) english FROM stu GROUP BY sname 例3:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-- 1 分组统计各部门下工资&gt;500 的员工的平均工资-- group by deptno 分组统计各部门-- where sal &gt; 500 工资&gt;500 的员工-- select avg(sal) 平均工资-- from emp 员工select deptno,avg(sal) avg_sal from emp where sal&gt;500 group by deptno ;-- 2 统计各部门下平均工资大于 500 的部门 -- group by deptno 统计各部门-- select avg(sal)-- having avg(sal)&gt;500 工资大于 500 select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;500 ;-- 3 算出部门 30 中得到最多奖金的员工奖金 -- where deptno = 30 部门 30-- select max(comm) 最多奖金select max(comm) from emp where deptno = 30 ;-- 4 算出部门 30 中得到最多奖金的员工姓名 -- where deptno = 30 部门 30 得到最多奖金-- select ename 员工姓名-- select ename,comm from emp where deptno=30 order by comm desc limit 0,1;-- select ename,comm from emp where deptno=30 and comm=(select max(comm) from emp where deptno = 30 ) ;select ename,comm from emp where (deptno,comm)=(select deptno,max(comm) from emp where deptno = 30 ) ;-- 5 算出每个职位的员工数和最低工资 -- group by job 每个职位-- select count(0) , min(sal) 员工数和最低工资select job,count(0) , min(sal) from emp group by job ;-- 6 算出每个部门,每个职位的平均工资和平均奖金(平均值包括没有奖金)，-- 如果平均奖金大于 300，显示“奖金不错”，-- 如果平均奖金 100 到 300，显示“奖金一般”，-- 如果平均奖金小于 100，显示“基本没有奖金”，-- 按部门编号降序，平均工资降序排列-- group by deptno,job 每个部门,每个职位-- select avg(sal) ,avg(ifnull(comm,0)) 平均工资和平均奖金-- case when then end .. 显示转换-- order by deptno desc ,avg(sal) desc 按部门编号降序，平均工资降序排列select deptno,job,avg(sal) ,case when avg(ifnull(comm,0))&gt;300 then &#x27;奖金不错&#x27; when avg(ifnull(comm,0))&gt;=100 and avg(ifnull(comm,0))&lt;=300 then &#x27;奖金一般&#x27; when avg(ifnull(comm,0))&lt;100 then &#x27;基本没有奖金&#x27; end comm_msg from emp group by deptno,job order by deptno desc ,avg(sal) desc;-- 7 列出员工表中每个部门的员工数，和部门 no -- group by deptno 每个部门-- select count(0) , deptno 员工数，和部门 noselect count(0) , deptno from emp group by deptno ;-- 8 得到工资大于自己部门平均工资的员工信息 -- 注意： 别名select * from emp e where sal &gt; (select avg(sal) from emp where deptno=e.deptno) ;-- 9 分组统计每个部门下，每种职位的平均奖金（也要算没奖金的人）和总工资(包括奖金) -- group by deptno,job ; 每个部门下，每种职位-- select avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) 平均奖金（也要算没奖金的人）和总工资(包括奖金) select deptno,job,avg(ifnull(comm,0)), sum(sal+ifnull(comm,0)) from emp group by deptno,job; 4. 多表查询 4.1 笛卡尔集【积】 Cross join行相乘 列相加 【大结果集】 bug 【避免该查询】忘记写 where 条件 ，或条件无效 1234-- 忘记写 where 条件SELECT * FROM emp,dept,salgrade ;-- 条件无效 SELECT * FROM emp,dept,salgrade WHERE emp.deptno=emp.deptno; 4.2 等值连接 Equi join&#x2F;Natural join两张表的数据 必须相关 【外键值 &#x3D; 另一张表的主键值】 等值连接 12-- 查询姓名 部门名称SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e , dept d WHERE e.deptno = d.deptno 自然连接【两表中同名的列】 12-- EMP deptno [emp 的 FK] Dept deptno [dept 的 PK]SELECT e.empno,e.ename,d.deptno,d.dname FROM emp e NATURAL JOIN dept d ; 4.3 非等值连接 Non-Equijoin参考值 【emp表 sal 3000 salgrade表 3000 ？1201~4000】 1234567891011-- 查询工号，姓名 ，工资，工资等级SELECT e.empno, e.ename, e.sal, s.grade FROM emp e, salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal ; 4.4 自连接 Self join树型表 无限级分类表 【表的FK 指向自己表的主键】 必须使用别名 123456SELECT COUNT(0) FROM emp e,emp m ; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.empno = e.empno; -- 笛卡尔集 16*16SELECT COUNT(0) FROM emp e,emp m WHERE e.mgr = m.empno; -- 自连接-- 查询员工姓名 工资 直接领导姓名 工资 SELECT e.ename emp_name,e.sal emp_sal,m.ename mgr_name,m.sal mgr_sal FROM emp e, emp m WHERE e.mgr = m.empno ; 4.5 左外连接 Left Outer Join123456789-- 查询所有员工姓名 部门名称 包括没有部门的员工SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno ; 4.6 右外连接 Right Outer Join123456789-- 查询所有部门名称 包括没有员工的 部门select e.ename, d.deptno, d.dname from emp e right outer join dept d on e.deptno = d.deptno ; 4.7 满外连接 Full Outer Joinmysql 不支持 Full join 【通过集合操作 union 合集】 12345678910111213141516171819-- 查询所有部门名称 包括没有员工的 部门 -- + 所有员工姓名 部门名称 包括没有部门的员工(SELECT e.ename, d.deptno, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno) UNION(SELECT e.ename, d.deptno, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno = d.deptno) 4.8 内连接 Inner Join12-- 查询 员工姓名 部门名SELECT e.ename,d.deptno,dname FROM emp e INNER JOIN dept d ON e.deptno = d.deptno ; 4.9 集合操作并集【UNION ，UNION ALL】 UNION 自动去重复 速度慢 UNION ALL 保留重复 速度快 注意： 列的个数相同 列的数据类型一致 无序 123456SELECT* FROM((SELECT * FROM emp WHERE deptno = 10 ORDER BY sal DESC )UNION(SELECT * FROM emp WHERE deptno = 20 ORDER BY sal DESC ))t ORDER BY t.sal DESC ; 5. 子查询子查询：where 子句 ，from子句，select 子句 , having 子句 123456789101112131415161718-- select 子句 [标量子查询]SELECT ename,(SELECT dname FROM dept WHERE deptno=e.deptno) dname FROM emp e;-- having 子句SELECT MIN(sal), deptno FROM emp GROUP BY deptno HAVING MIN(sal) = (SELECT MIN(min_sal) FROM (SELECT MIN(sal) min_sal FROM emp GROUP BY deptno) t) ; 子查询不返回 主查询不返回 12-- 查询工资比 工号8888 的员工还高员工姓名SELECT * FROM emp WHERE sal&gt;(SELECT sal FROM emp WHERE empno = 8888) ; 单列 对 多列 1SELECT * FROM emp WHERE sal&gt;(SELECT ename,sal FROM emp WHERE empno = 7788) ; 单行 对 多行 12-- Subquery returns more than 1 rowSELECT * FROM emp WHERE sal = (SELECT MIN(sal) FROM emp GROUP BY deptno) ; 5.1 单行子查询子查询结果【单行】 比较运算符 &#x3D; !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 12345678910111213-- 查询大于平均工资的员工SELECT * FROM emp WHERE sal &gt; (SELECT AVG(sal) FROM emp) ; -- 查询 7788 相同部门 工种的员工SELECT * FROM emp WHERE (deptno,job)=(SELECT deptno,job FROM emp WHERE empno = 7788) 注意：返回多行 【一行 对多行&#x2F;多值 ，一列对多列 ，NULL&#x2F;空值】 5.2 多行子查询返回 多行 【包含单行 –&gt; NULL值】 in 【 &#x3D; any ，&#x3D; some】 ，not in ， &gt; all &gt;&#x3D; all &lt; &lt;&#x3D; all ,&gt;any in ，not in 【无法使用索引查询，查询全表扫描】 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename,e.sal FROM emp e ,(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) tWHERE e.deptno = t.deptno AND e.sal = t.dept_min_sal ;-- 子查询SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) IN(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =ANY(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno)SELECT e.ename,e.sal FROM emp e WHERE (deptno,sal) =SOME(SELECT deptno,MIN(sal) dept_min_sal FROM emp GROUP BY deptno) exists ，not exists 1234567891011121314-- 查询各部门中最低工资的员工姓名SELECT e.ename, e.sal FROM emp e WHERE EXISTS (SELECT NULL FROM emp GROUP BY deptno HAVING deptno = e.deptno AND MIN(sal) = e.sal) ; in VS exists 1234in : 无法使用索引，全表扫描 not in 【注意去 null值】 主查询 3KW 子查询 1Kexists : 使用索引，不使用全表扫描 not exists 主查询 1k 子查询 3kw","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Mysql安装过程详解","slug":"Mysql安装过程详解","date":"2023-07-03T03:48:58.000Z","updated":"2023-07-11T01:36:53.000Z","comments":true,"path":"2023/07/03/Mysql安装过程详解/","link":"","permalink":"http://example.com/2023/07/03/Mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Mysql安装&#x2F;卸载1 卸载 2 安装下载https://downloads.mysql.com/archives/installer/ 安装 卸载不干净，无法安装 【解决方案】 https://blog.csdn.net/weixin_43147354/article/details/117241786 MicrosoftProgram_Install_and_Uninstall.meta.diagcab","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Java-IO流","slug":"Java-IO流","date":"2023-07-01T12:15:14.000Z","updated":"2023-07-01T14:36:24.000Z","comments":true,"path":"2023/07/01/Java-IO流/","link":"","permalink":"http://example.com/2023/07/01/Java-IO%E6%B5%81/","excerpt":"","text":"1. File1.1 File与流 1.2 File练习例11234567891011121314151617181920/*使用File对象，在C盘创建aaa/bbb/ccc的文件夹，在此文件夹下创建1.txt【C:/aaa/bbb/ccc/1.txt】 如果该文件存在，删除1.txt 如果该文件不存在，创建1.txt*/import java.io.File;import java.io.IOException;public class FileTest01 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\aaa\\\\bbb\\\\ccc\\\\1.txt&quot;); if (file.exists())&#123; file.delete(); &#125;else&#123; //创建文件夹 file.getParentFile().mkdirs(); //创建 文件 file.createNewFile(); &#125; &#125;&#125; 例21234567891011121314151617/*使用File对象 listFiles() 方法自定义类 implements FilenameFilterC:\\Program Files\\Java\\jdk1.8.0_321\\bin目录下，所有的 .exe结尾的文件打印出来。*/import java.io.File;import java.io.FilenameFilter;import java.io.IOException;import java.util.stream.Stream;public class FileTest02 &#123; public static void main(String[] args) throws IOException &#123; //虚拟 目录 file File file = new File(&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_361\\\\bin&quot;); String[] ay = file.list((dir, name) -&gt; name.endsWith(&quot;.exe&quot;)); Stream.of(ay).forEach(System.out::println); &#125;&#125; 2. 节点流2.1 字节流 2.2 节点流练习例312345678910111213141516171819202122232425/*使用FileOutputStream 向1.txt文件写入： A~Z 字符在 文件 结尾：a~z字符*/import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class FileOutputStreamTest03 &#123; public static void main(String[] args) throws IOException &#123; //输出流 自动创建文件 OutputStream os = new FileOutputStream(&quot;1.txt&quot;,true) ; //写 byte 比如：A for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125; /*for (int i = &#x27;A&#x27;; i &lt;=&#x27;Z&#x27;; i++) &#123; os.write(i); &#125;*/ //建议： 可选 //os.flush(); os.close(); &#125;&#125; 例412345678910111213141516171819202122232425262728293031/*使用FileInputStream IDEA具体的JAVA文件 比如： Test1.java打印该Java文件中所有的内容*/import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class FileInputStreamTest04 &#123; public static void main(String[] args) throws IOException &#123; //输入流 注意：目标数据源 一定存在的 InputStream is = new FileInputStream(&quot;Test1.java&quot;) ; //读 /*while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; System.out.print((char)data); &#125;*/ int data = 0 ; while((data = is.read())!=-1)&#123; System.out.print((char)data); &#125; is.close(); &#125;&#125; 2.3 字符流 2.4 节点流 输入流 输出流 例51234567891011121314151617181920212223/*使用流 实现把图片从C盘拷贝D盘。*/import java.io.*;public class PicCopyTest05 &#123; public static void main(String[] args) throws IOException &#123; //1.输入流 怼到 目标数据源 InputStream is = new FileInputStream(&quot;D:\\\\Java180_2\\\\doc\\\\day01-html基础\\\\res\\\\mm.jpg&quot;) ; //2.输出流 项目下 OutputStream os = new FileOutputStream(&quot;meimei.jpg&quot;) ; //3. 读 while (true)&#123; int data = is.read() ; //文件结尾 if (data==-1)&#123; break; &#125; //4.写 os.write(data); &#125; System.out.println(&quot;====图片拷贝结束=========&quot;); &#125;&#125; 3. 处理流3.1 流嵌套 3.2 处理流 3.3 调包侠https://commons.apache.org/proper/commons-io/description.html 4. 对象流 例61234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用对象流 实现对对象实现读写功能*///写入import java.io.*;public class ObjectOutputStreamTest11 &#123; public static void main(String[] args) throws IOException &#123; //1.对象 创建商品对象 【A.瞬时状态 -- JVM 内存】 Goods goods = new Goods(&quot;G1001&quot;, &quot;苹果&quot;, 4.5D); //2. 写入 4.txt 文件 节点文件流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;4.txt&quot;)) ; /*OutputStream os = new FileOutputStream(&quot;4.txt&quot;) ; ObjectOutputStream oos = new ObjectOutputStream(os) ;*/ //【B.持久状态 -- 文件系统】 //goods.setName(&quot;香蕉&quot;); //对象流 写入 oos.writeObject(goods); oos.flush(); oos.close(); //【C.脱管状态 -- 脱离管理】 //goods.setName(&quot;菠萝&quot;); &#125;&#125;//读取import java.io.*;public class ObjectInputStreamTest12 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.读取 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;4.txt&quot;)) ; Object o = ois.readObject(); ois.close(); System.out.println(o); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-集合","slug":"Java-集合","date":"2023-06-29T14:07:43.000Z","updated":"2023-07-29T14:15:39.000Z","comments":true,"path":"2023/06/29/Java-集合/","link":"","permalink":"http://example.com/2023/06/29/Java-%E9%9B%86%E5%90%88/","excerpt":"","text":"1. Map集合框架类图 HashMap常用方法键值对（“key &#x3D; value”），顾名思义，每一个键会对应一个值。 APIAPI 是用于构建应用程序软件的一组子程序定义，协议和工具。一般来说，这是一套明确定义的各种软件组件之间的通信方法。 例1：1234567891011121314151617181920212223242526272829/*1.遍历集合，并将序号与对应人名打印。2.向该map插入一个编码为5姓名为李晓红3.移除该map中的编号为1的信息4.将map集合中编号为2的姓名信息修改为&quot;周琳&quot;*/import java.util.HashMap;import java.util.Map;public class Ex01 &#123; public static void main(String[] args) &#123; Map map =new HashMap();//多态 map.put(1,&quot;张三丰&quot;); map.put(2,&quot;周芷若&quot;); map.put(3,&quot;汪峰&quot;); map.put(4,&quot;灭绝师太&quot;); //1.循环遍历 map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); //2.插入 map.put(5,&quot;李晓红&quot;); //3.移除 map.remove(1); //4.修改 //map.put(2,&quot;周琳&quot;); map.replace(2,&quot;周琳&quot;); System.out.println(&quot;==============================&quot;); map.forEach((k,v)-&gt; System.out.println(&quot;key:&quot;+k+&quot;，value:&quot;+v)); &#125;&#125; java8 参考循环输出： 123456Map map = new HashMap() ;map.put(1,&quot;张三1&quot;) ;map.put(2,&quot;张三2&quot;) ;map.put(3,&quot;张三3&quot;) ;// java lambda表达式 类似 ES6 的箭头函数 【可推导即可省略】map.forEach((k,v)-&gt; System.out.println(&quot;序号:&quot;+k+&quot;,姓名:&quot;+v)); 例2：1234567891011121314151617181920212223242526/*有2个数组，第一个省份数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，第二个省会数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为key，第二个数组元素作为value存储到Map集合中。如&#123;黑龙江省=哈尔滨, 浙江省=杭州, …&#125;。*/import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class Ex02 &#123; public static void main(String[] args) &#123; String[] proAy = &#123;&quot;黑龙江省&quot;,&quot;浙江省&quot;,&quot;江西省&quot;,&quot;广东省&quot;,&quot;福建省&quot;&#125; ; String[] cityAy = &#123;&quot;哈尔滨&quot;,&quot;杭州&quot;,&quot;南昌&quot;,&quot;广州&quot;,&quot;福州&quot;&#125; ; Map map = new LinkedHashMap(); // 把 数组中的元素 存放在 map的 条目中 for (int i=0;i&lt;proAy.length;i++)&#123; map.put(proAy[i],cityAy[i]); &#125; //打印map 无需循环 &#123;key=value,key=value&#125; System.out.println(map); &#125;&#125; 例3：1234567891011/*定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。 List list = new ArrayList() ;例如：集合中有”abc”、”bcd”两个元素， list.add(“abc”) ; list.add(“bcd”) ;程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。 Map map = ... String 类 1. length() 字母个数 2. charAt() 根据索引 获得 字母*/ Hashtable1null值问题? 对比： 2. Iterator基本使用 例41234567891011121314151617181920212223242526272829303132333435363738394041424344/*使用ArrayList存储多个学生信息1. 删除年龄&gt;18岁的学生2. 使用Iterator进行遍历 */import java.util.ArrayList;import java.util.Iterator;import java.util.function.Predicate;/** * 使用ArrayList存储多个学生信息 * 1. 删除年龄&gt;18岁的学生 * 2. 使用Iterator进行遍历 */public class Ex04 &#123; public static void main(String[] args) &#123; ArrayList&lt;Stu&gt; stuList = new ArrayList(); stuList.add(new Stu(19)) ; stuList.add(new Stu(39)) ; stuList.add(new Stu(14)) ; stuList.add(new Stu(16)) ; stuList.add(new Stu(26)) ; stuList.add(new Stu(12)) ; //推荐 java8的语法 removeIf(e-&gt;e.getAge()&gt;18) forEach(System.out::println) //stuList.removeIf( o -&gt; ((Stu)o).getAge()&gt;18 ) ; //stuList.removeIf( o -&gt; o.getAge()&gt;18 ) ; //stuList.forEach(System.out::println); //Iterator 判断有没有下一个元素 hasNext() 取出下一个元素 next() 删除当前元素 remove() Iterator&lt;Stu&gt; iterator = stuList.iterator(); while (iterator.hasNext()) &#123; //腐烂味道代码 坏味道代码 Stu stu = iterator.next(); if (stu.getAge()&gt;18)&#123; iterator.remove(); &#125; &#125; System.out.println(stuList); &#125;&#125; 参考java8 List 删除元素： 12345678List list = new ArrayList() ;list.add(new Stu(1,&quot;aaa&quot;,19)) ;list.add(new Stu(2,&quot;bbb&quot;,16)) ;list.add(new Stu(3,&quot;ccc&quot;,14)) ;//如果满足条件 进行删除list.removeIf(ele-&gt;((Stu)ele).getAge()&gt;18) ;//循环输出list.forEach(System.out::println); 3. 泛型为什么 怎么用 4. Set4.1 HashSet 例512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.HashSet;import java.util.Random;import java.util.Set;/** * 双色球规则： * 双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。 * 红色球号码从1—33中选择； * 蓝色球号码从1—16中选择； * 请随机生成一注双色球号码。 * （要求同色号码不重复） */public class Ex05 &#123; public static void main(String[] args) &#123; Random random = new Random(); // 蓝色球号码 int blueBall = random.nextInt(16)+1 ; HashSet&lt;Ball&gt; ballSet = new LinkedHashSet&lt;&gt;() ; // 一个 蓝色球 ballSet.add(new Ball(&quot;蓝球&quot;,blueBall)) ; while (ballSet.size() != 7) &#123; //红色球号码 int redBall = random.nextInt(33)+1 ; ballSet.add(new Ball(&quot;红球&quot;,redBall)) ; &#125; System.out.println(ballSet); &#125;&#125;class Ball&#123; private String color ; private Integer num ; public Ball(String color, Integer num) &#123; this.color = color; this.num = num; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Ball ball = (Ball) o; return Objects.equals(color, ball.color) &amp;&amp; Objects.equals(num, ball.num); &#125; @Override public int hashCode() &#123; return Objects.hash(color, num); &#125; @Override public String toString() &#123; return &quot;Ball&#123;&quot; + &quot;color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &quot;, num=&quot; + num + &#x27;&#125;&#x27;; &#125;&#125; 5. Map练习5.1 Map练习例61234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162一、利用Map，完成下面的功能：/*从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。如果该年没有举办世界杯，则输出：没有举办世界杯。*/import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Ex06 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //map.put(2023,null); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入年份:&quot;); //怼死 死去活来法 int year = scanner.nextInt(); String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg); scanner.close(); /*String team = map.get(year); if (team!=null)&#123; System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /*if (map.containsKey(year)) &#123; String team = map.get(year); System.out.println(team); &#125;else&#123; System.out.println(&quot;没有举办世界杯&quot;); &#125;*/ /* String msg = map.getOrDefault(year, &quot;没有举办世界杯&quot;); System.out.println(msg);*/ &#125;&#125; 例712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Scanner;/** * 二、在原有世界杯Map 的基础上， * 增加如下功能： * 读入一支球队的名字，输出该球队夺冠的年份列表。 * 例如， * 读入“巴西”，应当输出 1958 1962 1970 1994 2002 * 读入“荷兰”，应当输出 没有获得过世界杯 */public class Ex07 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1930, &quot;乌拉圭&quot;); map.put(1934, &quot;意大利&quot;); map.put(1938, &quot;意大利&quot;); map.put(1950, &quot;乌拉圭&quot;); map.put(1954, &quot;西德&quot;); map.put(1958, &quot;巴西&quot;); map.put(1962, &quot;巴西&quot;); map.put(1966, &quot;英格兰&quot;); map.put(1970, &quot;巴西&quot;); map.put(1974, &quot;西德&quot;); map.put(1978, &quot;阿根廷&quot;); map.put(1982, &quot;意大利&quot;); map.put(1986, &quot;阿根廷&quot;); map.put(1990, &quot;西德&quot;); map.put(1994, &quot;巴西&quot;); map.put(1998, &quot;法国&quot;); map.put(2002, &quot;巴西&quot;); map.put(2006, &quot;意大利&quot;); map.put(2010, &quot;西班牙&quot;); map.put(2014, &quot;德国&quot;); //逆向思维 Map&lt;String, StringBuilder&gt; teamMap = new HashMap&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; //当前 队伍 map集合中 是否包含当前 队伍 if (teamMap.containsKey(name)) &#123; // 字符串 缓存中 添加新的年份 StringBuilder sb = teamMap.get(name); sb.append(year).append(&quot;\\t&quot;) ; &#125;else &#123; //如果不包含 直接存放当前年份 teamMap.put(name, new StringBuilder(year + &quot;\\t&quot;)); &#125; &#125;); // System.out.println(teamMap); //键盘使用工具类 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一支球队的名字:&quot;); //怼死 死去活来法 String year = scanner.next(); String msg = teamMap.getOrDefault(year, new StringBuilder(&quot;没有获得过世界杯&quot;)).toString(); System.out.println(msg); &#125;&#125; 123456789101112131415//另一种方法 String inputTeamName = scanner.next(); AtomicBoolean isPrint = new AtomicBoolean(true); map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; System.out.println(year); //System.exit(-1); isPrint.set(false); &#125; &#125;); if (isPrint.get()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; 123456789101112131415161718//第三种方法 String inputTeamName = scanner.next(); //存放 获得世界杯的年份集合 List&lt;Integer&gt; yearList = new ArrayList&lt;&gt;() ; map.forEach((year,name)-&gt;&#123; if (name.equals(inputTeamName))&#123; yearList.add(year) ; &#125; &#125;); //集合为空 条件没有满足 if (yearList.isEmpty()) &#123; System.out.println(&quot;没有获得过世界杯&quot;); &#125; yearList.forEach(System.out::println); 5.2 Map.Entry 5.3 Map综合案例1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * * 将以上对应关系的数据存储到map集合中，key：表示站编号，value：表示站名，并遍历打印(可以不按顺序打印)： * 例如： * 第10站: 森林公园南门 * 第6站: 育新 * 第12站: 奥体中心 * 第13站: 北土城 */public class EX &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); &#125;&#125; 例81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * *计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； */public class Ex08 &#123; public static void main(String[] args) &#123; String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); //站之间的数量 int money = caclMoney(13) ; System.out.println(&quot;共:&quot; + money); &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; Map&lt;Integer,Integer&gt; moneyMap = new HashMap&lt;&gt;() ; moneyMap.put(0,3) ; moneyMap.put(1,3) ; moneyMap.put(2,3) ; moneyMap.put(3,3) ; moneyMap.put(4,4) ; moneyMap.put(5,4) ; // .... moneyMap.put(0,3) ; moneyMap.put(0,3) ; return count ; /*if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ;*/ &#125;&#125; 例9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*计算地铁票价规则： 总行程 3站内（包含3站）收费3元， 3站以上但不超过5站（包含5站）的收费4元， 5站以上的，在4元的基础上，每多1站增加2元， 10元封顶；*/import java.util.ArrayList;import java.util.HashMap;import java.util.Map;public class Test09 &#123; public static void main(String[] args) &#123; ArrayList&lt;Num&gt; numList = new ArrayList(); Map map = new HashMap(); map.put(1,&quot;朱辛庄&quot;); map.put(2,&quot;育知路&quot;); map.put(3,&quot;平西府&quot;); map.put(4,&quot;回龙观东大街&quot;); map.put(5,&quot;霍营&quot;); map.put(6,&quot;育新&quot;); map.put(7,&quot;西小口&quot;); map.put(8,&quot;永泰庄&quot;); map.put(9,&quot;林萃桥&quot;); map.put(10,&quot;森林公园南门&quot;); map.put(11,&quot;奥林匹克公园&quot;); map.put(12,&quot;奥体中心&quot;); map.put(13,&quot;北土城&quot;); for (Object j : map.keySet())&#123; System.out.println(&quot;第&quot; +j +&quot;站: &quot; +map.get(j)); &#125; int i=1; numList.add(new Num(1,3)) ; numList.add(new Num(2,3)) ; numList.add(new Num(3,3)) ; numList.add(new Num(4,4)) ; numList.add(new Num(5,4)) ; numList.add(new Num(5+i,4+2*i)) ; /*numList.forEach((k,v)-&gt;&#123; if(k.equals()&lt;=3)&#123; System.out.println(k + &quot; &quot;); &#125; &#125;);*/ &#125;&#125;class Num&#123; int number ; int money; public int getMoney() &#123; return money; &#125; public int getNumber() &#123; return number; &#125; public Num(int number,int money) &#123; this.number = number; this.money = money; &#125; @Override public String toString() &#123; return &quot;homework.Num&#123;&quot; + &quot;number=&quot; + number + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 例1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * 站编号和站名对应关系如下： * 1=朱辛庄 * 2=育知路 * 3=平西府 * 4=回龙观东大街 * 5=霍营 * 6=育新 * 7=西小口 * 8=永泰庄 * 9=林萃桥 * 10=森林公园南门 * 11=奥林匹克公园 * 12=奥体中心 * 13=北土城 * 打印格式（需要对键盘录入的上车站和到达站进行判断，如果没有该站，提示重新输入，直到站名存在为止）： 注意：每站需要2分钟 请输入上车站： 朱辛庄 请输入到达站： 西小口 从朱辛庄到西小口共经过6站收费6元，大约需要 12分钟； */public class Ex09 &#123; private static String[] nameAy = &#123;&quot;朱辛庄&quot;,&quot;育知路&quot;,&quot;平西府&quot;,&quot;回龙观东大街&quot;,&quot;霍营&quot;,&quot;育新&quot;,&quot;西小口&quot;,&quot;永泰庄&quot;,&quot;林萃桥&quot;,&quot;森林公园南门&quot;,&quot;奥林匹克公园&quot;,&quot;奥体中心&quot;,&quot;北土城&quot;&#125; ; private static Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(nameAy.length) ; public static void main(String[] args) &#123;// Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(nameAy.length) ; for (int i = 0; i &lt; nameAy.length; i++) &#123; map.put(i+1,nameAy[i]) ; &#125; //打印 map map.forEach((idx,name)-&gt; System.out.println(&quot;第&quot;+idx+&quot;站:&quot;+name)); String beginName = &quot;林萃桥&quot; ; String endName = &quot;平西府&quot;; int count = caclCount(beginName, endName); int time = count*2 ; //站之间的数量 int money = caclMoney(count) ; System.out.println(&quot;从&quot;+beginName+&quot;到&quot;+endName+&quot;共经过&quot;+count+&quot;站收费&quot;+money+&quot;元，大约需要 &quot;+time+&quot;分钟&quot;); &#125; /** * 根据 两站 站名 计算 之间 站之间的数量 * @param beginName * @param endName * @return */ private static int caclCount(String beginName,String endName)&#123; //map的 key站名 value 站序号 反转 Map&lt;String,Integer&gt; name2IndxMap = new HashMap&lt;&gt;() ; //站序号 站名 map.forEach((idx,name)-&gt; name2IndxMap.put(name,idx)); Integer beginIdx = name2IndxMap.get(beginName); Integer endIdx = name2IndxMap.get(endName); return Math.abs(beginIdx-endIdx) ; &#125; /** * 计算地铁票价规则： * 总行程 3站内（包含3站）收费3元， * 3站以上但不超过5站（包含5站）的收费4元， * 5站以上的，在4元的基础上，每多1站增加2元， * 10元封顶； * @param count 站之间的数量 * @return 多少钱 */ private static int caclMoney(int count)&#123; if (count&lt;=3)&#123; return 3 ; &#125; if (count&lt;=5)&#123; return 4 ; &#125; int money = 4+(count-5)*2 ; if (money&gt;10)&#123; return 10 ; &#125; return money ; &#125;&#125; 6.Set扩展6.1 TreeSet 6.2 例11123456789101112131415161718192021222324252627/*学生类 姓名 分数 double 存放 TreeSet中 实现 根据 分数 从大到小 内部排序Comparable 外部排序 ComparatorSet&lt;Stu&gt; set = new TreeSet&lt;&gt;() ;set.add(new Stu(“aa”,98.5)) ;set.add(new Stu(“bb”,88.5)) ;*/package set;import java.util.*;public class Ex11 &#123; public static void main(String[] args) &#123; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; (int) (c1.getScore()-c2.getScore())) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;((c1,c2)-&gt; c1.getScore().compareTo(c2.getScore())) ;// Set&lt;Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparing(Customer::getScore)) ; //Set&lt;set.Customer&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(set.Customer::getScore)) ; Set&lt;Customer&gt; set = new TreeSet&lt;&gt;() ; set.add(new Customer(&quot;小丽&quot;,500D)) ; set.add(new Customer(&quot;小红&quot;,400.8)) ; set.add(new Customer(&quot;小夏&quot;,400.3)) ; set.add(new Customer(&quot;小花&quot;,700D)) ; set.forEach(System.out::println); &#125;&#125; java8 外部排序写法： 1Set&lt;Stu&gt; set = new TreeSet&lt;&gt;(Comparator.comparingInt(Stu::getAge)) ; 7. Collections7.1 辅助类 7.2 例1212345678910111213141516171819202122232425262728/* 1. List&lt;Stu&gt; Collections.sort(stuList) Comparable Collections.sort(stuList,...) Comparator 分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序， 如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。*/package collections;import set.Customer;import java.util.Arrays;import java.util.Collections;import java.util.List;public class Ex12 &#123; public static void main(String[] args) &#123; //集合中 存放 Customer List&lt;Customer&gt; customerList = Arrays.asList(new Customer(&quot;aaa&quot;,100D),new Customer(&quot;bbb&quot;,80.5D),new Customer(&quot;ccc&quot;,90D)) ; //jdk1.8 新特性 不使用辅助类 Collections //customerList.sort((c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); //使用 辅助类 Collections //Collections.sort(customerList); Collections.sort(customerList,(c1,c2)-&gt;c1.getScore().compareTo(c2.getScore())); customerList.forEach(System.out::println); &#125;&#125; 8. Map扩展8.1 LinkedHashSet 8.2 LinkedHashMap 8.3 ConcurrentHashMap 8.4 Properties 9.泛型扩展9.1 什么是泛型 9.2 泛型好处 9.3 使用前后对比 9.4 类型参数 9.5 方法参数 9.6 泛型不是协变的 9.7 类型通配符 9.8 泛型局限性","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java开发利器--idea安装过程详解","slug":"Java开发利器-idea安装过程详解","date":"2023-06-29T13:46:51.000Z","updated":"2023-07-03T05:31:41.000Z","comments":true,"path":"2023/06/29/Java开发利器-idea安装过程详解/","link":"","permalink":"http://example.com/2023/06/29/Java%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-idea%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"0. IDEA0.1 安装 0.2 配置破解11. 打开 readme.txt 安装步骤进行破解 JDK 字体 编码 0.3 运行创建项目 创建Java类 编写&#x2F;运行源代码 0.4 debug 0.5 卸载 删除安装目录：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"ES6及之后新特性一览","slug":"ES6及之后新特性一览","date":"2023-06-25T04:40:11.000Z","updated":"2023-07-01T08:40:14.000Z","comments":true,"path":"2023/06/25/ES6及之后新特性一览/","link":"","permalink":"http://example.com/2023/06/25/ES6%E5%8F%8A%E4%B9%8B%E5%90%8E%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/","excerpt":"","text":"let声明变量let 声明变量1.let 不允许重复声明变量 var 可以重复声明2.let 不支持变量的声明提升，var可以3.let声明的变量会被所有代码块（{}内的范围）限制作用范围 var只会受到函数影响4.let 声明的变量不和顶层变量挂钩 const 声明常量const 声明常量1.const 不可以重复声明2.不支持声明提升3.作用范围受{}影响4.不和最上层对象window挂钩const num &#x3D; 10;const num &#x3D; 20;&#x2F;&#x2F;Cannot redeclare block-scoped variable ‘num’if(true){ const a &#x3D; 20;}console.log(a); let和const区别1.let声明的变量可以被修改，const声明的是常量 不可以改变2.let声明时可以不赋值，const声明时必须赋值 变量的解构赋值解构赋值；就是快速的从对象或者数组中取出成员的一个语法方式 解构对象12345678const obj = &#123; name:&quot;zs&quot;, age:18, genders:&quot;男&quot;&#125;let name = obj.name;let age = obj.age;let genders = obj.genders; 123456789101112131415const obj2 = &#123; name:&quot;ls&quot;, age:18, genders:&quot;女&quot;&#125;//解构对象//前面的必须是&#123;&#125;表示要从obj2这个对象中获取对象成员//name age genders 都是obj2的现有成员//obj2必须是对象let&#123;name,age,genders&#125; = obj2;console.log(name,age,genders);let&#123;name:a,age:b,genders:c&#125; = obj2;console.log(a,b,c);let&#123;max,min,ceil,floor,random&#125;=Math;console.log(max(10,20,30)); 解构数组12345678//使用解构赋值的方式从数组中提取成员const arr2 = [&quot;一&quot;,&quot;二&quot;,&quot;三&quot;];//解构数组//a b c 分别对应这个数组中的索引下标0 1 2//arr2 必须是数组//如果解构失败，返回结果就是undefinedlet [a,b,c,d] = arr2;console.log(a,b,c,d); 模板字符串ES5中 表示字符串的时候使用’’或者””ES6中 还有一种可以表示字符串的方法 就是&#96;&#96;ES5 字符串 需要同行书写，换行后需要拼接字符串 12const str2 = &#x27;hello&#x27; +&#x27;world&#x27; ES6 可以直接换行使用 12const str3 = `hello world` &#96;&#96;的拼接方式与””不同 12console.log(&quot;我要&quot;+a+&quot;块钱&quot;)console.log(`我要$&#123;a&#125;块钱`) 字符串与数值拓展字符串12345678910111213let &#123;log&#125; = console;let str = &quot;Tom&quot;;//判断字符串中是否存在指定字符 返回true或者falselet res = str.includes(&quot;opm&quot;);//判断字符串中以指定字符开头 返回true或者falseres = str.startsWith(&quot;p&quot;)//判断字符串中以指定字符结尾 返回true或者falseres = str.endsWith(&quot;m&quot;)//repeat() 将字符串重复N次，返回一个新的字符串res = str.repeat(3)//TomTomTomres = str.repeat(2.5)//TomTomres = str.repeat(0)//&quot;&quot;log(res); 数值12345678910111213141516171819202122232425262728let&#123;log&#125; = console;//Number.isFinite() 判断被传入的内容是否为有限数值let res = Number.isFinite(100);//trueres = Number.isFinite(100/0);//falseres = Number.isFinite(Infinity);//falseres = Number.isFinite(NaN);//falseres = Number.isFinite(&quot;100&quot;)//false//Number.isInteger() 判断被传入的内容是否为整数res = Number.isInteger(100);//trueres = Number.isInteger(100.0);//trueres = Number.isInteger(100.1);//falseres = Number.isInteger(&quot;Tom&quot;);//falseres = Number.isInteger(&quot;100&quot;)//false//Math.trunc() 将括号内的参数转化为数字再去掉小数点res = Math.trunc(1.2);//1res = Math.trunc(1.8);//1res = Math.trunc(-1.8);//-1res = Math.trunc(&quot;Tom&quot;);//NaNres = Math.trunc(&quot;10.2&quot;);//10//Math.sign() 判断括号内的数是正数负数还是0res = Math.sign(200);//1res = Math.sign(-200);//-1res = Math.sign(0);//0res = Math.sign(-0);//-0res = Math.sign(&quot;asld&quot;);//NaN 数组拓展12345678910111213//...扩展运算符: let arr = [1,2,3]; let arr2 = [4,5,6]; let res =[...arr,...arr2]; console.log(res);//1，2，3，4，5，6function test()&#123; //arguments 是函数参数的集合 是个伪数组 console.log(arguments); //Array.from() 将 伪数组 转换为 真实数组 res = Array.from(arguments); console.log(res);&#125;test(1,2,3) document.querySelectorAll() 通过选择器获取所有相关元素 返回的是NodeList 伪数组document.querySelector() 通过选择器获取首个相关元素 直接返回元素对象find() 主要用于查找一个符合条件的数组元素findIndex() 主要用于查找一个符合条件的数组元素的下标它的参数是一个回调函数 在回调函数中可以制定寻找元素的条件当条件成立为true时间。返回该元素，如果没有符合的条件，返回undefined 123456let arr3 = [11,22,33,44,55]res = arr3.find(function(item)&#123;//item 表示数组内的每一个成员 return item&gt;20; console.log(item);&#125;)console.log(lis); fill() 使用括号内的参数，直接在数组内填充数据（替换和添加）第一个参数 是替换的新value值第二个参数 是替换的起始坐标第三个参数 是替换的结束坐标 123let arr5 = [1,&quot;纯爱&quot;,&quot;纯爱&quot;];arr5.fill(&quot;牛头人&quot;,1,2);console.log(arr5); 对象拓展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; let name = &quot;张三&quot; let obj = &#123; name:name, fn:function()&#123;&#125; &#125; console.log(obj) //如果对象的属性和value的变量相同，就可以只写一个属性名 let obj2 = &#123; name, //name:name getMessage()&#123;&#125;, getList()&#123;&#125; &#125; console.log(obj2) let msg = &quot;class&quot;; //对象的属性名可以使用表达式 需要用到符号 [表达式] let obj3 = &#123; [msg+&quot;one&quot;]:&quot;Tom&quot;, [`$&#123;msg&#125;xxx`]()&#123;&#125; &#125; console.log(obj3) let obj4 = &#123; name:&quot;jerry&quot;, age:14 &#125; //对象内可以使用拓展运算符 let obj5 = &#123; ...obj4//相当于通过for in遍历，属于深拷贝 &#125; console.log(obj5) //Object.assign() 将需要操作的元素复制到目标对象中 //第一个参数 目标参数 //第二个参数及后面所有额参数都是 需要操作的对象 //如果复制的数据是 值类型数据 实现的是深拷贝 //如果复制的数据是 引用类型数据 使用的任然是该数据的指针(引用地址)，实现的是浅拷贝(重点) let obj6 = &#123;&#125;; let obj7 = &#123; name:&quot;ggBANG&quot;,//值类型深拷贝 friends:[&quot;小A&quot;]//引用类型浅拷贝 &#125; Object.assign(obj6,obj7); obj6.age = 20; obj6.friends = &quot;小王&quot;; console.log(obj6) console.log(obj7)&lt;/script&gt; 函数拓展1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; function fn()&#123;&#125; let fn2 = function()&#123;&#125; // =&gt; const fn3 = (a,b) =&gt;&#123; console.log(a+b) &#125; fn3(1,2) // xxx.onclick = ()=&gt;&#123;&#125; // setInterval(()=&gt;&#123;&#125;) //传入一个参数a, 并且a为函数的返回值 //只有一个参数的情况下 小括号可以省略 //函数内 只有一行需要执行的代码的时候 花括号可以省略 const fn4 = a =&gt;a; fn4(10) //箭头函数制定参数默认值 const fn5 = (a=20,b=50) =&gt;&#123; console.log(a,b); &#125; fn5() let div = document.querySelector(&#x27;div&#x27;); //函数区别 //1.箭头函数的this指向 函数的声明处 //2.箭头函数中无法使用arguments //3.箭头函数不可以作为构造函数 使用 div.onclick= () =&gt;&#123; console.log(this); &#125; // const fn6 = () =&gt;&#123; // console.log(arguments); // &#125; // fn6(1,2,3) const Tom = () =&gt;&#123; console.log(&quot;123&quot;); &#125; new Tom() &lt;/script&gt; SymbolSymbol：表示独一无二的值 1234567891011121314151617var names = Symbol();console.log(names);//使用symbol 当作对象名var obj = &#123; [names]:&quot;Tom&quot;&#125;console.log(obj);//Symbol 函数可以接收一个字符串作为字符串，表示堆Symbol实例的描述//主要是为了在控制台上显示，比较容易区分const ages = Symbol(&quot;age&quot;)console.log(ages)var obj2 = &#123; [ages]:18, [names]:&quot;Tom&quot;&#125;//获取带有Symbol格式的属性console.log(obj2[ages]);//不要加.了 Reflect 是一个内置对象的反射机制，用来提供方法 拦截js的操作Reflect.ownKeys(obj)返回一个数组forEach（）实现遍历的方法 123Reflect.ownKeys(obj).forEach(function(item)&#123; console.log(item);&#125;) Iterator接口Iterator接口的作用为各种数据结构，提供一个统一的，简单的访问接口使数组格式的成员能够按照某种次序排列es6创造了一种新的遍历命令 for of 循环， Iterator接口主要供for…of循环Iterator接口遍历的过程创建一个指针对象，指向当前数据结构的起始位置,第一次调用指针对象的next方法，可以将指针指向该数据结构的第一个成员第二次调用指针对象的next方法，指针就指向该数据结构的第二个成员不断调用指针对象的next方法，直到他指向数据结构的结束位置 1234let item = arr[Symbol.iterator]();console.log(item);console.log(item.next());console.log(item.next()); ES6规定，默认的Iterator接口部署在数据结构[Symbol.iterator]属性或者说 只要有 数据结构 具备Symbol.iterator属性 就认为是可遍历的Symbol.iterator属性本身就是一个函数，就是当前数据结构默认的遍历器生成函数执行这个函数就会返回一个遍历器原生默认具备 iterator 接口的数据结构如下:Array Set Map String arguments NodeList Set数据结构Set类似于数组，成员的值是唯一的，没有重复的值Set.size() 返回Set实例的成员总数Set.add() 添加Set成员Set.delete()删除Set成员Set.has() 查看括号内的成员是否在Set中存在 返回布尔类型 1234567let s1 = new Set([1,2,3,4]);console.log(s1);let s2 = new Set();s2.add(&#x27;hello&#x27;);s2.add(&#x27;world&#x27;);s2.delete(&quot;world&quot;);s2.clear(); Set遍历Set.keys() 返回键名的遍历器Set.values() 返回键值的遍历器Set.entries() 返回键值对的遍历器 123456789let result =s2.keys();console.log(result); result =s2.values();console.log(result); result =s2.entries(); console.log(result); s1.forEach(function(item)&#123; console.log(item);&#125;) 数组去重方法一： 123456let arr = [19,20,19,19,20,21,30,90];let s1 = new Set(arr);console.log(s1);//输出的是一个对象//需要转换为数组的话s1 = Array.from(s1);//使用Array.from() 转换成数组console.log(s1); 方法二： 12let s2 = [...new Set(arr)];//...扩展运算符console.log(s2); Map12345678910111213141516171819202122232425&lt;script&gt; //Map 类型对象 键值对的集合，但是Map中的key不限于字符串，可以是各种类型的值 let M1 = new Map(); M1.set(&#x27;name&#x27;,&#x27;tom&#x27;); M1.set(&#123;a:1&#125;,&#x27;tom&#x27;); M1.set(&#x27;big&#x27;,&#x27;small&#x27;); //操作方法 //Map.set(key.value); 在Map对象中添加key和对应的value //Map.get(key); 在Map对象中获取key对象的value //Map.delete(key); 删除指定的key //Map.has(key); 查看key是否在map中存在 返回布尔类型 //Map.clear(); 清空 console.log(M1); console.log(M1.get(&quot;name&quot;)); M1.delete(&quot;name&quot;); console.log(M1); let res = M1.has(&#x27;big&#x27;); console.log(res); //Map遍历方法 与 Set相同 res = M1.keys() res = M1.values() res = M1.entries() console.log(M1); console.log(res);&lt;/script&gt; ProxyObject.defineProperty() 拦截并处理数据第一个参数 需要拦截处理的对象第二个对象 对象内的属性第三个对象 {}配置项，格式是个对象 1234567891011121314151617181920let obj = &#123; data: 111, name:&quot;zs&quot;, age:20 &#125;let box = document.getElementById(&quot;box&quot;)Object.defineProperty(obj, &quot;data&quot;, &#123; get() &#123;// 当使用对象内的指定属性时调用 console.log(&quot;get函数调用&quot;); &#125;, set(value)&#123; console.log(&quot;set函数接收到了:&quot;,value); if(value&gt;=1000)&#123; box.innerHTML =`数据较大,请重新输入`; &#125; else&#123; box.innerHTML = `数据合理放心使用`; &#125; &#125;&#125;) Proxy代理: 123456789101112131415let proxy = new Proxy(obj,&#123; get(target,key)&#123; //target 表示 需要代理的对象 //key 表示的是访问的属性 console.log(target,key); return target[key]; &#125;, set(target,key,value)&#123; //target 表示 需要代理的对象 //key 表示的是设置的属性 //value 设置的新值 console.log(&quot;set:&quot;,target,key,value); target[key] = value//确认操作 &#125;&#125;) ReflectReflect 主要用来获取目标对象的行为,它与Object类似，但更容易读 Promise对象回调地狱当一个回调函数嵌套另一个回调函数的时候就会出现嵌套结构当嵌套结构多的时候，就会出现回调地狱的情况回调地狱 其实就是由多个回调函数互相嵌套导致的，代码维护性非常差 同步异步异步 当一行代码还没有执行结束，就可以去执行另一行代码的顺序 叫做异步同步 当代码逐行执行过程就是同步的过程异步的操作：定时器 callbackpromise 是异步编程的一种统一的解决方案，比传统回调函数，更合理更强大 1234567891011121314151617const api = new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; if(true)&#123; resolve()//resolve 表示成功的回调函数 &#125; else&#123; reject()//reject 表示失败的回调函数 &#125; &#125;,1000)&#125;)api.then(()=&gt;&#123; console.log(&quot;yyyyy&quot;);//.then() 成功&#125;).catch(()=&gt;&#123; console.log(&quot;nnnnn&quot;);//.catch() 失败&#125;) Promise 对象通过自身的状态，来控制异步操作。Promise实例具有三种状态异步操作未完成(pending)异步操作完成(fulfilled)异步操作失败(rejected) 链式调用为什么promise可以实现链式调用因为当promise方法执行结束后仍然会返回一个promise对象 123456789101112131415const a = promise.then((res) =&gt; &#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 2000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 3000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;); return 5000//传参&#125;).then((res)=&gt;&#123; console.log(&quot;成功赚取&quot; + res + &quot;元&quot;);&#125;).catch((err)=&gt;&#123; console.log(&quot;失败啦&quot;,err);&#125;)console.log(a) all方法Promise.all() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态都是fulfilled pAll的状态才是 fulfilled此时P1,P2,P3的返回值组成一个数组，传递给pAll中 race方法Promise.race() 将多个Promise实例 包装成一个新的promise实例要求P1,P2,P3的状态只要有一个fulfilled pRace的状态才是 fulfilled此时返回值是首次达到fulfilled状态的值除非全部reject否则不会触发.catch Generator函数ES6 提供的一种异步编程解决方案 123456789101112function *gen()&#123; console.log(1); yield;//yield 表示暂停执行标记，通过next方法恢复执行 console.log(2); yield; console.log(3);&#125;let g = gen()//next() 驱动下一步的执行g.next()g.next()g.next()console.log(g); Class语法与继承123456789101112131415class Person&#123;//创建一个Person类 也叫做 构造函数 //类中的属性需要使用constructor 构造器创建 constructor(name,age,height)&#123; this.name = name; this.age = age; this.height = height; &#125; // 在类中创造方法 say()&#123; console.log(&quot;这是Person类&quot;); &#125;&#125;let obj = new Person(&quot;zhangsan&quot;,19,&quot;180cm&quot;);console.log(obj);obj.say() class继承 123456789101112131415161718192021222324class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(&quot;这是&quot;,this.name,this.age,&quot;岁&quot;); &#125;&#125;const one = new Person(&quot;张飞&quot;,100);one.say();class Student extends Person&#123;//extends 表示StudentPerson类中继承 constructor(name,age,height)&#123; super(name,age);//super() 表示从父类中继承的属性内容 必须写在 construtor中 this.height = height; &#125; say()&#123; super.say(); console.log(&quot;是学生&quot;) &#125;&#125;let obj = new Student(&#x27;xz&#x27;,12,&#x27;120&#x27;);console.log(obj);obj.say();","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"Javascript 基础知识","slug":"Javascript-基础知识","date":"2023-06-12T05:11:08.000Z","updated":"2023-07-01T08:40:11.000Z","comments":true,"path":"2023/06/12/Javascript-基础知识/","link":"","permalink":"http://example.com/2023/06/12/Javascript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 JavaScrip简介JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。JavaScript 很容易学习。 ECMAScript 语法标准(es)JavaScript 输出JavaScript 可以通过不同的方式来输出数据：使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 外部的 JavaScript也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。 外部 JavaScript 文件的文件扩展名是 .js。 1&lt;script src=&quot;./01.js&quot;&gt;&lt;/script&gt; 变量1var a = 20; var 申明变量名a 变量名 用来存储变量20 变量&#x3D; 赋值符号 从右向左赋值 变量命名规则：1.可以是字母或者下划线_或者$开头2.长度不可超过255个字符3.名中不能含有空格，首字头不能是数字4.严格区分大小5.不能使用关键字或保留字6.汉字可使用不推荐当使用空的变量名时，得到的结果就是未定义 undefined使用不存在的变量名时，报错，d is not defined变量的声明提升:先使用变量再创建变量 得到的结果会是 undefined 只能提升变量名，不提升变量 12console.log(e);var e = 30; 相当于 123var e;console.log(e);var e = 30; 数据类型与转换基本数据类型:number 数字string 字符串 只要有引号包裹就是字符串boolean 布尔 true&#x2F;false将数据类型转化为number类型强制类型转换:Number（） 将数据类型转换成number转换字母等非数字内容的话会显示NaN (No a Number)parseFloat() 浮点型 将数据保留小数 并且转换为数字类型转换带数字的字符串时，必须开头为数字才能识别parseInt() 整型 将数据保留整数，并转换成数字类型isNaN()：判断内容是否是 非数字 如果是非数字 返回 true 反之为 false只查看数据内容，不查看数据类型数据类型转换为字符串强制类型转换String() 将数据类型转换为字符串xxx.toString() 将数据类型转换为字符串 需要转化的变量名写在前面将数据类型转换为布尔Boolean()0为false，其他为true值类型:number 数字string 字符串boolean 布尔null 空undefined未定义symbol 独一无二的引用数据类型：object 对象function函数array 数组tpyeof(undefined)&#x3D; undefined;tpyeof(null)&#x3D; object;tpyeof(error)&#x3D; object; 算数运算符+ 加法当符号两边都是数字的时候，会自动相加求和当符号两边有字符串时，会起到拼接字符串的作用（结果时字符串类型–隐式类型转换）当符号两边有布尔类型时，true为1，false为0 参与求和计算++ 自增加1++在后面 表示后加，处于正在加1的过程，还没加上，当再次使用变量时，才算自增结束++在前面 表示先加，直接自增结束，得到就是自增+1的结果- 减法当符号两边都是数字的时候，会自动相减求差当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算– 自减1，同自增* 乘法当符号两边都是数字的时候，会自动相乘求积当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算&#x2F; 除法当符号两边都是数字的时候，会自动相除求商当符号两边有字符串时，会先转换成数字再计算（非数字内容为NaN）当符号两边有布尔类型时，true为1，false为0 参与求和计算除数如果是0 得到的是 Infinity 无穷&#x2F;无限% 除余()优先运算符 比较运算符注意：&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D; 的不同&#x3D;&#x3D; 等号(只比较值，不比较数据类型)&#x3D;&#x3D;&#x3D; 全等号（值和数据类型都相同）&gt; 大于号&gt;&#x3D; 大于等于&lt; 小于&lt;&#x3D; 小于等于!&#x3D; 不等于!&#x3D;&#x3D; 不全等于 逻辑运算符&amp;&amp; 与 符号两边的表达都为true整个表达式的结果就是true 有一方为false，整个表达式的结果就是false|| 或 有一方为true，整个表达式的结果就是true！ 非 对象与事件实例化对象：var obj&#x3D;new Object();键值对（属性：属性值）obj.name&#x3D;”zs”;&#x2F;&#x2F;键值对就是XX&#x3D;XX字面量的方式创建对象: 12345var obj2 = &#123; name:&quot;1s&quot;, age:20, height:172&#125; 日期对象var&#x3D; new Date();date.getFullYear();获取当前年份getMonth 获取当前月份getDate日期getDay星期getHours小时getMinutes分钟getSeconds当前秒getMilliseconds 当前毫秒getTime从1970.1.1至今的毫秒数Math对象Math.max 返回最大数Math.min 返回最小数Math.ceil 天花板函数，有小数部分向上取整Math.floor 地板函数 舍掉小数部分Math.round(b) 四舍五入Math.random() 随机数字0-1 取不到1事件on绑定事件的关键字 click 点击事件box.onclick&#x3D;function(){}onblur 失去焦点 if else略 switchswitch 用来监视链路，捕获数据某种情况下需要执行的代码块switch 具有数据穿透性 需要break中断余下代码的执行default 相当于else 123456789101112switch(n)&#123; case 10: XXXX; break; case 20: XXXX; break; default: XXXX; break;&#125; 第二种情况：switch(true) 12345switch(true)&#123; case n&lt;10&amp;&amp;n&gt;=0: console.log(&quot;switch范围监测&quot;) break;&#125; 三目运算符表达式？ 结果1(true):结果2(false) 1a&gt;b ? console.log(&quot;a大&quot;):console.log(&quot;b大&quot;); for循环for循环执行顺序：for 首次执行 先创造变量 再判断条件 不走增量 直接执行代码块剩下的执行次数都是 先增量再判断 最后走代码块如果 变量不满足判断条件 循环结束for(初始化变量;判断条件；增量){重复执行代码块}break： 终止循环 终止整个循环体 余下代码不执行continue： 终止循环 终止当前次数的循环，余下代码不执行 while循环与do while循环1234while(i&lt;10)&#123; console.log(i); i++;&#125; 1234do &#123; i++; console.log(i); &#125; while (i &lt; 10) while 和 do while的区别while循环是 先判断再执行do while 循环 是先执行再判断 数组和数组api123456789101112131415161718192021222324252627282930313233var arr = new Array();//实例化数组// 数组内数据的序号 我们叫做下标（索引号）arr[0]=&quot;李白&quot;;arr[1]=&quot;白居易&quot;;console.log(arr);// 字面量的方式创建数组var arr2 = [&quot;ls&quot;,&quot;zs&quot;,123,false];console.log(arr2);// 数组的使用方式 数组名[下标]console.log(arr2[2]);// 数组名.length 数组内成员的个数console.log(arr2.length);//二维数组var arr4 = [1,3,4,[1,2,3]];console.log(arr4[3][1]);//多维数组var arr5 =[&#123; name:&quot;zs&quot;, age:18, friends:[&#x27;ls&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;ls&quot;, age:20, friends:[&#x27;zs&#x27;,&#x27;wr&#x27;]&#125;,&#123; name:&quot;wr&quot;, age:22, friends:[&#x27;ls&#x27;,&#x27;zs&#x27;]&#125;] 数组的操作方法1.数组.includes() 查看数组内是否包含指定成员，如果是就返回true,如果不包含就返回false 2.Array.isArray() 判断是否是一个数组格式 返回 true 或 false 3.数组.indexOf() 查看数组内的成员，如果存在就返回首次出现的下标，如果不存在就返回-14.数组.lastIndexOf() 查看数组内的成员，如果存在就返回最后一次出现的下标，如果不存在就返回-15.数组.join() 在数组各元素之间插入相同的字符串拼接，将数组转换成字符串6.数组.push() 在原数组末尾添加新成员，返回新数组长度，原数组被改变7.数组.unshift() 在数组开头添加新成员，返回新数组长度，原数组被改变8.数组.pop() 删除数组最后一名成员，返回被删除内容，原数组被改变9.数组.shift() 删除数组开头的成员，返回被删除内容，原数组被改变 10.数组.reverse() 反转数据11.数组.splice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组改变当括号内有两个参数的时候，表示从当前下标开始一直截取到几个，返回被截取的内容，原数组改变当括号内有三个参数的时候，第三个参数表示在截取位置添加的新内容，返回被截取的内容，原数组改变12.数组.slice() 当括号内有一个参数的时候，表示从当前下标开始一直截取到末尾，返回被截取的内容，原数组不改变当括号内有两个参数的时候，表示从当前下标开始到第二个参数下标结束，返回被截取的内容，原数组不改变var res &#x3D;arr.includes(“奥斯”); 字符串API字符串.length 获取字符串的长度字符串.split() 字符串转换成数组，根据括号的内容进行字符分割字符串.charAt() 返回指定下标处的字符字符串.indexOf() 返回查找首次出现字符的下标，如果不存在返回-1字符串.lastIndexOf() 返回查找最后一次出现字符的下标，如果不存在返回-1字符串.substr() 截取字符串 如果有一个参数 表示从当前下标开始截取到末尾 返回截取的内容如果有两个参数，表示从当前下标开始截取几个 返回截取的内容 函数匿名函数： 自调用 通过事件绑定在一起触发具名函数： function . 函数名()函数特性：不调用，不执行函数的使用叫做调用函数具有 预加载(函数的位置在定义先后不影响执行)具名函数的调用 函数名()return 返回值（余下代码不执行）function 函数名（形式参数）{}var a &#x3D; 函数名（实际参数）；封装函数 全局变量与局部变量变量是存在作用域的 分为 全局变量和局部变量局部变量： 在函数内部用var声明的变量就是局部变量（只在函数内部生效）全局变量：在函数外部用var声明的变量就是全局变量，可以在整个JS中生效不用var声明的，变量也是全局变量（不推荐使用）闭包：闭包的形式：多个函数互相嵌套闭包的目的：将内部函数的局部变量提到全局中去使用闭包的实现方式：不断地设置return 返回值闭包的缺点：会消耗电脑内存 影响性能 DOMdocument object model 文档对象模型 定时器1234567891011// setInterval(callback) 多次执行的定时器 callback参数 表示 回调函数start.onclick = function () &#123; timer = setInterval( function () &#123; console.log(1); &#125;, 1000) &#125; stop.onclick = function () &#123;// clearInterval(定时器的名字) 清除定时器 clearInterval(timer);&#125; thisthis 表示 这个this 在函数中 代指函数的调用者this在函数外 指向的是window对象，最大的对象 12345678910111213141516var lis = document.getElementsByTagName(&quot;li&quot;)console.log(this);for (var i = 0; i &lt; lis.length; i++)&#123; //属性绑定 写在循环的内部，事件的外部 // index 一般表示为下标 lis[i].index = i; lis[i].onclick = function() &#123; //先让所有颜色都变成蓝色 再让当前的这个变成红色 //这就是排他思想 for (var j = 0; j &lt; lis.length; j++)&#123; lis[j].style.background = &quot;skyblue&quot;; &#125; this.style.background = &quot;red&quot;; console.log(this.index);//获取到下标 &#125;&#125; 轮播图参考https://swiper.com.cn/ Node节点操作1.xx.parentNode 当前节点的父节点2.xx.childNodes 当前节点的所有子节点,包含文本节点(本次返回的text为回车造成的空格) 返回nodeList 伪数组3.xx.children 当前节点的所有子元素节点 返回HTMLCollection 伪数组4.xx.firstChild 当前节点的第一个子节点,包含文本节点5.xx.firstElementChild 当前节点的第一个子元素节点6.xx.lastChild 当前节点的最后一个子节点,包含文本节点7.xx.lastElementChild 当前节点的最后一个子元素节点8.xx.previousSibling 当前节点的前一个兄弟节点,包含文本节点9.xx.previousElementSibling 当前节点的前一个兄弟元素节点10.xx.nextSibling 当前节点的前一个兄弟节点,包含文本节点11.xx.nextElementSibling 当前节点的前一个兄弟元素节点节点的操作1.document.createElement() 创建节点2.xx.innerHTML 往节点内添加或替换内容(文本或标签)2.xx.innerText 往节点内添加或替换内容(文本)4.xx.appendChild() 往父节点的末尾添加新节点5.xx.insertBefore(新节点,目标节点) 将新节点添加到目标节点之前6.xx.cloneNode() 克隆节点,true的时候,将该节点及其子节点全部复制；flase的时候只复制节点本身。7.父节点.removeChild() 删除父节点的子节点 偏移量offsetWidth 元素自身的宽度 width+border+paddingoffsetHeight 元素自身的高度 同上offsetLeft 元素自身的位置offsetTop 元素自身的位置onscroll 滚动事件scroll卷曲的距离clientWidth可视区域的宽 width paddingclientWidth可视区域的宽 height padding document.body;&#x2F;&#x2F;获取body 标签document.documentElement&#x2F;&#x2F;获取html标签 事件对象event 事件对象 通过事件触发的时候调用函数内的参数该对象内包含了事件触发时的信息事件对象的兼容写法： 1var e = event || window.event;//兼容低版本ie浏览器 pageX 光标相对于网页的水平位置（ie无）*pageY 光标相对于网页的垂直位置（ie无）*screenX 光标相对于屏幕的水平位置screenY 光标相对于屏幕的垂直位置clientX 光标相对于可视区域的水平位置*clientY 光标相对于可视区域的垂直位置（重要且相同）xx.onkeypress 键盘按键 按下并且弹起xx.keyCode 表示键盘上对应按键的编码xx.onmouseenter 鼠标进入xx.onmouseleave 鼠标离开 事件冒泡和事件句柄事件冒泡：当一个元素的事件被触发的时候,比如鼠标点击了一个元素，同样的事件就会在这个元素的所有祖先元素上被触发这个过程就叫做事件冒泡,这个事件是从原始事件一直冒泡到dom树的最上层.不支持事件冒泡的事件: focus,blur,mouseenter,mouseleave,load,resize 12//阻止事件冒泡的兼容写法e.stopPropagation ? e.stopPropagation() :e.cancelBubble = true; 事件句柄:addEventLister 添加事件句柄第一个参数 事件的名称第二个参数 callback 回调函数第三个参数 false 触发的顺序是由内到外，叫做冒泡的顺序（默认）； true 触发的顺序是由外到内，叫做捕获的顺序同一个元素可以绑定多个相同事件，不会覆盖，挨个执行 123box.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;222&quot;); &#125;,true) 缓存注意：cookie localStorage sessionStorage的区别cookie 默认浏览器关闭时消失，存在于web服务器中，存储大小为4KBlocalStorage 本地储存 永久有效，除非手动删除，存储大小为5MBsessionStorage 会话存储 关闭浏览器或窗口事就消失，存储大小为5MBcookie缓存： 123456document.cookie=&quot;username = 李白&quot;//创建cookie缓存document.cookie=&quot;age = 30; expires = Tue, 20 Jun 2023 12:00:00 GMT&quot;//设置过期事件var res =document.cookie;var n = res.indexOf(&quot;=&quot;) +1 ;res = res.substr(n);console.log(res); localStorage缓存： 123456localStorage.setItem(&quot;NAME&quot;,&quot;TOM&quot;);//创建缓存 localStorage.setItem（key,value） localStorage.setItem(&quot;AGE&quot;,&quot;18&quot;);localStorage.removeItem(&quot;AGE&quot;);//删除指定缓存 localStorage.removeItem(key)var res = localStorage.getItem(&quot;NAME&quot;);//获取缓存 localStorage.getItem(key) var age = localStorage.getItem(&quot;AGE&quot;);localStorage.clear();//清空缓存 localStorage.clear() BOMbrowser object model 浏览器对象模型 Window对象window.open(“https://www.baidu.com&quot;//在当前窗口跳转window.close();&#x2F;&#x2F;关闭窗口 locationlocation.hostname web主机域名location.pathname 当前页面的路径location.port 端口号(0-65535)location.herf 整个URLlocation.protocol web协议常见的协议:http 和 https 的区别*http 免费 相对不安全，端口号默认80https 收费 比较安全，端口号默认443 secureftpfile history两种后退功能：history.back(); history.go(-1);两种前进功能：history.go(); history.go(1); navigatornavigator 设备信息对象navigator.appCodeName 浏览器代号navigator.appName 浏览器名称navigator.appVersion 浏览器版本navigator.vender 浏览器供应商navigator.cookieEnabled 浏览器是否启用了缓存navigator.platform 硬件平台navigator.userAgent 用户代理语言navigator.language 用户代理语言 正则表达式 实例化创建正则对象 1var reg = new RegExp(); &#x2F;&#x2F;字面量方式创造正则对象reg &#x3D; &#x2F;@&#x2F;; 含有@reg &#x3D; &#x2F;\\d&#x2F; 含有数字reg &#x3D; &#x2F;\\D&#x2F; 含有非数字reg &#x3D; &#x2F;\\s&#x2F; 含有不可见字符(空格，回车等)reg &#x3D; &#x2F;\\S&#x2F; 含有可见字符reg &#x3D; &#x2F;\\w&#x2F; 含有单词字符 字母 数字reg &#x3D; &#x2F;\\W&#x2F; 含有非单词字符 简单类reg &#x3D; &#x2F;[23]&#x2F; 含有2或者3负向类reg &#x3D; &#x2F;[^23]&#x2F; 含有非2或者3范围类reg.onblur &#x3D; &#x2F;[0-9]&#x2F; 含有0-9中的任意一个组合类reg &#x3D; &#x2F;[0-9a-z]&#x2F; 含有数字或者字母中的一个边界reg &#x3D; &#x2F;^12&#x2F; 必须以12开头reg &#x3D; &#x2F;23$&#x2F; 必须以23结束reg &#x3D; &#x2F;^123$&#x2F; 必须是123&#x2F;&#x2F;量词reg&#x3D; &#x2F;^123*$&#x2F; ‘3’的重复次数&gt;&#x3D;0次reg&#x3D; &#x2F;^123+$&#x2F; ‘3’的重复次数&gt;&#x3D;1次reg&#x3D; &#x2F;^123?$&#x2F; ‘3’的重复次数只能是0或1次reg&#x3D; &#x2F;^12{4}3$&#x2F; ‘2’的重复次数4次reg&#x3D; &#x2F;^12{4,}3$&#x2F; ‘2’的重复次数&gt;&#x3D;4次reg&#x3D; &#x2F;^12{4,10}3$&#x2F; ‘2’的重复次数4到10次 正则.test(需要校验的内容) 返回布尔类型 1var res = reg.test(inp.value); 高级JS(面向对象)值类型与引导类型值类型 ：number string boolean null undef symbol引用数据类型： array function object 值类型与引用数据类型的区别值类型 ：存储在栈中，内存空间固定当数据复制的时候，可以直接复制互不影响typeof 判断数据类型引用数据类型：存储在堆中，内存空间不固定浅拷贝：当数据复制的时候，只能复制数据的引用地址深拷贝：将数据复制并在堆中重新申请一片空间进行存储深拷贝实现的两种方式： 12var obj2 = JSON.stringify(obj);//对象 =&gt; string 将对象转换成json字符串var obj2 = JSON.parse(obj2);//string =&gt; 对象 将json字符串转换成对象 通过instanceof() 判断数据是哪一种引用类型（返回true&#x2F;false） 1var res = arr instanceof(Arry); 工厂模式和构造函数面向对象编程的基本特征封装： 将客观事物封装成抽象的类继承： 子类具有父类的公有属性多态： 对象的多功能，多方法，一个方法可以有多种表现形式字面量创建对象 创建量如果比较多就比较繁琐，并且对象之间没有关系 12345678var personOne = &#123; name:&quot;zs&quot;, age:20&#125;var personTwo = &#123; name:&quot;ls&quot;, age:24&#125; 通过封装的方式创建对象，解决代码重复的问题 123456function createPerson(name,age)&#123; return&#123; name:name, age:age &#125; &#125; 工厂模式 12345678function createPerson(name,age)&#123; var obj =new Object();//准备工厂环境 obj.name = name;//将属性进行加工 obj.age = age;//将属性进行加工 return obj;//将加工好的对象进行输出&#125;personOne = createPerson(&quot;王二&quot;,10);personTwo = createPerson(&quot;zy&quot;,30); 构造函数 12345678function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;var personOne = new CreatePerson(&quot;张三丰&quot;,&quot;108&quot;)var personTwo = new CreatePerson(&quot;孙悟空&quot;,&quot;正无穷&quot;)console.log(personOne);console.log(personTwo); 构造函数需要注意的事情：1.CreatePerson 称之为 构造函数 也叫做 类，构造函数就是类2.personOne 就是 CreatePerson 的实例对象3.构造函数中的this指向的是通过new实例化出来的4.必须使用new关键字 将函数实例化5.构造函数的开头必须大写6.构造函数会自动创造出来一个 constructor(构造器)属性，这是属性就是指向CreatePerson prototype原型属性，存在于每个构造函数之中通过prototype原型创建的方法可以在构造函数生成的实例中公用，有利于提升效率prototype 的顶端 是 object 123456789 function CreatePerson(name,age)&#123; this.name = name; this.age = age;&#125;CreatePerson.prototype.say = function()&#123; console.log(&quot;yyy&quot;); return 0;&#125;var one = new CreatePerson(&quot;zs&quot;,20); 对象继承12345678910111213141516171819202122232425function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.run=function()&#123; console.log(&quot;啊啊啊啊啊&quot;);&#125;Person.prototype.findWork=function()&#123; console.log(&quot;working&quot;);&#125;function Man()&#123; console.log(&quot;nnnnn&quot;);&#125;//看似赋值的过程 =&gt; 实际上实现的是浅拷贝// Man.prototype = Person.prototype; //for in 循环（用来遍历对象）for(var k in Person.prototype)&#123; console.log(k);//k是对象的属性 Man.prototype[k] = Person.prototype[k]&#125;Man.prototype.jump = function()&#123; console.log(&quot;hhhhhhhhhhh&quot;); &#125;console.log(Man.prototype);console.log(Person.prototype); 多态多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态的实现方式：覆盖指子类重新定义父类方法，基于prototype继承就是。 call和apply和bind12345678910111213141516171819 //thiswindow.color = &quot;red&quot;;document.color = &quot;green&quot;;// console.log(window);var obj = &#123; color:&quot;white&quot;&#125;function changeColor(a,b)&#123; console.log(a+&quot;和&quot;+b+&quot;喜欢&quot;+this.color)&#125;//函数.call(this需要指向的对象，参数必须使用逗号分隔)changeColor(&quot;小王&quot;,&quot;小明&quot;);changeColor.call(document,&quot;小王&quot;,&quot;小明&quot;);changeColor.call(obj,&quot;小王&quot;,&quot;小明&quot;);//函数.apply(this需要指向的对象，参数必须使用数组)changeColor.apply(document,[&quot;小王&quot;,&quot;小明&quot;]);changeColor.apply(obj,[&quot;小王&quot;,&quot;小明&quot;]);//函数名.bind(this需要指向的对象，参数可以是任意形式)() 返回的是函数需要再次调用changeColor.bind(obj,[&quot;小李&quot;],[&quot;zs&quot;])()","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"MarkDown学习(一)","slug":"MarkDown学习-一","date":"2022-06-22T13:39:30.000Z","updated":"2023-07-02T17:10:54.000Z","comments":true,"path":"2022/06/22/MarkDown学习-一/","link":"","permalink":"http://example.com/2022/06/22/MarkDown%E5%AD%A6%E4%B9%A0-%E4%B8%80/","excerpt":"","text":"MarkDOwn初识标题要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 () (例如：### My Header)。 1234567# 1级标题## 2级标题### 3级标题#### 四级标题 ##### 五级标题 ###### 六级标题 字体1*斜体文本* 斜体文本 1**加粗文本** 加粗文本 1***加粗和斜体文本*** 加粗和斜体文本 1~~删除文本~~ 删除文本 1&gt; 引用文本 引用文本 列表有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 一： First item Second item Third item Fourth item 二： 12341. First item1. Second item2. Third item3. Fourth item First item Second item Third item Fourth item 三： 12341. First item8. Second item7. Third item3. Fourth item First item Second item Third item Fourth item 无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 123456- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 复选框列表（CheckBoxList） 123- [ ] List Item 1 unchecked- [x] List Item 2 checked- [X] List Item 3 checked List Item 1 unchecked List Item 2 checked List Item 3 checked 代码12345678910111213141516#[derive(Debug)]pub enum State &#123; Start, Transient, Closed,&#125;impl From&lt;&amp;&#x27;a str&gt; for State &#123; fn from(s: &amp;&#x27;a str) -&gt; Self &#123; match s &#123; &quot;start&quot; =&gt; State::Start, &quot;closed&quot; =&gt; State::Closed, _ =&gt; unreachable!(), &#125; &#125;&#125; 123456789101112[ &#123; &quot;title&quot;: &quot;apples&quot;, &quot;count&quot;: [12000, 20000], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;, &#123; &quot;title&quot;: &quot;oranges&quot;, &quot;count&quot;: [17500, null], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;] 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Gre\\&#x27;ater&#x27; return (param2 - param1 + 1 + 0b10l) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; 12345678910111213&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt; function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt; 123456789101112131415161718192021function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=&quot;$&#123;cls&#125;&quot;`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log(&#x27;undefined&#x27;); &#125; return ( &lt;div&gt; &lt;web-component&gt;&#123;block&#125;&lt;/web-component&gt; &lt;/div&gt; )&#125;export $initHighlight; 1234567891011121314#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125; 123456789101112CREATE TABLE &quot;topic&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;forum_id&quot; integer NOT NULL, &quot;subject&quot; varchar(255) NOT NULL);ALTER TABLE &quot;topic&quot;ADD CONSTRAINT forum_id FOREIGN KEY (&quot;forum_id&quot;)REFERENCES &quot;forum&quot; (&quot;id&quot;);-- Initialsinsert into &quot;topic&quot; (&quot;forum_id&quot;, &quot;subject&quot;)values (2, &#x27;D&#x27;&#x27;artagnian&#x27;); 12345678910111213#import &lt;UIKit/UIKit.h&gt;#import &quot;Dependency.h&quot;@protocol WorldDataSource@optional- (NSString*)worldName;@required- (BOOL)allowsToLive;@end@property (nonatomic, readonly) NSString *title;- (IBAction) show;@end 12345678910111213141516/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123; public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; 123456789101112131415import Foundation@objc class Person: Entity &#123; var name: String! var age: Int! init(name: String, age: Int) &#123; /* /* ... */ */ &#125; // Return a descriptive string for this person func description(offset: Int = 0) -&gt; String &#123; return &quot;\\(name) is \\(age + offset) years old&quot; &#125;&#125; 123456789101112131415@font-face &#123; font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123; color: #F0F0F0; background: #600; font-family: Chunkfive, sans;&#125;@import url(print.css);@media print &#123; a[href^=http]::after &#123; content: attr(href) &#125;&#125; 12345678910111213# The Greeter classclass Greeter def initialize(name) @name = name.capitalize end def salute puts &quot;Hello #&#123;@name&#125;!&quot; endendg = Greeter.new(&quot;world&quot;)g.salute 12345678910111213# MakefileBUILDDIR = _buildEXTRAS ?= $(BUILDDIR)/extras.PHONY: main cleanmain: @echo &quot;Building main facility...&quot; build_main $(BUILDDIR)clean: rm -rf $(BUILDDIR)/* 123456789101112package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan float64) ch &lt;- 1.0e10 // magic number x, ok := &lt;- ch defer fmt.Println(`exitting now\\`) go println(len(&quot;hello world!&quot;)) return&#125; 123456789101112131415#!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then echo &quot;Superuser rights required&quot; exit 2figenApacheConf()&#123; echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125; 123456789101112; boilerplate[package]name = &quot;some_name&quot;authors = [&quot;Author&quot;]description = &quot;This is \\a description&quot;[[lib]]name = $&#123;NAME&#125;default = Trueauto = nocounter = 1_000 超链接1这是一个链接 [百度](https://baidu.com)。 这是一个链接 百度。 图片1![图片alt](图片链接 &quot;图片title&quot;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2022-06-03T11:42:34.000Z","updated":"2023-07-02T17:10:41.000Z","comments":true,"path":"2022/06/03/我的第一篇博客文章/","link":"","permalink":"http://example.com/2022/06/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"一年前，就试着搭建了这个Hexo框架的微博，但是只是部署到了Github上，并没有打理自己的博客，也没有写一些内容，这和当初搭建博客的目的有点南辕北辙了。这段时间确实是让人比较疲惫且受挫，但还是得打起精神，继续前进。","categories":[],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"代码审查","slug":"代码审查","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mybatis-plus","slug":"Mybatis-plus","permalink":"http://example.com/tags/Mybatis-plus/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"CORS","slug":"CORS","permalink":"http://example.com/tags/CORS/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://example.com/tags/RabbitMQ/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"},{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://example.com/tags/MarkDown/"}]}